# Comparing `tmp/pyalgotrading-2023.5.4-py3-none-any.whl.zip` & `tmp/pyalgotrading-2023.6.1-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,32 +1,32 @@
-Zip file size: 32769 bytes, number of entries: 30
+Zip file size: 34044 bytes, number of entries: 30
 -rw-rw-r--  2.0 unx      181 b- defN 23-May-09 09:57 pyalgotrading/__init__.py
--rw-rw-r--  2.0 unx     5975 b- defN 23-May-09 09:57 pyalgotrading/constants.py
+-rw-rw-r--  2.0 unx     6083 b- defN 23-Jun-10 13:22 pyalgotrading/constants.py
 -rw-rw-r--  2.0 unx      133 b- defN 22-Jul-16 11:17 pyalgotrading/algobulls/__init__.py
--rw-rw-r--  2.0 unx    18084 b- defN 23-May-09 09:57 pyalgotrading/algobulls/api.py
--rw-rw-r--  2.0 unx    35018 b- defN 23-May-09 09:57 pyalgotrading/algobulls/connection.py
--rw-rw-r--  2.0 unx     1864 b- defN 22-Jan-11 13:11 pyalgotrading/algobulls/exceptions.py
+-rw-rw-r--  2.0 unx    18706 b- defN 23-Jun-10 13:22 pyalgotrading/algobulls/api.py
+-rw-rw-r--  2.0 unx    38010 b- defN 23-Jun-10 13:22 pyalgotrading/algobulls/connection.py
+-rw-rw-r--  2.0 unx     2187 b- defN 23-Jun-10 13:22 pyalgotrading/algobulls/exceptions.py
 -rw-rw-r--  2.0 unx       66 b- defN 22-Jan-11 13:11 pyalgotrading/broker/__init__.py
 -rw-rw-r--  2.0 unx     7594 b- defN 23-May-09 09:57 pyalgotrading/broker/broker_connection_base.py
 -rw-rw-r--  2.0 unx    13703 b- defN 22-Jan-11 13:11 pyalgotrading/broker/broker_connection_zerodha.py
 -rw-rw-r--  2.0 unx     1204 b- defN 22-Jan-11 13:11 pyalgotrading/broker/utils.py
 -rw-rw-r--  2.0 unx        0 b- defN 22-Jan-11 13:11 pyalgotrading/instrument/__init__.py
 -rw-rw-r--  2.0 unx     1688 b- defN 22-Jan-11 13:11 pyalgotrading/instrument/instrument.py
 -rw-rw-r--  2.0 unx        0 b- defN 22-Jan-11 13:11 pyalgotrading/order/__init__.py
 -rw-rw-r--  2.0 unx     1742 b- defN 23-May-09 09:57 pyalgotrading/order/order_base.py
 -rw-rw-r--  2.0 unx     3576 b- defN 23-May-09 09:57 pyalgotrading/order/order_bracket_base.py
 -rw-rw-r--  2.0 unx     2313 b- defN 23-May-09 09:57 pyalgotrading/order/order_regular_base.py
 -rw-rw-r--  2.0 unx       40 b- defN 22-Sep-14 09:46 pyalgotrading/strategy/__init__.py
 -rw-rw-r--  2.0 unx     4717 b- defN 23-May-05 12:57 pyalgotrading/strategy/strategy_base.py
 -rw-rw-r--  2.0 unx      482 b- defN 22-Jan-11 13:11 pyalgotrading/strategy/validate_strategy.py
 -rw-rw-r--  2.0 unx        0 b- defN 22-Jan-11 13:11 pyalgotrading/utils/__init__.py
--rw-rw-r--  2.0 unx     7089 b- defN 23-May-09 09:57 pyalgotrading/utils/func.py
+-rw-rw-r--  2.0 unx     8656 b- defN 23-Jun-10 13:22 pyalgotrading/utils/func.py
 -rw-rw-r--  2.0 unx       83 b- defN 23-May-09 09:57 pyalgotrading/utils/candlesticks/__init__.py
 -rw-rw-r--  2.0 unx     2003 b- defN 22-Jan-11 13:11 pyalgotrading/utils/candlesticks/heikinashi.py
 -rw-rw-r--  2.0 unx     1434 b- defN 22-Jan-11 13:11 pyalgotrading/utils/candlesticks/linebreak.py
 -rw-rw-r--  2.0 unx     2089 b- defN 22-Jan-11 13:11 pyalgotrading/utils/candlesticks/renko.py
--rw-rw-r--  2.0 unx     1066 b- defN 23-May-09 09:57 pyalgotrading-2023.5.4.dist-info/LICENSE
--rw-rw-r--  2.0 unx     5123 b- defN 23-May-09 09:57 pyalgotrading-2023.5.4.dist-info/METADATA
--rw-rw-r--  2.0 unx       92 b- defN 23-May-09 09:57 pyalgotrading-2023.5.4.dist-info/WHEEL
--rw-rw-r--  2.0 unx       14 b- defN 23-May-09 09:57 pyalgotrading-2023.5.4.dist-info/top_level.txt
-?rw-rw-r--  2.0 unx     2757 b- defN 23-May-09 09:57 pyalgotrading-2023.5.4.dist-info/RECORD
-30 files, 120130 bytes uncompressed, 28227 bytes compressed:  76.5%
+-rw-rw-r--  2.0 unx     1066 b- defN 23-Jun-10 13:24 pyalgotrading-2023.6.1.dist-info/LICENSE
+-rw-rw-r--  2.0 unx     5123 b- defN 23-Jun-10 13:24 pyalgotrading-2023.6.1.dist-info/METADATA
+-rw-rw-r--  2.0 unx       92 b- defN 23-Jun-10 13:24 pyalgotrading-2023.6.1.dist-info/WHEEL
+-rw-rw-r--  2.0 unx       14 b- defN 23-Jun-10 13:24 pyalgotrading-2023.6.1.dist-info/top_level.txt
+?rw-rw-r--  2.0 unx     2757 b- defN 23-Jun-10 13:24 pyalgotrading-2023.6.1.dist-info/RECORD
+30 files, 125742 bytes uncompressed, 29502 bytes compressed:  76.5%
```

## zipnote {}

```diff
@@ -69,23 +69,23 @@
 
 Filename: pyalgotrading/utils/candlesticks/linebreak.py
 Comment: 
 
 Filename: pyalgotrading/utils/candlesticks/renko.py
 Comment: 
 
-Filename: pyalgotrading-2023.5.4.dist-info/LICENSE
+Filename: pyalgotrading-2023.6.1.dist-info/LICENSE
 Comment: 
 
-Filename: pyalgotrading-2023.5.4.dist-info/METADATA
+Filename: pyalgotrading-2023.6.1.dist-info/METADATA
 Comment: 
 
-Filename: pyalgotrading-2023.5.4.dist-info/WHEEL
+Filename: pyalgotrading-2023.6.1.dist-info/WHEEL
 Comment: 
 
-Filename: pyalgotrading-2023.5.4.dist-info/top_level.txt
+Filename: pyalgotrading-2023.6.1.dist-info/top_level.txt
 Comment: 
 
-Filename: pyalgotrading-2023.5.4.dist-info/RECORD
+Filename: pyalgotrading-2023.6.1.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## pyalgotrading/constants.py

```diff
@@ -242,9 +242,15 @@
     ENTRY_BUY = 'ENTRY_BUY'
     ENTRY_SELL = 'ENTRY_SELL'
     EXIT_BUY = 'EXIT_BUY'
     EXIT_SELL = 'EXIT_SELL'
     NO_ACTION = 'NO_ACTION'
 
 
-MESSAGE_REALTRADING_FORBIDDEN = 'Forbidden. This strategy is not approved for RT mode. Email us on support@algobulls.com to get your strategy approved. ' \
-                                'The AlgoBulls support team will guide you with the approval process. Once your strategy is approved, you can run it for RT directly from your AlgoBulls account.'
+KEY_DT_FORMAT_WITH_TIMEZONE = 0
+KEY_DT_FORMAT_WITHOUT_TIMEZONE = 1
+
+TRADING_TYPE_DT_FORMAT_MAP = {
+    TradingType.BACKTESTING: {KEY_DT_FORMAT_WITH_TIMEZONE: '%Y-%m-%d %H:%M %z', KEY_DT_FORMAT_WITHOUT_TIMEZONE: '%Y-%m-%d %H:%M'},
+    TradingType.PAPERTRADING: {KEY_DT_FORMAT_WITH_TIMEZONE: '%H:%M %z', KEY_DT_FORMAT_WITHOUT_TIMEZONE: '%H:%M'},
+    TradingType.REALTRADING: {KEY_DT_FORMAT_WITH_TIMEZONE: '%H:%M %z', KEY_DT_FORMAT_WITHOUT_TIMEZONE: '%H:%M'},
+}
```

## pyalgotrading/algobulls/api.py

```diff
@@ -3,16 +3,18 @@
 """
 import re
 from datetime import datetime as dt, timezone
 from json import JSONDecodeError
 
 import requests
 
-from .exceptions import AlgoBullsAPIBaseException, AlgoBullsAPIUnauthorizedError, AlgoBullsAPIInsufficientBalanceError, AlgoBullsAPIResourceNotFoundError, AlgoBullsAPIBadRequest, AlgoBullsAPIInternalServerErrorException, AlgoBullsAPIForbiddenError
-from ..constants import TradingType, TradingReportType, MESSAGE_REALTRADING_FORBIDDEN
+from .exceptions import AlgoBullsAPIBaseException, AlgoBullsAPIUnauthorizedErrorException, AlgoBullsAPIInsufficientBalanceErrorException, AlgoBullsAPIResourceNotFoundErrorException, AlgoBullsAPIBadRequestException, \
+    AlgoBullsAPIInternalServerErrorException, AlgoBullsAPIForbiddenErrorException, AlgoBullsAPIGatewayTimeoutErrorException
+from ..constants import TradingType, TradingReportType
+from ..utils.func import get_raw_response
 
 
 class AlgoBullsAPI:
     """
     AlgoBulls API
     """
     SERVER_ENDPOINT = 'https://api.algobulls.com/'
@@ -42,15 +44,16 @@
         Args:
             access_token: Access token generated by logging to the URL given by the `get_authorization_url()` method
         """
         self.headers = {
             'Authorization': f'{access_token}'
         }
 
-    def _send_request(self, method: str = 'get', endpoint: str = '', base_url: str = SERVER_ENDPOINT, params: [str, dict] = None, json_data: [str, dict] = None, requires_authorization: bool = True) -> dict:
+    def _send_request(self, method: str = 'get', endpoint: str = '', base_url: str = SERVER_ENDPOINT, params: [str, dict] = None, json_data: [str, dict] = None, requires_authorization: bool = True,
+                      raise_exception_unknown_status_code: bool = True) -> dict:
         """
         Send the request to the platform
         
         Args:
             method: get
             endpoint: endpoint url
             base_url: base url
@@ -59,43 +62,50 @@
             requires_authorization: True or False
 
         Returns:
             request status
         """
         url = f'{base_url}{endpoint}'
         headers = self.headers if requires_authorization else None
-        response = requests.request(method=method, headers=headers, url=url, params=params, json=json_data)
+        r = requests.request(method=method, headers=headers, url=url, params=params, json=json_data)
 
-        try:
-            response_json = response.json()
-        except JSONDecodeError:
-            response_json = str(response)
-
-        if response.status_code == 200:
-            response_json = response.json()
-            return response_json
-        elif response.status_code == 400:
-            raise AlgoBullsAPIBadRequest(method=method, url=url, response=response_json)
-        elif response.status_code == 401:
-            raise AlgoBullsAPIUnauthorizedError(method=method, url=url, response=response_json)
-            # try:
-            #     raise AlgoBullsAPIUnauthorizedError(method=method, url=url, response=response_json)
-            # except AlgoBullsAPIUnauthorizedError as ex:
-            #     print(f'{ex.get_error_type()}. {ex.response}')
-        elif response.status_code == 402:
-            raise AlgoBullsAPIInsufficientBalanceError(method=method, url=url, response=response_json)
-        elif response.status_code == 403:
-            raise AlgoBullsAPIForbiddenError(method=method, url=url, response=response_json)
-        elif response.status_code == 404:
-            raise AlgoBullsAPIResourceNotFoundError(method=method, url=url, response=response_json)
-        elif response.status_code == 500:
-            raise AlgoBullsAPIInternalServerErrorException(method=method, url=url, response=response_json)
+        if r.status_code == 200:
+            try:
+                r_json = r.json()
+                return r_json
+            except JSONDecodeError:
+                r.raw.decode_content = True
+                return {'response': get_raw_response(r)}
+        elif r.status_code == 400:
+            r.raw.decode_content = True
+            raise AlgoBullsAPIBadRequestException(method=method, url=url, response=get_raw_response(r), status_code=400)
+        elif r.status_code == 401:
+            r.raw.decode_content = True
+            raise AlgoBullsAPIUnauthorizedErrorException(method=method, url=url, response=get_raw_response(r), status_code=401)
+        elif r.status_code == 402:
+            r.raw.decode_content = True
+            raise AlgoBullsAPIInsufficientBalanceErrorException(method=method, url=url, response=get_raw_response(r), status_code=402)
+        elif r.status_code == 403:
+            r.raw.decode_content = True
+            raise AlgoBullsAPIForbiddenErrorException(method=method, url=url, response=get_raw_response(r), status_code=403)
+        elif r.status_code == 404:
+            r.raw.decode_content = True
+            raise AlgoBullsAPIResourceNotFoundErrorException(method=method, url=url, response=get_raw_response(r), status_code=404)
+        elif r.status_code == 500:
+            r.raw.decode_content = True
+            raise AlgoBullsAPIInternalServerErrorException(method=method, url=url, response=get_raw_response(r), status_code=500)
+        elif r.status_code == 504:
+            r.raw.decode_content = True
+            raise AlgoBullsAPIGatewayTimeoutErrorException(method=method, url=url, response=get_raw_response(r), status_code=504)
         else:
-            response.raw.decode_content = True
-            raise AlgoBullsAPIBaseException(method=method, url=url, response=response_json)
+            if raise_exception_unknown_status_code:
+                r.raw.decode_content = True
+                raise AlgoBullsAPIBaseException(method=method, url=url, response=get_raw_response(r), status_code=r.status_code)
+            else:
+                return r.json()
 
     def __fetch_key(self, strategy_code, trading_type):
         """
         Add strategy to Back Testing
         
         Args:
             strategy_code: strategy code
@@ -122,14 +132,15 @@
             response = self._send_request(method='put', endpoint=endpoint, json_data=json_data)
         elif trading_type is TradingType.BACKTESTING:
             response = self._send_request(method='patch', endpoint=endpoint, json_data=json_data)
         else:
             raise NotImplementedError
 
         key = response.get('key')
+
         return key
 
     def __get_key(self, strategy_code, trading_type):
         if trading_type is TradingType.BACKTESTING:
             if self.__key_backtesting.get(strategy_code) is None:
                 self.__key_backtesting[strategy_code] = self.__fetch_key(strategy_code=strategy_code, trading_type=TradingType.BACKTESTING)
             return self.__key_backtesting[strategy_code]
@@ -165,15 +176,15 @@
         try:
             json_data = {'strategyName': strategy_name, 'strategyDetails': strategy_details, 'abcVersion': abc_version}
             endpoint = f'v3/build/python/user/strategy/code'
             print(f"Uploading strategy '{strategy_name}' ...", end=' ')
             response = self._send_request(endpoint=endpoint, method='post', json_data=json_data)
             print('Success.')
             return response
-        except (AlgoBullsAPIForbiddenError, AlgoBullsAPIInsufficientBalanceError) as ex:
+        except (AlgoBullsAPIForbiddenErrorException, AlgoBullsAPIInsufficientBalanceErrorException) as ex:
             print('Fail.')
             print(f'{ex.get_error_type()}: {ex.response}')
 
     def update_strategy(self, strategy_code: str, strategy_name: str, strategy_details: str, abc_version: str) -> dict:
         """
         Update an already existing strategy on the AlgoBulls platform
 
@@ -188,28 +199,30 @@
 
         Info: ENDPOINT
             PUT v2/user/strategy/build/python
         """
         json_data = {'strategyId': strategy_code, 'strategyName': strategy_name, 'strategyDetails': strategy_details, 'abcVersion': abc_version}
         endpoint = f'v3/build/python/user/strategy/code'
         response = self._send_request(endpoint=endpoint, method='put', json_data=json_data)
+
         return response
 
     def get_all_strategies(self) -> dict:
         """
         Get all the Python strategies created by the user on the AlgoBulls platform
 
         Returns:
             JSON Response received from AlgoBulls platform with list of all the created strategies.
 
         Info: ENDPOINT
             `OPTIONS` v3/build/python/user/strategy/code
         """
         endpoint = f'v3/build/python/user/strategy/code'
         response = self._send_request(endpoint=endpoint, method='options')
+
         return response
 
     def get_strategy_details(self, strategy_code: str) -> dict:
         """
         Get strategy details for a particular strategy
 
         Args:
@@ -220,14 +233,15 @@
             
         Info: ENDPOINT
             `GET` v3/build/python/user/strategy/code/{strategy_code}
         """
         params = {}
         endpoint = f'v3/build/python/user/strategy/code/{strategy_code}'
         response = self._send_request(endpoint=endpoint, params=params)
+
         return response
 
     def search_instrument(self, tradingsymbol: str, exchange: str) -> dict:
         """
         Search for an instrument using its trading symbol
         
         Args:
@@ -239,14 +253,15 @@
             
         INFO: ENDPOINT
             `GET` v4/portfolio/searchInstrument
         """
         params = {'search': tradingsymbol, 'exchange': exchange}
         endpoint = f'v4/portfolio/searchInstrument'
         response = self._send_request(endpoint=endpoint, params=params, requires_authorization=False)
+
         return response
 
     def delete_previous_trades(self, strategy: str):
         """
         Delete the previous trades of given strategy
 
         Args:
@@ -256,14 +271,15 @@
             response: response from api
 
         Info: ENDPOINT
            `DELETE` v3/build/python/user/strategy/deleteAll?strategyId={strategy}
         """
         endpoint = f'v3/build/python/user/strategy/deleteAll?strategyId={strategy}'
         response = self._send_request(method='delete', endpoint=endpoint)
+
         return response
 
     def set_strategy_config(self, strategy_code: str, strategy_config: dict, trading_type: TradingType) -> (str, dict):
         """
         Set configuration before running a strategy
         
         Args:
@@ -279,89 +295,87 @@
 
         # Configure the params
         key = self.__get_key(strategy_code=strategy_code, trading_type=trading_type)
         endpoint = f'v4/portfolio/tweak/{key}?isPythonBuild=true'
         print('Setting Strategy Config...', end=' ')
         response = self._send_request(method='post', endpoint=endpoint, json_data=strategy_config)
         print('Success.')
+
         return key, response
 
-    def start_strategy_algotrading(self, strategy_code: str, start_timestamp: dt, end_timestamp: dt, trading_type: TradingType, lots: int) -> dict:
+    def start_strategy_algotrading(self, strategy_code: str, start_timestamp: dt, end_timestamp: dt, trading_type: TradingType, lots: int, initial_funds_virtual=1e9, broker_details: dict = None) -> dict:
         """
         Submit Backtesting / Paper Trading / Real Trading job for strategy with code strategy_code & return the job ID.
         
         Args:
             strategy_code: Strategy code
             start_timestamp: Start date/time
             end_timestamp: End date/time
             trading_type: Trading type
             lots: Lots
-
+            initial_funds_virtual: virtual funds before starting the strategy
+            broker_details: client's broking details
         Info: ENDPOINT
             `PATCH` v4/portfolio/strategies?isPythonBuild=true
         """
-        if trading_type == TradingType.REALTRADING:
-            return {'message': MESSAGE_REALTRADING_FORBIDDEN}
-        elif trading_type in [TradingType.PAPERTRADING, TradingType.BACKTESTING]:
-            endpoint = 'v4/portfolio/strategies?isPythonBuild=true'
-        else:
-            raise NotImplementedError
 
         try:
             key = self.__get_key(strategy_code=strategy_code, trading_type=trading_type)
             map_trading_type_to_date_key = {
                 TradingType.REALTRADING: 'liveDataTime',
                 TradingType.PAPERTRADING: 'backDataTime',
                 TradingType.BACKTESTING: 'backDataDate'
             }
-            _timestamp_format = "%d-%m-%YT%H:%MZ"
             execute_config = {
-                map_trading_type_to_date_key[trading_type]: [start_timestamp.astimezone().astimezone(timezone.utc).isoformat(), end_timestamp.astimezone().astimezone(timezone.utc).isoformat()],
-                'isLiveDataTestMode': trading_type == TradingType.PAPERTRADING,
-                'customizationsQuantity': lots
+                map_trading_type_to_date_key[trading_type]: [start_timestamp.astimezone(timezone.utc).isoformat(), end_timestamp.astimezone(timezone.utc).isoformat()],
+                'isLiveDataTestMode': trading_type in [TradingType.PAPERTRADING, TradingType.REALTRADING],
+                'customizationsQuantity': lots,
+                'brokingDetails': broker_details
             }
+
+            params = None
+            if trading_type in [TradingType.PAPERTRADING, TradingType.BACKTESTING]:
+                endpoint = 'v4/portfolio/strategies?isPythonBuild=true&isLive=false'
+                execute_config['initialFundsVirtual'] = initial_funds_virtual
+            elif trading_type is TradingType.REALTRADING:
+                endpoint = 'v4/portfolio/strategies?isPythonBuild=true&isLive=true'
+            else:
+                raise NotImplementedError
             json_data = {'method': 'update', 'newVal': 1, 'key': key, 'record': {'status': 0, 'lots': lots, 'executeConfig': execute_config}, 'dataIndex': 'executeConfig'}
             print(f'Submitting {trading_type.name} job...', end=' ')
-            response = self._send_request(method='patch', endpoint=endpoint, json_data=json_data)
-            print('Success.')
 
-            # cleanup
-            self.connection.pnl_data = None
+            response = self._send_request(method='patch', endpoint=endpoint, json_data=json_data, params=params)
+            print('Success.')
 
             return response
-        except (AlgoBullsAPIForbiddenError, AlgoBullsAPIInsufficientBalanceError) as ex:
+        except (AlgoBullsAPIForbiddenErrorException, AlgoBullsAPIInsufficientBalanceErrorException) as ex:
             print('Fail.')
             print(f'{ex.get_error_type()}: {ex.response}')
 
     def stop_strategy_algotrading(self, strategy_code: str, trading_type: TradingType) -> dict:
         """
         Stop Backtesting / Paper Trading / Real Trading job for strategy with code strategy_code & return the job ID.
         
         Args:
             strategy_code: Strategy code
             trading_type: Trading type
         
         Info: ENDPOINT
             `POST` v4/portfolio/strategies
         """
-        if trading_type == TradingType.REALTRADING:
-            return {'message': 'Please get approval for your strategy by writing to support@algobulls.com. Once approved, you can STOP the strategy in REALTRADING mode directly from the website.'}
-        elif trading_type in [TradingType.PAPERTRADING, TradingType.BACKTESTING]:
-            endpoint = 'v4/portfolio/strategies'
-        else:
-            raise NotImplementedError
-
+        endpoint = 'v4/portfolio/strategies'
         try:
             key = self.__get_key(strategy_code=strategy_code, trading_type=trading_type)
             json_data = {'method': 'update', 'newVal': 0, 'key': key, 'record': {'status': 2}, 'dataIndex': 'executeConfig'}
             print(f'Stopping {trading_type.name} job...', end=' ')
             response = self._send_request(method='patch', endpoint=endpoint, json_data=json_data)
             print('Success.')
+
             return response
-        except (AlgoBullsAPIForbiddenError, AlgoBullsAPIInsufficientBalanceError) as ex:
+        except (AlgoBullsAPIForbiddenErrorException, AlgoBullsAPIInsufficientBalanceErrorException) as ex:
             print('Fail.')
             print(f'{ex.get_error_type()}: {ex.response}')
 
     def get_job_status(self, strategy_code: str, trading_type: TradingType) -> dict:
         """
         Get status for a Back Testing / Paper Trading / Real Trading Job
 
@@ -375,14 +389,15 @@
         Info: ENDPOINT
             `GET` v2/user/strategy/status
         """
         key = self.__get_key(strategy_code=strategy_code, trading_type=trading_type)
         params = {'key': key}
         endpoint = f'v2/user/strategy/status'
         response = self._send_request(endpoint=endpoint, params=params)
+
         return response
 
     def get_logs(self, strategy_code: str, trading_type: TradingType) -> dict:
         """
         Fetch logs for a strategy
         
         Args:
@@ -395,14 +410,15 @@
         Info: ENDPOINT
             `POST`: v2/user/strategy/logs
         """
         endpoint = 'v2/user/strategy/logs'
         key = self.__get_key(strategy_code=strategy_code, trading_type=trading_type)
         json_data = {'key': key}
         response = self._send_request(method='post', endpoint=endpoint, json_data=json_data)
+
         return response
 
     def get_reports(self, strategy_code: str, trading_type: TradingType, report_type: TradingReportType) -> dict:
         """
         Fetch report for a strategy
 
         Args:
@@ -426,8 +442,9 @@
         elif report_type is TradingReportType.ORDER_HISTORY:
             endpoint = 'v2/user/strategy/orderhistory'
             params = {'key': key}
         else:
             raise NotImplementedError
 
         response = self._send_request(endpoint=endpoint, params=params)
+
         return response
```

## pyalgotrading/algobulls/connection.py

```diff
@@ -6,31 +6,33 @@
 from collections import OrderedDict
 from datetime import datetime as dt
 
 import pandas as pd
 import quantstats as qs
 
 from .api import AlgoBullsAPI
-from .exceptions import AlgoBullsAPIBadRequest
-from ..constants import StrategyMode, TradingType, TradingReportType, CandleInterval, MESSAGE_REALTRADING_FORBIDDEN, AlgoBullsEngineVersion
+from .exceptions import AlgoBullsAPIBadRequestException, AlgoBullsAPIGatewayTimeoutErrorException
+from ..constants import StrategyMode, TradingType, TradingReportType, CandleInterval, AlgoBullsEngineVersion
 from ..strategy.strategy_base import StrategyBase
-from ..utils.func import get_valid_enum_names
+from ..utils.func import get_valid_enum_names, get_datetime_with_tz
 
 
 class AlgoBullsConnection:
     """
     Class for AlgoBulls connection
     """
 
     def __init__(self):
         """
         Init method that is used while creating an object of this class
         """
         self.api = AlgoBullsAPI(self)
-        self.pnl_data = None
+        self.backtesting_pnl_data = None
+        self.papertrade_pnl_data = None
+        self.realtrade_pnl_data = None
 
     @staticmethod
     def get_authorization_url():
         """
         Fetch the authorization URL
 
         Returns:
@@ -119,14 +121,15 @@
                 try:
                     _strategy_code = {_dict['strategyName']: _dict['strategyCode'] for _dict in _}[strategy_name]
                     response = self.api.update_strategy(strategy_code=_strategy_code, strategy_name=strategy_name, strategy_details=strategy_details, abc_version=_abc_version)
 
                 except KeyError:
                     response = self.api.create_strategy(strategy_name=strategy_name, strategy_details=strategy_details,
                                                         abc_version=_abc_version)
+
         return response
 
     def get_all_strategies(self, return_as_dataframe=True):
         """
         Fetch all available strategies
 
         Args:
@@ -154,15 +157,15 @@
         """
         assert isinstance(strategy_code, str), f'Argument "strategy_code" should be a string'
 
         try:
             response = self.api.get_strategy_details(strategy_code)
             strategy_code = response['data']
             return strategy_code
-        except AlgoBullsAPIBadRequest:
+        except AlgoBullsAPIBadRequestException:
             print(f'ERROR: No strategy found with ID: {strategy_code}')
 
     def search_instrument(self, instrument, exchange='NSE'):
         """
         Search for an instrument
 
         Args:
@@ -170,26 +173,34 @@
             exchange: exchange, default is 'NSE'
 
         Returns:
             A list of matching instruments
         """
         assert isinstance(instrument, str), f'Argument "instrument" should be a string'
         response = self.api.search_instrument(instrument, exchange=exchange).get('data')
+
         return response
 
     def delete_previous_trades(self, strategy):
         """
         Delete all the previous trades and clear the pnl table
 
         Args:
             strategy: Strategy code
         """
-        response = self.api.delete_previous_trades(strategy)
-        if response['data'] != 'success':
-            print(f'Deletion of previous trade data for strategy "{strategy}" may not have been successful. Details: {response}')
+        response = {}
+        for _ in range(30):
+            try:
+                response = self.api.delete_previous_trades(strategy)
+                print(response.get('message'))
+                break
+            except AlgoBullsAPIGatewayTimeoutErrorException as ex:
+                print(f'Deleting previous trades... in process... (attempt {_})\n{ex}')
+                time.sleep(1)
+
         return response
 
     def get_job_status(self, strategy_code, trading_type):
         """
         Get status for a Back Testing / Paper Trading / Real Trading Job
 
         Args:
@@ -265,143 +276,289 @@
                     pandas_dataframe_all_rows()
                 _response = pd.DataFrame(response['data'])
             else:
                 _response = response['data']
             return _response
         else:
             print('Report not available yet. Please retry in sometime')
-            # return response
 
-    def backtest(self, strategy=None, start=None, end=None, instruments=None, lots=1, parameters=None, candle=None, mode=StrategyMode.INTRADAY, delete_previous_trades=True, **kwargs):
+    def get_pnl_report_table(self, strategy_code, trading_type):
         """
-        Submit a backtesting job for a strategy on the AlgoBulls Platform
+            Fetch BT/PT/RT Profit & Loss details
+
+            Args:
+                strategy_code: strategy code
+                trading_type: type of trades : Backtesting, Papertrading, Realtrading
+
+            Returns:
+                Report details
+        """
+        assert isinstance(strategy_code, str), f'Argument "strategy_code" should be a string'
+
+        # Fetch the data
+        data = self.get_report(strategy_code=strategy_code, trading_type=trading_type, report_type=TradingReportType.PNL_TABLE)
+
+        # Post-processing: Cleanup & converting data to dataframe
+        column_rename_map = OrderedDict([
+            ('strategy.instrument.segment', 'instrument_segment'),
+            ('strategy.instrument.tradingsymbol', 'instrument_tradingsymbol'),
+            ('entry.timestamp', 'entry_timestamp'),
+            ('entry.isBuy', 'entry_transaction_type'),
+            ('entry.quantity', 'entry_quantity'),
+            ('entry.prefix', 'entry_currency'),
+            ('entry.price', 'entry_price'),
+            ('exit.timestamp', 'exit_timestamp'),
+            ('exit.isBuy', 'exit_transaction_type'),
+            ('exit.quantity', 'exit_quantity'),
+            ('exit.prefix', 'exit_currency'),
+            ('exit.price', 'exit_price'),
+            ('pnlAbsolute.value', 'pnl_absolute')
+        ])
+        if data:
+            # Generate df from json data & perform cleanups
+            _df = pd.json_normalize(data[::-1])[list(column_rename_map.keys())].rename(columns=column_rename_map)
+            _df[['entry_timestamp', 'exit_timestamp']] = _df[['entry_timestamp', 'exit_timestamp']].apply(pd.to_datetime, format="%Y-%m-%d | %H:%M", errors="coerce")
+            _df['entry_transaction_type'] = _df['entry_transaction_type'].apply(lambda _: 'BUY' if _ else 'SELL')
+            _df['exit_transaction_type'] = _df['exit_transaction_type'].apply(lambda _: 'BUY' if _ else 'SELL')
+            _df["pnl_cumulative_absolute"] = _df["pnl_absolute"].cumsum(axis=0, skipna=True)
+
+        else:
+            # No data available, send back an empty dataframe
+            _df = pd.DataFrame(columns=list(column_rename_map.values()))
+
+        return _df
+
+    def get_report_statistics(self, strategy_code, initial_funds, report, html_dump, pnl_df):
+        """
+            Fetch BT/PT/RT report statistics
+
+            Args:
+                strategy_code: strategy code
+                report: format and content of the report
+                html_dump: save it as a html file
+                pnl_df: dataframe containing pnl reports
+                initial_funds: initial funds to before starting the job
+            Returns:
+                Report details
+        """
+
+        order_report = None
+
+        # get pnl data and cleanup as per quantstats format
+        _returns_df = pnl_df[['entry_timestamp', 'pnl_absolute']]
+        _returns_df = _returns_df.set_index('entry_timestamp')
+        _returns_df["total_funds"] = _returns_df.pnl_absolute.cumsum() + initial_funds
+        _returns_df = _returns_df.dropna()
+
+        # Note: Quantstats has a potential bug. It cannot work with multiple entries having the same timestamp. For now, we are dropping multiple entries with the same entry_timestamp (else the quantstats code below would throw an error)
+        # Suggestion for workaround: For entries with same entry timestamps, we can slightly modify the entry timestamps by adding single-digit microseconds to make them unique
+        _returns_df = _returns_df[~_returns_df.index.duplicated(keep='first')]
+
+        # Extract the final column; note: timestamp is the index so that is available too
+        total_funds_series = _returns_df.total_funds
+
+        # select report type
+        if report == "metrics":
+            order_report = qs.reports.metrics(total_funds_series)
+        elif report == "full":
+            order_report = qs.reports.full(total_funds_series)
+
+        # save as html file
+        if html_dump:
+            all_strategies = self.get_all_strategies()
+            strategy_name = all_strategies.loc[all_strategies['strategyCode'] == strategy_code]['strategyName'].iloc[0]
+            qs.reports.html(total_funds_series, title=strategy_name, output='', download_filename=f'report_{strategy_name}_{time.time():.0f}.html')
+
+        return order_report
+
+    def start_job(self, strategy=None, start=None, end=None, instruments=None, lots=1, parameters=None, candle=None, mode=StrategyMode.INTRADAY, initial_funds_virtual=1e9, delete_previous_trades=True, trading_type=None, broking_details=None,
+                  **kwargs):
+        """
+        Submit a BT/PT/RT job for a strategy on the AlgoBulls Platform
 
         Args:
             strategy: Strategy code
-            start: Start date/time
-            end: End date/time
+            start: Start date-time/time
+            end: End date-time/time
             instruments: Instrument key
             lots: Number of lots of the passed instrument to trade on
             parameters: Parameters
             candle: Candle interval
             mode: Intraday or delivery
             delete_previous_trades: Delete data for previous trades
+            initial_funds_virtual: virtual funds allotted before the backtesting starts
+            trading_type: type of trading : PT/BT/RT
+            broking_details: details of client's broker
 
         Legacy args (will be deprecated in future release):
-            'strategy_code' behaves same 'strategy'
-            'start_timestamp' behaves same 'start'
-            'end_timestamp' behaves same 'end'
-            'instrument' behaves same 'instruments'
-            'strategy_parameters' behaves same 'parameters'
-            'candle_interval' behaves same 'candle'
-            'strategy__mode' behaves same 'mode'
+            'strategy_code' behaves same as 'strategy'
+            'start_timestamp' behaves same as 'start'
+            'end_timestamp' behaves same as 'end'
+            'instrument' behaves same as 'instruments'
+            'strategy_parameters' behaves same as 'parameters'
+            'candle_interval' behaves same as 'candle'
+            'strategy_mode' behaves same as 'mode'
 
         Returns:
-            backtest job submission status
+            job submission status
         """
-
         # check if values received by new parameter names, else extract from old parameter names
         strategy = strategy if strategy is not None else kwargs.get('strategy_code')
         start = start if start is not None else kwargs.get('start_timestamp')
         end = end if end is not None else kwargs.get('end_timestamp')
         parameters = parameters if parameters is not None else kwargs.get('strategy_parameters')
         candle = candle if candle is not None else kwargs.get('candle_interval')
         instruments = instruments if instruments is not None else kwargs.get('instrument')
         mode = mode if 'strategy_mode' not in kwargs else kwargs.get('strategy_mode')
 
         # Sanity checks - Convert config parameters
         _error_msg_candle = f'Argument "candle" should be a valid string or an enum of type CandleInterval. Possible string values can be: {get_valid_enum_names(CandleInterval)}'
-        _error_msg_timestamps = f'Argument "start" should be a valid timestamp string (YYYY-MM-DD | HH:MM) or an instance of type datetime.datetime'
+        _error_msg_timestamps = f'\nString Format (YYYY-MM-DD HH:MM z) or an instance of type datetime.datetime for Back Testing \nString Format (HH:MM z) or an instance of type datetime.time for Real trading or Paper Trading'
         _error_msg_instruments = f'Argument "instruments" should be a valid instrument string or a list of valid instruments strings. You can use the \'get_instrument()\' method of AlgoBullsConnection class to search for instruments'
         _error_msg_mode = f'Argument "mode" should be a valid string or an enum of type StrategyMode. Possible string values can be: {get_valid_enum_names(StrategyMode)}'
-
+        _error_msg_broking_details = 'Argument "broking_details" should be a valid dict with valid keys. Expected keys "brokerName" and "credentialParameters" '
+        initial_funds_virtual = float(initial_funds_virtual)
         if isinstance(start, str):
-            start = dt.strptime(start, '%Y-%m-%d | %H:%M')
+            start = get_datetime_with_tz(start, trading_type)
         if isinstance(end, str):
-            end = dt.strptime(end, '%Y-%m-%d | %H:%M')
+            end = get_datetime_with_tz(end, trading_type)
         if isinstance(mode, str):
             _ = mode.upper()
             assert _ in StrategyMode.__members__, _error_msg_candle
             mode = StrategyMode[_]
         if isinstance(candle, str):
             _ = f"{'_' if candle[0].isdigit() else ''}{candle.strip().upper().replace(' ', '_')}"
             assert _ in CandleInterval.__members__, _error_msg_candle
             candle = CandleInterval[_]
         if isinstance(instruments, str):
             instruments = [instruments]
 
         # Sanity checks - Validate config parameters
         assert isinstance(strategy, str), f'Argument "strategy" should be a valid string'
-        assert isinstance(start, dt), _error_msg_timestamps
-        assert isinstance(end, dt), _error_msg_timestamps
+        assert isinstance(start, dt), 'Argument "start" should be a valid timestamp string\n' + _error_msg_timestamps
+        assert isinstance(end, dt), 'Argument "end" should be a valid timestamp string\n' + _error_msg_timestamps
         assert isinstance(instruments, list), _error_msg_instruments
         assert len(instruments) > 0, _error_msg_instruments
         assert (isinstance(lots, int) and lots > 0), f'Argument "lots" should be a positive integer.'
         assert isinstance(parameters, dict), f'Argument "parameters" should be a dict'
         assert isinstance(mode, StrategyMode), _error_msg_mode
         assert isinstance(candle, CandleInterval), _error_msg_candle
+        assert isinstance(initial_funds_virtual, float), 'Argument "initial_funds_virtual" should be a float'
         assert isinstance(delete_previous_trades, bool), 'Argument "delete_previous_trades" should be a boolean'
 
-        if delete_previous_trades:
-            self.delete_previous_trades(strategy)
+        if broking_details is not None:
+            assert isinstance(broking_details, dict), f'Argument "broking_details" should be a dict'
+            assert 'brokerName' in broking_details, f'Argument "broking_details" should be a dict with "brokerName" key'
+            assert 'credentialParameters' in broking_details, f'Argument "broking_details" should be a dict with "credentialParameters" key'
+
+        if trading_type is not TradingType.BACKTESTING:
+            start = dt.combine(dt.now().astimezone(start.tzinfo).date(), start.time(), tzinfo=start.tzinfo)
+            end = dt.combine(dt.now().astimezone(end.tzinfo).date(), end.time(), tzinfo=end.tzinfo)
 
         # Restructuring strategy params
         restructured_strategy_parameters = []
         for parameter_name in parameters:
             restructured_strategy_parameters.append({
                 'paramName': parameter_name,
                 'paramValue': parameters[parameter_name]
             })
 
         # generate instruments' id list
         instrument_list = []
         for _instrument in instruments:
-            instrument_results = self.search_instrument(_instrument.split(':')[-1])
+            exchange, tradingsymbol = _instrument.split(':')
+            instrument_results = self.search_instrument(tradingsymbol, exchange=exchange)
             for _ in instrument_results:
                 if _["value"] == _instrument:
                     instrument_list.append({'id': _["id"]})
                     break
 
-        # Setup config for Backtesting
+        # delete previous trades
+        if delete_previous_trades and trading_type in [TradingType.BACKTESTING, TradingType.PAPERTRADING]:
+            self.delete_previous_trades(strategy)
+
+        # Setup config for starting the job
         strategy_config = {
             'instruments': {
                 'instruments': instrument_list
             },
             'lots': lots,
             'userParams': restructured_strategy_parameters,
             'candleDuration': candle.value,
             'strategyMode': mode.value
         }
-        self.api.set_strategy_config(strategy_code=strategy, strategy_config=strategy_config, trading_type=TradingType.BACKTESTING)
+        self.api.set_strategy_config(strategy_code=strategy, strategy_config=strategy_config, trading_type=trading_type)
+
+        # Submit trading job
+        response = self.api.start_strategy_algotrading(strategy_code=strategy, start_timestamp=start, end_timestamp=end, trading_type=trading_type, lots=lots, initial_funds_virtual=initial_funds_virtual, broker_details=broking_details)
+
+        return response
+
+    def backtest(self, strategy=None, start=None, end=None, instruments=None, lots=1, parameters=None, candle=None, mode=StrategyMode.INTRADAY, delete_previous_trades=True, initial_funds_virtual=1e9, vendor_details=None, **kwargs):
+        """
+        Submit a backtesting job for a strategy on the AlgoBulls Platform
+
+        Args:
+            strategy: Strategy code
+            start: Start date-time/time
+            end: End date-time/time
+            instruments: Instrument key
+            lots: Number of lots of the passed instrument to trade on
+            parameters: Parameters
+            candle: Candle interval
+            mode: Intraday or delivery
+            delete_previous_trades: Delete data for previous trades
+            initial_funds_virtual: virtual funds allotted before the backtesting starts
+            vendor_details: vendor's details for authentication and verification
+
+        Legacy args (will be deprecated in future release):
+            'strategy_code' behaves same as 'strategy'
+            'start_timestamp' behaves same as 'start'
+            'end_timestamp' behaves same as 'end'
+            'instrument' behaves same as 'instruments'
+            'strategy_parameters' behaves same as 'parameters'
+            'candle_interval' behaves same as 'candle'
+            'strategy_mode' behaves same as 'mode'
+
+        Returns:=
+            backtest job submission status
+        """
+
+        # start backtesting job
+        response = self.start_job(
+            strategy=strategy, start=start, end=end, instruments=instruments, lots=lots, parameters=parameters, candle=candle, mode=mode,
+            initial_funds_virtual=initial_funds_virtual, delete_previous_trades=delete_previous_trades, trading_type=TradingType.BACKTESTING, broking_details=vendor_details, **kwargs
+        )
 
-        # Submit Backtesting job
-        response = self.api.start_strategy_algotrading(strategy_code=strategy, start_timestamp=start, end_timestamp=end, trading_type=TradingType.BACKTESTING, lots=lots)
+        # Clear previously saved pnl data, if any
+        self.backtesting_pnl_data = None
 
     def get_backtesting_job_status(self, strategy_code):
         """
         Get Back Testing job status for given strategy_code
 
         Args:
             strategy_code: Strategy code
 
         Returns:
             Job status
         """
         assert isinstance(strategy_code, str), f'Argument "strategy_code" should be a string'
+
         return self.get_job_status(strategy_code, TradingType.BACKTESTING)
 
     def stop_backtesting_job(self, strategy_code):
         """
         Stop a running Back Testing job
 
         Args:
             strategy_code: Strategy Code
 
         Returns:
-            Job status
+            stop job status
         """
         assert isinstance(strategy_code, str), f'Argument "strategy_code" should be a string'
         return self.stop_job(strategy_code=strategy_code, trading_type=TradingType.BACKTESTING)
 
     def get_backtesting_logs(self, strategy_code):
         """
         Fetch Back Testing logs
@@ -409,391 +566,331 @@
         Args:
             strategy_code: Strategy code
 
         Returns:
             Report details
         """
         assert isinstance(strategy_code, str), f'Argument "strategy_code" should be a string'
+
         return self.get_logs(strategy_code, trading_type=TradingType.BACKTESTING)
 
     def get_backtesting_report_pnl_table(self, strategy_code, show_all_rows=False):
         """
         Fetch Back Testing Profit & Loss details
 
         Args:
             strategy_code: strategy code
             show_all_rows: True or False
 
         Returns:
             Report details
         """
+        if self.backtesting_pnl_data is None:
+            self.backtesting_pnl_data = self.get_pnl_report_table(strategy_code, TradingType.BACKTESTING)
 
-        assert isinstance(strategy_code, str), f'Argument "strategy_code" should be a string'
-
-        # Fetch the data
-        data = self.get_report(strategy_code=strategy_code, trading_type=TradingType.BACKTESTING, report_type=TradingReportType.PNL_TABLE)
+        return self.backtesting_pnl_data
 
-        # Post-processing: Cleanup & converting data to dataframe
-        column_rename_map = OrderedDict([
-            ('strategy.instrument.segment', 'instrument_segment'),
-            ('strategy.instrument.tradingsymbol', 'instrument_tradingsymbol'),
-            ('entry.timestamp', 'entry_timestamp'),
-            ('entry.isBuy', 'entry_transaction_type'),
-            ('entry.quantity', 'entry_quantity'),
-            ('entry.prefix', 'entry_currency'),
-            ('entry.price', 'entry_price'),
-            ('exit.timestamp', 'exit_timestamp'),
-            ('exit.isBuy', 'exit_transaction_type'),
-            ('exit.quantity', 'exit_quantity'),
-            ('exit.prefix', 'exit_currency'),
-            ('exit.price', 'exit_price'),
-            ('pnlAbsolute.value', 'pnl_absolute')
-        ])
-        if data:
-            # Generate df from json data & perform cleanups
-            _df = pd.json_normalize(data[::-1])[list(column_rename_map.keys())].rename(columns=column_rename_map)
-            _df[['entry_timestamp', 'exit_timestamp']] = _df[['entry_timestamp', 'exit_timestamp']].apply(pd.to_datetime, format="%Y-%m-%d | %H:%M", errors="coerce")
-            _df['entry_transaction_type'] = _df['entry_transaction_type'].apply(lambda _: 'BUY' if _ else 'SELL')
-            _df['exit_transaction_type'] = _df['exit_transaction_type'].apply(lambda _: 'BUY' if _ else 'SELL')
-            _df["pnl_cumulative_absolute"] = _df["pnl_absolute"].cumsum(axis=0, skipna=True)
-
-        else:
-            # No data available, send back an empty dataframe
-            _df = pd.DataFrame(columns=list(column_rename_map.values()))
-
-        self.pnl_data = _df
-        return self.pnl_data
-
-    def get_backtesting_report_statistics(self, strategy_code, mode='quantstats', report='metrics', html_dump=False):
+    def get_backtesting_report_statistics(self, strategy_code, initial_funds=1e9, mode='quantstats', report='metrics', html_dump=False):
         """
         Fetch Back Testing report statistics
 
         Args:
             strategy_code: strategy code
+            initial_funds: initial funds that were set before backtesting
             mode: extension used to generate statistics
             report: format and content of the report
             html_dump: save it as a html file
 
         Returns:
             Report details
         """
-
         assert isinstance(strategy_code, str), f'Argument "strategy_code" should be a string'
-        order_report = None
-        initial_funds = 1e9  # TODO: Allow this to be customized by the user
-
-        if self.pnl_data is None:
+        if self.backtesting_pnl_data is None:
             self.get_backtesting_report_pnl_table(strategy_code)
         else:
             print('Generating Statistics for already fetched P&L data...')
 
-        # get pnl data and cleanup as per quantstats format
-        _returns_df = self.pnl_data[['entry_timestamp', 'pnl_absolute']]
-        _returns_df = _returns_df.set_index('entry_timestamp')
-        _returns_df["total_funds"] = _returns_df.pnl_absolute.cumsum() + initial_funds
-        _returns_df = _returns_df.dropna()
-
-        # Note: Quantstats has a potential bug. It cannot work with multiple entries having the same timestamp. For now, we are dropping multiple entries with the same entry_timestamp (else the quantstats code below would throw an error)
-        # Suggestion for workaround: For entries with same entry timestamps, we can slightly modify the entry timestamps by adding single-digit microseconds to make them unique
-        _returns_df = _returns_df[~_returns_df.index.duplicated(keep='first')]
-
-        # Extract the final column; note: timestamp is the index so that is available too
-        total_funds_series = _returns_df.total_funds
-
-        # select report type
-        if report == "metrics":
-            order_report = qs.reports.metrics(total_funds_series)
-        elif report == "full":
-            order_report = qs.reports.full(total_funds_series)
-
-        # save as html file
-        if html_dump:
-            all_strategies = self.get_all_strategies()
-            strategy_name = all_strategies.loc[all_strategies['strategyCode'] == strategy_code]['strategyName'].iloc[0]
-            qs.reports.html(total_funds_series, title=strategy_name, output='', download_filename=f'report_{strategy_name}_{time.time():.0f}.html')
+        order_report = self.get_report_statistics(strategy_code, initial_funds, report, html_dump, self.backtesting_pnl_data)
 
         return order_report
 
     def get_backtesting_report_order_history(self, strategy_code):
         """
         Fetch Back Testing order history
 
         Args:
             strategy_code: strategy code
 
         Returns:
             Report details
         """
         assert isinstance(strategy_code, str), f'Argument "strategy_code" should be a string'
+
         return self.get_report(strategy_code=strategy_code, trading_type=TradingType.BACKTESTING, report_type=TradingReportType.ORDER_HISTORY)
 
-    def papertrade(self, strategy=None, start=None, end=None, instruments=None, lots=None, parameters=None, candle=None, mode=StrategyMode.INTRADAY, delete_previous_trades=True, **kwargs):
+    def papertrade(self, strategy=None, start=None, end=None, instruments=None, lots=None, parameters=None, candle=None, mode=StrategyMode.INTRADAY, delete_previous_trades=True, initial_funds_virtual=1e9, vendor_details=None, **kwargs):
         """
         Submit a papertrade job for a strategy on the AlgoBulls Platform
 
         Args:
             strategy: Strategy code
-            start: Start date/time
-            end: End date/time
+            start: Start date-time/time
+            end: End date-time/time
             instruments: Instrument key
             lots: Number of lots of the passed instrument to trade on
             parameters: Parameters
             candle: Candle interval
             mode: Intraday or delivery
             delete_previous_trades: Delete data of all previous trades
+            initial_funds_virtual: virtual funds allotted before the paper trading starts
+            vendor_details: vendor's details for authentication and verification
 
         Legacy args (will be deprecated in future release):
-            'strategy_code' behaves same 'strategy'
-            'start_timestamp' behaves same 'start'
-            'end_timestamp' behaves same 'end'
-            'instrument' behaves same 'instruments'
-            'strategy_parameters' behaves same 'parameters'
-            'candle_interval' behaves same 'candle'
-            'strategy__mode' behaves same 'mode'
+            'strategy_code' behaves same as 'strategy'
+            'start_timestamp' behaves same as 'start'
+            'end_timestamp' behaves same as 'end'
+            'instrument' behaves same as 'instruments'
+            'strategy_parameters' behaves same as 'parameters'
+            'candle_interval' behaves same as 'candle'
+            'strategy_mode' behaves same as 'mode'
 
         Returns:
             papertrade job submission status
         """
 
-        # check if values received by new parameter names, else extract from old parameter names
-        strategy = strategy if strategy is not None else kwargs.get('strategy_code')
-        start = start if start is not None else kwargs.get('start_timestamp')
-        end = end if end is not None else kwargs.get('end_timestamp')
-        parameters = parameters if parameters is not None else kwargs.get('strategy_parameters')
-        candle = candle if candle is not None else kwargs.get('candle_interval')
-        instruments = instruments if instruments is not None else kwargs.get('instrument')
-        mode = mode if 'strategy_mode' not in kwargs else kwargs.get('strategy_mode')
+        # start papertrading job
+        response = self.start_job(
+            strategy=strategy, start=start, end=end, instruments=instruments, lots=lots, parameters=parameters, candle=candle, mode=mode,
+            initial_funds_virtual=initial_funds_virtual, delete_previous_trades=delete_previous_trades, trading_type=TradingType.PAPERTRADING, broking_details=vendor_details, **kwargs
+        )
 
-        # Sanity checks - Convert config parameters
-        _error_msg_candle = f'Argument "candle" should be a valid string or an enum of type CandleInterval. Possible string values can be: {get_valid_enum_names(CandleInterval)}'
-        _error_msg_timestamps = f'Argument "start" should be a valid time string (HH:MM) or an instance of type datetime.time'
-        _error_msg_instruments = f'Argument "instruments" should be a valid instrument string or a list of valid instruments strings. You can use the \'get_instrument()\' method of AlgoBullsConnection class to search for instruments'
-        _error_msg_mode = f'Argument "mode" should be a valid string or an enum of type StrategyMode. Possible string values can be: {get_valid_enum_names(StrategyMode)}'
-
-        if isinstance(start, str):
-            start = dt.combine(dt.today().date(), dt.strptime(start, '%H:%M').time())
-        if isinstance(end, str):
-            end = dt.combine(dt.today().date(), dt.strptime(end, '%H:%M').time())
-        if isinstance(mode, str):
-            _ = mode.upper()
-            assert _ in StrategyMode.__members__, _error_msg_candle
-            mode = StrategyMode[_]
-        if isinstance(candle, str):
-            _ = f"{'_' if candle[0].isdigit() else ''}{candle.strip().upper().replace(' ', '_')}"
-            assert _ in CandleInterval.__members__, _error_msg_candle
-            candle = CandleInterval[_]
-        if isinstance(instruments, str):
-            instruments = [instruments]
-
-        # Sanity checks - Validate config parameters
-        assert isinstance(strategy, str), f'Argument "strategy" should be a valid string'
-        assert isinstance(start, dt), _error_msg_timestamps
-        assert isinstance(end, dt), _error_msg_timestamps
-        assert isinstance(instruments, list), _error_msg_instruments
-        assert len(instruments) > 0, _error_msg_instruments
-        assert (isinstance(lots, int) and lots > 0), f'Argument "lots" should be a positive integer.'
-        assert isinstance(parameters, dict), f'Argument "parameters" should be a dict'
-        assert isinstance(mode, StrategyMode), _error_msg_mode
-        assert isinstance(candle, CandleInterval), _error_msg_candle
-
-        if delete_previous_trades:
-            self.delete_previous_trades(strategy)
-
-        # Restructuring strategy params
-        restructured_strategy_parameters = []
-        for parameter_name in parameters:
-            restructured_strategy_parameters.append({
-                'paramName': parameter_name,
-                'paramValue': parameters[parameter_name]
-            })
-
-        # generate instruments' id list
-        instrument_list = []
-        for _instrument in instruments:
-            instrument_results = self.search_instrument(_instrument.split(':')[-1])
-            for _error_msg_timestamps in instrument_results:
-                if _error_msg_timestamps["value"] == _instrument:
-                    instrument_list.append({'id': _error_msg_timestamps["id"]})
-                    break
-
-        # Setup config for Paper Trading
-        strategy_config = {
-            'instruments': {
-                'instruments': instrument_list
-            },
-            'lots': lots,
-            'userParams': restructured_strategy_parameters,
-            'candleDuration': candle.value,
-            'strategyMode': mode.value
-        }
-        self.api.set_strategy_config(strategy_code=strategy, strategy_config=strategy_config, trading_type=TradingType.PAPERTRADING)
-
-        # Submit Paper Trading job
-        response = self.api.start_strategy_algotrading(strategy_code=strategy, start_timestamp=start, end_timestamp=end, trading_type=TradingType.PAPERTRADING, lots=lots)
+        # Clear previously saved pnl data, if any
+        self.papertrade_pnl_data = None
 
     def get_papertrading_job_status(self, strategy_code):
         """
         Get Paper Trading job status
 
         Args:
             strategy_code: Strategy code
 
         Returns:
             Job status
         """
         assert isinstance(strategy_code, str), f'Argument "strategy_code" should be a string'
+
         return self.get_job_status(strategy_code, TradingType.PAPERTRADING)
 
     def stop_papertrading_job(self, strategy_code):
         """
         Stop the Paper Trading session
 
         Args:
             strategy_code: Strategy code
 
         Returns:
-            None
+            stop job status
         """
         assert isinstance(strategy_code, str), f'Argument "strategy_code" should be a string'
+
         return self.stop_job(strategy_code=strategy_code, trading_type=TradingType.PAPERTRADING)
 
     def get_papertrading_logs(self, strategy_code):
         """
         Fetch Paper Trading logs
 
         Args:
             strategy_code: Strategy code
 
         Returns:
             Report details
         """
         assert isinstance(strategy_code, str), f'Argument "strategy_code" should be a string'
+
         return self.get_logs(strategy_code=strategy_code, trading_type=TradingType.PAPERTRADING)
 
     def get_papertrading_report_pnl_table(self, strategy_code, show_all_rows=False):
         """
         Fetch Paper Trading Profit & Loss details
 
         Args:
-            strategy_code: Strategy code
+            strategy_code: strategy code
             show_all_rows: True or False
 
         Returns:
             Report details
         """
-        assert isinstance(strategy_code, str), f'Argument "strategy_code" should be a string'
-        return self.get_report(strategy_code=strategy_code, trading_type=TradingType.PAPERTRADING, report_type=TradingReportType.PNL_TABLE, render_as_dataframe=True, show_all_rows=show_all_rows)
+        if self.papertrade_pnl_data is None:
+            self.papertrade_pnl_data = self.get_pnl_report_table(strategy_code, TradingType.PAPERTRADING)
 
-    def get_papertrading_report_statistics(self, strategy_code):
+        return self.papertrade_pnl_data
+
+    def get_papertrading_report_statistics(self, strategy_code, initial_funds=1e9, mode='quantstats', report='metrics', html_dump=False):
         """
         Fetch Paper Trading report statistics
 
         Args:
-            strategy_code: Strategy code
+            strategy_code: strategy code
+            initial_funds: initial funds allotted before papertrading
+            mode: extension used to generate statistics
+            report: format and content of the report
+            html_dump: save it as a html file
 
         Returns:
             Report details
         """
+
         assert isinstance(strategy_code, str), f'Argument "strategy_code" should be a string'
-        return self.get_report(strategy_code=strategy_code, trading_type=TradingType.PAPERTRADING, report_type=TradingReportType.STATS_TABLE, render_as_dataframe=True)
+
+        if self.papertrade_pnl_data is None:
+            self.get_papertrading_report_pnl_table(strategy_code)
+        else:
+            print('Generating Statistics for already fetched P&L data...')
+
+        order_report = self.get_report_statistics(strategy_code, initial_funds, report, html_dump, self.papertrade_pnl_data)
+
+        return order_report
 
     def get_papertrading_report_order_history(self, strategy_code):
         """
         Fetch Paper Trading order history
 
         Args:
             strategy_code: Strategy code
 
         Returns:
             Report details
         """
         assert isinstance(strategy_code, str), f'Argument "strategy_code" should be a string'
+
         return self.get_report(strategy_code=strategy_code, trading_type=TradingType.PAPERTRADING, report_type=TradingReportType.ORDER_HISTORY)
 
-    def realtrade(self, *args, **kwargs):
+    def realtrade(self, strategy=None, start=None, end=None, instruments=None, lots=None, parameters=None, candle=None, mode=StrategyMode.INTRADAY, broking_details=None, **kwargs):
         """
         Start a Real Trading session.
         Update: This requires an approval process which is currently on request basis.
+
+        Start a real trade job for a strategy on the AlgoBulls Platform
+
+        Args:
+            strategy: Strategy code
+            start: Start date-time/time
+            end: End date-time/time
+            instruments: Instrument key
+            lots: Number of lots of the passed instrument to trade on
+            parameters: Parameters
+            candle: Candle interval
+            mode: Intraday or delivery
+            broking_details: client's broking details
+
+        Legacy args (will be deprecated in future release):
+            'strategy_code' behaves same as 'strategy'
+            'start_timestamp' behaves same as 'start'
+            'end_timestamp' behaves same as 'end'
+            'instrument' behaves same as 'instruments'
+            'strategy_parameters' behaves same as 'parameters'
+            'candle_interval' behaves same as 'candle'
+            'strategy_mode' behaves same as 'mode'
+
+        Returns:
+            realtrade job submission status
         """
-        print(MESSAGE_REALTRADING_FORBIDDEN)
+
+        # start real trading job
+        response = self.start_job(strategy=strategy, start=start, end=end, instruments=instruments, lots=lots, parameters=parameters, candle=candle, mode=mode, trading_type=TradingType.REALTRADING, broking_details=broking_details, **kwargs)
+
+        # Clear previously saved pnl data, if any
+        self.realtrade_pnl_data = None
 
     def livetrade(self, *args, **kwargs):
         self.realtrade(*args, **kwargs)
 
     def get_realtrading_job_status(self, strategy_code):
         """
         Fetch Real Trading job status
 
         Args:
             strategy_code: Strategy code
 
         Returns:
             Job status
         """
-        # assert (isinstance(broker, AlgoBullsSupportedBrokers) is True), f'Argument broker should be an enum of type {AlgoBullsSupportedBrokers.__name__}'
         assert isinstance(strategy_code, str), f'Argument "strategy_code" should be a string'
 
         return self.get_job_status(strategy_code, TradingType.REALTRADING)
 
     def stop_realtrading_job(self, strategy_code):
         """
         Stop the Real Trading session
 
         Args:
             strategy_code: Strategy code
 
         Returns:
-            None
+            stop job status
         """
-        # assert (isinstance(broker, AlgoBullsSupportedBrokers) is True), f'Argument broker should be an enum of type {AlgoBullsSupportedBrokers.__name__}'
         assert isinstance(strategy_code, str), f'Argument "strategy_code" should be a string'
+
         return self.stop_job(strategy_code=strategy_code, trading_type=TradingType.REALTRADING)
 
     def get_realtrading_logs(self, strategy_code):
         """
         Fetch Real Trading logs
 
         Args:
             strategy_code: Strategy code
 
         Returns:
             Report details
         """
-        # assert (isinstance(broker, AlgoBullsSupportedBrokers) is True), f'Argument broker should be an enum of type {AlgoBullsSupportedBrokers.__name__}'
         assert isinstance(strategy_code, str), f'Argument "strategy_code" should be a string'
 
         return self.get_logs(strategy_code=strategy_code, trading_type=TradingType.REALTRADING)
 
     def get_realtrading_report_pnl_table(self, strategy_code, show_all_rows=False):
         """
-        Fetch Real Trading Profit & Loss table
+        Fetch Real Trading Profit & Loss details
+
         Args:
-            strategy_code: Strategy code
+            strategy_code: strategy code
             show_all_rows: True or False
 
         Returns:
             Report details
         """
-        # assert (isinstance(broker, AlgoBullsSupportedBrokers) is True), f'Argument broker should be an enum of type {AlgoBullsSupportedBrokers.__name__}'
-        assert isinstance(strategy_code, str), f'Argument "strategy_code" should be a string'
-        return self.get_report(strategy_code=strategy_code, trading_type=TradingType.REALTRADING, report_type=TradingReportType.PNL_TABLE, render_as_dataframe=True, show_all_rows=show_all_rows)
+        if self.realtrade_pnl_data is None:
+            self.realtrade_pnl_data = self.get_pnl_report_table(strategy_code, TradingType.REALTRADING)
+
+        return self.realtrade_pnl_data
 
-    def get_realtrading_report_statistics(self, strategy_code):
+    def get_realtrading_report_statistics(self, strategy_code, initial_funds=1e9, mode='quantstats', report='metrics', html_dump=False):
         """
         Fetch Real Trading report statistics
+
         Args:
-            strategy_code: Strategy code
+            strategy_code: strategy code
+            initial_funds: initial funds allotted before papertrading
+            mode: extension used to generate statistics
+            report: format and content of the report
+            html_dump: save it as a html file
 
         Returns:
             Report details
         """
-        # assert (isinstance(broker, AlgoBullsSupportedBrokers) is True), f'Argument broker should be an enum of type {AlgoBullsSupportedBrokers.__name__}'
+
         assert isinstance(strategy_code, str), f'Argument "strategy_code" should be a string'
 
-        return self.get_report(strategy_code=strategy_code, trading_type=TradingType.REALTRADING, report_type=TradingReportType.STATS_TABLE, render_as_dataframe=True)
+        if self.realtrade_pnl_data is None:
+            self.get_realtrading_report_pnl_table(strategy_code)
+        else:
+            print('Generating Statistics for already fetched P&L data...')
+
+        order_report = self.get_report_statistics(strategy_code, initial_funds, report, html_dump, self.realtrade_pnl_data)
+
+        return order_report
 
     def get_realtrading_report_order_history(self, strategy_code):
         """
         Fetch Real Trading order history
         Args:
             strategy_code: Strategy code
 
@@ -804,15 +901,15 @@
         assert isinstance(strategy_code, str), f'Argument "strategy_code" should be a string'
 
         return self.get_report(strategy_code=strategy_code, trading_type=TradingType.REALTRADING, report_type=TradingReportType.ORDER_HISTORY)
 
 
 def pandas_dataframe_all_rows():
     """
+    Enable printing of all rows in a dataframe.
 
     Returns: None
-
     """
     pd.set_option('display.max_rows', None)
     pd.set_option('display.max_columns', None)
     pd.set_option('display.width', None)
     pd.set_option('display.max_colwidth', None)
```

## pyalgotrading/algobulls/exceptions.py

```diff
@@ -1,62 +1,63 @@
 class AlgoBullsAPIBaseException(Exception):
     """
     Base exception class for all API related exceptions
     """
 
-    def __init__(self, method, url, response):
+    def __init__(self, method, url, response, status_code):
         self.method = method
         self.url = url
         self.response = response
 
-        message = f'{self.get_error_type()} | Method: {self.method} | URL: {self.url} | Response: {self.response}'
+        message = f'{self.get_error_type()} | Method: {self.method} | URL: {self.url} | Response: {self.response} | status code: {status_code}'
+
         super().__init__(message)
 
     def get_error_type(self):
         return 'Unknown non-200 status code'
 
 
-class AlgoBullsAPIBadRequest(AlgoBullsAPIBaseException):
+class AlgoBullsAPIBadRequestException(AlgoBullsAPIBaseException):
     """
     Exception class for HTTP status code of 400 (Bad Request)
     """
 
     def get_error_type(self):
         return 'Bad Request'
 
 
-class AlgoBullsAPIUnauthorizedError(AlgoBullsAPIBaseException):
+class AlgoBullsAPIUnauthorizedErrorException(AlgoBullsAPIBaseException):
     """
     Exception class for HTTP status code of 401 (Unauthorized)
     """
 
     def get_error_type(self):
         return 'Unauthorized Error'
 
 
-class AlgoBullsAPIInsufficientBalanceError(AlgoBullsAPIBaseException):
+class AlgoBullsAPIInsufficientBalanceErrorException(AlgoBullsAPIBaseException):
     """
     Exception class for HTTP status code of 402 (Insufficient Balance)
     """
 
     def get_error_type(self):
         return 'Insufficient Balance'
 
 
-class AlgoBullsAPIForbiddenError(AlgoBullsAPIBaseException):
+class AlgoBullsAPIForbiddenErrorException(AlgoBullsAPIBaseException):
     """
     Exception class for HTTP status code of 403 (Operation not permitted)
     Use case: Trying to START or STOP a strategy when it is in intermediate state.
     """
 
     def get_error_type(self):
         return 'Forbidden'
 
 
-class AlgoBullsAPIResourceNotFoundError(AlgoBullsAPIBaseException):
+class AlgoBullsAPIResourceNotFoundErrorException(AlgoBullsAPIBaseException):
     """
     Exception class for HTTP status code of 404 (Resource Not Found)
     """
 
     def get_error_type(self):
         return 'Resource Not Found'
 
@@ -64,7 +65,16 @@
 class AlgoBullsAPIInternalServerErrorException(AlgoBullsAPIBaseException):
     """
     Exception class for HTTP status code of 500 (Internal Server Error)
     """
 
     def get_error_type(self):
         return 'Internal Server Error'
+
+
+class AlgoBullsAPIGatewayTimeoutErrorException(AlgoBullsAPIBaseException):
+    """
+    Exception class for HTTP status code of 504 (Gateway Timeout Error)
+    """
+
+    def get_error_type(self):
+        return 'Gateway Timeout Error'
```

## pyalgotrading/utils/func.py

```diff
@@ -1,13 +1,15 @@
 """
 A module for plotting candlesticks
 """
+from datetime import datetime as dt, timezone
+
 import pandas as pd
 
-from pyalgotrading.constants import PlotType
+from pyalgotrading.constants import PlotType, TRADING_TYPE_DT_FORMAT_MAP, KEY_DT_FORMAT_WITHOUT_TIMEZONE, KEY_DT_FORMAT_WITH_TIMEZONE
 
 
 def import_with_install(package_import_name, package_install_name=None, dependancies=()):
     """
     Helps import 'package' even if it's not installed.
 
     If package is installed, it will be imported and returned.
@@ -127,7 +129,35 @@
     if show:
         fig.show()
 
 
 def get_valid_enum_names(enum_obj):
     # returns list of names from enum_obj; does a simple cleanup - replacing '_' with spaces, striping leading/trailing spaces
     return [_.name.lower().replace('_', ' ').strip() for _ in enum_obj]
+
+
+def get_raw_response(response_obj):
+    return f'Content: {response_obj.content} | Raw: {response_obj.raw.data}'
+
+
+def get_datetime_with_tz(timestamp_str, trading_type, label=''):
+    """
+    Function converts the timestamp/time string to datetime object with timezone for BT, PT or RT for their respective formats
+
+    Args:
+        timestamp_str: datetime in string format for BT, time in string format for PT, RT
+        trading_type: trading type (BT, PT, RT)
+        label: name of the parameter
+    """
+
+    try:
+        timestamp_str = dt.strptime(timestamp_str, TRADING_TYPE_DT_FORMAT_MAP[trading_type][KEY_DT_FORMAT_WITH_TIMEZONE])
+    except ValueError:
+        try:
+            timestamp_str = dt.strptime(timestamp_str, TRADING_TYPE_DT_FORMAT_MAP[trading_type][KEY_DT_FORMAT_WITHOUT_TIMEZONE])
+            timestamp_str = timestamp_str.replace(tzinfo=timezone.utc)
+            print(f'Warning: Timezone info not provided. Expected timestamp format is "{TRADING_TYPE_DT_FORMAT_MAP[trading_type][KEY_DT_FORMAT_WITH_TIMEZONE]}", received time "{timestamp_str}". Assuming timezone as UTC(+0000)...')
+        except ValueError as ex:
+            raise ValueError(f'Error: Invalid string timestamp format for argument "{label}".\nExpected timestamp format for {trading_type.name} is "{TRADING_TYPE_DT_FORMAT_MAP[trading_type][KEY_DT_FORMAT_WITH_TIMEZONE]}". Received "{timestamp_str}" instead.')
+
+    return timestamp_str
+
```

## Comparing `pyalgotrading-2023.5.4.dist-info/LICENSE` & `pyalgotrading-2023.6.1.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `pyalgotrading-2023.5.4.dist-info/METADATA` & `pyalgotrading-2023.6.1.dist-info/METADATA`

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: pyalgotrading
-Version: 2023.5.4
+Version: 2023.6.1
 Summary: Official Python Package for Algorithmic Trading APIs powered by AlgoBulls
 Home-page: https://github.com/algobulls/pyalgotrading
 Author: Pushpak Dagade
 Author-email: pushpak@algobulls.com
 License: UNKNOWN
 Project-URL: Source, https://github.com/algobulls/pyalgotrading
 Project-URL: Documentation, https://algobulls.github.io/pyalgotrading/
```

## Comparing `pyalgotrading-2023.5.4.dist-info/RECORD` & `pyalgotrading-2023.6.1.dist-info/RECORD`

 * *Files 12% similar despite different names*

```diff
@@ -1,30 +1,30 @@
 pyalgotrading/__init__.py,sha256=e0lmS8IOW1JBf_jfyDAO-9cCEyNsNoSCjwetSCWPeIg,181
-pyalgotrading/constants.py,sha256=rW8tqwy8lE-UbC045fgY6tVK7su3sJ0UYx1vRlv13wQ,5975
+pyalgotrading/constants.py,sha256=-Cr5WIYjv3hnjEpUG-Ye3hdBi0m3LExuCTTTNuO72VQ,6083
 pyalgotrading/algobulls/__init__.py,sha256=IRkbWtJfgQnPH7gikjqpa6QsYnmk_NQ1lwtx7LPIC6c,133
-pyalgotrading/algobulls/api.py,sha256=DG7wpeD1Vfo_bAgUKcy0mS7bBlq8OxQyPZp0a3Gx_BE,18084
-pyalgotrading/algobulls/connection.py,sha256=ZRF_0TVPmm_-8xv9NWnINxuNpKebdDz3Fdh-pFKuiB4,35018
-pyalgotrading/algobulls/exceptions.py,sha256=zltDg4An4VH4FQAHDlHwaa_zXdhGoSEqKN82CbAQVPA,1864
+pyalgotrading/algobulls/api.py,sha256=wndez1slhqMUSqj8KkC8FMuep2dNYj66NZL8WzOdEtw,18706
+pyalgotrading/algobulls/connection.py,sha256=JWD71_leEbg7Q0MZclUrvo-HvGNVTGt7dQ9hsYtICKY,38010
+pyalgotrading/algobulls/exceptions.py,sha256=B96On8cN8tgtX7i4shKOlYfvjSjvspIRPbOpyF-jn0I,2187
 pyalgotrading/broker/__init__.py,sha256=jXVWBVRlqzevKxNDqrPANJz9WubROBes8gaKcxcYz58,66
 pyalgotrading/broker/broker_connection_base.py,sha256=vAJN5EAQuVfL8Ngf03wsaI5TTGdziCHKCb0bczGgSJ0,7594
 pyalgotrading/broker/broker_connection_zerodha.py,sha256=bw9Eu40YhSbRLhvVniY255uYeziX_EOVBPkfUUg4tFs,13703
 pyalgotrading/broker/utils.py,sha256=ojL1oebAjNrY_sS2z9JKHy1qo-Pif0ED2uNKLwdnQxo,1204
 pyalgotrading/instrument/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 pyalgotrading/instrument/instrument.py,sha256=PKqq784MYmpvBL2MIde1n44U9kwuRdSNIot1KKQ5J-o,1688
 pyalgotrading/order/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 pyalgotrading/order/order_base.py,sha256=trC_bvazLNvvuGqZEdacxzlacc3g73ZvqpedYYwuKJA,1742
 pyalgotrading/order/order_bracket_base.py,sha256=7Sj0nlCWE20wZiZ12NciptPYKKGE9KsnKLCjdO7sKV4,3576
 pyalgotrading/order/order_regular_base.py,sha256=wOFmv7QnxJvNKtqdoZn0a-cbTotik4cap5Z5mz0Qcs0,2313
 pyalgotrading/strategy/__init__.py,sha256=NSR4t9X44sjL8jVEg11SBt-_J8i8sArHE_LZX6m3lcU,40
 pyalgotrading/strategy/strategy_base.py,sha256=9I6ZdZT1IimO9g03QURrFo2Pxvs4Dsk8Ybdtij8ZIUQ,4717
 pyalgotrading/strategy/validate_strategy.py,sha256=Ot2kvROtG-tpcbK_Fv-OdapG8oNdgvSNV2hTWtfTCQI,482
 pyalgotrading/utils/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-pyalgotrading/utils/func.py,sha256=My_f832ZQMcE1AD_krq_IaXazltHYhqZY6qLGVcLJLw,7089
+pyalgotrading/utils/func.py,sha256=V1ktGhQqr1Hdyw30B6TMQ5wntnrW7NVwQZd1enyjyFc,8656
 pyalgotrading/utils/candlesticks/__init__.py,sha256=maIn__tvTvJDjldPhU9agBcNNuROt_lpNTV4CZ1Yl6I,83
 pyalgotrading/utils/candlesticks/heikinashi.py,sha256=SpcuK7AYV0sgzcw-DMfLNtTDn2RfWqGvWBt4no7yKD4,2003
 pyalgotrading/utils/candlesticks/linebreak.py,sha256=cYwoETMrenWOa06d03xASZoiou-qRz7n2mZYCi5ilEs,1434
 pyalgotrading/utils/candlesticks/renko.py,sha256=zovQ6D658pBLas86FuTu9fU3-Kkv2hM-4h7OQJjdxng,2089
-pyalgotrading-2023.5.4.dist-info/LICENSE,sha256=-LLEprvixKS-LwHef99YQSOFon_tWeTwJRAWuUwwr1g,1066
-pyalgotrading-2023.5.4.dist-info/METADATA,sha256=bisb0YnSQ-W8K2BZ3jkHXmGpaugeSJTi6ObXjWiy8dE,5123
-pyalgotrading-2023.5.4.dist-info/WHEEL,sha256=g4nMs7d-Xl9-xC9XovUrsDHGXt-FT0E17Yqo92DEfvY,92
-pyalgotrading-2023.5.4.dist-info/top_level.txt,sha256=A12PTnbXqO3gsZ0D0Gkyzf_OYRQxjJvtg3MqN-Ur2zY,14
-pyalgotrading-2023.5.4.dist-info/RECORD,,
+pyalgotrading-2023.6.1.dist-info/LICENSE,sha256=-LLEprvixKS-LwHef99YQSOFon_tWeTwJRAWuUwwr1g,1066
+pyalgotrading-2023.6.1.dist-info/METADATA,sha256=qJYm_8hLJLXhKBOWlh3gjbYD2bZjiFL7-OLJDuAGP9E,5123
+pyalgotrading-2023.6.1.dist-info/WHEEL,sha256=g4nMs7d-Xl9-xC9XovUrsDHGXt-FT0E17Yqo92DEfvY,92
+pyalgotrading-2023.6.1.dist-info/top_level.txt,sha256=A12PTnbXqO3gsZ0D0Gkyzf_OYRQxjJvtg3MqN-Ur2zY,14
+pyalgotrading-2023.6.1.dist-info/RECORD,,
```

