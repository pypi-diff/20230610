# Comparing `tmp/nisyscfg-0.0.5-py3-none-any.whl.zip` & `tmp/nisyscfg-0.1.0-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,35 +1,35 @@
-Zip file size: 48456 bytes, number of entries: 33
--rw-r--r--  2.0 unx        6 b- defN 22-Jul-13 02:13 nisyscfg/VERSION
--rw-r--r--  2.0 unx      175 b- defN 22-Jul-13 02:13 nisyscfg/__init__.py
--rw-r--r--  2.0 unx      731 b- defN 22-Jul-13 02:13 nisyscfg/_lib.py
--rw-r--r--  2.0 unx    53119 b- defN 22-Jul-13 02:13 nisyscfg/_library.py
--rw-r--r--  2.0 unx     1897 b- defN 22-Jul-13 02:13 nisyscfg/_library_singleton.py
--rw-r--r--  2.0 unx     3658 b- defN 22-Jul-13 02:13 nisyscfg/component_info.py
--rw-r--r--  2.0 unx     3595 b- defN 22-Jul-13 02:13 nisyscfg/dependency_info.py
--rw-r--r--  2.0 unx     5094 b- defN 22-Jul-13 02:13 nisyscfg/enums.py
--rw-r--r--  2.0 unx    10017 b- defN 22-Jul-13 02:13 nisyscfg/errors.py
--rw-r--r--  2.0 unx     1474 b- defN 22-Jul-13 02:13 nisyscfg/expert_info.py
--rw-r--r--  2.0 unx     1466 b- defN 22-Jul-13 02:13 nisyscfg/filter.py
--rw-r--r--  2.0 unx    20318 b- defN 22-Jul-13 02:13 nisyscfg/hardware_resource.py
--rw-r--r--  2.0 unx    23403 b- defN 22-Jul-13 02:13 nisyscfg/properties.py
--rw-r--r--  2.0 unx     1544 b- defN 22-Jul-13 02:13 nisyscfg/software_feed.py
--rw-r--r--  2.0 unx    47756 b- defN 22-Jul-13 02:13 nisyscfg/system.py
--rw-r--r--  2.0 unx      979 b- defN 22-Jul-13 02:13 nisyscfg/system_info.py
--rw-r--r--  2.0 unx     2281 b- defN 22-Jul-13 02:13 nisyscfg/timestamp.py
--rw-r--r--  2.0 unx      550 b- defN 22-Jul-13 02:13 nisyscfg/types.py
--rw-r--r--  2.0 unx        0 b- defN 22-Jul-13 02:13 nisyscfg/pxi/__init__.py
--rw-r--r--  2.0 unx     4030 b- defN 22-Jul-13 02:13 nisyscfg/pxi/enums.py
--rw-r--r--  2.0 unx     4085 b- defN 22-Jul-13 02:13 nisyscfg/pxi/properties.py
--rw-r--r--  2.0 unx        0 b- defN 22-Jul-13 02:13 nisyscfg/xnet/__init__.py
--rw-r--r--  2.0 unx     1315 b- defN 22-Jul-13 02:13 nisyscfg/xnet/enums.py
--rw-r--r--  2.0 unx     2943 b- defN 22-Jul-13 02:13 nisyscfg/xnet/properties.py
--rw-r--r--  2.0 unx        0 b- defN 22-Jul-13 02:13 tests/__init__.py
--rw-r--r--  2.0 unx      706 b- defN 22-Jul-13 02:13 tests/test_import.py
--rw-r--r--  2.0 unx    38753 b- defN 22-Jul-13 02:13 tests/test_session.py
--rw-r--r--  2.0 unx     1071 b- defN 22-Jul-13 02:13 nisyscfg-0.0.5.dist-info/LICENSE
--rw-r--r--  2.0 unx     2881 b- defN 22-Jul-13 02:13 nisyscfg-0.0.5.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 22-Jul-13 02:13 nisyscfg-0.0.5.dist-info/WHEEL
--rw-r--r--  2.0 unx       15 b- defN 22-Jul-13 02:13 nisyscfg-0.0.5.dist-info/top_level.txt
--rw-r--r--  2.0 unx        1 b- defN 22-Jul-13 02:13 nisyscfg-0.0.5.dist-info/zip-safe
-?rw-rw-r--  2.0 unx     2595 b- defN 22-Jul-13 02:13 nisyscfg-0.0.5.dist-info/RECORD
-33 files, 236550 bytes uncompressed, 44354 bytes compressed:  81.2%
+Zip file size: 48472 bytes, number of entries: 33
+-rw-r--r--  2.0 unx        6 b- defN 23-Jun-10 14:09 nisyscfg/VERSION
+-rw-r--r--  2.0 unx      175 b- defN 23-Jun-10 14:09 nisyscfg/__init__.py
+-rw-r--r--  2.0 unx      730 b- defN 23-Jun-10 14:09 nisyscfg/_lib.py
+-rw-r--r--  2.0 unx    52439 b- defN 23-Jun-10 14:09 nisyscfg/_library.py
+-rw-r--r--  2.0 unx     1828 b- defN 23-Jun-10 14:09 nisyscfg/_library_singleton.py
+-rw-r--r--  2.0 unx     3549 b- defN 23-Jun-10 14:09 nisyscfg/component_info.py
+-rw-r--r--  2.0 unx     3499 b- defN 23-Jun-10 14:09 nisyscfg/dependency_info.py
+-rw-r--r--  2.0 unx     4925 b- defN 23-Jun-10 14:09 nisyscfg/enums.py
+-rw-r--r--  2.0 unx     9734 b- defN 23-Jun-10 14:09 nisyscfg/errors.py
+-rw-r--r--  2.0 unx     1425 b- defN 23-Jun-10 14:09 nisyscfg/expert_info.py
+-rw-r--r--  2.0 unx     1496 b- defN 23-Jun-10 14:09 nisyscfg/filter.py
+-rw-r--r--  2.0 unx    21622 b- defN 23-Jun-10 14:09 nisyscfg/hardware_resource.py
+-rw-r--r--  2.0 unx    22498 b- defN 23-Jun-10 14:09 nisyscfg/properties.py
+-rw-r--r--  2.0 unx     1491 b- defN 23-Jun-10 14:09 nisyscfg/software_feed.py
+-rw-r--r--  2.0 unx    46901 b- defN 23-Jun-10 14:09 nisyscfg/system.py
+-rw-r--r--  2.0 unx      948 b- defN 23-Jun-10 14:09 nisyscfg/system_info.py
+-rw-r--r--  2.0 unx     2210 b- defN 23-Jun-10 14:09 nisyscfg/timestamp.py
+-rw-r--r--  2.0 unx      550 b- defN 23-Jun-10 14:09 nisyscfg/types.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jun-10 14:09 nisyscfg/pxi/__init__.py
+-rw-r--r--  2.0 unx     3929 b- defN 23-Jun-10 14:09 nisyscfg/pxi/enums.py
+-rw-r--r--  2.0 unx     4045 b- defN 23-Jun-10 14:09 nisyscfg/pxi/properties.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jun-10 14:09 nisyscfg/xnet/__init__.py
+-rw-r--r--  2.0 unx     1232 b- defN 23-Jun-10 14:09 nisyscfg/xnet/enums.py
+-rw-r--r--  2.0 unx     2871 b- defN 23-Jun-10 14:09 nisyscfg/xnet/properties.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jun-10 14:09 tests/__init__.py
+-rw-r--r--  2.0 unx      690 b- defN 23-Jun-10 14:09 tests/test_import.py
+-rw-r--r--  2.0 unx    37687 b- defN 23-Jun-10 14:09 tests/test_session.py
+-rw-r--r--  2.0 unx     1071 b- defN 23-Jun-10 14:09 nisyscfg-0.1.0.dist-info/LICENSE
+-rw-r--r--  2.0 unx     2845 b- defN 23-Jun-10 14:09 nisyscfg-0.1.0.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 23-Jun-10 14:09 nisyscfg-0.1.0.dist-info/WHEEL
+-rw-r--r--  2.0 unx       15 b- defN 23-Jun-10 14:09 nisyscfg-0.1.0.dist-info/top_level.txt
+-rw-r--r--  2.0 unx        1 b- defN 23-Jun-10 14:09 nisyscfg-0.1.0.dist-info/zip-safe
+-rw-rw-r--  2.0 unx     2594 b- defN 23-Jun-10 14:09 nisyscfg-0.1.0.dist-info/RECORD
+33 files, 233098 bytes uncompressed, 44370 bytes compressed:  81.0%
```

## zipnote {}

```diff
@@ -75,26 +75,26 @@
 
 Filename: tests/test_import.py
 Comment: 
 
 Filename: tests/test_session.py
 Comment: 
 
-Filename: nisyscfg-0.0.5.dist-info/LICENSE
+Filename: nisyscfg-0.1.0.dist-info/LICENSE
 Comment: 
 
-Filename: nisyscfg-0.0.5.dist-info/METADATA
+Filename: nisyscfg-0.1.0.dist-info/METADATA
 Comment: 
 
-Filename: nisyscfg-0.0.5.dist-info/WHEEL
+Filename: nisyscfg-0.1.0.dist-info/WHEEL
 Comment: 
 
-Filename: nisyscfg-0.0.5.dist-info/top_level.txt
+Filename: nisyscfg-0.1.0.dist-info/top_level.txt
 Comment: 
 
-Filename: nisyscfg-0.0.5.dist-info/zip-safe
+Filename: nisyscfg-0.1.0.dist-info/zip-safe
 Comment: 
 
-Filename: nisyscfg-0.0.5.dist-info/RECORD
+Filename: nisyscfg-0.1.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## nisyscfg/VERSION

```diff
@@ -1 +1 @@
-0.0.5
+0.1.0
```

## nisyscfg/_lib.py

```diff
@@ -6,15 +6,14 @@
 
 
 if sys.platform.startswith("win"):
     # On Windows, nisyscfg uses the system code page for the decoding of C-strings
     def get_syscfg_locale():
         return locale.getlocale()[1] or locale.getdefaultlocale()[1] or "ascii"
 
-
 else:
     # On other OSes, nisyscfg uses ISO-8859-1 (Latin1) for the decoding of C-strings
     def get_syscfg_locale():
         return "ISO-8859-1"
 
 
 def c_string_encode(value):
```

## nisyscfg/_library.py

 * *Ordering differences only*

```diff
@@ -1,680 +1,680 @@
-# This file is code generated
-# fmt: off
-
-import ctypes
-import threading
-
-from nisyscfg.enums import *  # noqa: F403
-from nisyscfg.errors import *  # noqa: F403
-from nisyscfg.types import *  # noqa: F403
-
-
-class Library(object):
-    def __init__(self, ctypes_library):
-        self._func_lock = threading.Lock()
-        self._library = ctypes_library
-        self._InitializeSession_cfunc = None
-        self._CloseHandle_cfunc = None
-        self._GetSystemExperts_cfunc = None
-        self._SetRemoteTimeout_cfunc = None
-        self._FindHardware_cfunc = None
-        self._FindSystems_cfunc = None
-        self._SelfTestHardware_cfunc = None
-        self._SelfCalibrateHardware_cfunc = None
-        self._ResetHardware_cfunc = None
-        self._RenameResource_cfunc = None
-        self._DeleteResource_cfunc = None
-        self._GetResourceProperty_cfunc = None
-        self._SetResourceProperty_cfunc = None
-        self._SetResourcePropertyWithType_cfunc = None
-        self._SetResourcePropertyV_cfunc = None
-        self._SetResourcePropertyWithTypeV_cfunc = None
-        self._GetResourceIndexedProperty_cfunc = None
-        self._SaveResourceChanges_cfunc = None
-        self._GetSystemProperty_cfunc = None
-        self._SetSystemProperty_cfunc = None
-        self._SetSystemPropertyV_cfunc = None
-        self._SaveSystemChanges_cfunc = None
-        self._CreateFilter_cfunc = None
-        self._SetFilterProperty_cfunc = None
-        self._SetFilterPropertyWithType_cfunc = None
-        self._SetFilterPropertyV_cfunc = None
-        self._SetFilterPropertyWithTypeV_cfunc = None
-        self._UpgradeFirmwareFromFile_cfunc = None
-        self._UpgradeFirmwareVersion_cfunc = None
-        self._EraseFirmware_cfunc = None
-        self._CheckFirmwareStatus_cfunc = None
-        self._Format_cfunc = None
-        self._FormatWithBaseSystemImage_cfunc = None
-        self._Restart_cfunc = None
-        self._GetAvailableSoftwareComponents_cfunc = None
-        self._GetAvailableSoftwareSets_cfunc = None
-        self._GetFilteredSoftwareComponents_cfunc = None
-        self._GetFilteredSoftwareSets_cfunc = None
-        self._GetFilteredBaseSystemImages_cfunc = None
-        self._GetInstalledSoftwareComponents_cfunc = None
-        self._GetInstalledSoftwareSet_cfunc = None
-        self._GetSystemImageAsFolder_cfunc = None
-        self._GetSystemImageAsFolder2_cfunc = None
-        self._CreateSystemImageAsFolder_cfunc = None
-        self._SetSystemImageFromFolder_cfunc = None
-        self._SetSystemImageFromFolder2_cfunc = None
-        self._InstallAll_cfunc = None
-        self._InstallUninstallComponents_cfunc = None
-        self._InstallUninstallComponents2_cfunc = None
-        self._InstallSoftwareSet_cfunc = None
-        self._InstallStartup_cfunc = None
-        self._UninstallAll_cfunc = None
-        self._GetSoftwareFeeds_cfunc = None
-        self._AddSoftwareFeed_cfunc = None
-        self._ModifySoftwareFeed_cfunc = None
-        self._RemoveSoftwareFeed_cfunc = None
-        self._ChangeAdministratorPassword_cfunc = None
-        self._ExportConfiguration_cfunc = None
-        self._ImportConfiguration_cfunc = None
-        self._GenerateMAXReport_cfunc = None
-        self._CreateComponentsEnum_cfunc = None
-        self._AddComponentToEnum_cfunc = None
-        self._FreeDetailedString_cfunc = None
-        self._NextResource_cfunc = None
-        self._NextSystemInfo_cfunc = None
-        self._NextExpertInfo_cfunc = None
-        self._NextComponentInfo_cfunc = None
-        self._NextSoftwareSet_cfunc = None
-        self._GetSoftwareSetInfo_cfunc = None
-        self._NextDependencyInfo_cfunc = None
-        self._NextSoftwareFeed_cfunc = None
-        self._ResetEnumeratorGetCount_cfunc = None
-        self._GetStatusDescription_cfunc = None
-        self._TimestampFromValues_cfunc = None
-        self._ValuesFromTimestamp_cfunc = None
-
-    def InitializeSession(self, targetName, username, password, language, forcePropertyRefresh, connectTimeoutMsec, expertEnumHandle, sessionHandle):  # noqa: N802,N803
-        with self._func_lock:
-            if self._InitializeSession_cfunc is None:
-                self._InitializeSession_cfunc = self._library.windll.NISysCfgInitializeSession
-                self._InitializeSession_cfunc.argtypes = [ctypes.POINTER(ctypes.c_char), ctypes.POINTER(ctypes.c_char), ctypes.POINTER(ctypes.c_char), Locale, Bool, ctypes.c_uint, EnumExpertHandle, SessionHandle]  # noqa: F405
-                self._InitializeSession_cfunc.restype = Status  # noqa: F405
-        return self._InitializeSession_cfunc(targetName, username, password, language, forcePropertyRefresh, connectTimeoutMsec, expertEnumHandle, sessionHandle)
-
-    def CloseHandle(self, syscfgHandle):  # noqa: N802,N803
-        with self._func_lock:
-            if self._CloseHandle_cfunc is None:
-                self._CloseHandle_cfunc = self._library.windll.NISysCfgCloseHandle
-                self._CloseHandle_cfunc.argtypes = [ctypes.c_void_p]  # noqa: F405
-                self._CloseHandle_cfunc.restype = Status  # noqa: F405
-        return self._CloseHandle_cfunc(syscfgHandle)
-
-    def GetSystemExperts(self, sessionHandle, expertNames, expertEnumHandle):  # noqa: N802,N803
-        with self._func_lock:
-            if self._GetSystemExperts_cfunc is None:
-                self._GetSystemExperts_cfunc = self._library.windll.NISysCfgGetSystemExperts
-                self._GetSystemExperts_cfunc.argtypes = [SessionHandle, ctypes.POINTER(ctypes.c_char), EnumExpertHandle]  # noqa: F405
-                self._GetSystemExperts_cfunc.restype = Status  # noqa: F405
-        return self._GetSystemExperts_cfunc(sessionHandle, expertNames, expertEnumHandle)
-
-    def SetRemoteTimeout(self, sessionHandle, remoteTimeoutMsec):  # noqa: N802,N803
-        with self._func_lock:
-            if self._SetRemoteTimeout_cfunc is None:
-                self._SetRemoteTimeout_cfunc = self._library.windll.NISysCfgSetRemoteTimeout
-                self._SetRemoteTimeout_cfunc.argtypes = [SessionHandle, ctypes.c_uint]  # noqa: F405
-                self._SetRemoteTimeout_cfunc.restype = Status  # noqa: F405
-        return self._SetRemoteTimeout_cfunc(sessionHandle, remoteTimeoutMsec)
-
-    def FindHardware(self, sessionHandle, filterMode, filterHandle, expertNames, resourceEnumHandle):  # noqa: N802,N803
-        with self._func_lock:
-            if self._FindHardware_cfunc is None:
-                self._FindHardware_cfunc = self._library.windll.NISysCfgFindHardware
-                self._FindHardware_cfunc.argtypes = [SessionHandle, FilterMode, FilterHandle, ctypes.POINTER(ctypes.c_char), EnumResourceHandle]  # noqa: F405
-                self._FindHardware_cfunc.restype = Status  # noqa: F405
-        return self._FindHardware_cfunc(sessionHandle, filterMode, filterHandle, expertNames, resourceEnumHandle)
-
-    def FindSystems(self, sessionHandle, deviceClass, detectOnlineSystems, cacheMode, findOutputMode, timeoutMsec, onlyInstallableSystems, systemEnumHandle):  # noqa: N802,N803
-        with self._func_lock:
-            if self._FindSystems_cfunc is None:
-                self._FindSystems_cfunc = self._library.windll.NISysCfgFindSystems
-                self._FindSystems_cfunc.argtypes = [SessionHandle, ctypes.POINTER(ctypes.c_char), Bool, IncludeCachedResults, SystemNameFormat, ctypes.c_uint, Bool, EnumSystemHandle]  # noqa: F405
-                self._FindSystems_cfunc.restype = Status  # noqa: F405
-        return self._FindSystems_cfunc(sessionHandle, deviceClass, detectOnlineSystems, cacheMode, findOutputMode, timeoutMsec, onlyInstallableSystems, systemEnumHandle)
-
-    def SelfTestHardware(self, resourceHandle, mode, detailedResult):  # noqa: N802,N803
-        with self._func_lock:
-            if self._SelfTestHardware_cfunc is None:
-                self._SelfTestHardware_cfunc = self._library.windll.NISysCfgSelfTestHardware
-                self._SelfTestHardware_cfunc.argtypes = [ResourceHandle, ctypes.c_uint, ctypes.POINTER(ctypes.POINTER(ctypes.c_char))]  # noqa: F405
-                self._SelfTestHardware_cfunc.restype = Status  # noqa: F405
-        return self._SelfTestHardware_cfunc(resourceHandle, mode, detailedResult)
-
-    def SelfCalibrateHardware(self, resourceHandle, detailedResult):  # noqa: N802,N803
-        with self._func_lock:
-            if self._SelfCalibrateHardware_cfunc is None:
-                self._SelfCalibrateHardware_cfunc = self._library.windll.NISysCfgSelfCalibrateHardware
-                self._SelfCalibrateHardware_cfunc.argtypes = [ResourceHandle, ctypes.POINTER(ctypes.POINTER(ctypes.c_char))]  # noqa: F405
-                self._SelfCalibrateHardware_cfunc.restype = Status  # noqa: F405
-        return self._SelfCalibrateHardware_cfunc(resourceHandle, detailedResult)
-
-    def ResetHardware(self, resourceHandle, mode):  # noqa: N802,N803
-        with self._func_lock:
-            if self._ResetHardware_cfunc is None:
-                self._ResetHardware_cfunc = self._library.windll.NISysCfgResetHardware
-                self._ResetHardware_cfunc.argtypes = [ResourceHandle, ctypes.c_uint]  # noqa: F405
-                self._ResetHardware_cfunc.restype = Status  # noqa: F405
-        return self._ResetHardware_cfunc(resourceHandle, mode)
-
-    def RenameResource(self, resourceHandle, newName, overwriteConflict, updateDependencies, nameAlreadyExisted, overwrittenResourceHandle):  # noqa: N802,N803
-        with self._func_lock:
-            if self._RenameResource_cfunc is None:
-                self._RenameResource_cfunc = self._library.windll.NISysCfgRenameResource
-                self._RenameResource_cfunc.argtypes = [ResourceHandle, ctypes.POINTER(ctypes.c_char), Bool, Bool, ctypes.POINTER(ctypes.c_int), ResourceHandle]  # noqa: F405
-                self._RenameResource_cfunc.restype = Status  # noqa: F405
-        return self._RenameResource_cfunc(resourceHandle, newName, overwriteConflict, updateDependencies, nameAlreadyExisted, overwrittenResourceHandle)
-
-    def DeleteResource(self, resourceHandle, mode, dependentItemsDeleted, detailedResult):  # noqa: N802,N803
-        with self._func_lock:
-            if self._DeleteResource_cfunc is None:
-                self._DeleteResource_cfunc = self._library.windll.NISysCfgDeleteResource
-                self._DeleteResource_cfunc.argtypes = [ResourceHandle, DeleteValidationMode, ctypes.POINTER(ctypes.c_int), ctypes.POINTER(ctypes.POINTER(ctypes.c_char))]  # noqa: F405
-                self._DeleteResource_cfunc.restype = Status  # noqa: F405
-        return self._DeleteResource_cfunc(resourceHandle, mode, dependentItemsDeleted, detailedResult)
-
-    def GetResourceProperty(self, resourceHandle, propertyID, value):  # noqa: N802,N803
-        with self._func_lock:
-            if self._GetResourceProperty_cfunc is None:
-                self._GetResourceProperty_cfunc = self._library.windll.NISysCfgGetResourceProperty
-                self._GetResourceProperty_cfunc.argtypes = [ResourceHandle, ctypes.c_uint, ctypes.c_void_p]  # noqa: F405
-                self._GetResourceProperty_cfunc.restype = Status  # noqa: F405
-        return self._GetResourceProperty_cfunc(resourceHandle, propertyID, value)
-
-    def SetResourceProperty(self, resourceHandle, propertyID, args):  # noqa: N802,N803
-        with self._func_lock:
-            if self._SetResourceProperty_cfunc is None:
-                self._SetResourceProperty_cfunc = self._library.cdll.NISysCfgSetResourceProperty
-                self._SetResourceProperty_cfunc.restype = Status  # noqa: F405
-        return self._SetResourceProperty_cfunc(resourceHandle, propertyID, args)
-
-    def SetResourcePropertyWithType(self, resourceHandle, propertyID, propertyType, args):  # noqa: N802,N803
-        with self._func_lock:
-            if self._SetResourcePropertyWithType_cfunc is None:
-                self._SetResourcePropertyWithType_cfunc = self._library.cdll.NISysCfgSetResourcePropertyWithType
-                self._SetResourcePropertyWithType_cfunc.restype = Status  # noqa: F405
-        return self._SetResourcePropertyWithType_cfunc(resourceHandle, propertyID, propertyType, args)
-
-    def SetResourcePropertyV(self, resourceHandle, propertyID, args):  # noqa: N802,N803
-        with self._func_lock:
-            if self._SetResourcePropertyV_cfunc is None:
-                self._SetResourcePropertyV_cfunc = self._library.windll.NISysCfgSetResourcePropertyV
-                self._SetResourcePropertyV_cfunc.restype = Status  # noqa: F405
-        return self._SetResourcePropertyV_cfunc(resourceHandle, propertyID, args)
-
-    def SetResourcePropertyWithTypeV(self, resourceHandle, propertyID, propertyType, args):  # noqa: N802,N803
-        with self._func_lock:
-            if self._SetResourcePropertyWithTypeV_cfunc is None:
-                self._SetResourcePropertyWithTypeV_cfunc = self._library.windll.NISysCfgSetResourcePropertyWithTypeV
-                self._SetResourcePropertyWithTypeV_cfunc.restype = Status  # noqa: F405
-        return self._SetResourcePropertyWithTypeV_cfunc(resourceHandle, propertyID, propertyType, args)
-
-    def GetResourceIndexedProperty(self, resourceHandle, propertyID, index, value):  # noqa: N802,N803
-        with self._func_lock:
-            if self._GetResourceIndexedProperty_cfunc is None:
-                self._GetResourceIndexedProperty_cfunc = self._library.windll.NISysCfgGetResourceIndexedProperty
-                self._GetResourceIndexedProperty_cfunc.argtypes = [ResourceHandle, ctypes.c_uint, ctypes.c_uint, ctypes.c_void_p]  # noqa: F405
-                self._GetResourceIndexedProperty_cfunc.restype = Status  # noqa: F405
-        return self._GetResourceIndexedProperty_cfunc(resourceHandle, propertyID, index, value)
-
-    def SaveResourceChanges(self, resourceHandle, changesRequireRestart, detailedResult):  # noqa: N802,N803
-        with self._func_lock:
-            if self._SaveResourceChanges_cfunc is None:
-                self._SaveResourceChanges_cfunc = self._library.windll.NISysCfgSaveResourceChanges
-                self._SaveResourceChanges_cfunc.argtypes = [ResourceHandle, ctypes.POINTER(ctypes.c_int), ctypes.POINTER(ctypes.POINTER(ctypes.c_char))]  # noqa: F405
-                self._SaveResourceChanges_cfunc.restype = Status  # noqa: F405
-        return self._SaveResourceChanges_cfunc(resourceHandle, changesRequireRestart, detailedResult)
-
-    def GetSystemProperty(self, sessionHandle, propertyID, value):  # noqa: N802,N803
-        with self._func_lock:
-            if self._GetSystemProperty_cfunc is None:
-                self._GetSystemProperty_cfunc = self._library.windll.NISysCfgGetSystemProperty
-                self._GetSystemProperty_cfunc.argtypes = [SessionHandle, ctypes.c_uint, ctypes.c_void_p]  # noqa: F405
-                self._GetSystemProperty_cfunc.restype = Status  # noqa: F405
-        return self._GetSystemProperty_cfunc(sessionHandle, propertyID, value)
-
-    def SetSystemProperty(self, sessionHandle, propertyID, args):  # noqa: N802,N803
-        with self._func_lock:
-            if self._SetSystemProperty_cfunc is None:
-                self._SetSystemProperty_cfunc = self._library.cdll.NISysCfgSetSystemProperty
-                self._SetSystemProperty_cfunc.restype = Status  # noqa: F405
-        return self._SetSystemProperty_cfunc(sessionHandle, propertyID, args)
-
-    def SetSystemPropertyV(self, sessionHandle, propertyID, args):  # noqa: N802,N803
-        with self._func_lock:
-            if self._SetSystemPropertyV_cfunc is None:
-                self._SetSystemPropertyV_cfunc = self._library.windll.NISysCfgSetSystemPropertyV
-                self._SetSystemPropertyV_cfunc.restype = Status  # noqa: F405
-        return self._SetSystemPropertyV_cfunc(sessionHandle, propertyID, args)
-
-    def SaveSystemChanges(self, sessionHandle, changesRequireRestart, detailedResult):  # noqa: N802,N803
-        with self._func_lock:
-            if self._SaveSystemChanges_cfunc is None:
-                self._SaveSystemChanges_cfunc = self._library.windll.NISysCfgSaveSystemChanges
-                self._SaveSystemChanges_cfunc.argtypes = [SessionHandle, ctypes.POINTER(ctypes.c_int), ctypes.POINTER(ctypes.POINTER(ctypes.c_char))]  # noqa: F405
-                self._SaveSystemChanges_cfunc.restype = Status  # noqa: F405
-        return self._SaveSystemChanges_cfunc(sessionHandle, changesRequireRestart, detailedResult)
-
-    def CreateFilter(self, sessionHandle, filterHandle):  # noqa: N802,N803
-        with self._func_lock:
-            if self._CreateFilter_cfunc is None:
-                self._CreateFilter_cfunc = self._library.windll.NISysCfgCreateFilter
-                self._CreateFilter_cfunc.argtypes = [SessionHandle, FilterHandle]  # noqa: F405
-                self._CreateFilter_cfunc.restype = Status  # noqa: F405
-        return self._CreateFilter_cfunc(sessionHandle, filterHandle)
-
-    def SetFilterProperty(self, filterHandle, propertyID, args):  # noqa: N802,N803
-        with self._func_lock:
-            if self._SetFilterProperty_cfunc is None:
-                self._SetFilterProperty_cfunc = self._library.cdll.NISysCfgSetFilterProperty
-                self._SetFilterProperty_cfunc.restype = Status  # noqa: F405
-        return self._SetFilterProperty_cfunc(filterHandle, propertyID, args)
-
-    def SetFilterPropertyWithType(self, filterHandle, propertyID, propertyType, args):  # noqa: N802,N803
-        with self._func_lock:
-            if self._SetFilterPropertyWithType_cfunc is None:
-                self._SetFilterPropertyWithType_cfunc = self._library.cdll.NISysCfgSetFilterPropertyWithType
-                self._SetFilterPropertyWithType_cfunc.restype = Status  # noqa: F405
-        return self._SetFilterPropertyWithType_cfunc(filterHandle, propertyID, propertyType, args)
-
-    def SetFilterPropertyV(self, filterHandle, propertyID, args):  # noqa: N802,N803
-        with self._func_lock:
-            if self._SetFilterPropertyV_cfunc is None:
-                self._SetFilterPropertyV_cfunc = self._library.windll.NISysCfgSetFilterPropertyV
-                self._SetFilterPropertyV_cfunc.restype = Status  # noqa: F405
-        return self._SetFilterPropertyV_cfunc(filterHandle, propertyID, args)
-
-    def SetFilterPropertyWithTypeV(self, filterHandle, propertyID, propertyType, args):  # noqa: N802,N803
-        with self._func_lock:
-            if self._SetFilterPropertyWithTypeV_cfunc is None:
-                self._SetFilterPropertyWithTypeV_cfunc = self._library.windll.NISysCfgSetFilterPropertyWithTypeV
-                self._SetFilterPropertyWithTypeV_cfunc.restype = Status  # noqa: F405
-        return self._SetFilterPropertyWithTypeV_cfunc(filterHandle, propertyID, propertyType, args)
-
-    def UpgradeFirmwareFromFile(self, resourceHandle, firmwareFile, autoStopTasks, alwaysOverwrite, waitForOperationToFinish, firmwareStatus, detailedResult):  # noqa: N802,N803
-        with self._func_lock:
-            if self._UpgradeFirmwareFromFile_cfunc is None:
-                self._UpgradeFirmwareFromFile_cfunc = self._library.windll.NISysCfgUpgradeFirmwareFromFile
-                self._UpgradeFirmwareFromFile_cfunc.argtypes = [ResourceHandle, ctypes.POINTER(ctypes.c_char), Bool, Bool, Bool, ctypes.POINTER(ctypes.c_int), ctypes.POINTER(ctypes.POINTER(ctypes.c_char))]  # noqa: F405
-                self._UpgradeFirmwareFromFile_cfunc.restype = Status  # noqa: F405
-        return self._UpgradeFirmwareFromFile_cfunc(resourceHandle, firmwareFile, autoStopTasks, alwaysOverwrite, waitForOperationToFinish, firmwareStatus, detailedResult)
-
-    def UpgradeFirmwareVersion(self, resourceHandle, firmwareVersion, autoStopTasks, alwaysOverwrite, waitForOperationToFinish, firmwareStatus, detailedResult):  # noqa: N802,N803
-        with self._func_lock:
-            if self._UpgradeFirmwareVersion_cfunc is None:
-                self._UpgradeFirmwareVersion_cfunc = self._library.windll.NISysCfgUpgradeFirmwareVersion
-                self._UpgradeFirmwareVersion_cfunc.argtypes = [ResourceHandle, ctypes.POINTER(ctypes.c_char), Bool, Bool, Bool, ctypes.POINTER(ctypes.c_int), ctypes.POINTER(ctypes.POINTER(ctypes.c_char))]  # noqa: F405
-                self._UpgradeFirmwareVersion_cfunc.restype = Status  # noqa: F405
-        return self._UpgradeFirmwareVersion_cfunc(resourceHandle, firmwareVersion, autoStopTasks, alwaysOverwrite, waitForOperationToFinish, firmwareStatus, detailedResult)
-
-    def EraseFirmware(self, resourceHandle, autoStopTasks, firmwareStatus, detailedResult):  # noqa: N802,N803
-        with self._func_lock:
-            if self._EraseFirmware_cfunc is None:
-                self._EraseFirmware_cfunc = self._library.windll.NISysCfgEraseFirmware
-                self._EraseFirmware_cfunc.argtypes = [ResourceHandle, Bool, ctypes.POINTER(ctypes.c_int), ctypes.POINTER(ctypes.POINTER(ctypes.c_char))]  # noqa: F405
-                self._EraseFirmware_cfunc.restype = Status  # noqa: F405
-        return self._EraseFirmware_cfunc(resourceHandle, autoStopTasks, firmwareStatus, detailedResult)
-
-    def CheckFirmwareStatus(self, resourceHandle, percentComplete, firmwareStatus, detailedResult):  # noqa: N802,N803
-        with self._func_lock:
-            if self._CheckFirmwareStatus_cfunc is None:
-                self._CheckFirmwareStatus_cfunc = self._library.windll.NISysCfgCheckFirmwareStatus
-                self._CheckFirmwareStatus_cfunc.argtypes = [ResourceHandle, ctypes.POINTER(ctypes.c_int), ctypes.POINTER(ctypes.c_int), ctypes.POINTER(ctypes.POINTER(ctypes.c_char))]  # noqa: F405
-                self._CheckFirmwareStatus_cfunc.restype = Status  # noqa: F405
-        return self._CheckFirmwareStatus_cfunc(resourceHandle, percentComplete, firmwareStatus, detailedResult)
-
-    def Format(self, sessionHandle, forceSafeMode, restartAfterFormat, fileSystem, networkSettings, timeoutMsec):  # noqa: N802,N803
-        with self._func_lock:
-            if self._Format_cfunc is None:
-                self._Format_cfunc = self._library.windll.NISysCfgFormat
-                self._Format_cfunc.argtypes = [SessionHandle, Bool, Bool, FileSystemMode, NetworkInterfaceSettings, ctypes.c_uint]  # noqa: F405
-                self._Format_cfunc.restype = Status  # noqa: F405
-        return self._Format_cfunc(sessionHandle, forceSafeMode, restartAfterFormat, fileSystem, networkSettings, timeoutMsec)
-
-    def FormatWithBaseSystemImage(self, sessionHandle, autoRestart, fileSystem, networkSettings, systemImageID, systemImageVersion, timeoutMsec):  # noqa: N802,N803
-        with self._func_lock:
-            if self._FormatWithBaseSystemImage_cfunc is None:
-                self._FormatWithBaseSystemImage_cfunc = self._library.windll.NISysCfgFormatWithBaseSystemImage
-                self._FormatWithBaseSystemImage_cfunc.argtypes = [SessionHandle, Bool, FileSystemMode, NetworkInterfaceSettings, ctypes.POINTER(ctypes.c_char), ctypes.POINTER(ctypes.c_char), ctypes.c_uint]  # noqa: F405
-                self._FormatWithBaseSystemImage_cfunc.restype = Status  # noqa: F405
-        return self._FormatWithBaseSystemImage_cfunc(sessionHandle, autoRestart, fileSystem, networkSettings, systemImageID, systemImageVersion, timeoutMsec)
-
-    def Restart(self, sessionHandle, waitForRestartToFinish, installMode, flushDNS, timeoutMsec, newIpAddress):  # noqa: N802,N803
-        with self._func_lock:
-            if self._Restart_cfunc is None:
-                self._Restart_cfunc = self._library.windll.NISysCfgRestart
-                self._Restart_cfunc.argtypes = [SessionHandle, Bool, Bool, Bool, ctypes.c_uint, ctypes.POINTER(ctypes.c_char)]  # noqa: F405
-                self._Restart_cfunc.restype = Status  # noqa: F405
-        return self._Restart_cfunc(sessionHandle, waitForRestartToFinish, installMode, flushDNS, timeoutMsec, newIpAddress)
-
-    def GetAvailableSoftwareComponents(self, sessionHandle, itemTypes, componentEnumHandle):  # noqa: N802,N803
-        with self._func_lock:
-            if self._GetAvailableSoftwareComponents_cfunc is None:
-                self._GetAvailableSoftwareComponents_cfunc = self._library.windll.NISysCfgGetAvailableSoftwareComponents
-                self._GetAvailableSoftwareComponents_cfunc.argtypes = [SessionHandle, IncludeComponentTypes, EnumSoftwareComponentHandle]  # noqa: F405
-                self._GetAvailableSoftwareComponents_cfunc.restype = Status  # noqa: F405
-        return self._GetAvailableSoftwareComponents_cfunc(sessionHandle, itemTypes, componentEnumHandle)
-
-    def GetAvailableSoftwareSets(self, sessionHandle, setEnumHandle):  # noqa: N802,N803
-        with self._func_lock:
-            if self._GetAvailableSoftwareSets_cfunc is None:
-                self._GetAvailableSoftwareSets_cfunc = self._library.windll.NISysCfgGetAvailableSoftwareSets
-                self._GetAvailableSoftwareSets_cfunc.argtypes = [SessionHandle, EnumSoftwareSetHandle]  # noqa: F405
-                self._GetAvailableSoftwareSets_cfunc.restype = Status  # noqa: F405
-        return self._GetAvailableSoftwareSets_cfunc(sessionHandle, setEnumHandle)
-
-    def GetFilteredSoftwareComponents(self, repositoryPath, deviceClass, operatingSystem, productID, itemTypes, componentEnumHandle):  # noqa: N802,N803
-        with self._func_lock:
-            if self._GetFilteredSoftwareComponents_cfunc is None:
-                self._GetFilteredSoftwareComponents_cfunc = self._library.windll.NISysCfgGetFilteredSoftwareComponents
-                self._GetFilteredSoftwareComponents_cfunc.argtypes = [ctypes.POINTER(ctypes.c_char), ctypes.POINTER(ctypes.c_char), ctypes.POINTER(ctypes.c_char), ctypes.c_uint, IncludeComponentTypes, EnumSoftwareComponentHandle]  # noqa: F405
-                self._GetFilteredSoftwareComponents_cfunc.restype = Status  # noqa: F405
-        return self._GetFilteredSoftwareComponents_cfunc(repositoryPath, deviceClass, operatingSystem, productID, itemTypes, componentEnumHandle)
-
-    def GetFilteredSoftwareSets(self, repositoryPath, deviceClass, operatingSystem, productID, setEnumHandle):  # noqa: N802,N803
-        with self._func_lock:
-            if self._GetFilteredSoftwareSets_cfunc is None:
-                self._GetFilteredSoftwareSets_cfunc = self._library.windll.NISysCfgGetFilteredSoftwareSets
-                self._GetFilteredSoftwareSets_cfunc.argtypes = [ctypes.POINTER(ctypes.c_char), ctypes.POINTER(ctypes.c_char), ctypes.POINTER(ctypes.c_char), ctypes.c_uint, EnumSoftwareSetHandle]  # noqa: F405
-                self._GetFilteredSoftwareSets_cfunc.restype = Status  # noqa: F405
-        return self._GetFilteredSoftwareSets_cfunc(repositoryPath, deviceClass, operatingSystem, productID, setEnumHandle)
-
-    def GetFilteredBaseSystemImages(self, repositoryPath, deviceClass, operatingSystem, productID, systemImageEnumHandle):  # noqa: N802,N803
-        with self._func_lock:
-            if self._GetFilteredBaseSystemImages_cfunc is None:
-                self._GetFilteredBaseSystemImages_cfunc = self._library.windll.NISysCfgGetFilteredBaseSystemImages
-                self._GetFilteredBaseSystemImages_cfunc.argtypes = [ctypes.POINTER(ctypes.c_char), ctypes.POINTER(ctypes.c_char), ctypes.POINTER(ctypes.c_char), ctypes.c_uint, EnumSoftwareComponentHandle]  # noqa: F405
-                self._GetFilteredBaseSystemImages_cfunc.restype = Status  # noqa: F405
-        return self._GetFilteredBaseSystemImages_cfunc(repositoryPath, deviceClass, operatingSystem, productID, systemImageEnumHandle)
-
-    def GetInstalledSoftwareComponents(self, sessionHandle, itemTypes, cached, componentEnumHandle):  # noqa: N802,N803
-        with self._func_lock:
-            if self._GetInstalledSoftwareComponents_cfunc is None:
-                self._GetInstalledSoftwareComponents_cfunc = self._library.windll.NISysCfgGetInstalledSoftwareComponents
-                self._GetInstalledSoftwareComponents_cfunc.argtypes = [SessionHandle, IncludeComponentTypes, Bool, EnumSoftwareComponentHandle]  # noqa: F405
-                self._GetInstalledSoftwareComponents_cfunc.restype = Status  # noqa: F405
-        return self._GetInstalledSoftwareComponents_cfunc(sessionHandle, itemTypes, cached, componentEnumHandle)
-
-    def GetInstalledSoftwareSet(self, sessionHandle, cached, setHandle):  # noqa: N802,N803
-        with self._func_lock:
-            if self._GetInstalledSoftwareSet_cfunc is None:
-                self._GetInstalledSoftwareSet_cfunc = self._library.windll.NISysCfgGetInstalledSoftwareSet
-                self._GetInstalledSoftwareSet_cfunc.argtypes = [SessionHandle, Bool, SoftwareSetHandle]  # noqa: F405
-                self._GetInstalledSoftwareSet_cfunc.restype = Status  # noqa: F405
-        return self._GetInstalledSoftwareSet_cfunc(sessionHandle, cached, setHandle)
-
-    def GetSystemImageAsFolder(self, sessionHandle, destinationFolder, encryptionPassphrase, overwriteIfExists, installedSoftwareOnly, autoRestart):  # noqa: N802,N803
-        with self._func_lock:
-            if self._GetSystemImageAsFolder_cfunc is None:
-                self._GetSystemImageAsFolder_cfunc = self._library.windll.NISysCfgGetSystemImageAsFolder
-                self._GetSystemImageAsFolder_cfunc.argtypes = [SessionHandle, ctypes.POINTER(ctypes.c_char), ctypes.POINTER(ctypes.c_char), Bool, Bool, Bool]  # noqa: F405
-                self._GetSystemImageAsFolder_cfunc.restype = Status  # noqa: F405
-        return self._GetSystemImageAsFolder_cfunc(sessionHandle, destinationFolder, encryptionPassphrase, overwriteIfExists, installedSoftwareOnly, autoRestart)
-
-    def GetSystemImageAsFolder2(self, sessionHandle, autoRestart, destinationFolder, encryptionPassphrase, numBlacklistEntries, blacklistFilesDirectories, overwriteIfExists, installedSoftwareOnly):  # noqa: N802,N803
-        with self._func_lock:
-            if self._GetSystemImageAsFolder2_cfunc is None:
-                self._GetSystemImageAsFolder2_cfunc = self._library.windll.NISysCfgGetSystemImageAsFolder2
-                self._GetSystemImageAsFolder2_cfunc.argtypes = [SessionHandle, Bool, ctypes.POINTER(ctypes.c_char), ctypes.POINTER(ctypes.c_char), ctypes.c_uint, ctypes.POINTER(ctypes.POINTER(ctypes.c_char)), Bool, Bool]  # noqa: F405
-                self._GetSystemImageAsFolder2_cfunc.restype = Status  # noqa: F405
-        return self._GetSystemImageAsFolder2_cfunc(sessionHandle, autoRestart, destinationFolder, encryptionPassphrase, numBlacklistEntries, blacklistFilesDirectories, overwriteIfExists, installedSoftwareOnly)
-
-    def CreateSystemImageAsFolder(self, sessionHandle, imageTitle, imageID, imageVersion, imageDescription, autoRestart, destinationFolder, encryptionPassphrase, numBlacklistEntries, blacklistFilesDirectories, overwriteIfExists):  # noqa: N802,N803
-        with self._func_lock:
-            if self._CreateSystemImageAsFolder_cfunc is None:
-                self._CreateSystemImageAsFolder_cfunc = self._library.windll.NISysCfgCreateSystemImageAsFolder
-                self._CreateSystemImageAsFolder_cfunc.argtypes = [SessionHandle, ctypes.POINTER(ctypes.c_char), ctypes.POINTER(ctypes.c_char), ctypes.POINTER(ctypes.c_char), ctypes.POINTER(ctypes.c_char), Bool, ctypes.POINTER(ctypes.c_char), ctypes.POINTER(ctypes.c_char), ctypes.c_uint, ctypes.POINTER(ctypes.POINTER(ctypes.c_char)), Bool]  # noqa: F405
-                self._CreateSystemImageAsFolder_cfunc.restype = Status  # noqa: F405
-        return self._CreateSystemImageAsFolder_cfunc(sessionHandle, imageTitle, imageID, imageVersion, imageDescription, autoRestart, destinationFolder, encryptionPassphrase, numBlacklistEntries, blacklistFilesDirectories, overwriteIfExists)
-
-    def SetSystemImageFromFolder(self, sessionHandle, sourceFolder, encryptionPassphrase, autoRestart, originalSystemOnly):  # noqa: N802,N803
-        with self._func_lock:
-            if self._SetSystemImageFromFolder_cfunc is None:
-                self._SetSystemImageFromFolder_cfunc = self._library.windll.NISysCfgSetSystemImageFromFolder
-                self._SetSystemImageFromFolder_cfunc.argtypes = [SessionHandle, ctypes.POINTER(ctypes.c_char), ctypes.POINTER(ctypes.c_char), Bool, Bool]  # noqa: F405
-                self._SetSystemImageFromFolder_cfunc.restype = Status  # noqa: F405
-        return self._SetSystemImageFromFolder_cfunc(sessionHandle, sourceFolder, encryptionPassphrase, autoRestart, originalSystemOnly)
-
-    def SetSystemImageFromFolder2(self, sessionHandle, autoRestart, sourceFolder, encryptionPassphrase, numBlacklistEntries, blacklistFilesDirectories, originalSystemOnly, networkSettings):  # noqa: N802,N803
-        with self._func_lock:
-            if self._SetSystemImageFromFolder2_cfunc is None:
-                self._SetSystemImageFromFolder2_cfunc = self._library.windll.NISysCfgSetSystemImageFromFolder2
-                self._SetSystemImageFromFolder2_cfunc.argtypes = [SessionHandle, Bool, ctypes.POINTER(ctypes.c_char), ctypes.POINTER(ctypes.c_char), ctypes.c_uint, ctypes.POINTER(ctypes.POINTER(ctypes.c_char)), Bool, NetworkInterfaceSettings]  # noqa: F405
-                self._SetSystemImageFromFolder2_cfunc.restype = Status  # noqa: F405
-        return self._SetSystemImageFromFolder2_cfunc(sessionHandle, autoRestart, sourceFolder, encryptionPassphrase, numBlacklistEntries, blacklistFilesDirectories, originalSystemOnly, networkSettings)
-
-    def InstallAll(self, sessionHandle, autoRestart, deselectConflicts, installedComponentEnumHandle, brokenDependencyEnumHandle):  # noqa: N802,N803
-        with self._func_lock:
-            if self._InstallAll_cfunc is None:
-                self._InstallAll_cfunc = self._library.windll.NISysCfgInstallAll
-                self._InstallAll_cfunc.argtypes = [SessionHandle, Bool, Bool, EnumSoftwareComponentHandle, EnumDependencyHandle]  # noqa: F405
-                self._InstallAll_cfunc.restype = Status  # noqa: F405
-        return self._InstallAll_cfunc(sessionHandle, autoRestart, deselectConflicts, installedComponentEnumHandle, brokenDependencyEnumHandle)
-
-    def InstallUninstallComponents(self, sessionHandle, autoRestart, autoSelectDependencies, componentToInstallEnumHandle, numComponentsToUninstall, componentIDsToUninstall, brokenDependencyEnumHandle):  # noqa: N802,N803
-        with self._func_lock:
-            if self._InstallUninstallComponents_cfunc is None:
-                self._InstallUninstallComponents_cfunc = self._library.windll.NISysCfgInstallUninstallComponents
-                self._InstallUninstallComponents_cfunc.argtypes = [SessionHandle, Bool, Bool, EnumSoftwareComponentHandle, ctypes.c_uint, ctypes.POINTER(ctypes.POINTER(ctypes.c_char)), EnumDependencyHandle]  # noqa: F405
-                self._InstallUninstallComponents_cfunc.restype = Status  # noqa: F405
-        return self._InstallUninstallComponents_cfunc(sessionHandle, autoRestart, autoSelectDependencies, componentToInstallEnumHandle, numComponentsToUninstall, componentIDsToUninstall, brokenDependencyEnumHandle)
-
-    def InstallUninstallComponents2(self, sessionHandle, autoRestart, autoSelectDependencies, autoSelectRecommends, componentToInstallEnumHandle, numComponentsToUninstall, componentIDsToUninstall, brokenDependencyEnumHandle):  # noqa: N802,N803
-        with self._func_lock:
-            if self._InstallUninstallComponents2_cfunc is None:
-                self._InstallUninstallComponents2_cfunc = self._library.windll.NISysCfgInstallUninstallComponents2
-                self._InstallUninstallComponents2_cfunc.argtypes = [SessionHandle, Bool, Bool, Bool, EnumSoftwareComponentHandle, ctypes.c_uint, ctypes.POINTER(ctypes.POINTER(ctypes.c_char)), EnumDependencyHandle]  # noqa: F405
-                self._InstallUninstallComponents2_cfunc.restype = Status  # noqa: F405
-        return self._InstallUninstallComponents2_cfunc(sessionHandle, autoRestart, autoSelectDependencies, autoSelectRecommends, componentToInstallEnumHandle, numComponentsToUninstall, componentIDsToUninstall, brokenDependencyEnumHandle)
-
-    def InstallSoftwareSet(self, sessionHandle, autoRestart, softwareSetID, version, addonEnumHandle, brokenDependencyEnumHandle):  # noqa: N802,N803
-        with self._func_lock:
-            if self._InstallSoftwareSet_cfunc is None:
-                self._InstallSoftwareSet_cfunc = self._library.windll.NISysCfgInstallSoftwareSet
-                self._InstallSoftwareSet_cfunc.argtypes = [SessionHandle, Bool, ctypes.POINTER(ctypes.c_char), ctypes.POINTER(ctypes.c_char), EnumSoftwareComponentHandle, EnumDependencyHandle]  # noqa: F405
-                self._InstallSoftwareSet_cfunc.restype = Status  # noqa: F405
-        return self._InstallSoftwareSet_cfunc(sessionHandle, autoRestart, softwareSetID, version, addonEnumHandle, brokenDependencyEnumHandle)
-
-    def InstallStartup(self, sessionHandle, autoRestart, startupEnumHandle, uninstallConflicts, installedComponentEnumHandle, uninstalledComponentEnumHandle, brokenDependencyEnumHandle):  # noqa: N802,N803
-        with self._func_lock:
-            if self._InstallStartup_cfunc is None:
-                self._InstallStartup_cfunc = self._library.windll.NISysCfgInstallStartup
-                self._InstallStartup_cfunc.argtypes = [SessionHandle, Bool, EnumSoftwareComponentHandle, Bool, EnumSoftwareComponentHandle, EnumSoftwareComponentHandle, EnumDependencyHandle]  # noqa: F405
-                self._InstallStartup_cfunc.restype = Status  # noqa: F405
-        return self._InstallStartup_cfunc(sessionHandle, autoRestart, startupEnumHandle, uninstallConflicts, installedComponentEnumHandle, uninstalledComponentEnumHandle, brokenDependencyEnumHandle)
-
-    def UninstallAll(self, sessionHandle, autoRestart):  # noqa: N802,N803
-        with self._func_lock:
-            if self._UninstallAll_cfunc is None:
-                self._UninstallAll_cfunc = self._library.windll.NISysCfgUninstallAll
-                self._UninstallAll_cfunc.argtypes = [SessionHandle, Bool]  # noqa: F405
-                self._UninstallAll_cfunc.restype = Status  # noqa: F405
-        return self._UninstallAll_cfunc(sessionHandle, autoRestart)
-
-    def GetSoftwareFeeds(self, sessionHandle, feedEnumHandle):  # noqa: N802,N803
-        with self._func_lock:
-            if self._GetSoftwareFeeds_cfunc is None:
-                self._GetSoftwareFeeds_cfunc = self._library.windll.NISysCfgGetSoftwareFeeds
-                self._GetSoftwareFeeds_cfunc.argtypes = [SessionHandle, EnumSoftwareFeedHandle]  # noqa: F405
-                self._GetSoftwareFeeds_cfunc.restype = Status  # noqa: F405
-        return self._GetSoftwareFeeds_cfunc(sessionHandle, feedEnumHandle)
-
-    def AddSoftwareFeed(self, sessionHandle, feedName, uri, enabled, trusted):  # noqa: N802,N803
-        with self._func_lock:
-            if self._AddSoftwareFeed_cfunc is None:
-                self._AddSoftwareFeed_cfunc = self._library.windll.NISysCfgAddSoftwareFeed
-                self._AddSoftwareFeed_cfunc.argtypes = [SessionHandle, ctypes.POINTER(ctypes.c_char), ctypes.POINTER(ctypes.c_char), Bool, Bool]  # noqa: F405
-                self._AddSoftwareFeed_cfunc.restype = Status  # noqa: F405
-        return self._AddSoftwareFeed_cfunc(sessionHandle, feedName, uri, enabled, trusted)
-
-    def ModifySoftwareFeed(self, sessionHandle, feedName, newFeedName, uri, enabled, trusted):  # noqa: N802,N803
-        with self._func_lock:
-            if self._ModifySoftwareFeed_cfunc is None:
-                self._ModifySoftwareFeed_cfunc = self._library.windll.NISysCfgModifySoftwareFeed
-                self._ModifySoftwareFeed_cfunc.argtypes = [SessionHandle, ctypes.POINTER(ctypes.c_char), ctypes.POINTER(ctypes.c_char), ctypes.POINTER(ctypes.c_char), Bool, Bool]  # noqa: F405
-                self._ModifySoftwareFeed_cfunc.restype = Status  # noqa: F405
-        return self._ModifySoftwareFeed_cfunc(sessionHandle, feedName, newFeedName, uri, enabled, trusted)
-
-    def RemoveSoftwareFeed(self, sessionHandle, feedName):  # noqa: N802,N803
-        with self._func_lock:
-            if self._RemoveSoftwareFeed_cfunc is None:
-                self._RemoveSoftwareFeed_cfunc = self._library.windll.NISysCfgRemoveSoftwareFeed
-                self._RemoveSoftwareFeed_cfunc.argtypes = [SessionHandle, ctypes.POINTER(ctypes.c_char)]  # noqa: F405
-                self._RemoveSoftwareFeed_cfunc.restype = Status  # noqa: F405
-        return self._RemoveSoftwareFeed_cfunc(sessionHandle, feedName)
-
-    def ChangeAdministratorPassword(self, sessionHandle, newPassword):  # noqa: N802,N803
-        with self._func_lock:
-            if self._ChangeAdministratorPassword_cfunc is None:
-                self._ChangeAdministratorPassword_cfunc = self._library.windll.NISysCfgChangeAdministratorPassword
-                self._ChangeAdministratorPassword_cfunc.argtypes = [SessionHandle, ctypes.POINTER(ctypes.c_char)]  # noqa: F405
-                self._ChangeAdministratorPassword_cfunc.restype = Status  # noqa: F405
-        return self._ChangeAdministratorPassword_cfunc(sessionHandle, newPassword)
-
-    def ExportConfiguration(self, sessionHandle, destinationFile, expertNames, overwriteIfExists):  # noqa: N802,N803
-        with self._func_lock:
-            if self._ExportConfiguration_cfunc is None:
-                self._ExportConfiguration_cfunc = self._library.windll.NISysCfgExportConfiguration
-                self._ExportConfiguration_cfunc.argtypes = [SessionHandle, ctypes.POINTER(ctypes.c_char), ctypes.POINTER(ctypes.c_char), Bool]  # noqa: F405
-                self._ExportConfiguration_cfunc.restype = Status  # noqa: F405
-        return self._ExportConfiguration_cfunc(sessionHandle, destinationFile, expertNames, overwriteIfExists)
-
-    def ImportConfiguration(self, sessionHandle, sourceFile, expertNames, importMode, detailedResult):  # noqa: N802,N803
-        with self._func_lock:
-            if self._ImportConfiguration_cfunc is None:
-                self._ImportConfiguration_cfunc = self._library.windll.NISysCfgImportConfiguration
-                self._ImportConfiguration_cfunc.argtypes = [SessionHandle, ctypes.POINTER(ctypes.c_char), ctypes.POINTER(ctypes.c_char), ImportMode, ctypes.POINTER(ctypes.POINTER(ctypes.c_char))]  # noqa: F405
-                self._ImportConfiguration_cfunc.restype = Status  # noqa: F405
-        return self._ImportConfiguration_cfunc(sessionHandle, sourceFile, expertNames, importMode, detailedResult)
-
-    def GenerateMAXReport(self, sessionHandle, outputFilename, reportType, overwriteIfExists):  # noqa: N802,N803
-        with self._func_lock:
-            if self._GenerateMAXReport_cfunc is None:
-                self._GenerateMAXReport_cfunc = self._library.windll.NISysCfgGenerateMAXReport
-                self._GenerateMAXReport_cfunc.argtypes = [SessionHandle, ctypes.POINTER(ctypes.c_char), ReportType, Bool]  # noqa: F405
-                self._GenerateMAXReport_cfunc.restype = Status  # noqa: F405
-        return self._GenerateMAXReport_cfunc(sessionHandle, outputFilename, reportType, overwriteIfExists)
-
-    def CreateComponentsEnum(self, componentEnumHandle):  # noqa: N802,N803
-        with self._func_lock:
-            if self._CreateComponentsEnum_cfunc is None:
-                self._CreateComponentsEnum_cfunc = self._library.windll.NISysCfgCreateComponentsEnum
-                self._CreateComponentsEnum_cfunc.argtypes = [EnumSoftwareComponentHandle]  # noqa: F405
-                self._CreateComponentsEnum_cfunc.restype = Status  # noqa: F405
-        return self._CreateComponentsEnum_cfunc(componentEnumHandle)
-
-    def AddComponentToEnum(self, componentEnumHandle, ID, version, mode):  # noqa: N802,N803
-        with self._func_lock:
-            if self._AddComponentToEnum_cfunc is None:
-                self._AddComponentToEnum_cfunc = self._library.windll.NISysCfgAddComponentToEnum
-                self._AddComponentToEnum_cfunc.argtypes = [EnumSoftwareComponentHandle, ctypes.POINTER(ctypes.c_char), ctypes.POINTER(ctypes.c_char), VersionSelectionMode]  # noqa: F405
-                self._AddComponentToEnum_cfunc.restype = Status  # noqa: F405
-        return self._AddComponentToEnum_cfunc(componentEnumHandle, ID, version, mode)
-
-    def FreeDetailedString(self, str):  # noqa: N802,N803
-        with self._func_lock:
-            if self._FreeDetailedString_cfunc is None:
-                self._FreeDetailedString_cfunc = self._library.windll.NISysCfgFreeDetailedString
-                self._FreeDetailedString_cfunc.argtypes = [ctypes.POINTER(ctypes.c_char)]  # noqa: F405
-                self._FreeDetailedString_cfunc.restype = Status  # noqa: F405
-        return self._FreeDetailedString_cfunc(str)
-
-    def NextResource(self, sessionHandle, resourceEnumHandle, resourceHandle):  # noqa: N802,N803
-        with self._func_lock:
-            if self._NextResource_cfunc is None:
-                self._NextResource_cfunc = self._library.windll.NISysCfgNextResource
-                self._NextResource_cfunc.argtypes = [SessionHandle, EnumResourceHandle, ResourceHandle]  # noqa: F405
-                self._NextResource_cfunc.restype = Status  # noqa: F405
-        return self._NextResource_cfunc(sessionHandle, resourceEnumHandle, resourceHandle)
-
-    def NextSystemInfo(self, systemEnumHandle, system):  # noqa: N802,N803
-        with self._func_lock:
-            if self._NextSystemInfo_cfunc is None:
-                self._NextSystemInfo_cfunc = self._library.windll.NISysCfgNextSystemInfo
-                self._NextSystemInfo_cfunc.argtypes = [EnumSystemHandle, ctypes.POINTER(ctypes.c_char)]  # noqa: F405
-                self._NextSystemInfo_cfunc.restype = Status  # noqa: F405
-        return self._NextSystemInfo_cfunc(systemEnumHandle, system)
-
-    def NextExpertInfo(self, expertEnumHandle, expertName, displayName, version):  # noqa: N802,N803
-        with self._func_lock:
-            if self._NextExpertInfo_cfunc is None:
-                self._NextExpertInfo_cfunc = self._library.windll.NISysCfgNextExpertInfo
-                self._NextExpertInfo_cfunc.argtypes = [EnumExpertHandle, ctypes.POINTER(ctypes.c_char), ctypes.POINTER(ctypes.c_char), ctypes.POINTER(ctypes.c_char)]  # noqa: F405
-                self._NextExpertInfo_cfunc.restype = Status  # noqa: F405
-        return self._NextExpertInfo_cfunc(expertEnumHandle, expertName, displayName, version)
-
-    def NextComponentInfo(self, componentEnumHandle, ID, version, title, itemType, detailedDescription):  # noqa: N802,N803
-        with self._func_lock:
-            if self._NextComponentInfo_cfunc is None:
-                self._NextComponentInfo_cfunc = self._library.windll.NISysCfgNextComponentInfo
-                self._NextComponentInfo_cfunc.argtypes = [EnumSoftwareComponentHandle, ctypes.POINTER(ctypes.c_char), ctypes.POINTER(ctypes.c_char), ctypes.POINTER(ctypes.c_char), ctypes.POINTER(ctypes.c_int), ctypes.POINTER(ctypes.POINTER(ctypes.c_char))]  # noqa: F405
-                self._NextComponentInfo_cfunc.restype = Status  # noqa: F405
-        return self._NextComponentInfo_cfunc(componentEnumHandle, ID, version, title, itemType, detailedDescription)
-
-    def NextSoftwareSet(self, setEnumHandle, setHandle):  # noqa: N802,N803
-        with self._func_lock:
-            if self._NextSoftwareSet_cfunc is None:
-                self._NextSoftwareSet_cfunc = self._library.windll.NISysCfgNextSoftwareSet
-                self._NextSoftwareSet_cfunc.argtypes = [EnumSoftwareSetHandle, SoftwareSetHandle]  # noqa: F405
-                self._NextSoftwareSet_cfunc.restype = Status  # noqa: F405
-        return self._NextSoftwareSet_cfunc(setEnumHandle, setHandle)
-
-    def GetSoftwareSetInfo(self, setHandle, itemTypes, includeAddOnDeps, ID, version, title, setType, detailedDescription, addOnEnumHandle, itemEnumHandle):  # noqa: N802,N803
-        with self._func_lock:
-            if self._GetSoftwareSetInfo_cfunc is None:
-                self._GetSoftwareSetInfo_cfunc = self._library.windll.NISysCfgGetSoftwareSetInfo
-                self._GetSoftwareSetInfo_cfunc.argtypes = [SoftwareSetHandle, IncludeComponentTypes, Bool, ctypes.POINTER(ctypes.c_char), ctypes.POINTER(ctypes.c_char), ctypes.POINTER(ctypes.c_char), ctypes.POINTER(ctypes.c_int), ctypes.POINTER(ctypes.POINTER(ctypes.c_char)), EnumSoftwareComponentHandle, EnumSoftwareComponentHandle]  # noqa: F405
-                self._GetSoftwareSetInfo_cfunc.restype = Status  # noqa: F405
-        return self._GetSoftwareSetInfo_cfunc(setHandle, itemTypes, includeAddOnDeps, ID, version, title, setType, detailedDescription, addOnEnumHandle, itemEnumHandle)
-
-    def NextDependencyInfo(self, dependencyEnumHandle, dependerID, dependerVersion, dependerTitle, dependerDetailedDescription, dependeeID, dependeeVersion, dependeeTitle, dependeeDetailedDescription):  # noqa: N802,N803
-        with self._func_lock:
-            if self._NextDependencyInfo_cfunc is None:
-                self._NextDependencyInfo_cfunc = self._library.windll.NISysCfgNextDependencyInfo
-                self._NextDependencyInfo_cfunc.argtypes = [EnumDependencyHandle, ctypes.POINTER(ctypes.c_char), ctypes.POINTER(ctypes.c_char), ctypes.POINTER(ctypes.c_char), ctypes.POINTER(ctypes.POINTER(ctypes.c_char)), ctypes.POINTER(ctypes.c_char), ctypes.POINTER(ctypes.c_char), ctypes.POINTER(ctypes.c_char), ctypes.POINTER(ctypes.POINTER(ctypes.c_char))]  # noqa: F405
-                self._NextDependencyInfo_cfunc.restype = Status  # noqa: F405
-        return self._NextDependencyInfo_cfunc(dependencyEnumHandle, dependerID, dependerVersion, dependerTitle, dependerDetailedDescription, dependeeID, dependeeVersion, dependeeTitle, dependeeDetailedDescription)
-
-    def NextSoftwareFeed(self, feedEnumHandle, feedName, uri, enabled, trusted):  # noqa: N802,N803
-        with self._func_lock:
-            if self._NextSoftwareFeed_cfunc is None:
-                self._NextSoftwareFeed_cfunc = self._library.windll.NISysCfgNextSoftwareFeed
-                self._NextSoftwareFeed_cfunc.argtypes = [EnumSoftwareFeedHandle, ctypes.POINTER(ctypes.c_char), ctypes.POINTER(ctypes.c_char), ctypes.POINTER(ctypes.c_int), ctypes.POINTER(ctypes.c_int)]  # noqa: F405
-                self._NextSoftwareFeed_cfunc.restype = Status  # noqa: F405
-        return self._NextSoftwareFeed_cfunc(feedEnumHandle, feedName, uri, enabled, trusted)
-
-    def ResetEnumeratorGetCount(self, enumHandle, count):  # noqa: N802,N803
-        with self._func_lock:
-            if self._ResetEnumeratorGetCount_cfunc is None:
-                self._ResetEnumeratorGetCount_cfunc = self._library.windll.NISysCfgResetEnumeratorGetCount
-                self._ResetEnumeratorGetCount_cfunc.argtypes = [ctypes.c_void_p, ctypes.POINTER(ctypes.c_uint)]  # noqa: F405
-                self._ResetEnumeratorGetCount_cfunc.restype = Status  # noqa: F405
-        return self._ResetEnumeratorGetCount_cfunc(enumHandle, count)
-
-    def GetStatusDescription(self, sessionHandle, status, detailedDescription):  # noqa: N802,N803
-        with self._func_lock:
-            if self._GetStatusDescription_cfunc is None:
-                self._GetStatusDescription_cfunc = self._library.windll.NISysCfgGetStatusDescription
-                self._GetStatusDescription_cfunc.argtypes = [SessionHandle, Status, ctypes.POINTER(ctypes.POINTER(ctypes.c_char))]  # noqa: F405
-                self._GetStatusDescription_cfunc.restype = Status  # noqa: F405
-        return self._GetStatusDescription_cfunc(sessionHandle, status, detailedDescription)
-
-    def TimestampFromValues(self, secondsSinceEpoch1970, fractionalSeconds, timestamp):  # noqa: N802,N803
-        with self._func_lock:
-            if self._TimestampFromValues_cfunc is None:
-                self._TimestampFromValues_cfunc = self._library.windll.NISysCfgTimestampFromValues
-                self._TimestampFromValues_cfunc.argtypes = [UInt64, ctypes.c_double, ctypes.POINTER(TimestampUTC)]  # noqa: F405
-                self._TimestampFromValues_cfunc.restype = Status  # noqa: F405
-        return self._TimestampFromValues_cfunc(secondsSinceEpoch1970, fractionalSeconds, timestamp)
-
-    def ValuesFromTimestamp(self, timestamp, secondsSinceEpoch1970, fractionalSeconds):  # noqa: N802,N803
-        with self._func_lock:
-            if self._ValuesFromTimestamp_cfunc is None:
-                self._ValuesFromTimestamp_cfunc = self._library.windll.NISysCfgValuesFromTimestamp
-                self._ValuesFromTimestamp_cfunc.argtypes = [TimestampUTC, ctypes.POINTER(UInt64), ctypes.POINTER(ctypes.c_double)]  # noqa: F405
-                self._ValuesFromTimestamp_cfunc.restype = Status  # noqa: F405
-        return self._ValuesFromTimestamp_cfunc(timestamp, secondsSinceEpoch1970, fractionalSeconds)
+# This file is code generated
+# fmt: off
+
+import ctypes
+import threading
+
+from nisyscfg.enums import *  # noqa: F403
+from nisyscfg.errors import *  # noqa: F403
+from nisyscfg.types import *  # noqa: F403
+
+
+class Library(object):
+    def __init__(self, ctypes_library):
+        self._func_lock = threading.Lock()
+        self._library = ctypes_library
+        self._InitializeSession_cfunc = None
+        self._CloseHandle_cfunc = None
+        self._GetSystemExperts_cfunc = None
+        self._SetRemoteTimeout_cfunc = None
+        self._FindHardware_cfunc = None
+        self._FindSystems_cfunc = None
+        self._SelfTestHardware_cfunc = None
+        self._SelfCalibrateHardware_cfunc = None
+        self._ResetHardware_cfunc = None
+        self._RenameResource_cfunc = None
+        self._DeleteResource_cfunc = None
+        self._GetResourceProperty_cfunc = None
+        self._SetResourceProperty_cfunc = None
+        self._SetResourcePropertyWithType_cfunc = None
+        self._SetResourcePropertyV_cfunc = None
+        self._SetResourcePropertyWithTypeV_cfunc = None
+        self._GetResourceIndexedProperty_cfunc = None
+        self._SaveResourceChanges_cfunc = None
+        self._GetSystemProperty_cfunc = None
+        self._SetSystemProperty_cfunc = None
+        self._SetSystemPropertyV_cfunc = None
+        self._SaveSystemChanges_cfunc = None
+        self._CreateFilter_cfunc = None
+        self._SetFilterProperty_cfunc = None
+        self._SetFilterPropertyWithType_cfunc = None
+        self._SetFilterPropertyV_cfunc = None
+        self._SetFilterPropertyWithTypeV_cfunc = None
+        self._UpgradeFirmwareFromFile_cfunc = None
+        self._UpgradeFirmwareVersion_cfunc = None
+        self._EraseFirmware_cfunc = None
+        self._CheckFirmwareStatus_cfunc = None
+        self._Format_cfunc = None
+        self._FormatWithBaseSystemImage_cfunc = None
+        self._Restart_cfunc = None
+        self._GetAvailableSoftwareComponents_cfunc = None
+        self._GetAvailableSoftwareSets_cfunc = None
+        self._GetFilteredSoftwareComponents_cfunc = None
+        self._GetFilteredSoftwareSets_cfunc = None
+        self._GetFilteredBaseSystemImages_cfunc = None
+        self._GetInstalledSoftwareComponents_cfunc = None
+        self._GetInstalledSoftwareSet_cfunc = None
+        self._GetSystemImageAsFolder_cfunc = None
+        self._GetSystemImageAsFolder2_cfunc = None
+        self._CreateSystemImageAsFolder_cfunc = None
+        self._SetSystemImageFromFolder_cfunc = None
+        self._SetSystemImageFromFolder2_cfunc = None
+        self._InstallAll_cfunc = None
+        self._InstallUninstallComponents_cfunc = None
+        self._InstallUninstallComponents2_cfunc = None
+        self._InstallSoftwareSet_cfunc = None
+        self._InstallStartup_cfunc = None
+        self._UninstallAll_cfunc = None
+        self._GetSoftwareFeeds_cfunc = None
+        self._AddSoftwareFeed_cfunc = None
+        self._ModifySoftwareFeed_cfunc = None
+        self._RemoveSoftwareFeed_cfunc = None
+        self._ChangeAdministratorPassword_cfunc = None
+        self._ExportConfiguration_cfunc = None
+        self._ImportConfiguration_cfunc = None
+        self._GenerateMAXReport_cfunc = None
+        self._CreateComponentsEnum_cfunc = None
+        self._AddComponentToEnum_cfunc = None
+        self._FreeDetailedString_cfunc = None
+        self._NextResource_cfunc = None
+        self._NextSystemInfo_cfunc = None
+        self._NextExpertInfo_cfunc = None
+        self._NextComponentInfo_cfunc = None
+        self._NextSoftwareSet_cfunc = None
+        self._GetSoftwareSetInfo_cfunc = None
+        self._NextDependencyInfo_cfunc = None
+        self._NextSoftwareFeed_cfunc = None
+        self._ResetEnumeratorGetCount_cfunc = None
+        self._GetStatusDescription_cfunc = None
+        self._TimestampFromValues_cfunc = None
+        self._ValuesFromTimestamp_cfunc = None
+
+    def InitializeSession(self, targetName, username, password, language, forcePropertyRefresh, connectTimeoutMsec, expertEnumHandle, sessionHandle):  # noqa: N802,N803
+        with self._func_lock:
+            if self._InitializeSession_cfunc is None:
+                self._InitializeSession_cfunc = self._library.windll.NISysCfgInitializeSession
+                self._InitializeSession_cfunc.argtypes = [ctypes.POINTER(ctypes.c_char), ctypes.POINTER(ctypes.c_char), ctypes.POINTER(ctypes.c_char), Locale, Bool, ctypes.c_uint, EnumExpertHandle, SessionHandle]  # noqa: F405
+                self._InitializeSession_cfunc.restype = Status  # noqa: F405
+        return self._InitializeSession_cfunc(targetName, username, password, language, forcePropertyRefresh, connectTimeoutMsec, expertEnumHandle, sessionHandle)
+
+    def CloseHandle(self, syscfgHandle):  # noqa: N802,N803
+        with self._func_lock:
+            if self._CloseHandle_cfunc is None:
+                self._CloseHandle_cfunc = self._library.windll.NISysCfgCloseHandle
+                self._CloseHandle_cfunc.argtypes = [ctypes.c_void_p]  # noqa: F405
+                self._CloseHandle_cfunc.restype = Status  # noqa: F405
+        return self._CloseHandle_cfunc(syscfgHandle)
+
+    def GetSystemExperts(self, sessionHandle, expertNames, expertEnumHandle):  # noqa: N802,N803
+        with self._func_lock:
+            if self._GetSystemExperts_cfunc is None:
+                self._GetSystemExperts_cfunc = self._library.windll.NISysCfgGetSystemExperts
+                self._GetSystemExperts_cfunc.argtypes = [SessionHandle, ctypes.POINTER(ctypes.c_char), EnumExpertHandle]  # noqa: F405
+                self._GetSystemExperts_cfunc.restype = Status  # noqa: F405
+        return self._GetSystemExperts_cfunc(sessionHandle, expertNames, expertEnumHandle)
+
+    def SetRemoteTimeout(self, sessionHandle, remoteTimeoutMsec):  # noqa: N802,N803
+        with self._func_lock:
+            if self._SetRemoteTimeout_cfunc is None:
+                self._SetRemoteTimeout_cfunc = self._library.windll.NISysCfgSetRemoteTimeout
+                self._SetRemoteTimeout_cfunc.argtypes = [SessionHandle, ctypes.c_uint]  # noqa: F405
+                self._SetRemoteTimeout_cfunc.restype = Status  # noqa: F405
+        return self._SetRemoteTimeout_cfunc(sessionHandle, remoteTimeoutMsec)
+
+    def FindHardware(self, sessionHandle, filterMode, filterHandle, expertNames, resourceEnumHandle):  # noqa: N802,N803
+        with self._func_lock:
+            if self._FindHardware_cfunc is None:
+                self._FindHardware_cfunc = self._library.windll.NISysCfgFindHardware
+                self._FindHardware_cfunc.argtypes = [SessionHandle, FilterMode, FilterHandle, ctypes.POINTER(ctypes.c_char), EnumResourceHandle]  # noqa: F405
+                self._FindHardware_cfunc.restype = Status  # noqa: F405
+        return self._FindHardware_cfunc(sessionHandle, filterMode, filterHandle, expertNames, resourceEnumHandle)
+
+    def FindSystems(self, sessionHandle, deviceClass, detectOnlineSystems, cacheMode, findOutputMode, timeoutMsec, onlyInstallableSystems, systemEnumHandle):  # noqa: N802,N803
+        with self._func_lock:
+            if self._FindSystems_cfunc is None:
+                self._FindSystems_cfunc = self._library.windll.NISysCfgFindSystems
+                self._FindSystems_cfunc.argtypes = [SessionHandle, ctypes.POINTER(ctypes.c_char), Bool, IncludeCachedResults, SystemNameFormat, ctypes.c_uint, Bool, EnumSystemHandle]  # noqa: F405
+                self._FindSystems_cfunc.restype = Status  # noqa: F405
+        return self._FindSystems_cfunc(sessionHandle, deviceClass, detectOnlineSystems, cacheMode, findOutputMode, timeoutMsec, onlyInstallableSystems, systemEnumHandle)
+
+    def SelfTestHardware(self, resourceHandle, mode, detailedResult):  # noqa: N802,N803
+        with self._func_lock:
+            if self._SelfTestHardware_cfunc is None:
+                self._SelfTestHardware_cfunc = self._library.windll.NISysCfgSelfTestHardware
+                self._SelfTestHardware_cfunc.argtypes = [ResourceHandle, ctypes.c_uint, ctypes.POINTER(ctypes.POINTER(ctypes.c_char))]  # noqa: F405
+                self._SelfTestHardware_cfunc.restype = Status  # noqa: F405
+        return self._SelfTestHardware_cfunc(resourceHandle, mode, detailedResult)
+
+    def SelfCalibrateHardware(self, resourceHandle, detailedResult):  # noqa: N802,N803
+        with self._func_lock:
+            if self._SelfCalibrateHardware_cfunc is None:
+                self._SelfCalibrateHardware_cfunc = self._library.windll.NISysCfgSelfCalibrateHardware
+                self._SelfCalibrateHardware_cfunc.argtypes = [ResourceHandle, ctypes.POINTER(ctypes.POINTER(ctypes.c_char))]  # noqa: F405
+                self._SelfCalibrateHardware_cfunc.restype = Status  # noqa: F405
+        return self._SelfCalibrateHardware_cfunc(resourceHandle, detailedResult)
+
+    def ResetHardware(self, resourceHandle, mode):  # noqa: N802,N803
+        with self._func_lock:
+            if self._ResetHardware_cfunc is None:
+                self._ResetHardware_cfunc = self._library.windll.NISysCfgResetHardware
+                self._ResetHardware_cfunc.argtypes = [ResourceHandle, ctypes.c_uint]  # noqa: F405
+                self._ResetHardware_cfunc.restype = Status  # noqa: F405
+        return self._ResetHardware_cfunc(resourceHandle, mode)
+
+    def RenameResource(self, resourceHandle, newName, overwriteConflict, updateDependencies, nameAlreadyExisted, overwrittenResourceHandle):  # noqa: N802,N803
+        with self._func_lock:
+            if self._RenameResource_cfunc is None:
+                self._RenameResource_cfunc = self._library.windll.NISysCfgRenameResource
+                self._RenameResource_cfunc.argtypes = [ResourceHandle, ctypes.POINTER(ctypes.c_char), Bool, Bool, ctypes.POINTER(ctypes.c_int), ResourceHandle]  # noqa: F405
+                self._RenameResource_cfunc.restype = Status  # noqa: F405
+        return self._RenameResource_cfunc(resourceHandle, newName, overwriteConflict, updateDependencies, nameAlreadyExisted, overwrittenResourceHandle)
+
+    def DeleteResource(self, resourceHandle, mode, dependentItemsDeleted, detailedResult):  # noqa: N802,N803
+        with self._func_lock:
+            if self._DeleteResource_cfunc is None:
+                self._DeleteResource_cfunc = self._library.windll.NISysCfgDeleteResource
+                self._DeleteResource_cfunc.argtypes = [ResourceHandle, DeleteValidationMode, ctypes.POINTER(ctypes.c_int), ctypes.POINTER(ctypes.POINTER(ctypes.c_char))]  # noqa: F405
+                self._DeleteResource_cfunc.restype = Status  # noqa: F405
+        return self._DeleteResource_cfunc(resourceHandle, mode, dependentItemsDeleted, detailedResult)
+
+    def GetResourceProperty(self, resourceHandle, propertyID, value):  # noqa: N802,N803
+        with self._func_lock:
+            if self._GetResourceProperty_cfunc is None:
+                self._GetResourceProperty_cfunc = self._library.windll.NISysCfgGetResourceProperty
+                self._GetResourceProperty_cfunc.argtypes = [ResourceHandle, ctypes.c_uint, ctypes.c_void_p]  # noqa: F405
+                self._GetResourceProperty_cfunc.restype = Status  # noqa: F405
+        return self._GetResourceProperty_cfunc(resourceHandle, propertyID, value)
+
+    def SetResourceProperty(self, resourceHandle, propertyID, args):  # noqa: N802,N803
+        with self._func_lock:
+            if self._SetResourceProperty_cfunc is None:
+                self._SetResourceProperty_cfunc = self._library.cdll.NISysCfgSetResourceProperty
+                self._SetResourceProperty_cfunc.restype = Status  # noqa: F405
+        return self._SetResourceProperty_cfunc(resourceHandle, propertyID, args)
+
+    def SetResourcePropertyWithType(self, resourceHandle, propertyID, propertyType, args):  # noqa: N802,N803
+        with self._func_lock:
+            if self._SetResourcePropertyWithType_cfunc is None:
+                self._SetResourcePropertyWithType_cfunc = self._library.cdll.NISysCfgSetResourcePropertyWithType
+                self._SetResourcePropertyWithType_cfunc.restype = Status  # noqa: F405
+        return self._SetResourcePropertyWithType_cfunc(resourceHandle, propertyID, propertyType, args)
+
+    def SetResourcePropertyV(self, resourceHandle, propertyID, args):  # noqa: N802,N803
+        with self._func_lock:
+            if self._SetResourcePropertyV_cfunc is None:
+                self._SetResourcePropertyV_cfunc = self._library.windll.NISysCfgSetResourcePropertyV
+                self._SetResourcePropertyV_cfunc.restype = Status  # noqa: F405
+        return self._SetResourcePropertyV_cfunc(resourceHandle, propertyID, args)
+
+    def SetResourcePropertyWithTypeV(self, resourceHandle, propertyID, propertyType, args):  # noqa: N802,N803
+        with self._func_lock:
+            if self._SetResourcePropertyWithTypeV_cfunc is None:
+                self._SetResourcePropertyWithTypeV_cfunc = self._library.windll.NISysCfgSetResourcePropertyWithTypeV
+                self._SetResourcePropertyWithTypeV_cfunc.restype = Status  # noqa: F405
+        return self._SetResourcePropertyWithTypeV_cfunc(resourceHandle, propertyID, propertyType, args)
+
+    def GetResourceIndexedProperty(self, resourceHandle, propertyID, index, value):  # noqa: N802,N803
+        with self._func_lock:
+            if self._GetResourceIndexedProperty_cfunc is None:
+                self._GetResourceIndexedProperty_cfunc = self._library.windll.NISysCfgGetResourceIndexedProperty
+                self._GetResourceIndexedProperty_cfunc.argtypes = [ResourceHandle, ctypes.c_uint, ctypes.c_uint, ctypes.c_void_p]  # noqa: F405
+                self._GetResourceIndexedProperty_cfunc.restype = Status  # noqa: F405
+        return self._GetResourceIndexedProperty_cfunc(resourceHandle, propertyID, index, value)
+
+    def SaveResourceChanges(self, resourceHandle, changesRequireRestart, detailedResult):  # noqa: N802,N803
+        with self._func_lock:
+            if self._SaveResourceChanges_cfunc is None:
+                self._SaveResourceChanges_cfunc = self._library.windll.NISysCfgSaveResourceChanges
+                self._SaveResourceChanges_cfunc.argtypes = [ResourceHandle, ctypes.POINTER(ctypes.c_int), ctypes.POINTER(ctypes.POINTER(ctypes.c_char))]  # noqa: F405
+                self._SaveResourceChanges_cfunc.restype = Status  # noqa: F405
+        return self._SaveResourceChanges_cfunc(resourceHandle, changesRequireRestart, detailedResult)
+
+    def GetSystemProperty(self, sessionHandle, propertyID, value):  # noqa: N802,N803
+        with self._func_lock:
+            if self._GetSystemProperty_cfunc is None:
+                self._GetSystemProperty_cfunc = self._library.windll.NISysCfgGetSystemProperty
+                self._GetSystemProperty_cfunc.argtypes = [SessionHandle, ctypes.c_uint, ctypes.c_void_p]  # noqa: F405
+                self._GetSystemProperty_cfunc.restype = Status  # noqa: F405
+        return self._GetSystemProperty_cfunc(sessionHandle, propertyID, value)
+
+    def SetSystemProperty(self, sessionHandle, propertyID, args):  # noqa: N802,N803
+        with self._func_lock:
+            if self._SetSystemProperty_cfunc is None:
+                self._SetSystemProperty_cfunc = self._library.cdll.NISysCfgSetSystemProperty
+                self._SetSystemProperty_cfunc.restype = Status  # noqa: F405
+        return self._SetSystemProperty_cfunc(sessionHandle, propertyID, args)
+
+    def SetSystemPropertyV(self, sessionHandle, propertyID, args):  # noqa: N802,N803
+        with self._func_lock:
+            if self._SetSystemPropertyV_cfunc is None:
+                self._SetSystemPropertyV_cfunc = self._library.windll.NISysCfgSetSystemPropertyV
+                self._SetSystemPropertyV_cfunc.restype = Status  # noqa: F405
+        return self._SetSystemPropertyV_cfunc(sessionHandle, propertyID, args)
+
+    def SaveSystemChanges(self, sessionHandle, changesRequireRestart, detailedResult):  # noqa: N802,N803
+        with self._func_lock:
+            if self._SaveSystemChanges_cfunc is None:
+                self._SaveSystemChanges_cfunc = self._library.windll.NISysCfgSaveSystemChanges
+                self._SaveSystemChanges_cfunc.argtypes = [SessionHandle, ctypes.POINTER(ctypes.c_int), ctypes.POINTER(ctypes.POINTER(ctypes.c_char))]  # noqa: F405
+                self._SaveSystemChanges_cfunc.restype = Status  # noqa: F405
+        return self._SaveSystemChanges_cfunc(sessionHandle, changesRequireRestart, detailedResult)
+
+    def CreateFilter(self, sessionHandle, filterHandle):  # noqa: N802,N803
+        with self._func_lock:
+            if self._CreateFilter_cfunc is None:
+                self._CreateFilter_cfunc = self._library.windll.NISysCfgCreateFilter
+                self._CreateFilter_cfunc.argtypes = [SessionHandle, FilterHandle]  # noqa: F405
+                self._CreateFilter_cfunc.restype = Status  # noqa: F405
+        return self._CreateFilter_cfunc(sessionHandle, filterHandle)
+
+    def SetFilterProperty(self, filterHandle, propertyID, args):  # noqa: N802,N803
+        with self._func_lock:
+            if self._SetFilterProperty_cfunc is None:
+                self._SetFilterProperty_cfunc = self._library.cdll.NISysCfgSetFilterProperty
+                self._SetFilterProperty_cfunc.restype = Status  # noqa: F405
+        return self._SetFilterProperty_cfunc(filterHandle, propertyID, args)
+
+    def SetFilterPropertyWithType(self, filterHandle, propertyID, propertyType, args):  # noqa: N802,N803
+        with self._func_lock:
+            if self._SetFilterPropertyWithType_cfunc is None:
+                self._SetFilterPropertyWithType_cfunc = self._library.cdll.NISysCfgSetFilterPropertyWithType
+                self._SetFilterPropertyWithType_cfunc.restype = Status  # noqa: F405
+        return self._SetFilterPropertyWithType_cfunc(filterHandle, propertyID, propertyType, args)
+
+    def SetFilterPropertyV(self, filterHandle, propertyID, args):  # noqa: N802,N803
+        with self._func_lock:
+            if self._SetFilterPropertyV_cfunc is None:
+                self._SetFilterPropertyV_cfunc = self._library.windll.NISysCfgSetFilterPropertyV
+                self._SetFilterPropertyV_cfunc.restype = Status  # noqa: F405
+        return self._SetFilterPropertyV_cfunc(filterHandle, propertyID, args)
+
+    def SetFilterPropertyWithTypeV(self, filterHandle, propertyID, propertyType, args):  # noqa: N802,N803
+        with self._func_lock:
+            if self._SetFilterPropertyWithTypeV_cfunc is None:
+                self._SetFilterPropertyWithTypeV_cfunc = self._library.windll.NISysCfgSetFilterPropertyWithTypeV
+                self._SetFilterPropertyWithTypeV_cfunc.restype = Status  # noqa: F405
+        return self._SetFilterPropertyWithTypeV_cfunc(filterHandle, propertyID, propertyType, args)
+
+    def UpgradeFirmwareFromFile(self, resourceHandle, firmwareFile, autoStopTasks, alwaysOverwrite, waitForOperationToFinish, firmwareStatus, detailedResult):  # noqa: N802,N803
+        with self._func_lock:
+            if self._UpgradeFirmwareFromFile_cfunc is None:
+                self._UpgradeFirmwareFromFile_cfunc = self._library.windll.NISysCfgUpgradeFirmwareFromFile
+                self._UpgradeFirmwareFromFile_cfunc.argtypes = [ResourceHandle, ctypes.POINTER(ctypes.c_char), Bool, Bool, Bool, ctypes.POINTER(ctypes.c_int), ctypes.POINTER(ctypes.POINTER(ctypes.c_char))]  # noqa: F405
+                self._UpgradeFirmwareFromFile_cfunc.restype = Status  # noqa: F405
+        return self._UpgradeFirmwareFromFile_cfunc(resourceHandle, firmwareFile, autoStopTasks, alwaysOverwrite, waitForOperationToFinish, firmwareStatus, detailedResult)
+
+    def UpgradeFirmwareVersion(self, resourceHandle, firmwareVersion, autoStopTasks, alwaysOverwrite, waitForOperationToFinish, firmwareStatus, detailedResult):  # noqa: N802,N803
+        with self._func_lock:
+            if self._UpgradeFirmwareVersion_cfunc is None:
+                self._UpgradeFirmwareVersion_cfunc = self._library.windll.NISysCfgUpgradeFirmwareVersion
+                self._UpgradeFirmwareVersion_cfunc.argtypes = [ResourceHandle, ctypes.POINTER(ctypes.c_char), Bool, Bool, Bool, ctypes.POINTER(ctypes.c_int), ctypes.POINTER(ctypes.POINTER(ctypes.c_char))]  # noqa: F405
+                self._UpgradeFirmwareVersion_cfunc.restype = Status  # noqa: F405
+        return self._UpgradeFirmwareVersion_cfunc(resourceHandle, firmwareVersion, autoStopTasks, alwaysOverwrite, waitForOperationToFinish, firmwareStatus, detailedResult)
+
+    def EraseFirmware(self, resourceHandle, autoStopTasks, firmwareStatus, detailedResult):  # noqa: N802,N803
+        with self._func_lock:
+            if self._EraseFirmware_cfunc is None:
+                self._EraseFirmware_cfunc = self._library.windll.NISysCfgEraseFirmware
+                self._EraseFirmware_cfunc.argtypes = [ResourceHandle, Bool, ctypes.POINTER(ctypes.c_int), ctypes.POINTER(ctypes.POINTER(ctypes.c_char))]  # noqa: F405
+                self._EraseFirmware_cfunc.restype = Status  # noqa: F405
+        return self._EraseFirmware_cfunc(resourceHandle, autoStopTasks, firmwareStatus, detailedResult)
+
+    def CheckFirmwareStatus(self, resourceHandle, percentComplete, firmwareStatus, detailedResult):  # noqa: N802,N803
+        with self._func_lock:
+            if self._CheckFirmwareStatus_cfunc is None:
+                self._CheckFirmwareStatus_cfunc = self._library.windll.NISysCfgCheckFirmwareStatus
+                self._CheckFirmwareStatus_cfunc.argtypes = [ResourceHandle, ctypes.POINTER(ctypes.c_int), ctypes.POINTER(ctypes.c_int), ctypes.POINTER(ctypes.POINTER(ctypes.c_char))]  # noqa: F405
+                self._CheckFirmwareStatus_cfunc.restype = Status  # noqa: F405
+        return self._CheckFirmwareStatus_cfunc(resourceHandle, percentComplete, firmwareStatus, detailedResult)
+
+    def Format(self, sessionHandle, forceSafeMode, restartAfterFormat, fileSystem, networkSettings, timeoutMsec):  # noqa: N802,N803
+        with self._func_lock:
+            if self._Format_cfunc is None:
+                self._Format_cfunc = self._library.windll.NISysCfgFormat
+                self._Format_cfunc.argtypes = [SessionHandle, Bool, Bool, FileSystemMode, NetworkInterfaceSettings, ctypes.c_uint]  # noqa: F405
+                self._Format_cfunc.restype = Status  # noqa: F405
+        return self._Format_cfunc(sessionHandle, forceSafeMode, restartAfterFormat, fileSystem, networkSettings, timeoutMsec)
+
+    def FormatWithBaseSystemImage(self, sessionHandle, autoRestart, fileSystem, networkSettings, systemImageID, systemImageVersion, timeoutMsec):  # noqa: N802,N803
+        with self._func_lock:
+            if self._FormatWithBaseSystemImage_cfunc is None:
+                self._FormatWithBaseSystemImage_cfunc = self._library.windll.NISysCfgFormatWithBaseSystemImage
+                self._FormatWithBaseSystemImage_cfunc.argtypes = [SessionHandle, Bool, FileSystemMode, NetworkInterfaceSettings, ctypes.POINTER(ctypes.c_char), ctypes.POINTER(ctypes.c_char), ctypes.c_uint]  # noqa: F405
+                self._FormatWithBaseSystemImage_cfunc.restype = Status  # noqa: F405
+        return self._FormatWithBaseSystemImage_cfunc(sessionHandle, autoRestart, fileSystem, networkSettings, systemImageID, systemImageVersion, timeoutMsec)
+
+    def Restart(self, sessionHandle, waitForRestartToFinish, installMode, flushDNS, timeoutMsec, newIpAddress):  # noqa: N802,N803
+        with self._func_lock:
+            if self._Restart_cfunc is None:
+                self._Restart_cfunc = self._library.windll.NISysCfgRestart
+                self._Restart_cfunc.argtypes = [SessionHandle, Bool, Bool, Bool, ctypes.c_uint, ctypes.POINTER(ctypes.c_char)]  # noqa: F405
+                self._Restart_cfunc.restype = Status  # noqa: F405
+        return self._Restart_cfunc(sessionHandle, waitForRestartToFinish, installMode, flushDNS, timeoutMsec, newIpAddress)
+
+    def GetAvailableSoftwareComponents(self, sessionHandle, itemTypes, componentEnumHandle):  # noqa: N802,N803
+        with self._func_lock:
+            if self._GetAvailableSoftwareComponents_cfunc is None:
+                self._GetAvailableSoftwareComponents_cfunc = self._library.windll.NISysCfgGetAvailableSoftwareComponents
+                self._GetAvailableSoftwareComponents_cfunc.argtypes = [SessionHandle, IncludeComponentTypes, EnumSoftwareComponentHandle]  # noqa: F405
+                self._GetAvailableSoftwareComponents_cfunc.restype = Status  # noqa: F405
+        return self._GetAvailableSoftwareComponents_cfunc(sessionHandle, itemTypes, componentEnumHandle)
+
+    def GetAvailableSoftwareSets(self, sessionHandle, setEnumHandle):  # noqa: N802,N803
+        with self._func_lock:
+            if self._GetAvailableSoftwareSets_cfunc is None:
+                self._GetAvailableSoftwareSets_cfunc = self._library.windll.NISysCfgGetAvailableSoftwareSets
+                self._GetAvailableSoftwareSets_cfunc.argtypes = [SessionHandle, EnumSoftwareSetHandle]  # noqa: F405
+                self._GetAvailableSoftwareSets_cfunc.restype = Status  # noqa: F405
+        return self._GetAvailableSoftwareSets_cfunc(sessionHandle, setEnumHandle)
+
+    def GetFilteredSoftwareComponents(self, repositoryPath, deviceClass, operatingSystem, productID, itemTypes, componentEnumHandle):  # noqa: N802,N803
+        with self._func_lock:
+            if self._GetFilteredSoftwareComponents_cfunc is None:
+                self._GetFilteredSoftwareComponents_cfunc = self._library.windll.NISysCfgGetFilteredSoftwareComponents
+                self._GetFilteredSoftwareComponents_cfunc.argtypes = [ctypes.POINTER(ctypes.c_char), ctypes.POINTER(ctypes.c_char), ctypes.POINTER(ctypes.c_char), ctypes.c_uint, IncludeComponentTypes, EnumSoftwareComponentHandle]  # noqa: F405
+                self._GetFilteredSoftwareComponents_cfunc.restype = Status  # noqa: F405
+        return self._GetFilteredSoftwareComponents_cfunc(repositoryPath, deviceClass, operatingSystem, productID, itemTypes, componentEnumHandle)
+
+    def GetFilteredSoftwareSets(self, repositoryPath, deviceClass, operatingSystem, productID, setEnumHandle):  # noqa: N802,N803
+        with self._func_lock:
+            if self._GetFilteredSoftwareSets_cfunc is None:
+                self._GetFilteredSoftwareSets_cfunc = self._library.windll.NISysCfgGetFilteredSoftwareSets
+                self._GetFilteredSoftwareSets_cfunc.argtypes = [ctypes.POINTER(ctypes.c_char), ctypes.POINTER(ctypes.c_char), ctypes.POINTER(ctypes.c_char), ctypes.c_uint, EnumSoftwareSetHandle]  # noqa: F405
+                self._GetFilteredSoftwareSets_cfunc.restype = Status  # noqa: F405
+        return self._GetFilteredSoftwareSets_cfunc(repositoryPath, deviceClass, operatingSystem, productID, setEnumHandle)
+
+    def GetFilteredBaseSystemImages(self, repositoryPath, deviceClass, operatingSystem, productID, systemImageEnumHandle):  # noqa: N802,N803
+        with self._func_lock:
+            if self._GetFilteredBaseSystemImages_cfunc is None:
+                self._GetFilteredBaseSystemImages_cfunc = self._library.windll.NISysCfgGetFilteredBaseSystemImages
+                self._GetFilteredBaseSystemImages_cfunc.argtypes = [ctypes.POINTER(ctypes.c_char), ctypes.POINTER(ctypes.c_char), ctypes.POINTER(ctypes.c_char), ctypes.c_uint, EnumSoftwareComponentHandle]  # noqa: F405
+                self._GetFilteredBaseSystemImages_cfunc.restype = Status  # noqa: F405
+        return self._GetFilteredBaseSystemImages_cfunc(repositoryPath, deviceClass, operatingSystem, productID, systemImageEnumHandle)
+
+    def GetInstalledSoftwareComponents(self, sessionHandle, itemTypes, cached, componentEnumHandle):  # noqa: N802,N803
+        with self._func_lock:
+            if self._GetInstalledSoftwareComponents_cfunc is None:
+                self._GetInstalledSoftwareComponents_cfunc = self._library.windll.NISysCfgGetInstalledSoftwareComponents
+                self._GetInstalledSoftwareComponents_cfunc.argtypes = [SessionHandle, IncludeComponentTypes, Bool, EnumSoftwareComponentHandle]  # noqa: F405
+                self._GetInstalledSoftwareComponents_cfunc.restype = Status  # noqa: F405
+        return self._GetInstalledSoftwareComponents_cfunc(sessionHandle, itemTypes, cached, componentEnumHandle)
+
+    def GetInstalledSoftwareSet(self, sessionHandle, cached, setHandle):  # noqa: N802,N803
+        with self._func_lock:
+            if self._GetInstalledSoftwareSet_cfunc is None:
+                self._GetInstalledSoftwareSet_cfunc = self._library.windll.NISysCfgGetInstalledSoftwareSet
+                self._GetInstalledSoftwareSet_cfunc.argtypes = [SessionHandle, Bool, SoftwareSetHandle]  # noqa: F405
+                self._GetInstalledSoftwareSet_cfunc.restype = Status  # noqa: F405
+        return self._GetInstalledSoftwareSet_cfunc(sessionHandle, cached, setHandle)
+
+    def GetSystemImageAsFolder(self, sessionHandle, destinationFolder, encryptionPassphrase, overwriteIfExists, installedSoftwareOnly, autoRestart):  # noqa: N802,N803
+        with self._func_lock:
+            if self._GetSystemImageAsFolder_cfunc is None:
+                self._GetSystemImageAsFolder_cfunc = self._library.windll.NISysCfgGetSystemImageAsFolder
+                self._GetSystemImageAsFolder_cfunc.argtypes = [SessionHandle, ctypes.POINTER(ctypes.c_char), ctypes.POINTER(ctypes.c_char), Bool, Bool, Bool]  # noqa: F405
+                self._GetSystemImageAsFolder_cfunc.restype = Status  # noqa: F405
+        return self._GetSystemImageAsFolder_cfunc(sessionHandle, destinationFolder, encryptionPassphrase, overwriteIfExists, installedSoftwareOnly, autoRestart)
+
+    def GetSystemImageAsFolder2(self, sessionHandle, autoRestart, destinationFolder, encryptionPassphrase, numBlacklistEntries, blacklistFilesDirectories, overwriteIfExists, installedSoftwareOnly):  # noqa: N802,N803
+        with self._func_lock:
+            if self._GetSystemImageAsFolder2_cfunc is None:
+                self._GetSystemImageAsFolder2_cfunc = self._library.windll.NISysCfgGetSystemImageAsFolder2
+                self._GetSystemImageAsFolder2_cfunc.argtypes = [SessionHandle, Bool, ctypes.POINTER(ctypes.c_char), ctypes.POINTER(ctypes.c_char), ctypes.c_uint, ctypes.POINTER(ctypes.POINTER(ctypes.c_char)), Bool, Bool]  # noqa: F405
+                self._GetSystemImageAsFolder2_cfunc.restype = Status  # noqa: F405
+        return self._GetSystemImageAsFolder2_cfunc(sessionHandle, autoRestart, destinationFolder, encryptionPassphrase, numBlacklistEntries, blacklistFilesDirectories, overwriteIfExists, installedSoftwareOnly)
+
+    def CreateSystemImageAsFolder(self, sessionHandle, imageTitle, imageID, imageVersion, imageDescription, autoRestart, destinationFolder, encryptionPassphrase, numBlacklistEntries, blacklistFilesDirectories, overwriteIfExists):  # noqa: N802,N803
+        with self._func_lock:
+            if self._CreateSystemImageAsFolder_cfunc is None:
+                self._CreateSystemImageAsFolder_cfunc = self._library.windll.NISysCfgCreateSystemImageAsFolder
+                self._CreateSystemImageAsFolder_cfunc.argtypes = [SessionHandle, ctypes.POINTER(ctypes.c_char), ctypes.POINTER(ctypes.c_char), ctypes.POINTER(ctypes.c_char), ctypes.POINTER(ctypes.c_char), Bool, ctypes.POINTER(ctypes.c_char), ctypes.POINTER(ctypes.c_char), ctypes.c_uint, ctypes.POINTER(ctypes.POINTER(ctypes.c_char)), Bool]  # noqa: F405
+                self._CreateSystemImageAsFolder_cfunc.restype = Status  # noqa: F405
+        return self._CreateSystemImageAsFolder_cfunc(sessionHandle, imageTitle, imageID, imageVersion, imageDescription, autoRestart, destinationFolder, encryptionPassphrase, numBlacklistEntries, blacklistFilesDirectories, overwriteIfExists)
+
+    def SetSystemImageFromFolder(self, sessionHandle, sourceFolder, encryptionPassphrase, autoRestart, originalSystemOnly):  # noqa: N802,N803
+        with self._func_lock:
+            if self._SetSystemImageFromFolder_cfunc is None:
+                self._SetSystemImageFromFolder_cfunc = self._library.windll.NISysCfgSetSystemImageFromFolder
+                self._SetSystemImageFromFolder_cfunc.argtypes = [SessionHandle, ctypes.POINTER(ctypes.c_char), ctypes.POINTER(ctypes.c_char), Bool, Bool]  # noqa: F405
+                self._SetSystemImageFromFolder_cfunc.restype = Status  # noqa: F405
+        return self._SetSystemImageFromFolder_cfunc(sessionHandle, sourceFolder, encryptionPassphrase, autoRestart, originalSystemOnly)
+
+    def SetSystemImageFromFolder2(self, sessionHandle, autoRestart, sourceFolder, encryptionPassphrase, numBlacklistEntries, blacklistFilesDirectories, originalSystemOnly, networkSettings):  # noqa: N802,N803
+        with self._func_lock:
+            if self._SetSystemImageFromFolder2_cfunc is None:
+                self._SetSystemImageFromFolder2_cfunc = self._library.windll.NISysCfgSetSystemImageFromFolder2
+                self._SetSystemImageFromFolder2_cfunc.argtypes = [SessionHandle, Bool, ctypes.POINTER(ctypes.c_char), ctypes.POINTER(ctypes.c_char), ctypes.c_uint, ctypes.POINTER(ctypes.POINTER(ctypes.c_char)), Bool, NetworkInterfaceSettings]  # noqa: F405
+                self._SetSystemImageFromFolder2_cfunc.restype = Status  # noqa: F405
+        return self._SetSystemImageFromFolder2_cfunc(sessionHandle, autoRestart, sourceFolder, encryptionPassphrase, numBlacklistEntries, blacklistFilesDirectories, originalSystemOnly, networkSettings)
+
+    def InstallAll(self, sessionHandle, autoRestart, deselectConflicts, installedComponentEnumHandle, brokenDependencyEnumHandle):  # noqa: N802,N803
+        with self._func_lock:
+            if self._InstallAll_cfunc is None:
+                self._InstallAll_cfunc = self._library.windll.NISysCfgInstallAll
+                self._InstallAll_cfunc.argtypes = [SessionHandle, Bool, Bool, EnumSoftwareComponentHandle, EnumDependencyHandle]  # noqa: F405
+                self._InstallAll_cfunc.restype = Status  # noqa: F405
+        return self._InstallAll_cfunc(sessionHandle, autoRestart, deselectConflicts, installedComponentEnumHandle, brokenDependencyEnumHandle)
+
+    def InstallUninstallComponents(self, sessionHandle, autoRestart, autoSelectDependencies, componentToInstallEnumHandle, numComponentsToUninstall, componentIDsToUninstall, brokenDependencyEnumHandle):  # noqa: N802,N803
+        with self._func_lock:
+            if self._InstallUninstallComponents_cfunc is None:
+                self._InstallUninstallComponents_cfunc = self._library.windll.NISysCfgInstallUninstallComponents
+                self._InstallUninstallComponents_cfunc.argtypes = [SessionHandle, Bool, Bool, EnumSoftwareComponentHandle, ctypes.c_uint, ctypes.POINTER(ctypes.POINTER(ctypes.c_char)), EnumDependencyHandle]  # noqa: F405
+                self._InstallUninstallComponents_cfunc.restype = Status  # noqa: F405
+        return self._InstallUninstallComponents_cfunc(sessionHandle, autoRestart, autoSelectDependencies, componentToInstallEnumHandle, numComponentsToUninstall, componentIDsToUninstall, brokenDependencyEnumHandle)
+
+    def InstallUninstallComponents2(self, sessionHandle, autoRestart, autoSelectDependencies, autoSelectRecommends, componentToInstallEnumHandle, numComponentsToUninstall, componentIDsToUninstall, brokenDependencyEnumHandle):  # noqa: N802,N803
+        with self._func_lock:
+            if self._InstallUninstallComponents2_cfunc is None:
+                self._InstallUninstallComponents2_cfunc = self._library.windll.NISysCfgInstallUninstallComponents2
+                self._InstallUninstallComponents2_cfunc.argtypes = [SessionHandle, Bool, Bool, Bool, EnumSoftwareComponentHandle, ctypes.c_uint, ctypes.POINTER(ctypes.POINTER(ctypes.c_char)), EnumDependencyHandle]  # noqa: F405
+                self._InstallUninstallComponents2_cfunc.restype = Status  # noqa: F405
+        return self._InstallUninstallComponents2_cfunc(sessionHandle, autoRestart, autoSelectDependencies, autoSelectRecommends, componentToInstallEnumHandle, numComponentsToUninstall, componentIDsToUninstall, brokenDependencyEnumHandle)
+
+    def InstallSoftwareSet(self, sessionHandle, autoRestart, softwareSetID, version, addonEnumHandle, brokenDependencyEnumHandle):  # noqa: N802,N803
+        with self._func_lock:
+            if self._InstallSoftwareSet_cfunc is None:
+                self._InstallSoftwareSet_cfunc = self._library.windll.NISysCfgInstallSoftwareSet
+                self._InstallSoftwareSet_cfunc.argtypes = [SessionHandle, Bool, ctypes.POINTER(ctypes.c_char), ctypes.POINTER(ctypes.c_char), EnumSoftwareComponentHandle, EnumDependencyHandle]  # noqa: F405
+                self._InstallSoftwareSet_cfunc.restype = Status  # noqa: F405
+        return self._InstallSoftwareSet_cfunc(sessionHandle, autoRestart, softwareSetID, version, addonEnumHandle, brokenDependencyEnumHandle)
+
+    def InstallStartup(self, sessionHandle, autoRestart, startupEnumHandle, uninstallConflicts, installedComponentEnumHandle, uninstalledComponentEnumHandle, brokenDependencyEnumHandle):  # noqa: N802,N803
+        with self._func_lock:
+            if self._InstallStartup_cfunc is None:
+                self._InstallStartup_cfunc = self._library.windll.NISysCfgInstallStartup
+                self._InstallStartup_cfunc.argtypes = [SessionHandle, Bool, EnumSoftwareComponentHandle, Bool, EnumSoftwareComponentHandle, EnumSoftwareComponentHandle, EnumDependencyHandle]  # noqa: F405
+                self._InstallStartup_cfunc.restype = Status  # noqa: F405
+        return self._InstallStartup_cfunc(sessionHandle, autoRestart, startupEnumHandle, uninstallConflicts, installedComponentEnumHandle, uninstalledComponentEnumHandle, brokenDependencyEnumHandle)
+
+    def UninstallAll(self, sessionHandle, autoRestart):  # noqa: N802,N803
+        with self._func_lock:
+            if self._UninstallAll_cfunc is None:
+                self._UninstallAll_cfunc = self._library.windll.NISysCfgUninstallAll
+                self._UninstallAll_cfunc.argtypes = [SessionHandle, Bool]  # noqa: F405
+                self._UninstallAll_cfunc.restype = Status  # noqa: F405
+        return self._UninstallAll_cfunc(sessionHandle, autoRestart)
+
+    def GetSoftwareFeeds(self, sessionHandle, feedEnumHandle):  # noqa: N802,N803
+        with self._func_lock:
+            if self._GetSoftwareFeeds_cfunc is None:
+                self._GetSoftwareFeeds_cfunc = self._library.windll.NISysCfgGetSoftwareFeeds
+                self._GetSoftwareFeeds_cfunc.argtypes = [SessionHandle, EnumSoftwareFeedHandle]  # noqa: F405
+                self._GetSoftwareFeeds_cfunc.restype = Status  # noqa: F405
+        return self._GetSoftwareFeeds_cfunc(sessionHandle, feedEnumHandle)
+
+    def AddSoftwareFeed(self, sessionHandle, feedName, uri, enabled, trusted):  # noqa: N802,N803
+        with self._func_lock:
+            if self._AddSoftwareFeed_cfunc is None:
+                self._AddSoftwareFeed_cfunc = self._library.windll.NISysCfgAddSoftwareFeed
+                self._AddSoftwareFeed_cfunc.argtypes = [SessionHandle, ctypes.POINTER(ctypes.c_char), ctypes.POINTER(ctypes.c_char), Bool, Bool]  # noqa: F405
+                self._AddSoftwareFeed_cfunc.restype = Status  # noqa: F405
+        return self._AddSoftwareFeed_cfunc(sessionHandle, feedName, uri, enabled, trusted)
+
+    def ModifySoftwareFeed(self, sessionHandle, feedName, newFeedName, uri, enabled, trusted):  # noqa: N802,N803
+        with self._func_lock:
+            if self._ModifySoftwareFeed_cfunc is None:
+                self._ModifySoftwareFeed_cfunc = self._library.windll.NISysCfgModifySoftwareFeed
+                self._ModifySoftwareFeed_cfunc.argtypes = [SessionHandle, ctypes.POINTER(ctypes.c_char), ctypes.POINTER(ctypes.c_char), ctypes.POINTER(ctypes.c_char), Bool, Bool]  # noqa: F405
+                self._ModifySoftwareFeed_cfunc.restype = Status  # noqa: F405
+        return self._ModifySoftwareFeed_cfunc(sessionHandle, feedName, newFeedName, uri, enabled, trusted)
+
+    def RemoveSoftwareFeed(self, sessionHandle, feedName):  # noqa: N802,N803
+        with self._func_lock:
+            if self._RemoveSoftwareFeed_cfunc is None:
+                self._RemoveSoftwareFeed_cfunc = self._library.windll.NISysCfgRemoveSoftwareFeed
+                self._RemoveSoftwareFeed_cfunc.argtypes = [SessionHandle, ctypes.POINTER(ctypes.c_char)]  # noqa: F405
+                self._RemoveSoftwareFeed_cfunc.restype = Status  # noqa: F405
+        return self._RemoveSoftwareFeed_cfunc(sessionHandle, feedName)
+
+    def ChangeAdministratorPassword(self, sessionHandle, newPassword):  # noqa: N802,N803
+        with self._func_lock:
+            if self._ChangeAdministratorPassword_cfunc is None:
+                self._ChangeAdministratorPassword_cfunc = self._library.windll.NISysCfgChangeAdministratorPassword
+                self._ChangeAdministratorPassword_cfunc.argtypes = [SessionHandle, ctypes.POINTER(ctypes.c_char)]  # noqa: F405
+                self._ChangeAdministratorPassword_cfunc.restype = Status  # noqa: F405
+        return self._ChangeAdministratorPassword_cfunc(sessionHandle, newPassword)
+
+    def ExportConfiguration(self, sessionHandle, destinationFile, expertNames, overwriteIfExists):  # noqa: N802,N803
+        with self._func_lock:
+            if self._ExportConfiguration_cfunc is None:
+                self._ExportConfiguration_cfunc = self._library.windll.NISysCfgExportConfiguration
+                self._ExportConfiguration_cfunc.argtypes = [SessionHandle, ctypes.POINTER(ctypes.c_char), ctypes.POINTER(ctypes.c_char), Bool]  # noqa: F405
+                self._ExportConfiguration_cfunc.restype = Status  # noqa: F405
+        return self._ExportConfiguration_cfunc(sessionHandle, destinationFile, expertNames, overwriteIfExists)
+
+    def ImportConfiguration(self, sessionHandle, sourceFile, expertNames, importMode, detailedResult):  # noqa: N802,N803
+        with self._func_lock:
+            if self._ImportConfiguration_cfunc is None:
+                self._ImportConfiguration_cfunc = self._library.windll.NISysCfgImportConfiguration
+                self._ImportConfiguration_cfunc.argtypes = [SessionHandle, ctypes.POINTER(ctypes.c_char), ctypes.POINTER(ctypes.c_char), ImportMode, ctypes.POINTER(ctypes.POINTER(ctypes.c_char))]  # noqa: F405
+                self._ImportConfiguration_cfunc.restype = Status  # noqa: F405
+        return self._ImportConfiguration_cfunc(sessionHandle, sourceFile, expertNames, importMode, detailedResult)
+
+    def GenerateMAXReport(self, sessionHandle, outputFilename, reportType, overwriteIfExists):  # noqa: N802,N803
+        with self._func_lock:
+            if self._GenerateMAXReport_cfunc is None:
+                self._GenerateMAXReport_cfunc = self._library.windll.NISysCfgGenerateMAXReport
+                self._GenerateMAXReport_cfunc.argtypes = [SessionHandle, ctypes.POINTER(ctypes.c_char), ReportType, Bool]  # noqa: F405
+                self._GenerateMAXReport_cfunc.restype = Status  # noqa: F405
+        return self._GenerateMAXReport_cfunc(sessionHandle, outputFilename, reportType, overwriteIfExists)
+
+    def CreateComponentsEnum(self, componentEnumHandle):  # noqa: N802,N803
+        with self._func_lock:
+            if self._CreateComponentsEnum_cfunc is None:
+                self._CreateComponentsEnum_cfunc = self._library.windll.NISysCfgCreateComponentsEnum
+                self._CreateComponentsEnum_cfunc.argtypes = [EnumSoftwareComponentHandle]  # noqa: F405
+                self._CreateComponentsEnum_cfunc.restype = Status  # noqa: F405
+        return self._CreateComponentsEnum_cfunc(componentEnumHandle)
+
+    def AddComponentToEnum(self, componentEnumHandle, ID, version, mode):  # noqa: N802,N803
+        with self._func_lock:
+            if self._AddComponentToEnum_cfunc is None:
+                self._AddComponentToEnum_cfunc = self._library.windll.NISysCfgAddComponentToEnum
+                self._AddComponentToEnum_cfunc.argtypes = [EnumSoftwareComponentHandle, ctypes.POINTER(ctypes.c_char), ctypes.POINTER(ctypes.c_char), VersionSelectionMode]  # noqa: F405
+                self._AddComponentToEnum_cfunc.restype = Status  # noqa: F405
+        return self._AddComponentToEnum_cfunc(componentEnumHandle, ID, version, mode)
+
+    def FreeDetailedString(self, str):  # noqa: N802,N803
+        with self._func_lock:
+            if self._FreeDetailedString_cfunc is None:
+                self._FreeDetailedString_cfunc = self._library.windll.NISysCfgFreeDetailedString
+                self._FreeDetailedString_cfunc.argtypes = [ctypes.POINTER(ctypes.c_char)]  # noqa: F405
+                self._FreeDetailedString_cfunc.restype = Status  # noqa: F405
+        return self._FreeDetailedString_cfunc(str)
+
+    def NextResource(self, sessionHandle, resourceEnumHandle, resourceHandle):  # noqa: N802,N803
+        with self._func_lock:
+            if self._NextResource_cfunc is None:
+                self._NextResource_cfunc = self._library.windll.NISysCfgNextResource
+                self._NextResource_cfunc.argtypes = [SessionHandle, EnumResourceHandle, ResourceHandle]  # noqa: F405
+                self._NextResource_cfunc.restype = Status  # noqa: F405
+        return self._NextResource_cfunc(sessionHandle, resourceEnumHandle, resourceHandle)
+
+    def NextSystemInfo(self, systemEnumHandle, system):  # noqa: N802,N803
+        with self._func_lock:
+            if self._NextSystemInfo_cfunc is None:
+                self._NextSystemInfo_cfunc = self._library.windll.NISysCfgNextSystemInfo
+                self._NextSystemInfo_cfunc.argtypes = [EnumSystemHandle, ctypes.POINTER(ctypes.c_char)]  # noqa: F405
+                self._NextSystemInfo_cfunc.restype = Status  # noqa: F405
+        return self._NextSystemInfo_cfunc(systemEnumHandle, system)
+
+    def NextExpertInfo(self, expertEnumHandle, expertName, displayName, version):  # noqa: N802,N803
+        with self._func_lock:
+            if self._NextExpertInfo_cfunc is None:
+                self._NextExpertInfo_cfunc = self._library.windll.NISysCfgNextExpertInfo
+                self._NextExpertInfo_cfunc.argtypes = [EnumExpertHandle, ctypes.POINTER(ctypes.c_char), ctypes.POINTER(ctypes.c_char), ctypes.POINTER(ctypes.c_char)]  # noqa: F405
+                self._NextExpertInfo_cfunc.restype = Status  # noqa: F405
+        return self._NextExpertInfo_cfunc(expertEnumHandle, expertName, displayName, version)
+
+    def NextComponentInfo(self, componentEnumHandle, ID, version, title, itemType, detailedDescription):  # noqa: N802,N803
+        with self._func_lock:
+            if self._NextComponentInfo_cfunc is None:
+                self._NextComponentInfo_cfunc = self._library.windll.NISysCfgNextComponentInfo
+                self._NextComponentInfo_cfunc.argtypes = [EnumSoftwareComponentHandle, ctypes.POINTER(ctypes.c_char), ctypes.POINTER(ctypes.c_char), ctypes.POINTER(ctypes.c_char), ctypes.POINTER(ctypes.c_int), ctypes.POINTER(ctypes.POINTER(ctypes.c_char))]  # noqa: F405
+                self._NextComponentInfo_cfunc.restype = Status  # noqa: F405
+        return self._NextComponentInfo_cfunc(componentEnumHandle, ID, version, title, itemType, detailedDescription)
+
+    def NextSoftwareSet(self, setEnumHandle, setHandle):  # noqa: N802,N803
+        with self._func_lock:
+            if self._NextSoftwareSet_cfunc is None:
+                self._NextSoftwareSet_cfunc = self._library.windll.NISysCfgNextSoftwareSet
+                self._NextSoftwareSet_cfunc.argtypes = [EnumSoftwareSetHandle, SoftwareSetHandle]  # noqa: F405
+                self._NextSoftwareSet_cfunc.restype = Status  # noqa: F405
+        return self._NextSoftwareSet_cfunc(setEnumHandle, setHandle)
+
+    def GetSoftwareSetInfo(self, setHandle, itemTypes, includeAddOnDeps, ID, version, title, setType, detailedDescription, addOnEnumHandle, itemEnumHandle):  # noqa: N802,N803
+        with self._func_lock:
+            if self._GetSoftwareSetInfo_cfunc is None:
+                self._GetSoftwareSetInfo_cfunc = self._library.windll.NISysCfgGetSoftwareSetInfo
+                self._GetSoftwareSetInfo_cfunc.argtypes = [SoftwareSetHandle, IncludeComponentTypes, Bool, ctypes.POINTER(ctypes.c_char), ctypes.POINTER(ctypes.c_char), ctypes.POINTER(ctypes.c_char), ctypes.POINTER(ctypes.c_int), ctypes.POINTER(ctypes.POINTER(ctypes.c_char)), EnumSoftwareComponentHandle, EnumSoftwareComponentHandle]  # noqa: F405
+                self._GetSoftwareSetInfo_cfunc.restype = Status  # noqa: F405
+        return self._GetSoftwareSetInfo_cfunc(setHandle, itemTypes, includeAddOnDeps, ID, version, title, setType, detailedDescription, addOnEnumHandle, itemEnumHandle)
+
+    def NextDependencyInfo(self, dependencyEnumHandle, dependerID, dependerVersion, dependerTitle, dependerDetailedDescription, dependeeID, dependeeVersion, dependeeTitle, dependeeDetailedDescription):  # noqa: N802,N803
+        with self._func_lock:
+            if self._NextDependencyInfo_cfunc is None:
+                self._NextDependencyInfo_cfunc = self._library.windll.NISysCfgNextDependencyInfo
+                self._NextDependencyInfo_cfunc.argtypes = [EnumDependencyHandle, ctypes.POINTER(ctypes.c_char), ctypes.POINTER(ctypes.c_char), ctypes.POINTER(ctypes.c_char), ctypes.POINTER(ctypes.POINTER(ctypes.c_char)), ctypes.POINTER(ctypes.c_char), ctypes.POINTER(ctypes.c_char), ctypes.POINTER(ctypes.c_char), ctypes.POINTER(ctypes.POINTER(ctypes.c_char))]  # noqa: F405
+                self._NextDependencyInfo_cfunc.restype = Status  # noqa: F405
+        return self._NextDependencyInfo_cfunc(dependencyEnumHandle, dependerID, dependerVersion, dependerTitle, dependerDetailedDescription, dependeeID, dependeeVersion, dependeeTitle, dependeeDetailedDescription)
+
+    def NextSoftwareFeed(self, feedEnumHandle, feedName, uri, enabled, trusted):  # noqa: N802,N803
+        with self._func_lock:
+            if self._NextSoftwareFeed_cfunc is None:
+                self._NextSoftwareFeed_cfunc = self._library.windll.NISysCfgNextSoftwareFeed
+                self._NextSoftwareFeed_cfunc.argtypes = [EnumSoftwareFeedHandle, ctypes.POINTER(ctypes.c_char), ctypes.POINTER(ctypes.c_char), ctypes.POINTER(ctypes.c_int), ctypes.POINTER(ctypes.c_int)]  # noqa: F405
+                self._NextSoftwareFeed_cfunc.restype = Status  # noqa: F405
+        return self._NextSoftwareFeed_cfunc(feedEnumHandle, feedName, uri, enabled, trusted)
+
+    def ResetEnumeratorGetCount(self, enumHandle, count):  # noqa: N802,N803
+        with self._func_lock:
+            if self._ResetEnumeratorGetCount_cfunc is None:
+                self._ResetEnumeratorGetCount_cfunc = self._library.windll.NISysCfgResetEnumeratorGetCount
+                self._ResetEnumeratorGetCount_cfunc.argtypes = [ctypes.c_void_p, ctypes.POINTER(ctypes.c_uint)]  # noqa: F405
+                self._ResetEnumeratorGetCount_cfunc.restype = Status  # noqa: F405
+        return self._ResetEnumeratorGetCount_cfunc(enumHandle, count)
+
+    def GetStatusDescription(self, sessionHandle, status, detailedDescription):  # noqa: N802,N803
+        with self._func_lock:
+            if self._GetStatusDescription_cfunc is None:
+                self._GetStatusDescription_cfunc = self._library.windll.NISysCfgGetStatusDescription
+                self._GetStatusDescription_cfunc.argtypes = [SessionHandle, Status, ctypes.POINTER(ctypes.POINTER(ctypes.c_char))]  # noqa: F405
+                self._GetStatusDescription_cfunc.restype = Status  # noqa: F405
+        return self._GetStatusDescription_cfunc(sessionHandle, status, detailedDescription)
+
+    def TimestampFromValues(self, secondsSinceEpoch1970, fractionalSeconds, timestamp):  # noqa: N802,N803
+        with self._func_lock:
+            if self._TimestampFromValues_cfunc is None:
+                self._TimestampFromValues_cfunc = self._library.windll.NISysCfgTimestampFromValues
+                self._TimestampFromValues_cfunc.argtypes = [UInt64, ctypes.c_double, ctypes.POINTER(TimestampUTC)]  # noqa: F405
+                self._TimestampFromValues_cfunc.restype = Status  # noqa: F405
+        return self._TimestampFromValues_cfunc(secondsSinceEpoch1970, fractionalSeconds, timestamp)
+
+    def ValuesFromTimestamp(self, timestamp, secondsSinceEpoch1970, fractionalSeconds):  # noqa: N802,N803
+        with self._func_lock:
+            if self._ValuesFromTimestamp_cfunc is None:
+                self._ValuesFromTimestamp_cfunc = self._library.windll.NISysCfgValuesFromTimestamp
+                self._ValuesFromTimestamp_cfunc.argtypes = [TimestampUTC, ctypes.POINTER(UInt64), ctypes.POINTER(ctypes.c_double)]  # noqa: F405
+                self._ValuesFromTimestamp_cfunc.restype = Status  # noqa: F405
+        return self._ValuesFromTimestamp_cfunc(timestamp, secondsSinceEpoch1970, fractionalSeconds)
```

## nisyscfg/_library_singleton.py

 * *Ordering differences only*

```diff
@@ -1,69 +1,69 @@
-import ctypes
-import platform
-import threading
-
-from nisyscfg import _library
-from nisyscfg import errors
-
-
-class CTypesLibrary(object):
-    def __init__(self, cdll, windll=None):
-        self._cdll = cdll
-        self._windll = windll
-        if self._windll is None:
-            self._windll = self._cdll
-
-    @property
-    def cdll(self):
-        return self._cdll
-
-    @property
-    def windll(self):
-        return self._windll
-
-
-_instance = None
-_instance_lock = threading.Lock()
-_library_info = {
-    "Linux": {"64bit": {"name": "libnisyscfg.so", "type": "cdll"}},
-    "Windows": {
-        "32bit": {"name": "nisyscfg.dll", "type": "dual"},
-        "64bit": {"name": "nisyscfg.dll", "type": "cdll"},
-    },
-}
-
-
-def _get_library_name():
-    try:
-        return _library_info[platform.system()][platform.architecture()[0]]["name"]
-    except KeyError:
-        raise errors.UnsupportedPlatformError
-
-
-def _get_library_type():
-    try:
-        return _library_info[platform.system()][platform.architecture()[0]]["type"]
-    except KeyError:
-        raise errors.UnsupportedPlatformError
-
-
-def get():
-    global _instance
-    global _instance_lock
-
-    with _instance_lock:
-        if _instance is None:
-            try:
-                library_type = _get_library_type()
-                if library_type == "dual":
-                    ctypes_library = CTypesLibrary(
-                        ctypes.CDLL(_get_library_name()),
-                        ctypes.WinDLL(_get_library_name()),
-                    )
-                else:
-                    assert library_type == "cdll"
-                    ctypes_library = CTypesLibrary(ctypes.CDLL(_get_library_name()))
-            except OSError:
-                raise errors.LibraryNotInstalledError()
-            _instance = _library.Library(ctypes_library)
-    return _instance
+import ctypes
+import platform
+import threading
+
+from nisyscfg import _library
+from nisyscfg import errors
+
+
+class CTypesLibrary(object):
+    def __init__(self, cdll, windll=None):
+        self._cdll = cdll
+        self._windll = windll
+        if self._windll is None:
+            self._windll = self._cdll
+
+    @property
+    def cdll(self):
+        return self._cdll
+
+    @property
+    def windll(self):
+        return self._windll
+
+
+_instance = None
+_instance_lock = threading.Lock()
+_library_info = {
+    "Linux": {"64bit": {"name": "libnisyscfg.so", "type": "cdll"}},
+    "Windows": {
+        "32bit": {"name": "nisyscfg.dll", "type": "dual"},
+        "64bit": {"name": "nisyscfg.dll", "type": "cdll"},
+    },
+}
+
+
+def _get_library_name():
+    try:
+        return _library_info[platform.system()][platform.architecture()[0]]["name"]
+    except KeyError:
+        raise errors.UnsupportedPlatformError
+
+
+def _get_library_type():
+    try:
+        return _library_info[platform.system()][platform.architecture()[0]]["type"]
+    except KeyError:
+        raise errors.UnsupportedPlatformError
+
+
+def get():
+    global _instance
+    global _instance_lock
+
+    with _instance_lock:
+        if _instance is None:
+            try:
+                library_type = _get_library_type()
+                if library_type == "dual":
+                    ctypes_library = CTypesLibrary(
+                        ctypes.CDLL(_get_library_name()),
+                        ctypes.WinDLL(_get_library_name()),
+                    )
+                else:
+                    assert library_type == "cdll"
+                    ctypes_library = CTypesLibrary(ctypes.CDLL(_get_library_name()))
+            except OSError:
+                raise errors.LibraryNotInstalledError()
+            _instance = _library.Library(ctypes_library)
+    return _instance
```

## nisyscfg/component_info.py

 * *Ordering differences only*

```diff
@@ -1,109 +1,109 @@
-import ctypes
-import nisyscfg.enums
-import nisyscfg.errors
-import typing
-
-from nisyscfg._lib import c_string_decode
-from nisyscfg._lib import c_string_encode
-
-
-ComponentInfo = typing.NamedTuple(
-    "ComponentInfo",
-    [
-        ("id", str),
-        ("version", str),
-        ("title", str),
-        ("type", str),
-        ("details", str),
-    ],
-)
-
-
-class ComponentInfoIterator(object):
-    def __init__(self, handle):
-        self._handle = handle
-        self._library = nisyscfg._library_singleton.get()
-
-    def __del__(self):
-        self.close()
-
-    def __iter__(self):
-        return self
-
-    def __next__(self) -> ComponentInfo:
-        if not self._handle:
-            raise StopIteration()
-        id = nisyscfg.types.simple_string()
-        version = nisyscfg.types.simple_string()
-        title = nisyscfg.types.simple_string()
-        item_type = nisyscfg.types.ctypes.c_int()
-        c_details = ctypes.POINTER(ctypes.c_char)()
-        error_code = self._library.NextComponentInfo(
-            self._handle, id, version, title, ctypes.pointer(item_type), c_details
-        )
-        if error_code == nisyscfg.errors.Status.END_OF_ENUM:
-            raise StopIteration()
-        nisyscfg.errors.handle_error(self, error_code)
-
-        if c_details:
-            details = c_string_decode(ctypes.cast(c_details, ctypes.c_char_p).value)
-            error_code = self._library.FreeDetailedString(c_details)
-            nisyscfg.errors.handle_error(self, error_code)
-        else:
-            details = None
-
-        return ComponentInfo(
-            id=c_string_decode(id.value),
-            version=c_string_decode(version.value),
-            title=c_string_decode(title.value),
-            type=nisyscfg.enums.ComponentType(item_type.value),
-            details=details,
-        )
-
-    def close(self) -> None:
-        if self._handle:
-            error_code = self._library.CloseHandle(self._handle)
-            nisyscfg.errors.handle_error(self, error_code)
-            self._handle = None
-
-
-class EnumSoftwareComponent(object):
-    def __init__(self):
-        self._handle = nisyscfg.types.EnumSoftwareComponentHandle()
-        self._library = nisyscfg._library_singleton.get()
-        error_code = self._library.CreateComponentsEnum(ctypes.pointer(self._handle))
-        nisyscfg.errors.handle_error(self, error_code)
-
-    def __del__(self):
-        self.close()
-
-    def close(self) -> None:
-        if self._handle:
-            error_code = self._library.CloseHandle(self._handle)
-            nisyscfg.errors.handle_error(self, error_code)
-            self._handle = None
-
-    def add_component(
-        self,
-        id: str,
-        version: str = "",
-        mode: nisyscfg.enums.VersionSelectionMode = nisyscfg.enums.VersionSelectionMode.HIGHEST,
-    ) -> None:
-        """
-        Adds a software component
-
-        id - ID of the software component to be added to the enumeration.
-
-        version - Desired version of the software component being added to the
-        enumeration. This field is optional as long as the version selection
-        mode is set to Highest.
-
-        mode - Choose whether an exact version or the highest version of the
-        software component specified by id should be added to the enumeration.
-
-        Raises an nisyscfg.errors.LibraryError exception in the event of an error.
-        """
-        error_code = self._library.AddComponentToEnum(
-            self._handle, c_string_encode(id), c_string_encode(version), mode
-        )
-        nisyscfg.errors.handle_error(self, error_code)
+import ctypes
+import nisyscfg.enums
+import nisyscfg.errors
+import typing
+
+from nisyscfg._lib import c_string_decode
+from nisyscfg._lib import c_string_encode
+
+
+ComponentInfo = typing.NamedTuple(
+    "ComponentInfo",
+    [
+        ("id", str),
+        ("version", str),
+        ("title", str),
+        ("type", str),
+        ("details", str),
+    ],
+)
+
+
+class ComponentInfoIterator(object):
+    def __init__(self, handle):
+        self._handle = handle
+        self._library = nisyscfg._library_singleton.get()
+
+    def __del__(self):
+        self.close()
+
+    def __iter__(self):
+        return self
+
+    def __next__(self) -> ComponentInfo:
+        if not self._handle:
+            raise StopIteration()
+        id = nisyscfg.types.simple_string()
+        version = nisyscfg.types.simple_string()
+        title = nisyscfg.types.simple_string()
+        item_type = nisyscfg.types.ctypes.c_int()
+        c_details = ctypes.POINTER(ctypes.c_char)()
+        error_code = self._library.NextComponentInfo(
+            self._handle, id, version, title, ctypes.pointer(item_type), c_details
+        )
+        if error_code == nisyscfg.errors.Status.END_OF_ENUM:
+            raise StopIteration()
+        nisyscfg.errors.handle_error(self, error_code)
+
+        if c_details:
+            details = c_string_decode(ctypes.cast(c_details, ctypes.c_char_p).value)
+            error_code = self._library.FreeDetailedString(c_details)
+            nisyscfg.errors.handle_error(self, error_code)
+        else:
+            details = None
+
+        return ComponentInfo(
+            id=c_string_decode(id.value),
+            version=c_string_decode(version.value),
+            title=c_string_decode(title.value),
+            type=nisyscfg.enums.ComponentType(item_type.value),
+            details=details,
+        )
+
+    def close(self) -> None:
+        if self._handle:
+            error_code = self._library.CloseHandle(self._handle)
+            nisyscfg.errors.handle_error(self, error_code)
+            self._handle = None
+
+
+class EnumSoftwareComponent(object):
+    def __init__(self):
+        self._handle = nisyscfg.types.EnumSoftwareComponentHandle()
+        self._library = nisyscfg._library_singleton.get()
+        error_code = self._library.CreateComponentsEnum(ctypes.pointer(self._handle))
+        nisyscfg.errors.handle_error(self, error_code)
+
+    def __del__(self):
+        self.close()
+
+    def close(self) -> None:
+        if self._handle:
+            error_code = self._library.CloseHandle(self._handle)
+            nisyscfg.errors.handle_error(self, error_code)
+            self._handle = None
+
+    def add_component(
+        self,
+        id: str,
+        version: str = "",
+        mode: nisyscfg.enums.VersionSelectionMode = nisyscfg.enums.VersionSelectionMode.HIGHEST,
+    ) -> None:
+        """
+        Adds a software component
+
+        id - ID of the software component to be added to the enumeration.
+
+        version - Desired version of the software component being added to the
+        enumeration. This field is optional as long as the version selection
+        mode is set to Highest.
+
+        mode - Choose whether an exact version or the highest version of the
+        software component specified by id should be added to the enumeration.
+
+        Raises an nisyscfg.errors.LibraryError exception in the event of an error.
+        """
+        error_code = self._library.AddComponentToEnum(
+            self._handle, c_string_encode(id), c_string_encode(version), mode
+        )
+        nisyscfg.errors.handle_error(self, error_code)
```

## nisyscfg/dependency_info.py

 * *Ordering differences only*

```diff
@@ -1,96 +1,96 @@
-import ctypes
-import nisyscfg.component_info
-import nisyscfg.enums
-import nisyscfg.errors
-import typing
-
-from nisyscfg._lib import c_string_decode
-
-DependencyInfo = typing.NamedTuple(
-    "DependencyInfo",
-    [
-        ("depender", nisyscfg.component_info.ComponentInfo),
-        ("dependee", nisyscfg.component_info.ComponentInfo),
-    ],
-)
-
-
-class DependencyInfoIterator(object):
-    def __init__(self, handle):
-        self._handle = handle
-        self._library = nisyscfg._library_singleton.get()
-
-    def __del__(self):
-        self.close()
-
-    def __iter__(self):
-        return self
-
-    def __next__(self) -> DependencyInfo:
-        if not self._handle:
-            raise StopIteration()
-        depender_id = nisyscfg.types.simple_string()
-        depender_version = nisyscfg.types.simple_string()
-        depender_title = nisyscfg.types.simple_string()
-        c_depender_detailed_description = ctypes.POINTER(ctypes.c_char)()
-
-        dependee_id = nisyscfg.types.simple_string()
-        dependee_version = nisyscfg.types.simple_string()
-        dependee_title = nisyscfg.types.simple_string()
-        c_dependee_detailed_description = ctypes.POINTER(ctypes.c_char)()
-
-        error_code = self._library.NextDependencyInfo(
-            self._handle,
-            depender_id,
-            depender_version,
-            depender_title,
-            ctypes.pointer(c_depender_detailed_description),
-            dependee_id,
-            dependee_version,
-            dependee_title,
-            ctypes.pointer(c_dependee_detailed_description),
-        )
-        if error_code == nisyscfg.errors.Status.END_OF_ENUM:
-            raise StopIteration()
-        nisyscfg.errors.handle_error(self, error_code)
-
-        if c_depender_detailed_description:
-            depender_detailed_description = c_string_decode(
-                ctypes.cast(c_depender_detailed_description, ctypes.c_char_p).value
-            )
-            error_code = self._library.FreeDetailedString(c_depender_detailed_description)
-            nisyscfg.errors.handle_error(self, error_code)
-        else:
-            depender_detailed_description = ""
-
-        if c_dependee_detailed_description:
-            dependee_detailed_description = c_string_decode(
-                ctypes.cast(c_dependee_detailed_description, ctypes.c_char_p).value
-            )
-            error_code = self._library.FreeDetailedString(c_dependee_detailed_description)
-            nisyscfg.errors.handle_error(self, error_code)
-        else:
-            dependee_detailed_description = ""
-
-        return DependencyInfo(
-            depender=nisyscfg.component_info.ComponentInfo(
-                id=c_string_decode(depender_id),
-                version=c_string_decode(depender_version),
-                title=c_string_decode(depender_title),
-                type=nisyscfg.enums.ComponentType.UNKNOWN,
-                details=depender_detailed_description,
-            ),
-            dependee=nisyscfg.component_info.ComponentInfo(
-                id=c_string_decode(dependee_id),
-                version=c_string_decode(dependee_version),
-                title=c_string_decode(dependee_title),
-                type=nisyscfg.enums.ComponentType.UNKNOWN,
-                details=dependee_detailed_description,
-            ),
-        )
-
-    def close(self) -> None:
-        if self._handle:
-            error_code = self._library.CloseHandle(self._handle)
-            nisyscfg.errors.handle_error(self, error_code)
-            self._handle = None
+import ctypes
+import nisyscfg.component_info
+import nisyscfg.enums
+import nisyscfg.errors
+import typing
+
+from nisyscfg._lib import c_string_decode
+
+DependencyInfo = typing.NamedTuple(
+    "DependencyInfo",
+    [
+        ("depender", nisyscfg.component_info.ComponentInfo),
+        ("dependee", nisyscfg.component_info.ComponentInfo),
+    ],
+)
+
+
+class DependencyInfoIterator(object):
+    def __init__(self, handle):
+        self._handle = handle
+        self._library = nisyscfg._library_singleton.get()
+
+    def __del__(self):
+        self.close()
+
+    def __iter__(self):
+        return self
+
+    def __next__(self) -> DependencyInfo:
+        if not self._handle:
+            raise StopIteration()
+        depender_id = nisyscfg.types.simple_string()
+        depender_version = nisyscfg.types.simple_string()
+        depender_title = nisyscfg.types.simple_string()
+        c_depender_detailed_description = ctypes.POINTER(ctypes.c_char)()
+
+        dependee_id = nisyscfg.types.simple_string()
+        dependee_version = nisyscfg.types.simple_string()
+        dependee_title = nisyscfg.types.simple_string()
+        c_dependee_detailed_description = ctypes.POINTER(ctypes.c_char)()
+
+        error_code = self._library.NextDependencyInfo(
+            self._handle,
+            depender_id,
+            depender_version,
+            depender_title,
+            ctypes.pointer(c_depender_detailed_description),
+            dependee_id,
+            dependee_version,
+            dependee_title,
+            ctypes.pointer(c_dependee_detailed_description),
+        )
+        if error_code == nisyscfg.errors.Status.END_OF_ENUM:
+            raise StopIteration()
+        nisyscfg.errors.handle_error(self, error_code)
+
+        if c_depender_detailed_description:
+            depender_detailed_description = c_string_decode(
+                ctypes.cast(c_depender_detailed_description, ctypes.c_char_p).value
+            )
+            error_code = self._library.FreeDetailedString(c_depender_detailed_description)
+            nisyscfg.errors.handle_error(self, error_code)
+        else:
+            depender_detailed_description = ""
+
+        if c_dependee_detailed_description:
+            dependee_detailed_description = c_string_decode(
+                ctypes.cast(c_dependee_detailed_description, ctypes.c_char_p).value
+            )
+            error_code = self._library.FreeDetailedString(c_dependee_detailed_description)
+            nisyscfg.errors.handle_error(self, error_code)
+        else:
+            dependee_detailed_description = ""
+
+        return DependencyInfo(
+            depender=nisyscfg.component_info.ComponentInfo(
+                id=c_string_decode(depender_id),
+                version=c_string_decode(depender_version),
+                title=c_string_decode(depender_title),
+                type=nisyscfg.enums.ComponentType.UNKNOWN,
+                details=depender_detailed_description,
+            ),
+            dependee=nisyscfg.component_info.ComponentInfo(
+                id=c_string_decode(dependee_id),
+                version=c_string_decode(dependee_version),
+                title=c_string_decode(dependee_title),
+                type=nisyscfg.enums.ComponentType.UNKNOWN,
+                details=dependee_detailed_description,
+            ),
+        )
+
+    def close(self) -> None:
+        if self._handle:
+            error_code = self._library.CloseHandle(self._handle)
+            nisyscfg.errors.handle_error(self, error_code)
+            self._handle = None
```

## nisyscfg/enums.py

```diff
@@ -1,276 +1,282 @@
-# This file is code generated
-
-from enum import IntEnum
-
-
-class BaseEnum(IntEnum):
-    @classmethod
-    def from_param(cls, obj):
-        return int(obj)
-
-
-class IncludeCachedResults(BaseEnum):
-    NONE = 0
-    ONLY_IF_ONLINE = 1
-    ALL = 3
-
-
-class SystemNameFormat(BaseEnum):
-    HOSTNAME = 16
-    HOSTNAME_IP = 18
-    HOSTNAME_MAC = 19
-    IP = 32
-    IP_HOSTNAME = 33
-    IP_MAC = 35
-    MAC = 48
-    MAC_HOSTNAME = 49
-    MAC_IP = 50
-
-
-class FileSystemMode(BaseEnum):
-    DEFAULT = 0
-    FAT = 1
-    RELIANCE = 2
-    UBIFS = 16384
-    EXT4 = 32768
-
-
-class NetworkInterfaceSettings(BaseEnum):
-    RESET_PRIMARY_RESET_OTHERS = 0
-    PRESERVE_PRIMARY_RESET_OTHERS = 1
-    PRESERVE_PRIMARY_PRESERVE_OTHERS = 2
-    PRESERVE_PRIMARY_APPLY_OTHERS = 3
-    APPLY_PRIMARY_RESET_OTHERS = 4
-    APPLY_PRIMARY_PRESERVE_OTHERS = 5
-    APPLY_PRIMARY_APPLY_OTHERS = 6
-
-
-class ComponentType(BaseEnum):
-    STANDARD = 0
-    HIDDEN = 1
-    SYSTEM = 2
-    UNKNOWN = 3
-    STARTUP = 4
-    IMAGE = 5
-    ESSENTIAL = 6
-
-
-class IncludeComponentTypes(BaseEnum):
-    ALL_VISIBLE = 0
-    ALL_VISIBLE_AND_HIDDEN = 1
-    ONLY_STANDARD = 2
-    ONLY_STARTUP = 3
-
-
-class VersionSelectionMode(BaseEnum):
-    HIGHEST = 0
-    EXACT = 1
-
-
-class ImportMode(BaseEnum):
-    MERGE_ITEMS = 0
-    DELETE_CONFIG_FIRST = 1048576
-    PRESERVE_CONFLICT_ITEMS = 2097152
-
-
-class ReportType(BaseEnum):
-    XML = 0
-    HTML = 1
-    TECHNICAL_SUPPORT_ZIP = 2
-
-
-class BusType(BaseEnum):
-    BUILT_IN = 0
-    PCI_PXI = 1
-    USB = 2
-    GPIB = 3
-    VXI = 4
-    SERIAL = 5
-    TCP_IP = 6
-    COMPACT_RIO = 7
-    SCXI = 8
-    COMPACT_DAQ = 9
-    SWITCH_BLOCK = 10
-    SCC = 11
-    FIRE_WIRE = 12
-    ACCESSORY = 13
-    CAN = 14
-    SWITCH_BLOCK_DEVICE = 15
-
-
-class HasDriverType(BaseEnum):
-    UNKNOWN = -1
-    NOT_INSTALLED = 0
-    INSTALLED = 1
-
-
-class IsPresentType(BaseEnum):
-    INITIALIZING = -2
-    UNKNOWN = -1
-    NOT_PRESENT = 0
-    PRESENT = 1
-
-
-class IpAddressMode(BaseEnum):
-    STATIC = 1
-    DHCP_OR_LINK_LOCAL = 2
-    LINK_LOCAL_ONLY = 4
-    DHCP_ONLY = 8
-
-
-class Bool(BaseEnum):
-    FALSE = 0
-    TRUE = 1
-
-
-class Locale(BaseEnum):
-    DEFAULT = 0
-    CHINESE_SIMPLIFIED = 2052
-    ENGLISH = 1033
-    FRENCH = 1036
-    GERMAN = 1031
-    JAPANESE = 1041
-    KOREAN = 1042
-
-
-class FilterMode(BaseEnum):
-    MATCH_VALUES_ALL = 1
-    MATCH_VALUES_ANY = 2
-    MATCH_VALUES_NONE = 3
-    ALL_PROPERTIES_EXIST = 4
-
-
-class ServiceType(BaseEnum):
-    MDNS_NI_TCP = 0
-    MDNS_NI_REALTIME = 1
-    MDNS_NI_SYSAPI = 2
-    MDNS_NI_HTTP = 3
-    LOCAL_SYSTEM = 4
-    LOCAL_NET_INTERFACE = 5
-    LOCAL_TIME_KEEPER = 6
-    LOCAL_TIME_SOURCE = 7
-    MDNS_LXI = 8
-    LOCAL_FPGA = 9
-
-
-class AdapterType(BaseEnum):
-    ETHERNET = 1
-    WLAN = 2
-
-
-class AdapterMode(BaseEnum):
-    DISABLED = 1
-    TCP_IP_ETHERNET = 2
-    DETERMINISTIC = 4
-    ETHER_CAT = 8
-    TCP_IP_WLAN = 32
-    TCP_IP_ACCESS_POINT = 64
-
-
-class LinkSpeed(BaseEnum):
-    NONE = 0
-    AUTO = 1
-    TEN_MEGABIT_HALF = 2
-    TEN_MEGABIT_FULL = 4
-    HUNDRED_MEGABIT_HALF = 8
-    HUNDRED_MEGABIT_FULL = 16
-    GIGABIT_HALF = 32
-    GIGABIT_FULL = 64
-    WLAN80211A = 131072
-    WLAN80211B = 262144
-    WLAN80211G = 524288
-    WLAN80211N = 1048576
-    WLAN80211N_5GHZ = 2097152
-
-
-class PacketDetection(BaseEnum):
-    NONE = 0
-    LINE_INTERRUPT = 1
-    POLLING = 2
-    SIGNALED_INTERRUPT = 4
-
-
-class ConnectionType(BaseEnum):
-    NONE = 0
-    INFRASTRUCTURE = 1
-    AD_HOC = 2
-
-
-class SecurityType(BaseEnum):
-    NONE = 0
-    NOT_SUPPORTED = 1
-    OPEN = 2
-    WEP = 4
-    WPA_PSK = 8
-    WPA_EAP = 16
-    WPA2_PSK = 32
-    WPA2_EAP = 64
-
-
-class EapType(BaseEnum):
-    NONE = 0
-    EAP_TLS = 1
-    EAP_TTLS = 2
-    EAP_FAST = 4
-    LEAP = 8
-    PEAP = 16
-
-
-class FirmwareStatus(BaseEnum):
-    READY_PENDING_AUTO_RESTART = -4
-    VERIFYING_NEW_IMAGE = -3
-    WRITING_FLASHING_NEW_IMAGE = -2
-    UPDATE_MODE_WAITING_FOR_IMAGE = -1
-    CORRUPT_CANNOT_RUN = 0
-    NONE_INSTALLED = 1
-    INSTALLED_NORMAL_OPERATION = 2
-    READY_PENDING_USER_RESTART = 3
-    READY_PENDING_USER_ACTION = 4
-    UPDATE_ATTEMPT_FAILED = 5
-
-
-class DeleteValidationMode(BaseEnum):
-    VALIDATE_BUT_DO_NOT_DELETE = -1
-    DELETE_IF_NO_DEPENDENCIES_EXIST = 0
-    DELETE_ITEM_AND_ANY_DEPENDENCIES = 1
-    DELETE_ITEM_BUT_KEEP_DEPENDENCIES = 2
-
-
-class AccessType(BaseEnum):
-    LOCAL_ONLY = 0
-    LOCAL_AND_REMOTE = 1
-
-
-class LedState(BaseEnum):
-    OFF = 0
-    SOLID_GREEN = 1
-    SOLID_YELLOW = 2
-    BLINKING_GREEN = 4
-    BLINKING_YELLOW = 8
-
-
-class SwitchState(BaseEnum):
-    DISABLED = 0
-    ENABLED = 1
-
-
-class FirmwareUpdateMode(BaseEnum):
-    NONE = 0
-    MANUAL = 1
-    DRIVER_MANAGED = 2
-
-
-class ModuleProgramMode(BaseEnum):
-    NONE = 0
-    REALTIME_CPU = 1
-    REALTIME_SCAN = 2
-    LABVIEW_FPGA = 4
-
-
-class PropertyType(BaseEnum):
-    BOOL = 1
-    INT = 2
-    UNSIGNED_INT = 3
-    DOUBLE = 4
-    STRING = 6
-    TIMESTAMP = 7
+# This file is code generated
+
+from enum import IntEnum, IntFlag
+
+
+class BaseEnum(IntEnum):
+    @classmethod
+    def from_param(cls, obj):
+        return int(obj)
+
+
+class BaseFlag(IntFlag):
+    @classmethod
+    def from_param(cls, obj):
+        return int(obj)
+
+
+class IncludeCachedResults(BaseEnum):
+    NONE = 0
+    ONLY_IF_ONLINE = 1
+    ALL = 3
+
+
+class SystemNameFormat(BaseEnum):
+    HOSTNAME = 16
+    HOSTNAME_IP = 18
+    HOSTNAME_MAC = 19
+    IP = 32
+    IP_HOSTNAME = 33
+    IP_MAC = 35
+    MAC = 48
+    MAC_HOSTNAME = 49
+    MAC_IP = 50
+
+
+class FileSystemMode(BaseEnum):
+    DEFAULT = 0
+    FAT = 1
+    RELIANCE = 2
+    UBIFS = 16384
+    EXT4 = 32768
+
+
+class NetworkInterfaceSettings(BaseEnum):
+    RESET_PRIMARY_RESET_OTHERS = 0
+    PRESERVE_PRIMARY_RESET_OTHERS = 1
+    PRESERVE_PRIMARY_PRESERVE_OTHERS = 2
+    PRESERVE_PRIMARY_APPLY_OTHERS = 3
+    APPLY_PRIMARY_RESET_OTHERS = 4
+    APPLY_PRIMARY_PRESERVE_OTHERS = 5
+    APPLY_PRIMARY_APPLY_OTHERS = 6
+
+
+class ComponentType(BaseEnum):
+    STANDARD = 0
+    HIDDEN = 1
+    SYSTEM = 2
+    UNKNOWN = 3
+    STARTUP = 4
+    IMAGE = 5
+    ESSENTIAL = 6
+
+
+class IncludeComponentTypes(BaseEnum):
+    ALL_VISIBLE = 0
+    ALL_VISIBLE_AND_HIDDEN = 1
+    ONLY_STANDARD = 2
+    ONLY_STARTUP = 3
+
+
+class VersionSelectionMode(BaseEnum):
+    HIGHEST = 0
+    EXACT = 1
+
+
+class ImportMode(BaseEnum):
+    MERGE_ITEMS = 0
+    DELETE_CONFIG_FIRST = 1048576
+    PRESERVE_CONFLICT_ITEMS = 2097152
+
+
+class ReportType(BaseEnum):
+    XML = 0
+    HTML = 1
+    TECHNICAL_SUPPORT_ZIP = 2
+
+
+class BusType(BaseEnum):
+    BUILT_IN = 0
+    PCI_PXI = 1
+    USB = 2
+    GPIB = 3
+    VXI = 4
+    SERIAL = 5
+    TCP_IP = 6
+    COMPACT_RIO = 7
+    SCXI = 8
+    COMPACT_DAQ = 9
+    SWITCH_BLOCK = 10
+    SCC = 11
+    FIRE_WIRE = 12
+    ACCESSORY = 13
+    CAN = 14
+    SWITCH_BLOCK_DEVICE = 15
+
+
+class HasDriverType(BaseEnum):
+    UNKNOWN = -1
+    NOT_INSTALLED = 0
+    INSTALLED = 1
+
+
+class IsPresentType(BaseEnum):
+    INITIALIZING = -2
+    UNKNOWN = -1
+    NOT_PRESENT = 0
+    PRESENT = 1
+
+
+class IpAddressMode(BaseEnum):
+    STATIC = 1
+    DHCP_OR_LINK_LOCAL = 2
+    LINK_LOCAL_ONLY = 4
+    DHCP_ONLY = 8
+
+
+class Bool(BaseEnum):
+    FALSE = 0
+    TRUE = 1
+
+
+class Locale(BaseEnum):
+    DEFAULT = 0
+    CHINESE_SIMPLIFIED = 2052
+    ENGLISH = 1033
+    FRENCH = 1036
+    GERMAN = 1031
+    JAPANESE = 1041
+    KOREAN = 1042
+
+
+class FilterMode(BaseEnum):
+    MATCH_VALUES_ALL = 1
+    MATCH_VALUES_ANY = 2
+    MATCH_VALUES_NONE = 3
+    ALL_PROPERTIES_EXIST = 4
+
+
+class ServiceType(BaseEnum):
+    MDNS_NI_TCP = 0
+    MDNS_NI_REALTIME = 1
+    MDNS_NI_SYSAPI = 2
+    MDNS_NI_HTTP = 3
+    LOCAL_SYSTEM = 4
+    LOCAL_NET_INTERFACE = 5
+    LOCAL_TIME_KEEPER = 6
+    LOCAL_TIME_SOURCE = 7
+    MDNS_LXI = 8
+    LOCAL_FPGA = 9
+
+
+class AdapterType(BaseEnum):
+    ETHERNET = 1
+    WLAN = 2
+
+
+class AdapterMode(BaseEnum):
+    DISABLED = 1
+    TCP_IP_ETHERNET = 2
+    DETERMINISTIC = 4
+    ETHER_CAT = 8
+    TCP_IP_WLAN = 32
+    TCP_IP_ACCESS_POINT = 64
+
+
+class LinkSpeed(BaseEnum):
+    NONE = 0
+    AUTO = 1
+    TEN_MEGABIT_HALF = 2
+    TEN_MEGABIT_FULL = 4
+    HUNDRED_MEGABIT_HALF = 8
+    HUNDRED_MEGABIT_FULL = 16
+    GIGABIT_HALF = 32
+    GIGABIT_FULL = 64
+    WLAN80211A = 131072
+    WLAN80211B = 262144
+    WLAN80211G = 524288
+    WLAN80211N = 1048576
+    WLAN80211N_5GHZ = 2097152
+
+
+class PacketDetection(BaseEnum):
+    NONE = 0
+    LINE_INTERRUPT = 1
+    POLLING = 2
+    SIGNALED_INTERRUPT = 4
+
+
+class ConnectionType(BaseEnum):
+    NONE = 0
+    INFRASTRUCTURE = 1
+    AD_HOC = 2
+
+
+class SecurityType(BaseEnum):
+    NONE = 0
+    NOT_SUPPORTED = 1
+    OPEN = 2
+    WEP = 4
+    WPA_PSK = 8
+    WPA_EAP = 16
+    WPA2_PSK = 32
+    WPA2_EAP = 64
+
+
+class EapType(BaseEnum):
+    NONE = 0
+    EAP_TLS = 1
+    EAP_TTLS = 2
+    EAP_FAST = 4
+    LEAP = 8
+    PEAP = 16
+
+
+class FirmwareStatus(BaseEnum):
+    READY_PENDING_AUTO_RESTART = -4
+    VERIFYING_NEW_IMAGE = -3
+    WRITING_FLASHING_NEW_IMAGE = -2
+    UPDATE_MODE_WAITING_FOR_IMAGE = -1
+    CORRUPT_CANNOT_RUN = 0
+    NONE_INSTALLED = 1
+    INSTALLED_NORMAL_OPERATION = 2
+    READY_PENDING_USER_RESTART = 3
+    READY_PENDING_USER_ACTION = 4
+    UPDATE_ATTEMPT_FAILED = 5
+
+
+class DeleteValidationMode(BaseEnum):
+    VALIDATE_BUT_DO_NOT_DELETE = -1
+    DELETE_IF_NO_DEPENDENCIES_EXIST = 0
+    DELETE_ITEM_AND_ANY_DEPENDENCIES = 1
+    DELETE_ITEM_BUT_KEEP_DEPENDENCIES = 2
+
+
+class AccessType(BaseEnum):
+    LOCAL_ONLY = 0
+    LOCAL_AND_REMOTE = 1
+
+
+class LedState(BaseEnum):
+    OFF = 0
+    SOLID_GREEN = 1
+    SOLID_YELLOW = 2
+    BLINKING_GREEN = 4
+    BLINKING_YELLOW = 8
+
+
+class SwitchState(BaseEnum):
+    DISABLED = 0
+    ENABLED = 1
+
+
+class FirmwareUpdateMode(BaseEnum):
+    NONE = 0
+    MANUAL = 1
+    DRIVER_MANAGED = 2
+
+
+class ModuleProgramMode(BaseEnum):
+    NONE = 0
+    REALTIME_CPU = 1
+    REALTIME_SCAN = 2
+    LABVIEW_FPGA = 4
+
+
+class PropertyType(BaseEnum):
+    BOOL = 1
+    INT = 2
+    UNSIGNED_INT = 3
+    DOUBLE = 4
+    STRING = 6
+    TIMESTAMP = 7
```

## nisyscfg/errors.py

 * *Ordering differences only*

```diff
@@ -1,283 +1,283 @@
-# This file is code generated
-
-import platform
-import warnings
-
-from nisyscfg.enums import BaseEnum
-
-
-def _is_success(code):
-    return code == 0
-
-
-def _is_error(code):
-    return code < 0
-
-
-def _is_warning(code):
-    return code > 0
-
-
-class Error(Exception):
-    def __init__(self, message):
-        super(Error, self).__init__(message)
-
-
-class LibraryError(Error):
-    def __init__(self, code, description):
-        assert _is_error(code), "Should not raise Error if code is not fatal."
-        self.code = code
-        self.description = description
-        if self.description:
-            message = str(self.code) + ": " + self.description
-        else:
-            message = str(self.code) + ":"
-        super(LibraryError, self).__init__(message)
-
-
-class LibraryWarning(Warning):
-    def __init__(self, code, description):
-        assert _is_warning(code), "Should not create Warning if code is not positive."
-        self.code = code
-        self.description = description
-        if self.description:
-            message = "Warning {0}: {1}".format(str(self.code), self.description)
-        else:
-            message = "Warning {0}:".format(str(self.code))
-        super(LibraryWarning, self).__init__(message)
-
-
-class UnsupportedPlatformError(Error):
-    def __init__(self):
-        super(UnsupportedPlatformError, self).__init__(
-            "Platform is unsupported: " + platform.architecture()[0] + " " + platform.system()
-        )
-
-
-class LibraryNotInstalledError(Error):
-    def __init__(self):
-        super(LibraryNotInstalledError, self).__init__(
-            "The NI System Configuration runtime could not be loaded. Make sure"
-            " it is installed and its bitness matches that of your Python"
-            " interpreter. Please visit http://www.ni.com/downloads/drivers/ to"
-            " download and install it."
-        )
-
-
-def handle_error(session, code, ignore_warnings=False, is_error_handling=False):
-    if _is_success(code) or (_is_warning(code) and ignore_warnings):
-        return
-
-    try:
-        status = Status(code)
-        # Only lookup descriptions for nisyscfg status codes
-        if is_error_handling:
-            # The caller is in the midst of error handling and an error occurred.
-            # Don't try to get the description or we'll start recursing until the stack overflows.
-            description = ""
-        else:
-            description = session._get_status_description(code)
-    except Exception:
-        status = code
-        description = ""
-
-    if _is_error(code):
-        raise LibraryError(status, description)
-
-    assert _is_warning(code)
-    warnings.warn(LibraryWarning(status, description))
-
-
-warnings.filterwarnings("always", category=LibraryWarning)
-
-
-class Status(BaseEnum):
-    OK = 0
-    END_OF_ENUM = 1
-    SELF_TEST_BASIC_ONLY = 263024
-    FOUND_CACHED_OFFLINE_SYSTEM = 263168
-    RESTART_LOCALHOST_INITIATED = 263169
-    CHANGED_PROPERTY_NOT_SAVED = 263170
-    NOT_IMPLEMENTED = -2147467263
-    NULL_POINTER = -2147467261
-    FAIL = -2147467259
-    UNEXPECTED = -2147418113
-    OUT_OF_MEMORY = -2147024882
-    INVALID_ARG = -2147024809
-    OPERATION_TIMED_OUT = -2147220448
-    FILE_NOT_FOUND = -2147220322
-    INVALID_MAC_FORMAT = -2147220278
-    PROP_MISMATCH = -2147220624
-    PROP_DOES_NOT_EXIST = -2147220623
-    URI_ILLEGAL_SYNTAX = -2147220622
-    URI_TARGET_DOES_NOT_EXIST = -2147220621
-    URI_EXPERT_DOES_NOT_EXIST = -2147220620
-    ITEM_DOES_NOT_EXIST = -2147220619
-    INVALID_MODE = -2147220618
-    SYS_CONFIG_API_NOT_INSTALLED = -2147220616
-    NAME_SYNTAX_ILLEGAL = -2147220614
-    NAME_COLLISION = -2147220613
-    NO_PROP_VALIDATED = -2147220612
-    URI_UNAUTHORIZED = -2147220611
-    RENAME_RESOURCE_DEPENDENCIES = -2147220610
-    VALUE_INVALID = -2147220609
-    VALUES_INCONSISTENT = -2147220608
-    CANCELED = -2147220607
-    RESPONSE_SYNTAX = -2147220606
-    RESOURCE_IS_NOT_PRESENT = -2147220605
-    RESOURCE_IS_SIMULATED = -2147220604
-    NOT_IN_FIRMWARE_UPDATE_STATE = -2147220603
-    FIRMWARE_IMAGE_DEVICE_MISMATCH = -2147220602
-    FIRMWARE_IMAGE_CORRUPT = -2147220601
-    INVALID_FIRMWARE_VERSION = -2147220600
-    OLDER_FIRMWARE_VERSION = -2147220599
-    INVALID_LOGIN_CREDENTIALS = -2147220598
-    FIRMWARE_UPDATE_ATTEMPT_FAILED = -2147220597
-    ENCRYPTION_FAILED = -2147220596
-    SOME_PROPS_NOT_VALIDATED = -2147220595
-    INVALID_CALIBRATION_CREDENTIALS = -2147220594
-    CANNOT_DELETE_PRESENT_RESOURCE = -2147220593
-    URI_TARGET_TRANSMIT_ERROR = -2147220592
-    DECRYPTION_FAILED = -2147220591
-    FIRMWARE_EXPERT_VERSION_MISMATCH = -2147220590
-    AMBIGUOUS_IMPORT_ACTION = -2147220589
-    REQUIRED_ITEM_FAILED_IMPORT = -2147220588
-    ITEM_IN_USE = -2147220587
-    ITEM_TYPE_NOT_SUPPORTED = -2147220586
-    PERMISSION_DENIED = -2147220560
-    SYSTEM_NOT_FOUND = -2147220559
-    TRANSFORM_FAILED = -2147220558
-    NOT_INSTALLED = -2147220557
-    LAUNCH_FAILURE = -2147220556
-    INTERNAL_TIMEOUT = -2147220555
-    MISSING_TRANSFORM = -2147220554
-    INCORRECT_EXTENSION = -2147220553
-    FILE_READ_ONLY = -2147220552
-    REPORT_OVERWRITE = -2147220551
-    DIRECTORY_ERROR = -2147220550
-    CANNOT_OPEN_FILE = -2147220480
-    INSUFFICIENT_PERMISSIONS = -2147220479
-    NCE_COPIER_FAILED = -2147220478
-    FILE_OPERATION_FAILED = -2147220477
-    NAME_COLLISION_ERROR = -2147220476
-    UNEXPECTED_ERROR = -2147220475
-    NCE_NO_STREAM_ERROR = -2147220474
-    NCE_COMPRESSION_ERROR = -2147220473
-    NCE_STREAM_READ_ERROR = -2147220472
-    NCE_STREAM_WRITE_ERROR = -2147220471
-    NCE_STREAM_SEEK_ERROR = -2147220470
-    NCE_REPO_NOT_READY = -2147220469
-    NCE_REPO_INVALID = -2147220468
-    NCE_REPO_INCOMPAT = -2147220467
-    NCE_NO_IMPORT_STORAGE = -2147220466
-    NCE_NO_EXPORT_STORAGE = -2147220465
-    NCE_NO_OBJ_COPIER = -2147220464
-    COPY_IN_PROGRESS = -2147220463
-    FILE_NOT_RECOGNIZED = -2147220462
-    SYSTEM_NOT_SUPPORTED = -2147220461
-    SYSTEM_NOT_REACHABLE = -2147220460
-    PRODUCT_SOFTWARE_NOT_INSTALLED = -2147220459
-    PRODUCT_SOFTWARE_TOO_OLD = -2147220458
-    PRODUCT_SOFTWARE_TOO_NEW = -2147220457
-    DATA_TOO_OLD = -2147220456
-    DATA_TOO_NEW = -2147220455
-    NO_ITEMS_TO_COPY = -2147220454
-    ORPHAN_ITEMS = -2147220453
-    DIRTY_ITEMS = -2147220452
-    FILE_OVERWRITE = -2147220451
-    ITEM_OVERWRITE = -2147220450
-    MISSING_DEPENDENCY = -2147220449
-    OPERATION_CANCELED = -2147220447
-    WARNING_CONFLICTS = -2147220446
-    ERROR_CONFLICTS = -2147220445
-    ITEMS_REQUIRE_USER_INPUT = -2147220444
-    PRODUCT_EXPERT_NOT_READY = -2147220443
-    ORPHAN_FILES = -2147220442
-    IS_CONST = -2147220441
-    UNSUPPORTED_PRODUCT_MODE = -2147220440
-    INSTALL_OPTION_NOT_SUPPORTED = -2147220381
-    FIRMWARE_TOO_OLD = -2147220380
-    SOFTWARE_TOO_OLD = -2147220379
-    REQUIRES_SSH = -2147220378
-    OPKG_RESPONSE_SYNTAX = -2147220377
-    WRONG_SOFTWARE_SET_TYPE = -2147220376
-    REQUIRES_OPKG = -2147220375
-    HD_FORMAT_ENCRYPT_NOT_SUPPORTED = -2147220374
-    HD_FORMAT_NO_RECOVERY_KEY_DEVICE = -2147220373
-    RESTART_LOCALHOST_AMBIGUOUS = -2147220372
-    IMAGE_INVALID_CORRUPT = -2147220371
-    SAFE_OR_INSTALL_MODE_REQUIRED = -2147220370
-    ENCRYPT_PHRASE_MISMATCH = -2147220369
-    INVALID_IP = -2147220368
-    INVALID_GATEWAY = -2147220367
-    INVALID_DNS = -2147220366
-    INVALID_SUBNET = -2147220365
-    CMD_NOT_SUPPORTED = -2147220364
-    CONFIG_FAILED = -2147220363
-    LOCKED = -2147220362
-    BAD_PASSWORD = -2147220361
-    NOT_CONFIGURABLE = -2147220360
-    UNLOCK_FAILED = -2147220359
-    LOCK_FAILED = -2147220358
-    INSTALL_FAILED = -2147220357
-    INSTALLATION_CORRUPT = -2147220356
-    EMPTY_FILE = -2147220355
-    UNCONFIGURED_IP = -2147220354
-    INSTALLATION_GENERIC_FAILURE = -2147220352
-    DOWNLOAD_ALREADY_STARTED = -2147220350
-    ABORTED = -2147220349
-    DISK_FULL = -2147220338
-    HD_FORMAT_FAILED = -2147220337
-    HD_FORMAT_NOT_SAFE_MODE = -2147220336
-    HD_FORMAT_REBOOT_FAILED = -2147220335
-    CONNECTION_REFUSED = -2147220334
-    GET_REMOTE_FILES_FAILED = -2147220331
-    PUT_REMOTE_FILES_FAILED = -2147220330
-    INVALID_IMAGE = -2147220329
-    IMAGE_DEVICE_CODE_MISMATCH = -2147220328
-    SYSTEM_MISMATCH = -2147220327
-    HD_FORMAT_WRONG_FS = -2147220326
-    CUSTOM_INSTALL_NOT_SUPPORTED = -2147220325
-    FTP_FAILED = -2147220324
-    TIMEOUT = -2147220323
-    DIR_NOT_FOUND = -2147220321
-    PATH_NOT_FOUND = -2147220320
-    NO_SOFTWARE_AVAILABLE = -2147220319
-    OVERWRITE_ERROR = -2147220318
-    HD_FORMAT_CANNOT_KEEP_CFG = -2147220317
-    FILE_OR_PATH_TOO_LONG = -2147220316
-    DDP_INTERNAL_TIMEOUT = -2147220315
-    IO_PERMISSION_DENIED = -2147220314
-    PATH_ALREADY_EXISTS = -2147220313
-    EXECUTION_FAILURE = -2147220312
-    DOWNLOAD_ERROR = -2147220311
-    NET_SEND_FAILED = -2147220309
-    CONTACT_HOST_DISCONNECTED = -2147220308
-    NET_SVC_DOWN = -2147220307
-    NOT_CONFIRMED = -2147220306
-    HOST_NOT_RESOLVED = -2147220305
-    REBOOT_TIMEOUT = -2147220304
-    NO_CONFIRMATION_FP1600 = -2147220303
-    DUPLICATE_STARTUP = -2147220300
-    REMOTE_INVALID_ARGUMENT = -2147220299
-    NOT_UNINSTALLABLE = -2147220298
-    DUPLICATES_NOT_ALLOWED = -2147220297
-    NOT_INSTALLABLE = -2147220296
-    WRONG_DEVICE = -2147220295
-    WRONG_OS = -2147220294
-    OS_VERSION_TOO_OLD = -2147220293
-    IO_ERROR = -2147220292
-    CORRUPT_CONFIG = -2147220291
-    BUFFER_OVERFLOW = -2147220290
-    UNSUPPORTED_CDF_VERSION = -2147220289
-    INVALID_STACK = -2147220288
-    INCOMPLETE_STACK = -2147220287
-    STACK_ITEM_MISSING = -2147220286
-    TOP_LEVEL_HIDDEN_COMPONENT_ERROR = -2147220285
-    INVALID_ADDON = -2147220284
-    NO_RT_IMAGES_FOLDER = -2147220283
-    NO_RT_IMAGES_REGISTRY = -2147220282
-    NO_RTS2_CDF = -2147220281
-    UNSUPPORTED_OS = -2147220280
-    EXACT_VERSION_REQUIRED = -2147220279
-    INVALID_STARTUP = -2147220277
+# This file is code generated
+
+import platform
+import warnings
+
+from nisyscfg.enums import BaseEnum
+
+
+def _is_success(code):
+    return code == 0
+
+
+def _is_error(code):
+    return code < 0
+
+
+def _is_warning(code):
+    return code > 0
+
+
+class Error(Exception):
+    def __init__(self, message):
+        super(Error, self).__init__(message)
+
+
+class LibraryError(Error):
+    def __init__(self, code, description):
+        assert _is_error(code), "Should not raise Error if code is not fatal."
+        self.code = code
+        self.description = description
+        if self.description:
+            message = str(self.code) + ": " + self.description
+        else:
+            message = str(self.code) + ":"
+        super(LibraryError, self).__init__(message)
+
+
+class LibraryWarning(Warning):
+    def __init__(self, code, description):
+        assert _is_warning(code), "Should not create Warning if code is not positive."
+        self.code = code
+        self.description = description
+        if self.description:
+            message = "Warning {0}: {1}".format(str(self.code), self.description)
+        else:
+            message = "Warning {0}:".format(str(self.code))
+        super(LibraryWarning, self).__init__(message)
+
+
+class UnsupportedPlatformError(Error):
+    def __init__(self):
+        super(UnsupportedPlatformError, self).__init__(
+            "Platform is unsupported: " + platform.architecture()[0] + " " + platform.system()
+        )
+
+
+class LibraryNotInstalledError(Error):
+    def __init__(self):
+        super(LibraryNotInstalledError, self).__init__(
+            "The NI System Configuration runtime could not be loaded. Make sure"
+            " it is installed and its bitness matches that of your Python"
+            " interpreter. Please visit http://www.ni.com/downloads/drivers/ to"
+            " download and install it."
+        )
+
+
+def handle_error(session, code, ignore_warnings=False, is_error_handling=False):
+    if _is_success(code) or (_is_warning(code) and ignore_warnings):
+        return
+
+    try:
+        status = Status(code)
+        # Only lookup descriptions for nisyscfg status codes
+        if is_error_handling:
+            # The caller is in the midst of error handling and an error occurred.
+            # Don't try to get the description or we'll start recursing until the stack overflows.
+            description = ""
+        else:
+            description = session._get_status_description(code)
+    except Exception:
+        status = code
+        description = ""
+
+    if _is_error(code):
+        raise LibraryError(status, description)
+
+    assert _is_warning(code)
+    warnings.warn(LibraryWarning(status, description))
+
+
+warnings.filterwarnings("always", category=LibraryWarning)
+
+
+class Status(BaseEnum):
+    OK = 0
+    END_OF_ENUM = 1
+    SELF_TEST_BASIC_ONLY = 263024
+    FOUND_CACHED_OFFLINE_SYSTEM = 263168
+    RESTART_LOCALHOST_INITIATED = 263169
+    CHANGED_PROPERTY_NOT_SAVED = 263170
+    NOT_IMPLEMENTED = -2147467263
+    NULL_POINTER = -2147467261
+    FAIL = -2147467259
+    UNEXPECTED = -2147418113
+    OUT_OF_MEMORY = -2147024882
+    INVALID_ARG = -2147024809
+    OPERATION_TIMED_OUT = -2147220448
+    FILE_NOT_FOUND = -2147220322
+    INVALID_MAC_FORMAT = -2147220278
+    PROP_MISMATCH = -2147220624
+    PROP_DOES_NOT_EXIST = -2147220623
+    URI_ILLEGAL_SYNTAX = -2147220622
+    URI_TARGET_DOES_NOT_EXIST = -2147220621
+    URI_EXPERT_DOES_NOT_EXIST = -2147220620
+    ITEM_DOES_NOT_EXIST = -2147220619
+    INVALID_MODE = -2147220618
+    SYS_CONFIG_API_NOT_INSTALLED = -2147220616
+    NAME_SYNTAX_ILLEGAL = -2147220614
+    NAME_COLLISION = -2147220613
+    NO_PROP_VALIDATED = -2147220612
+    URI_UNAUTHORIZED = -2147220611
+    RENAME_RESOURCE_DEPENDENCIES = -2147220610
+    VALUE_INVALID = -2147220609
+    VALUES_INCONSISTENT = -2147220608
+    CANCELED = -2147220607
+    RESPONSE_SYNTAX = -2147220606
+    RESOURCE_IS_NOT_PRESENT = -2147220605
+    RESOURCE_IS_SIMULATED = -2147220604
+    NOT_IN_FIRMWARE_UPDATE_STATE = -2147220603
+    FIRMWARE_IMAGE_DEVICE_MISMATCH = -2147220602
+    FIRMWARE_IMAGE_CORRUPT = -2147220601
+    INVALID_FIRMWARE_VERSION = -2147220600
+    OLDER_FIRMWARE_VERSION = -2147220599
+    INVALID_LOGIN_CREDENTIALS = -2147220598
+    FIRMWARE_UPDATE_ATTEMPT_FAILED = -2147220597
+    ENCRYPTION_FAILED = -2147220596
+    SOME_PROPS_NOT_VALIDATED = -2147220595
+    INVALID_CALIBRATION_CREDENTIALS = -2147220594
+    CANNOT_DELETE_PRESENT_RESOURCE = -2147220593
+    URI_TARGET_TRANSMIT_ERROR = -2147220592
+    DECRYPTION_FAILED = -2147220591
+    FIRMWARE_EXPERT_VERSION_MISMATCH = -2147220590
+    AMBIGUOUS_IMPORT_ACTION = -2147220589
+    REQUIRED_ITEM_FAILED_IMPORT = -2147220588
+    ITEM_IN_USE = -2147220587
+    ITEM_TYPE_NOT_SUPPORTED = -2147220586
+    PERMISSION_DENIED = -2147220560
+    SYSTEM_NOT_FOUND = -2147220559
+    TRANSFORM_FAILED = -2147220558
+    NOT_INSTALLED = -2147220557
+    LAUNCH_FAILURE = -2147220556
+    INTERNAL_TIMEOUT = -2147220555
+    MISSING_TRANSFORM = -2147220554
+    INCORRECT_EXTENSION = -2147220553
+    FILE_READ_ONLY = -2147220552
+    REPORT_OVERWRITE = -2147220551
+    DIRECTORY_ERROR = -2147220550
+    CANNOT_OPEN_FILE = -2147220480
+    INSUFFICIENT_PERMISSIONS = -2147220479
+    NCE_COPIER_FAILED = -2147220478
+    FILE_OPERATION_FAILED = -2147220477
+    NAME_COLLISION_ERROR = -2147220476
+    UNEXPECTED_ERROR = -2147220475
+    NCE_NO_STREAM_ERROR = -2147220474
+    NCE_COMPRESSION_ERROR = -2147220473
+    NCE_STREAM_READ_ERROR = -2147220472
+    NCE_STREAM_WRITE_ERROR = -2147220471
+    NCE_STREAM_SEEK_ERROR = -2147220470
+    NCE_REPO_NOT_READY = -2147220469
+    NCE_REPO_INVALID = -2147220468
+    NCE_REPO_INCOMPAT = -2147220467
+    NCE_NO_IMPORT_STORAGE = -2147220466
+    NCE_NO_EXPORT_STORAGE = -2147220465
+    NCE_NO_OBJ_COPIER = -2147220464
+    COPY_IN_PROGRESS = -2147220463
+    FILE_NOT_RECOGNIZED = -2147220462
+    SYSTEM_NOT_SUPPORTED = -2147220461
+    SYSTEM_NOT_REACHABLE = -2147220460
+    PRODUCT_SOFTWARE_NOT_INSTALLED = -2147220459
+    PRODUCT_SOFTWARE_TOO_OLD = -2147220458
+    PRODUCT_SOFTWARE_TOO_NEW = -2147220457
+    DATA_TOO_OLD = -2147220456
+    DATA_TOO_NEW = -2147220455
+    NO_ITEMS_TO_COPY = -2147220454
+    ORPHAN_ITEMS = -2147220453
+    DIRTY_ITEMS = -2147220452
+    FILE_OVERWRITE = -2147220451
+    ITEM_OVERWRITE = -2147220450
+    MISSING_DEPENDENCY = -2147220449
+    OPERATION_CANCELED = -2147220447
+    WARNING_CONFLICTS = -2147220446
+    ERROR_CONFLICTS = -2147220445
+    ITEMS_REQUIRE_USER_INPUT = -2147220444
+    PRODUCT_EXPERT_NOT_READY = -2147220443
+    ORPHAN_FILES = -2147220442
+    IS_CONST = -2147220441
+    UNSUPPORTED_PRODUCT_MODE = -2147220440
+    INSTALL_OPTION_NOT_SUPPORTED = -2147220381
+    FIRMWARE_TOO_OLD = -2147220380
+    SOFTWARE_TOO_OLD = -2147220379
+    REQUIRES_SSH = -2147220378
+    OPKG_RESPONSE_SYNTAX = -2147220377
+    WRONG_SOFTWARE_SET_TYPE = -2147220376
+    REQUIRES_OPKG = -2147220375
+    HD_FORMAT_ENCRYPT_NOT_SUPPORTED = -2147220374
+    HD_FORMAT_NO_RECOVERY_KEY_DEVICE = -2147220373
+    RESTART_LOCALHOST_AMBIGUOUS = -2147220372
+    IMAGE_INVALID_CORRUPT = -2147220371
+    SAFE_OR_INSTALL_MODE_REQUIRED = -2147220370
+    ENCRYPT_PHRASE_MISMATCH = -2147220369
+    INVALID_IP = -2147220368
+    INVALID_GATEWAY = -2147220367
+    INVALID_DNS = -2147220366
+    INVALID_SUBNET = -2147220365
+    CMD_NOT_SUPPORTED = -2147220364
+    CONFIG_FAILED = -2147220363
+    LOCKED = -2147220362
+    BAD_PASSWORD = -2147220361
+    NOT_CONFIGURABLE = -2147220360
+    UNLOCK_FAILED = -2147220359
+    LOCK_FAILED = -2147220358
+    INSTALL_FAILED = -2147220357
+    INSTALLATION_CORRUPT = -2147220356
+    EMPTY_FILE = -2147220355
+    UNCONFIGURED_IP = -2147220354
+    INSTALLATION_GENERIC_FAILURE = -2147220352
+    DOWNLOAD_ALREADY_STARTED = -2147220350
+    ABORTED = -2147220349
+    DISK_FULL = -2147220338
+    HD_FORMAT_FAILED = -2147220337
+    HD_FORMAT_NOT_SAFE_MODE = -2147220336
+    HD_FORMAT_REBOOT_FAILED = -2147220335
+    CONNECTION_REFUSED = -2147220334
+    GET_REMOTE_FILES_FAILED = -2147220331
+    PUT_REMOTE_FILES_FAILED = -2147220330
+    INVALID_IMAGE = -2147220329
+    IMAGE_DEVICE_CODE_MISMATCH = -2147220328
+    SYSTEM_MISMATCH = -2147220327
+    HD_FORMAT_WRONG_FS = -2147220326
+    CUSTOM_INSTALL_NOT_SUPPORTED = -2147220325
+    FTP_FAILED = -2147220324
+    TIMEOUT = -2147220323
+    DIR_NOT_FOUND = -2147220321
+    PATH_NOT_FOUND = -2147220320
+    NO_SOFTWARE_AVAILABLE = -2147220319
+    OVERWRITE_ERROR = -2147220318
+    HD_FORMAT_CANNOT_KEEP_CFG = -2147220317
+    FILE_OR_PATH_TOO_LONG = -2147220316
+    DDP_INTERNAL_TIMEOUT = -2147220315
+    IO_PERMISSION_DENIED = -2147220314
+    PATH_ALREADY_EXISTS = -2147220313
+    EXECUTION_FAILURE = -2147220312
+    DOWNLOAD_ERROR = -2147220311
+    NET_SEND_FAILED = -2147220309
+    CONTACT_HOST_DISCONNECTED = -2147220308
+    NET_SVC_DOWN = -2147220307
+    NOT_CONFIRMED = -2147220306
+    HOST_NOT_RESOLVED = -2147220305
+    REBOOT_TIMEOUT = -2147220304
+    NO_CONFIRMATION_FP1600 = -2147220303
+    DUPLICATE_STARTUP = -2147220300
+    REMOTE_INVALID_ARGUMENT = -2147220299
+    NOT_UNINSTALLABLE = -2147220298
+    DUPLICATES_NOT_ALLOWED = -2147220297
+    NOT_INSTALLABLE = -2147220296
+    WRONG_DEVICE = -2147220295
+    WRONG_OS = -2147220294
+    OS_VERSION_TOO_OLD = -2147220293
+    IO_ERROR = -2147220292
+    CORRUPT_CONFIG = -2147220291
+    BUFFER_OVERFLOW = -2147220290
+    UNSUPPORTED_CDF_VERSION = -2147220289
+    INVALID_STACK = -2147220288
+    INCOMPLETE_STACK = -2147220287
+    STACK_ITEM_MISSING = -2147220286
+    TOP_LEVEL_HIDDEN_COMPONENT_ERROR = -2147220285
+    INVALID_ADDON = -2147220284
+    NO_RT_IMAGES_FOLDER = -2147220283
+    NO_RT_IMAGES_REGISTRY = -2147220282
+    NO_RTS2_CDF = -2147220281
+    UNSUPPORTED_OS = -2147220280
+    EXACT_VERSION_REQUIRED = -2147220279
+    INVALID_STARTUP = -2147220277
```

## nisyscfg/expert_info.py

 * *Ordering differences only*

```diff
@@ -1,49 +1,49 @@
-import nisyscfg.errors
-import typing
-
-from nisyscfg._lib import c_string_decode
-
-
-ExpertInfo = typing.NamedTuple(
-    "ExpertInfo",
-    [
-        ("expert_name", str),
-        ("display_name", str),
-        ("version", str),
-    ],
-)
-
-
-class ExpertInfoIterator(object):
-    def __init__(self, handle):
-        self._handle = handle
-        self._library = nisyscfg._library_singleton.get()
-
-    def __del__(self):
-        self.close()
-
-    def __iter__(self):
-        return self
-
-    def __next__(self) -> ExpertInfo:
-        if not self._handle:
-            # TODO(tkrebes): raise RuntimeError
-            raise StopIteration()
-        expert_name = nisyscfg.types.simple_string()
-        display_name = nisyscfg.types.simple_string()
-        version = nisyscfg.types.simple_string()
-        error_code = self._library.NextExpertInfo(self._handle, expert_name, display_name, version)
-        if error_code == nisyscfg.errors.Status.END_OF_ENUM:
-            raise StopIteration()
-        nisyscfg.errors.handle_error(self, error_code)
-        return ExpertInfo(
-            c_string_decode(expert_name.value),
-            c_string_decode(display_name.value),
-            c_string_decode(version.value),
-        )
-
-    def close(self) -> None:
-        if self._handle:
-            error_code = self._library.CloseHandle(self._handle)
-            nisyscfg.errors.handle_error(self, error_code)
-            self._handle = None
+import nisyscfg.errors
+import typing
+
+from nisyscfg._lib import c_string_decode
+
+
+ExpertInfo = typing.NamedTuple(
+    "ExpertInfo",
+    [
+        ("expert_name", str),
+        ("display_name", str),
+        ("version", str),
+    ],
+)
+
+
+class ExpertInfoIterator(object):
+    def __init__(self, handle):
+        self._handle = handle
+        self._library = nisyscfg._library_singleton.get()
+
+    def __del__(self):
+        self.close()
+
+    def __iter__(self):
+        return self
+
+    def __next__(self) -> ExpertInfo:
+        if not self._handle:
+            # TODO(tkrebes): raise RuntimeError
+            raise StopIteration()
+        expert_name = nisyscfg.types.simple_string()
+        display_name = nisyscfg.types.simple_string()
+        version = nisyscfg.types.simple_string()
+        error_code = self._library.NextExpertInfo(self._handle, expert_name, display_name, version)
+        if error_code == nisyscfg.errors.Status.END_OF_ENUM:
+            raise StopIteration()
+        nisyscfg.errors.handle_error(self, error_code)
+        return ExpertInfo(
+            c_string_decode(expert_name.value),
+            c_string_decode(display_name.value),
+            c_string_decode(version.value),
+        )
+
+    def close(self) -> None:
+        if self._handle:
+            error_code = self._library.CloseHandle(self._handle)
+            nisyscfg.errors.handle_error(self, error_code)
+            self._handle = None
```

## nisyscfg/filter.py

```diff
@@ -1,39 +1,41 @@
-import ctypes
-import nisyscfg.errors
-import nisyscfg.properties
-import nisyscfg.xnet.properties
-
-from nisyscfg._lib import c_string_encode
-
-
-@nisyscfg.properties.PropertyBag(nisyscfg.properties.Filter)
-@nisyscfg.properties.PropertyBag(nisyscfg.xnet.properties.Filter, expert="xnet")
-class Filter(object):
-    def __init__(self, session):
-        self._handle = nisyscfg.types.FilterHandle()
-        self._library = nisyscfg._library_singleton.get()
-        self._property_accessor = nisyscfg.properties.PropertyAccessor(
-            setter=self._set_property_with_type
-        )
-        error_code = self._library.CreateFilter(session, ctypes.pointer(self._handle))
-        nisyscfg.errors.handle_error(self, error_code)
-
-    def __del__(self):
-        self.close()
-
-    def close(self):
-        if self._handle:
-            error_code = self._library.CloseHandle(self._handle)
-            nisyscfg.errors.handle_error(self, error_code)
-            self._handle = None
-
-    def _set_property_with_type(self, id, value, c_type, nisyscfg_type):
-        if c_type == ctypes.c_char_p:
-            value = c_string_encode(value)
-        elif issubclass(c_type, nisyscfg.enums.BaseEnum):
-            value = ctypes.c_int(value)
-        else:
-            value = c_type(value)
-
-        error_code = self._library.SetFilterPropertyWithType(self._handle, id, nisyscfg_type, value)
-        nisyscfg.errors.handle_error(self, error_code)
+import ctypes
+import nisyscfg.errors
+import nisyscfg.properties
+import nisyscfg.xnet.properties
+
+from nisyscfg._lib import c_string_encode
+
+
+@nisyscfg.properties.PropertyBag(nisyscfg.properties.Filter)
+@nisyscfg.properties.PropertyBag(nisyscfg.xnet.properties.Filter, expert="xnet")
+class Filter(object):
+    def __init__(self, session):
+        self._handle = nisyscfg.types.FilterHandle()
+        self._library = nisyscfg._library_singleton.get()
+        self._property_accessor = nisyscfg.properties.PropertyAccessor(
+            setter=self._set_property_with_type
+        )
+        error_code = self._library.CreateFilter(session, ctypes.pointer(self._handle))
+        nisyscfg.errors.handle_error(self, error_code)
+
+    def __del__(self):
+        self.close()
+
+    def close(self):
+        if self._handle:
+            error_code = self._library.CloseHandle(self._handle)
+            nisyscfg.errors.handle_error(self, error_code)
+            self._handle = None
+
+    def _set_property_with_type(self, id, value, c_type, nisyscfg_type):
+        if c_type == ctypes.c_char_p:
+            value = c_string_encode(value)
+        elif issubclass(c_type, nisyscfg.enums.BaseEnum) or issubclass(
+            c_type, nisyscfg.enums.BaseFlag
+        ):
+            value = ctypes.c_int(value)
+        else:
+            value = c_type(value)
+
+        error_code = self._library.SetFilterPropertyWithType(self._handle, id, nisyscfg_type, value)
+        nisyscfg.errors.handle_error(self, error_code)
```

## nisyscfg/hardware_resource.py

```diff
@@ -1,510 +1,550 @@
-import ctypes
-from functools import reduce
-import nisyscfg.errors
-import nisyscfg.properties
-import nisyscfg.pxi.properties
-import nisyscfg.timestamp
-import nisyscfg.types
-import nisyscfg.xnet.properties
-import typing
-
-from nisyscfg._lib import c_string_decode
-from nisyscfg._lib import c_string_encode
-
-
-class _NoDefault(object):
-    pass
-
-
-SaveChangesResult = typing.NamedTuple(
-    "SaveChangesResult",
-    [
-        ("restart_required", bool),
-        ("details", str),
-    ],
-)
-
-UpgradeFirmwareResult = typing.NamedTuple(
-    "UpgradeFirmwareResult",
-    [
-        ("status", nisyscfg.enums.FirmwareStatus),
-        ("details", str),
-    ],
-)
-
-FirmwareStatusResult = typing.NamedTuple(
-    "FirmwareStatusResult",
-    [
-        ("percent_complete", int),
-        ("status", nisyscfg.enums.FirmwareStatus),
-        ("details", str),
-    ],
-)
-
-DeleteResult = typing.NamedTuple(
-    "DeleteResult",
-    [
-        ("dependent_items_deleted", bool),
-        ("details", str),
-    ],
-)
-
-
-class HardwareResourceIterator(object):
-    def __init__(self, session, handle):
-        self._children = []
-        self._session = session
-        self._handle = handle
-        self._library = nisyscfg._library_singleton.get()
-
-    def __del__(self):
-        self.close()
-
-    def __iter__(self):
-        return self
-
-    def __next__(self):
-        if not self._handle:
-            # TODO(tkrebes): raise RuntimeError
-            raise StopIteration()
-        resource_handle = nisyscfg.types.ResourceHandle()
-        error_code = self._library.NextResource(
-            self._session, self._handle, ctypes.pointer(resource_handle)
-        )
-        if error_code == nisyscfg.errors.Status.END_OF_ENUM:
-            raise StopIteration()
-        nisyscfg.errors.handle_error(self, error_code)
-        resource = HardwareResource(resource_handle)
-        self._children.append(resource)
-        return resource
-
-    def close(self):
-        self._children.reverse()
-        for child in self._children:
-            child.close()
-        if self._handle:
-            error_code = self._library.CloseHandle(self._handle)
-            nisyscfg.errors.handle_error(self, error_code)
-            self._handle = None
-
-
-@nisyscfg.properties.PropertyBag(nisyscfg.properties.Resource, nisyscfg.properties.IndexedResource)
-@nisyscfg.properties.PropertyBag(
-    nisyscfg.pxi.properties.Resource,
-    nisyscfg.pxi.properties.IndexedResource,
-    expert="pxi",
-)
-@nisyscfg.properties.PropertyBag(nisyscfg.xnet.properties.Resource, expert="xnet")
-class HardwareResource(object):
-    def __init__(self, handle):
-        self._handle = handle
-        self._library = nisyscfg._library_singleton.get()
-        self._property_accessor = nisyscfg.properties.PropertyAccessor(
-            setter=self._set_property,
-            getter=self._get_property,
-            indexed_getter=self._get_indexed_property,
-        )
-
-    def __del__(self):
-        self.close()
-
-    def __repr__(self):
-        return "HardwareResource(name={})".format(self.name)
-
-    @property
-    def name(self):
-        """
-        Returns a name that identifies a resource
-        """
-        name = self.expert_user_alias[0]
-        # If the resource doesn't have an alias, use the resource name instead
-        if not name:
-            name = self.expert_resource_name[0]
-        return name
-
-    def close(self):
-        """
-        Closes reference to previously allocated resource.
-
-        Raises an nisyscfg.errors.LibraryError exception in the event of an
-        error.
-        """
-        if self._handle:
-            error_code = self._library.CloseHandle(self._handle)
-            nisyscfg.errors.handle_error(self, error_code)
-            self._handle = None
-
-    def _get_property(self, id, c_type):
-        if c_type == ctypes.c_char_p:
-            value = nisyscfg.types.simple_string()
-            value_arg = value
-        elif issubclass(c_type, nisyscfg.enums.BaseEnum):
-            value = ctypes.c_int()
-            value_arg = ctypes.pointer(value)
-        else:
-            value = c_type(0)
-            value_arg = ctypes.pointer(value)
-
-        error_code = self._library.GetResourceProperty(self._handle, id, value_arg)
-        nisyscfg.errors.handle_error(self, error_code)
-
-        if issubclass(c_type, nisyscfg.enums.BaseEnum):
-            return c_type(value.value)
-
-        if c_type == nisyscfg.types.TimestampUTC:
-            return nisyscfg.timestamp._convert_ctype_to_datetime(value)
-
-        return c_string_decode(value.value)
-
-    def _get_indexed_property(self, id, index, c_type):
-        if c_type == ctypes.c_char_p:
-            value = nisyscfg.types.simple_string()
-            value_arg = value
-        elif issubclass(c_type, nisyscfg.enums.BaseEnum):
-            value = ctypes.c_int()
-            value_arg = ctypes.pointer(value)
-        else:
-            value = c_type()
-            value_arg = ctypes.pointer(value)
-
-        error_code = self._library.GetResourceIndexedProperty(self._handle, id, index, value_arg)
-        nisyscfg.errors.handle_error(self, error_code)
-
-        if issubclass(c_type, nisyscfg.enums.BaseEnum):
-            return c_type(value.value)
-
-        if c_type == nisyscfg.types.TimestampUTC:
-            return nisyscfg.timestamp._convert_ctype_to_datetime(value)
-
-        return c_string_decode(value.value)
-
-    def get_property(self, name, default=_NoDefault()):
-        """
-        Returns value of hardware resource property
-
-        Return the value for hardware resource property specified by the name,
-        else default. If default is not given and the property does not exist,
-        this function raises an nisyscfg.errors.LibraryError exception.
-        """
-        try:
-            return reduce(getattr, name.split("."), self)
-        except nisyscfg.errors.LibraryError as err:
-            if err.code != nisyscfg.errors.Status.PROP_DOES_NOT_EXIST or isinstance(
-                default, _NoDefault
-            ):
-                raise
-            return default
-
-    def _set_property(self, id, value, c_type, nisyscfg_type):
-        if c_type == ctypes.c_char_p:
-            value = c_string_encode(value)
-        elif issubclass(c_type, nisyscfg.enums.BaseEnum):
-            value = ctypes.c_int(value)
-        elif c_type == nisyscfg.types.TimestampUTC:
-            value = nisyscfg.timestamp._convert_datetime_to_ctype(value)
-        else:
-            value = c_type(value)
-
-        error_code = self._library.SetResourceProperty(self._handle, id, value)
-        nisyscfg.errors.handle_error(self, error_code)
-
-    def rename(self, new_name, overwrite_conflict=False, update_dependencies=False):
-        """
-        Changes the display name of a resource.
-
-        new_name - The user-specified new name for the resource.
-
-        overwrite_conflict - Allows resource name changes to occur if there are
-        any naming conflicts. If this value is True, the resource name change
-        occurs even if another resource with the same name already exists. If
-        this value is False (default), this function raises if another resource
-        with the same name already exists. If this value is True and you choose
-        a name that is already assigned to an existing resource, this function
-        also changes the name of the existing resource.
-
-        update_dependencies - Updates dependencies (for example: a task or
-        channel) if the resource being renamed has them. Dependencies will be
-        updated to refer to the new name by default. Select FALSE if you do not
-        want to update these dependencies.
-        Note: If overwrite_conflict is True and an existing resource was also
-        renamed due to a conflict, the dependencies for that resource will not
-        be updated. This option only affects the dependencies for the resource
-        you are currently renaming.
-
-        Returns HardwareResource whose name was overwritten. This will be None
-        if no other resource was overwritten.
-
-        Raises an nisyscfg.errors.LibraryError exception in the event of an
-        error.
-        """
-        name_already_existed = ctypes.c_int()
-        overwritten_resource_handle = nisyscfg.types.ResourceHandle()
-        error_code = self._library.RenameResource(
-            self._handle,
-            c_string_encode(new_name),
-            overwrite_conflict,
-            update_dependencies,
-            ctypes.pointer(name_already_existed),
-            ctypes.pointer(overwritten_resource_handle),
-        )
-        nisyscfg.errors.handle_error(self, error_code)
-
-        # TODO(tkrebes): Ensure lifetime of HardwareResource does not exceed the
-        # session.
-        overwritten_resource = overwritten_resource_handle.value and HardwareResource(
-            overwritten_resource_handle
-        )
-
-        # Do not return the bool 'name_already_existed' since it is equivalent
-        # to 'overwritten_syscfg_resource == None'.
-        return overwritten_resource
-
-    def reset(self, mode=0):
-        """
-        Executes a reset on a specified resource.
-
-        Raises an nisyscfg.errors.LibraryError exception in the event of an
-        error.
-        """
-        error_code = self._library.ResetHardware(self._handle, mode)
-        nisyscfg.errors.handle_error(self, error_code)
-
-    def save_changes(self) -> SaveChangesResult:
-        """
-        Writes and saves property changes on a device.
-
-        Returns tuple (restart_required, details)
-
-            restart_required - Specifies whether the changes require a reboot.
-            If True, call restart.
-
-            details - A string containing results of any errors
-            that may have occurred during execution.
-
-        Raises an nisyscfg.errors.LibraryError exception in the event of an
-        error.
-        """
-        restart_required = ctypes.c_int()
-        c_details = ctypes.POINTER(ctypes.c_char)()
-        error_code = self._library.SaveResourceChanges(
-            self._handle, restart_required, ctypes.pointer(c_details)
-        )
-        if c_details:
-            details = c_string_decode(ctypes.cast(c_details, ctypes.c_char_p).value)
-            error_code_2 = self._library.FreeDetailedString(c_details)
-        nisyscfg.errors.handle_error(self, error_code)
-        nisyscfg.errors.handle_error(self, error_code_2)
-
-        return SaveChangesResult(restart_required=restart_required.value != 0, details=details)
-
-    def self_test(self, mode=0):
-        """
-        Verifies that system devices are able to perform basic I/O functions.
-
-        No other tasks should run on the system while executing the self test
-        because the driver may need exclusive access to some device resources.
-        You do not need to disconnect devices from external equipment because
-        the state of I/O lines are maintained throughout the test.
-
-        mode - Reserved. This must be 0.
-
-        Returns a string containing results of any errors that may have occurred
-        during execution.
-
-        Raises an nisyscfg.errors.LibraryError exception in the event of an
-        error.
-        """
-        c_details = ctypes.POINTER(ctypes.c_char)()
-        error_code = self._library.SelfTestHardware(self._handle, mode, ctypes.pointer(c_details))
-        if c_details:
-            details = c_string_decode(ctypes.cast(c_details, ctypes.c_char_p).value)
-            error_code_2 = self._library.FreeDetailedString(c_details)
-        nisyscfg.errors.handle_error(self, error_code)
-        nisyscfg.errors.handle_error(self, error_code_2)
-
-        return details
-
-    def upgrade_firmware(
-        self,
-        version: str = None,
-        filepath: str = None,
-        auto_stop_task: bool = True,
-        force: bool = False,
-        sync_call: bool = True,
-    ) -> UpgradeFirmwareResult:
-        """
-        Updates the firmware on the target.
-
-        version - Specifies the firmware version you want to apply to the
-        target. Use '0' to install the latest available firmware.
-
-        filepath - Specifies the firmware file you want to upload to the target.
-
-        Note: Parameters version and filepath are mutually exclusive and you
-        must specify one and only one.
-
-        auto_stop_task - Specifies to automatically end all tasks running on the
-        target, even if they are incomplete and switch to firmware update mode.
-        The default is True.
-
-        force - Specifies to overwrite the destination firmware image even if
-        the version is the same as or older than the version of the destination
-        firmware image. If False, the function checks the version of the
-        firmware returned by the expert and, if the returned version is newer
-        than the version you are upgrading, this function returns an error. If
-        the firmware version is the same and this parameter is set to False, the
-        function does not upgrade the firmware and returns success. If True,
-        this function automatically upgrades the firmware, regardless of the
-        version of the destination firmware image. The default is False.
-
-        sync_call - Specifies whether to wait for the upgrade operation to
-        finish before returning. If False, the upgrade operation may continue
-        running even after this function returns. To check the status, query
-        the firmware_status property. The default is True.
-
-        Returns tuple (status, details)
-
-            status - The status of the firmware update. If this output returns
-            FirmwareStatus.READY_PENDING_USER_RESTART, call restart. You can
-            view more information about additional results in the details
-            output.
-
-            details - Results of any errors that may have occurred when
-            this function completed. This output also may return additional
-            information about the value returned from status.
-
-        Raises an nisyscfg.errors.LibraryError exception in the event of an
-        error.
-        """
-        if version and filepath:
-            raise ValueError("version and filepath are mutually exclusive parameters")
-
-        firmware_status = ctypes.c_int()
-        c_details = ctypes.POINTER(ctypes.c_char)()
-        if version:
-            error_code = self._library.UpgradeFirmwareVersion(
-                self._handle,
-                c_string_encode(version),
-                auto_stop_task,
-                force,
-                sync_call,
-                ctypes.pointer(firmware_status),
-                ctypes.pointer(c_details),
-            )
-        elif filepath:
-            error_code = self._library.UpgradeFirmwareFromFile(
-                self._handle,
-                c_string_encode(filepath),
-                auto_stop_task,
-                force,
-                sync_call,
-                ctypes.pointer(firmware_status),
-                ctypes.pointer(c_details),
-            )
-        else:
-            raise ValueError(
-                "upgrade_firmware() requires either version or filepath to be specified"
-            )
-
-        if c_details:
-            details = c_string_decode(ctypes.cast(c_details, ctypes.c_char_p).value)
-            error_code_2 = self._library.FreeDetailedString(c_details)
-        nisyscfg.errors.handle_error(self, error_code)
-        nisyscfg.errors.handle_error(self, error_code_2)
-
-        return UpgradeFirmwareResult(
-            status=nisyscfg.enums.FirmwareStatus(firmware_status.value), details=details
-        )
-
-    @property
-    def firmware_status(self) -> FirmwareStatusResult:
-        """
-        Returns the status of the firmware upgrade in progress.
-
-        Returns tuple (percent_complete, status, details)
-
-            percent_complete - The status, in percent, of the current step in
-            the firmware upgrade. This parameter returns -1 if there is no
-            firmware update in progress.
-
-            status - The status of the firmware update. If this output
-            returns FirmwareStatus.READY_PENDING_USER_RESTART, call restart. You
-            can view more information about additional results in the details
-            output.
-
-            details - Results of any errors that may have occurred when this
-            function completed. This output also may return additional
-            information about the value returned from status.
-
-        Raises an nisyscfg.errors.LibraryError exception in the event of an
-        error.
-        """
-        percent_complete = ctypes.c_int()
-        firmware_status = ctypes.c_int()
-        c_details = ctypes.POINTER(ctypes.c_char)()
-        error_code = self._library.CheckFirmwareStatus(
-            self._handle, percent_complete, firmware_status, ctypes.pointer(c_details)
-        )
-        if c_details:
-            details = c_string_decode(ctypes.cast(c_details, ctypes.c_char_p).value)
-            error_code_2 = self._library.FreeDetailedString(c_details)
-        nisyscfg.errors.handle_error(self, error_code)
-        nisyscfg.errors.handle_error(self, error_code_2)
-
-        return FirmwareStatusResult(
-            percent_complete=percent_complete.value,
-            status=nisyscfg.enums.FirmwareStatus(firmware_status.value),
-            details=details,
-        )
-
-    def delete(self, mode=nisyscfg.enums.DeleteValidationMode.DELETE_IF_NO_DEPENDENCIES_EXIST):
-        """
-        Permanently removes a hardware resource and its configuration data from
-        the system.
-
-        Note: Not all devices can be deleted; consult your product documentation.
-
-        mode - Specifies the conditions under which to delete the specified
-        resource.
-        ================================= ======================================
-        Mode                              Description
-        --------------------------------- --------------------------------------
-        VALIDATE_BUT_DO_NOT_DELETE        Verify whether the resource can be
-                                          deleted and whether it has
-                                          dependencies.
-        DELETE_IF_NO_DEPENDENCIES_EXIST   Delete the resource only if no
-                                          dependencies exist. These could be
-                                          tasks or child resources.
-        DELETE_ITEM_AND_ANY_DEPENDENCIES  Delete this resource. If any
-                                          dependencies exist, delete them too.
-        DELETE_ITEM_BUT_KEEP_DEPENDENCIES Delete this resource. If any
-                                          dependencies exist, leave them in an
-                                          unusable state.
-        ================================= ======================================
-
-        Returns tuple (dependent_items_deleted, details)
-
-            dependent_items_deleted - Returns whether resources other than the
-            specified one were deleted. For example, this may happen if the
-            resource is a simulated chassis that contained modules.
-
-            details - A string containing results of any errors that may
-            have occurred during execution.
-
-        Raises an nisyscfg.errors.LibraryError exception in the event of an
-        error.
-        """
-        dependent_items_deleted = ctypes.c_int()
-        c_details = ctypes.POINTER(ctypes.c_char)()
-        error_code = self._library.DeleteResource(
-            self._handle, mode, dependent_items_deleted, ctypes.pointer(c_details)
-        )
-        if c_details:
-            details = c_string_decode(ctypes.cast(c_details, ctypes.c_char_p).value)
-            error_code_2 = self._library.FreeDetailedString(c_details)
-        nisyscfg.errors.handle_error(self, error_code)
-        nisyscfg.errors.handle_error(self, error_code_2)
-
-        return DeleteResult(
-            dependent_items_deleted=dependent_items_deleted.value != 0, details=details
-        )
+import ctypes
+from functools import reduce
+import nisyscfg.errors
+import nisyscfg.properties
+import nisyscfg.pxi.properties
+import nisyscfg.timestamp
+import nisyscfg.types
+import nisyscfg.xnet.properties
+import typing
+
+from nisyscfg._lib import c_string_decode
+from nisyscfg._lib import c_string_encode
+
+
+class _NoDefault(object):
+    pass
+
+
+SaveChangesResult = typing.NamedTuple(
+    "SaveChangesResult",
+    [
+        ("restart_required", bool),
+        ("details", str),
+    ],
+)
+
+UpgradeFirmwareResult = typing.NamedTuple(
+    "UpgradeFirmwareResult",
+    [
+        ("status", nisyscfg.enums.FirmwareStatus),
+        ("details", str),
+    ],
+)
+
+FirmwareStatusResult = typing.NamedTuple(
+    "FirmwareStatusResult",
+    [
+        ("percent_complete", int),
+        ("status", nisyscfg.enums.FirmwareStatus),
+        ("details", str),
+    ],
+)
+
+DeleteResult = typing.NamedTuple(
+    "DeleteResult",
+    [
+        ("dependent_items_deleted", bool),
+        ("details", str),
+    ],
+)
+
+
+class HardwareResourceIterator(object):
+    def __init__(self, session, handle):
+        self._children = []
+        self._session = session
+        self._handle = handle
+        self._library = nisyscfg._library_singleton.get()
+
+    def __del__(self):
+        self.close()
+
+    def __iter__(self):
+        return self
+
+    def __next__(self):
+        if not self._handle:
+            # TODO(tkrebes): raise RuntimeError
+            raise StopIteration()
+        resource_handle = nisyscfg.types.ResourceHandle()
+        error_code = self._library.NextResource(
+            self._session, self._handle, ctypes.pointer(resource_handle)
+        )
+        if error_code == nisyscfg.errors.Status.END_OF_ENUM:
+            raise StopIteration()
+        nisyscfg.errors.handle_error(self, error_code)
+        resource = HardwareResource(resource_handle)
+        self._children.append(resource)
+        return resource
+
+    def close(self):
+        self._children.reverse()
+        for child in self._children:
+            child.close()
+        if self._handle:
+            error_code = self._library.CloseHandle(self._handle)
+            nisyscfg.errors.handle_error(self, error_code)
+            self._handle = None
+
+
+@nisyscfg.properties.PropertyBag(nisyscfg.properties.Resource, nisyscfg.properties.IndexedResource)
+@nisyscfg.properties.PropertyBag(
+    nisyscfg.pxi.properties.Resource,
+    nisyscfg.pxi.properties.IndexedResource,
+    expert="pxi",
+)
+@nisyscfg.properties.PropertyBag(nisyscfg.xnet.properties.Resource, expert="xnet")
+class HardwareResource(object):
+    def __init__(self, handle):
+        self._handle = handle
+        self._library = nisyscfg._library_singleton.get()
+        self._property_accessor = nisyscfg.properties.PropertyAccessor(
+            setter=self._set_property,
+            getter=self._get_property,
+            indexed_getter=self._get_indexed_property,
+        )
+
+    def __del__(self):
+        self.close()
+
+    def __repr__(self):
+        return "HardwareResource(name={})".format(self.name)
+
+    @property
+    def name(self):
+        """
+        Returns a name that identifies a resource
+        """
+        name = self.expert_user_alias[0]
+        # If the resource doesn't have an alias, use the resource name instead
+        if not name:
+            name = self.expert_resource_name[0]
+        return name
+
+    def close(self):
+        """
+        Closes reference to previously allocated resource.
+
+        Raises an nisyscfg.errors.LibraryError exception in the event of an
+        error.
+        """
+        if self._handle:
+            error_code = self._library.CloseHandle(self._handle)
+            nisyscfg.errors.handle_error(self, error_code)
+            self._handle = None
+
+    def _get_property(self, id, c_type):
+        if c_type == ctypes.c_char_p:
+            value = nisyscfg.types.simple_string()
+            value_arg = value
+        elif issubclass(c_type, nisyscfg.enums.BaseEnum) or issubclass(
+            c_type, nisyscfg.enums.BaseFlag
+        ):
+            value = ctypes.c_int()
+            value_arg = ctypes.pointer(value)
+        else:
+            value = c_type(0)
+            value_arg = ctypes.pointer(value)
+
+        error_code = self._library.GetResourceProperty(self._handle, id, value_arg)
+        nisyscfg.errors.handle_error(self, error_code)
+
+        if issubclass(c_type, nisyscfg.enums.BaseEnum) or issubclass(
+            c_type, nisyscfg.enums.BaseFlag
+        ):
+            return c_type(value.value)
+
+        if c_type == nisyscfg.types.TimestampUTC:
+            return nisyscfg.timestamp._convert_ctype_to_datetime(value)
+
+        return c_string_decode(value.value)
+
+    def _get_indexed_property(self, id, index, c_type):
+        if c_type == ctypes.c_char_p:
+            value = nisyscfg.types.simple_string()
+            value_arg = value
+        elif issubclass(c_type, nisyscfg.enums.BaseEnum) or issubclass(
+            c_type, nisyscfg.enums.BaseFlag
+        ):
+            value = ctypes.c_int()
+            value_arg = ctypes.pointer(value)
+        else:
+            value = c_type()
+            value_arg = ctypes.pointer(value)
+
+        error_code = self._library.GetResourceIndexedProperty(self._handle, id, index, value_arg)
+        nisyscfg.errors.handle_error(self, error_code)
+
+        if issubclass(c_type, nisyscfg.enums.BaseEnum) or issubclass(
+            c_type, nisyscfg.enums.BaseFlag
+        ):
+            return c_type(value.value)
+
+        if c_type == nisyscfg.types.TimestampUTC:
+            return nisyscfg.timestamp._convert_ctype_to_datetime(value)
+
+        return c_string_decode(value.value)
+
+    def get_property(self, name, default=_NoDefault()):
+        """
+        Returns value of hardware resource property
+
+        Return the value for hardware resource property specified by the name,
+        else default. If default is not given and the property does not exist,
+        this function raises an nisyscfg.errors.LibraryError exception.
+        """
+        try:
+            return reduce(getattr, name.split("."), self)
+        except nisyscfg.errors.LibraryError as err:
+            if err.code != nisyscfg.errors.Status.PROP_DOES_NOT_EXIST or isinstance(
+                default, _NoDefault
+            ):
+                raise
+            return default
+
+    def _set_property(self, id, value, c_type, nisyscfg_type):
+        if c_type == ctypes.c_char_p:
+            value = c_string_encode(value)
+        elif issubclass(c_type, nisyscfg.enums.BaseEnum) or issubclass(
+            c_type, nisyscfg.enums.BaseFlag
+        ):
+            value = ctypes.c_int(value)
+        elif c_type == nisyscfg.types.TimestampUTC:
+            value = nisyscfg.timestamp._convert_datetime_to_ctype(value)
+        else:
+            value = c_type(value)
+
+        error_code = self._library.SetResourceProperty(self._handle, id, value)
+        nisyscfg.errors.handle_error(self, error_code)
+
+    def rename(self, new_name, overwrite_conflict=False, update_dependencies=False):
+        """
+        Changes the display name of a resource.
+
+        new_name - The user-specified new name for the resource.
+
+        overwrite_conflict - Allows resource name changes to occur if there are
+        any naming conflicts. If this value is True, the resource name change
+        occurs even if another resource with the same name already exists. If
+        this value is False (default), this function raises if another resource
+        with the same name already exists. If this value is True and you choose
+        a name that is already assigned to an existing resource, this function
+        also changes the name of the existing resource.
+
+        update_dependencies - Updates dependencies (for example: a task or
+        channel) if the resource being renamed has them. Dependencies will be
+        updated to refer to the new name by default. Select FALSE if you do not
+        want to update these dependencies.
+        Note: If overwrite_conflict is True and an existing resource was also
+        renamed due to a conflict, the dependencies for that resource will not
+        be updated. This option only affects the dependencies for the resource
+        you are currently renaming.
+
+        Returns HardwareResource whose name was overwritten. This will be None
+        if no other resource was overwritten.
+
+        Raises an nisyscfg.errors.LibraryError exception in the event of an
+        error.
+        """
+        name_already_existed = ctypes.c_int()
+        overwritten_resource_handle = nisyscfg.types.ResourceHandle()
+        error_code = self._library.RenameResource(
+            self._handle,
+            c_string_encode(new_name),
+            overwrite_conflict,
+            update_dependencies,
+            ctypes.pointer(name_already_existed),
+            ctypes.pointer(overwritten_resource_handle),
+        )
+        nisyscfg.errors.handle_error(self, error_code)
+
+        # TODO(tkrebes): Ensure lifetime of HardwareResource does not exceed the
+        # session.
+        overwritten_resource = overwritten_resource_handle.value and HardwareResource(
+            overwritten_resource_handle
+        )
+
+        # Do not return the bool 'name_already_existed' since it is equivalent
+        # to 'overwritten_syscfg_resource == None'.
+        return overwritten_resource
+
+    def reset(self, mode=0):
+        """
+        Executes a reset on a specified resource.
+
+        Raises an nisyscfg.errors.LibraryError exception in the event of an
+        error.
+        """
+        error_code = self._library.ResetHardware(self._handle, mode)
+        nisyscfg.errors.handle_error(self, error_code)
+
+    def save_changes(self) -> SaveChangesResult:
+        """
+        Writes and saves property changes on a device.
+
+        Returns tuple (restart_required, details)
+
+            restart_required - Specifies whether the changes require a reboot.
+            If True, call restart.
+
+            details - A string containing results of any errors
+            that may have occurred during execution.
+
+        Raises an nisyscfg.errors.LibraryError exception in the event of an
+        error.
+        """
+        restart_required = ctypes.c_int()
+        c_details = ctypes.POINTER(ctypes.c_char)()
+        error_code = self._library.SaveResourceChanges(
+            self._handle, restart_required, ctypes.pointer(c_details)
+        )
+        if c_details:
+            details = c_string_decode(ctypes.cast(c_details, ctypes.c_char_p).value)
+            error_code_2 = self._library.FreeDetailedString(c_details)
+        nisyscfg.errors.handle_error(self, error_code)
+        nisyscfg.errors.handle_error(self, error_code_2)
+
+        return SaveChangesResult(restart_required=restart_required.value != 0, details=details)
+
+    def self_calibrate(self):
+        """
+        Performs a self-calibration on a device.
+
+        Self-calibration adjusts the calibration constants with respect to an
+        onboard reference stored on the device. The new calibration constants
+        are defined with respect to the calibration constants created during an
+        external calibration to ensure that the measurements are traceable to
+        these external standards. The new calibration constants do not affect
+        the constants created during an external calibration because they are
+        stored in a different area of the device memory. You can perform a self-
+        calibration at any time to adjust the device for use in environments
+        other than those in which the device was externally calibrated.
+
+        Returns a string containing results of any errors that may have occurred
+        during execution.
+
+        Raises an nisyscfg.errors.LibraryError exception in the event of an
+        error.
+        """
+        c_details = ctypes.POINTER(ctypes.c_char)()
+        error_code = self._library.SelfCalibrateHardware(self._handle, ctypes.pointer(c_details))
+        if c_details:
+            details = c_string_decode(ctypes.cast(c_details, ctypes.c_char_p).value)
+            error_code_2 = self._library.FreeDetailedString(c_details)
+        nisyscfg.errors.handle_error(self, error_code)
+        nisyscfg.errors.handle_error(self, error_code_2)
+
+        return details
+
+    def self_test(self, mode=0):
+        """
+        Verifies that system devices are able to perform basic I/O functions.
+
+        No other tasks should run on the system while executing the self test
+        because the driver may need exclusive access to some device resources.
+        You do not need to disconnect devices from external equipment because
+        the state of I/O lines are maintained throughout the test.
+
+        mode - Reserved. This must be 0.
+
+        Returns a string containing results of any errors that may have occurred
+        during execution.
+
+        Raises an nisyscfg.errors.LibraryError exception in the event of an
+        error.
+        """
+        c_details = ctypes.POINTER(ctypes.c_char)()
+        error_code = self._library.SelfTestHardware(self._handle, mode, ctypes.pointer(c_details))
+        if c_details:
+            details = c_string_decode(ctypes.cast(c_details, ctypes.c_char_p).value)
+            error_code_2 = self._library.FreeDetailedString(c_details)
+        nisyscfg.errors.handle_error(self, error_code)
+        nisyscfg.errors.handle_error(self, error_code_2)
+
+        return details
+
+    def upgrade_firmware(
+        self,
+        version: str = None,
+        filepath: str = None,
+        auto_stop_task: bool = True,
+        force: bool = False,
+        sync_call: bool = True,
+    ) -> UpgradeFirmwareResult:
+        """
+        Updates the firmware on the target.
+
+        version - Specifies the firmware version you want to apply to the
+        target. Use '0' to install the latest available firmware.
+
+        filepath - Specifies the firmware file you want to upload to the target.
+
+        Note: Parameters version and filepath are mutually exclusive and you
+        must specify one and only one.
+
+        auto_stop_task - Specifies to automatically end all tasks running on the
+        target, even if they are incomplete and switch to firmware update mode.
+        The default is True.
+
+        force - Specifies to overwrite the destination firmware image even if
+        the version is the same as or older than the version of the destination
+        firmware image. If False, the function checks the version of the
+        firmware returned by the expert and, if the returned version is newer
+        than the version you are upgrading, this function returns an error. If
+        the firmware version is the same and this parameter is set to False, the
+        function does not upgrade the firmware and returns success. If True,
+        this function automatically upgrades the firmware, regardless of the
+        version of the destination firmware image. The default is False.
+
+        sync_call - Specifies whether to wait for the upgrade operation to
+        finish before returning. If False, the upgrade operation may continue
+        running even after this function returns. To check the status, query
+        the firmware_status property. The default is True.
+
+        Returns tuple (status, details)
+
+            status - The status of the firmware update. If this output returns
+            FirmwareStatus.READY_PENDING_USER_RESTART, call restart. You can
+            view more information about additional results in the details
+            output.
+
+            details - Results of any errors that may have occurred when
+            this function completed. This output also may return additional
+            information about the value returned from status.
+
+        Raises an nisyscfg.errors.LibraryError exception in the event of an
+        error.
+        """
+        if version and filepath:
+            raise ValueError("version and filepath are mutually exclusive parameters")
+
+        firmware_status = ctypes.c_int()
+        c_details = ctypes.POINTER(ctypes.c_char)()
+        if version:
+            error_code = self._library.UpgradeFirmwareVersion(
+                self._handle,
+                c_string_encode(version),
+                auto_stop_task,
+                force,
+                sync_call,
+                ctypes.pointer(firmware_status),
+                ctypes.pointer(c_details),
+            )
+        elif filepath:
+            error_code = self._library.UpgradeFirmwareFromFile(
+                self._handle,
+                c_string_encode(filepath),
+                auto_stop_task,
+                force,
+                sync_call,
+                ctypes.pointer(firmware_status),
+                ctypes.pointer(c_details),
+            )
+        else:
+            raise ValueError(
+                "upgrade_firmware() requires either version or filepath to be specified"
+            )
+
+        if c_details:
+            details = c_string_decode(ctypes.cast(c_details, ctypes.c_char_p).value)
+            error_code_2 = self._library.FreeDetailedString(c_details)
+        nisyscfg.errors.handle_error(self, error_code)
+        nisyscfg.errors.handle_error(self, error_code_2)
+
+        return UpgradeFirmwareResult(
+            status=nisyscfg.enums.FirmwareStatus(firmware_status.value), details=details
+        )
+
+    @property
+    def firmware_status(self) -> FirmwareStatusResult:
+        """
+        Returns the status of the firmware upgrade in progress.
+
+        Returns tuple (percent_complete, status, details)
+
+            percent_complete - The status, in percent, of the current step in
+            the firmware upgrade. This parameter returns -1 if there is no
+            firmware update in progress.
+
+            status - The status of the firmware update. If this output
+            returns FirmwareStatus.READY_PENDING_USER_RESTART, call restart. You
+            can view more information about additional results in the details
+            output.
+
+            details - Results of any errors that may have occurred when this
+            function completed. This output also may return additional
+            information about the value returned from status.
+
+        Raises an nisyscfg.errors.LibraryError exception in the event of an
+        error.
+        """
+        percent_complete = ctypes.c_int()
+        firmware_status = ctypes.c_int()
+        c_details = ctypes.POINTER(ctypes.c_char)()
+        error_code = self._library.CheckFirmwareStatus(
+            self._handle, percent_complete, firmware_status, ctypes.pointer(c_details)
+        )
+        if c_details:
+            details = c_string_decode(ctypes.cast(c_details, ctypes.c_char_p).value)
+            error_code_2 = self._library.FreeDetailedString(c_details)
+        nisyscfg.errors.handle_error(self, error_code)
+        nisyscfg.errors.handle_error(self, error_code_2)
+
+        return FirmwareStatusResult(
+            percent_complete=percent_complete.value,
+            status=nisyscfg.enums.FirmwareStatus(firmware_status.value),
+            details=details,
+        )
+
+    def delete(self, mode=nisyscfg.enums.DeleteValidationMode.DELETE_IF_NO_DEPENDENCIES_EXIST):
+        """
+        Permanently removes a hardware resource and its configuration data from
+        the system.
+
+        Note: Not all devices can be deleted; consult your product documentation.
+
+        mode - Specifies the conditions under which to delete the specified
+        resource.
+        ================================= ======================================
+        Mode                              Description
+        --------------------------------- --------------------------------------
+        VALIDATE_BUT_DO_NOT_DELETE        Verify whether the resource can be
+                                          deleted and whether it has
+                                          dependencies.
+        DELETE_IF_NO_DEPENDENCIES_EXIST   Delete the resource only if no
+                                          dependencies exist. These could be
+                                          tasks or child resources.
+        DELETE_ITEM_AND_ANY_DEPENDENCIES  Delete this resource. If any
+                                          dependencies exist, delete them too.
+        DELETE_ITEM_BUT_KEEP_DEPENDENCIES Delete this resource. If any
+                                          dependencies exist, leave them in an
+                                          unusable state.
+        ================================= ======================================
+
+        Returns tuple (dependent_items_deleted, details)
+
+            dependent_items_deleted - Returns whether resources other than the
+            specified one were deleted. For example, this may happen if the
+            resource is a simulated chassis that contained modules.
+
+            details - A string containing results of any errors that may
+            have occurred during execution.
+
+        Raises an nisyscfg.errors.LibraryError exception in the event of an
+        error.
+        """
+        dependent_items_deleted = ctypes.c_int()
+        c_details = ctypes.POINTER(ctypes.c_char)()
+        error_code = self._library.DeleteResource(
+            self._handle, mode, dependent_items_deleted, ctypes.pointer(c_details)
+        )
+        if c_details:
+            details = c_string_decode(ctypes.cast(c_details, ctypes.c_char_p).value)
+            error_code_2 = self._library.FreeDetailedString(c_details)
+        nisyscfg.errors.handle_error(self, error_code)
+        nisyscfg.errors.handle_error(self, error_code_2)
+
+        return DeleteResult(
+            dependent_items_deleted=dependent_items_deleted.value != 0, details=details
+        )
```

## nisyscfg/properties.py

```diff
@@ -1,609 +1,581 @@
-import ctypes
-from nisyscfg.enums import (
-    AccessType,
-    AdapterMode,
-    AdapterType,
-    Bool,
-    BusType,
-    ConnectionType,
-    EapType,
-    FileSystemMode,
-    FirmwareUpdateMode,
-    HasDriverType,
-    IpAddressMode,
-    IsPresentType,
-    LedState,
-    LinkSpeed,
-    ModuleProgramMode,
-    PacketDetection,
-    PropertyType,
-    SecurityType,
-    ServiceType,
-    SwitchState,
-)
-import nisyscfg.timestamp
-
-from typing import List, Union
-
-
-class PropertyAccessor(object):
-
-    __slots__ = "_getter", "_setter", "_indexed_getter"
-
-    def __init__(self, setter=None, getter=None, indexed_getter=None):
-        self._setter = setter
-        self._getter = getter
-        self._indexed_getter = indexed_getter
-
-    def set_bool_property(self, id, value):
-        self._setter(id, value, Bool, PropertyType.BOOL)
-
-    def set_int_property(self, id, value):
-        self._setter(id, value, ctypes.c_int, PropertyType.INT)
-
-    def set_unsigned_int_property(self, id, value):
-        self._setter(id, value, ctypes.c_uint, PropertyType.UNSIGNED_INT)
-
-    def set_double_property(self, id, value):
-        self._setter(id, value, ctypes.c_double, PropertyType.DOUBLE)
-
-    def set_string_property(self, id, value):
-        self._setter(id, value, ctypes.c_char_p, PropertyType.STRING)
-
-    def set_timestamp_property(self, id, value):
-        self._setter(id, value, nisyscfg.types.TimestampUTC, PropertyType.TIMESTAMP)
-
-    def get_bool_property(self, id):
-        return self._getter(id, Bool)
-
-    def get_int_property(self, id):
-        return self._getter(id, ctypes.c_int)
-
-    def get_unsigned_int_property(self, id):
-        return self._getter(id, ctypes.c_uint)
-
-    def get_double_property(self, id):
-        return self._getter(id, ctypes.c_double)
-
-    def get_string_property(self, id):
-        return self._getter(id, ctypes.c_char_p)
-
-    def get_timestamp_property(self, id):
-        return self._getter(id, nisyscfg.types.TimestampUTC)
-
-    def get_indexed_bool_property(self, id, index):
-        return self._indexed_getter(id, index, Bool)
-
-    def get_indexed_int_property(self, id, index):
-        return self._indexed_getter(id, index, ctypes.c_int)
-
-    def get_indexed_unsigned_int_property(self, id, index):
-        return self._indexed_getter(id, index, ctypes.c_uint)
-
-    def get_indexed_double_property(self, id, index):
-        return self._indexed_getter(id, index, ctypes.c_double)
-
-    def get_indexed_string_property(self, id, index):
-        return self._indexed_getter(id, index, ctypes.c_char_p)
-
-    def get_indexed_timestamp_property(self, id, index):
-        return self._indexed_getter(id, index, nisyscfg.types.TimestampUTC)
-
-
-class TypeProperty(object):
-
-    __slots__ = "_id", "_enum", "_readable", "_writeable"
-
-    def __init__(self, id, enum=None, *, readable: bool = True, writeable: bool = True):
-        self._id = id
-        self._enum = enum
-        self._readable = readable
-        self._writeable = writeable
-
-
-class BoolProperty(TypeProperty):
-
-    __slots__ = ()
-
-    def get(self, accessor: PropertyAccessor):
-        value = accessor.get_bool_property(self._id)
-        if self._enum:
-            return self._enum(value)
-        return value
-
-    def set(self, accessor: PropertyAccessor, value):
-        accessor.set_bool_property(self._id, value)
-
-
-class IntProperty(TypeProperty):
-
-    __slots__ = ()
-
-    def get(self, accessor: PropertyAccessor):
-        value = accessor.get_int_property(self._id)
-        if self._enum:
-            return self._enum(value)
-        return value
-
-    def set(self, accessor: PropertyAccessor, value):
-        accessor.set_int_property(self._id, value)
-
-
-class UnsignedIntProperty(TypeProperty):
-
-    __slots__ = ()
-
-    def get(self, accessor: PropertyAccessor):
-        value = accessor.get_unsigned_int_property(self._id)
-        if self._enum:
-            return self._enum(value)
-        return value
-
-    def set(self, accessor: PropertyAccessor, value):
-        accessor.set_unsigned_int_property(self._id, value)
-
-
-class BitmaskProperty(TypeProperty):
-
-    __slots__ = ()
-
-    def get(self, accessor: PropertyAccessor):
-        value = accessor.get_unsigned_int_property(self._id)
-        if self._enum:
-            return [mask for mask in self._enum if value & mask]
-        return [value]
-
-
-class DoubleProperty(TypeProperty):
-
-    __slots__ = ()
-
-    def get(self, accessor: PropertyAccessor) -> float:
-        return accessor.get_double_property(self._id)
-
-    def set(self, accessor: PropertyAccessor, value: float):
-        accessor.set_double_property(self._id, value)
-
-
-class StringProperty(TypeProperty):
-
-    __slots__ = ()
-
-    def get(self, accessor: PropertyAccessor) -> str:
-        return accessor.get_string_property(self._id)
-
-    def set(self, accessor: PropertyAccessor, value: str):
-        accessor.set_string_property(self._id, value)
-
-
-class TimestampProperty(TypeProperty):
-
-    __slots__ = ()
-
-    def get(self, accessor: PropertyAccessor):
-        return accessor.get_timestamp_property(self._id)
-
-    def set(self, accessor: PropertyAccessor, value):
-        accessor.set_timestamp_property(self._id, value)
-
-
-class IndexedPropertyItems(object):
-    def __init__(self, accessor: PropertyAccessor, tag):
-        self._accessor = accessor
-        self._tag = tag
-
-    def __getitem__(self, index):
-        try:
-            index + 1
-        except TypeError:
-            raise TypeError(index)
-        # The index is stored as a 12-bit number in the driver.
-        if index < 0 and index >= 4096:
-            raise IndexError(index)
-        try:
-            return self._tag.get_index(self._accessor, index)
-        except nisyscfg.errors.LibraryError as err:
-            if err.code == nisyscfg.errors.Status.PROP_DOES_NOT_EXIST:
-                raise IndexError(index)
-            raise
-
-    def __len__(self):
-        if not hasattr(self, "_len"):
-            try:
-                self._len = self._tag.count_property.get(self._accessor)
-
-            # Not all NI System API experts implement the count property. So
-            # if it does not exist, explicitly count each index.
-            except nisyscfg.errors.LibraryError as err:
-                if err.code == nisyscfg.errors.Status.PROP_DOES_NOT_EXIST:
-                    self._len = sum(1 for _ in self)
-        return self._len
-
-    def __iter__(self):
-        class IndexedPropertyItemsIter(object):
-
-            __slots__ = "_properties", "_index"
-
-            def __init__(self, properties):
-                self._properties = properties
-                self._index = -1
-
-            def __next__(self):
-                self._index += 1
-                try:
-                    return self._properties[self._index]
-                except IndexError:
-                    raise StopIteration()
-
-            def next(self):
-                return self.__next__()
-
-        return IndexedPropertyItemsIter(self)
-
-
-class IndexedProperty(TypeProperty):
-
-    __slots__ = ("_count_property",)
-
-    def __init__(
-        self, id, count_property, enum=None, *, readable: bool = True, writeable: bool = True
-    ):
-        self._id = id
-        self._count_property = count_property
-        self._enum = enum
-        self._readable = readable
-        self._writeable = writeable
-
-    @property
-    def count_property(self):
-        return self._count_property
-
-    def get(self, accessor: PropertyAccessor):
-        return IndexedPropertyItems(accessor, self)
-
-
-class IndexedBoolProperty(IndexedProperty):
-
-    __slots__ = ()
-
-    def get_index(self, accessor: PropertyAccessor, index: int):
-        value = accessor.get_indexed_bool_property(self._id, index)
-        if self._enum:
-            return self._enum(value)
-        return value
-
-
-class IndexedIntProperty(IndexedProperty):
-
-    __slots__ = ()
-
-    def get_index(self, accessor: PropertyAccessor, index: int):
-        value = accessor.get_indexed_int_property(self._id, index)
-        if self._enum:
-            return self._enum(value)
-        return value
-
-
-class IndexedUnsignedIntProperty(IndexedProperty):
-
-    __slots__ = ()
-
-    def get_index(self, accessor: PropertyAccessor, index: int):
-        value = accessor.get_indexed_unsigned_int_property(self._id, index)
-        if self._enum:
-            return self._enum(value)
-        return value
-
-
-class IndexedDoubleProperty(IndexedProperty):
-
-    __slots__ = ()
-
-    def get_index(self, accessor: PropertyAccessor, index: int):
-        return accessor.get_indexed_double_property(self._id, index)
-
-
-class IndexedStringProperty(IndexedProperty):
-
-    __slots__ = ()
-
-    def get_index(self, accessor: PropertyAccessor, index: int):
-        return accessor.get_indexed_string_property(self._id, index)
-
-
-class IndexedTimestampProperty(IndexedProperty):
-
-    __slots__ = ()
-
-    def get_index(self, accessor: PropertyAccessor, index: int):
-        return accessor.get_indexed_timestamp_property(self._id, index)
-
-
-class PropertyGroup(object):
-    pass
-
-
-class Resource(PropertyGroup):
-    IS_DEVICE = BoolProperty(16781312)
-    IS_CHASSIS = BoolProperty(16941056)
-    CONNECTS_TO_BUS_TYPE = IntProperty(16785408, enum=BusType)
-    VENDOR_ID = UnsignedIntProperty(16789504)
-    VENDOR_NAME = StringProperty(16793600)
-    PRODUCT_ID = UnsignedIntProperty(16797696)
-    PRODUCT_NAME = StringProperty(16801792)
-    SERIAL_NUMBER = StringProperty(16805888)
-    FIRMWARE_REVISION = StringProperty(16969728)
-    IS_NI_PRODUCT = BoolProperty(16809984)
-    IS_SIMULATED = BoolProperty(16814080)
-    CONNECTS_TO_LINK_NAME = StringProperty(16818176)
-    HAS_DRIVER = IntProperty(16920576, enum=HasDriverType)
-    IS_PRESENT = IntProperty(16924672, enum=IsPresentType)
-    SLOT_NUMBER = IntProperty(16822272)
-    SUPPORTS_INTERNAL_CALIBRATION = BoolProperty(16842752)
-    INTERNAL_CALIBRATION_LAST_TIME = TimestampProperty(16846848)
-    INTERNAL_CALIBRATION_LAST_TEMP = DoubleProperty(16850944)
-    SUPPORTS_EXTERNAL_CALIBRATION = BoolProperty(16859136)
-    EXTERNAL_CALIBRATION_LAST_TEMP = DoubleProperty(16867328)
-    CALIBRATION_COMMENTS = StringProperty(16961536)
-    INTERNAL_CALIBRATION_LAST_LIMITED = BoolProperty(17420288)
-    EXTERNAL_CALIBRATION_CHECKSUM = StringProperty(17432576)
-    CURRENT_TEMP = DoubleProperty(16965632)
-    PXI_PCI_BUS_NUMBER = UnsignedIntProperty(16875520)
-    PXI_PCI_DEVICE_NUMBER = UnsignedIntProperty(16879616)
-    PXI_PCI_FUNCTION_NUMBER = UnsignedIntProperty(16883712)
-    PXI_PCI_LINK_WIDTH = IntProperty(16973824)
-    PXI_PCI_MAX_LINK_WIDTH = IntProperty(16977920)
-    USB_INTERFACE = UnsignedIntProperty(16887808)
-    TCP_HOST_NAME = StringProperty(16928768)
-    TCP_MAC_ADDRESS = StringProperty(16986112)
-    TCP_IP_ADDRESS = StringProperty(16957440)
-    TCP_DEVICE_CLASS = StringProperty(17022976)
-    GPIB_PRIMARY_ADDRESS = IntProperty(16994304)
-    GPIB_SECONDARY_ADDRESS = IntProperty(16998400)
-    SERIAL_PORT_BINDING = StringProperty(17076224)
-    PROVIDES_BUS_TYPE = IntProperty(16932864, enum=BusType)
-    PROVIDES_LINK_NAME = StringProperty(16936960)
-    NUMBER_OF_SLOTS = IntProperty(16826368)
-    SUPPORTS_FIRMWARE_UPDATE = BoolProperty(17080320)
-    FIRMWARE_FILE_PATTERN = StringProperty(17084416)
-    RECOMMENDED_CALIBRATION_INTERVAL = IntProperty(17207296)
-    SUPPORTS_CALIBRATION_WRITE = BoolProperty(17215488)
-    HARDWARE_REVISION = StringProperty(17256448)
-    CPU_MODEL_NAME = StringProperty(17313792)
-    CPU_STEPPING_REVISION = IntProperty(17317888)
-    MODEL_NAME_NUMBER = UnsignedIntProperty(17436672)
-    MODULE_PROGRAM_MODE = IntProperty(17440768, enum=ModuleProgramMode)
-    CONNECTS_TO_NUM_SLOTS = IntProperty(17072128)
-    SLOT_OFFSET_LEFT = UnsignedIntProperty(17276928)
-    INTERNAL_CALIBRATION_VALUES_IN_RANGE = BoolProperty(17489920)
-    FIRMWARE_UPDATE_MODE = IntProperty(17354752, enum=FirmwareUpdateMode)
-    EXTERNAL_CALIBRATION_LAST_TIME = TimestampProperty(16863232)
-    RECOMMENDED_NEXT_CALIBRATION_TIME = TimestampProperty(16871424)
-    EXTERNAL_CALIBRATION_LAST_LIMITED = BoolProperty(17428480)
-    CALIBRATION_CURRENT_PASSWORD = StringProperty(17223680)
-    CALIBRATION_NEW_PASSWORD = StringProperty(17227776)
-    SYSTEM_CONFIGURATION_WEB_ACCESS = IntProperty(219504640, enum=AccessType)
-    ADAPTER_TYPE = IntProperty(219332608, enum=AdapterType)
-    MAC_ADDRESS = StringProperty(219168768)
-    ADAPTER_MODE = IntProperty(219160576, enum=AdapterMode)
-    TCP_IP_REQUEST_MODE = IntProperty(219172864, enum=IpAddressMode)
-    TCP_IP_V4_ADDRESS = StringProperty(219181056)
-    TCP_IP_V4_SUBNET = StringProperty(219189248)
-    TCP_IP_V4_GATEWAY = StringProperty(219193344)
-    TCP_IP_V4_DNS_SERVER = StringProperty(219197440)
-    TCP_PREFERRED_LINK_SPEED = IntProperty(219213824, enum=LinkSpeed)
-    TCP_CURRENT_LINK_SPEED = IntProperty(219222016, enum=LinkSpeed)
-    TCP_PACKET_DETECTION = IntProperty(219258880, enum=PacketDetection)
-    TCP_POLLING_INTERVAL = UnsignedIntProperty(219262976)
-    IS_PRIMARY_ADAPTER = BoolProperty(219308032)
-    ETHER_CAT_MASTER_ID = UnsignedIntProperty(219250688)
-    ETHER_CAT_MASTER_REDUNDANCY = BoolProperty(219500544)
-    WLAN_BSSID = StringProperty(219398144)
-    WLAN_CURRENT_LINK_QUALITY = UnsignedIntProperty(219394048)
-    WLAN_CURRENT_SSID = StringProperty(219377664)
-    WLAN_CURRENT_CONNECTION_TYPE = IntProperty(219381760, enum=ConnectionType)
-    WLAN_CURRENT_SECURITY_TYPE = IntProperty(219385856, enum=SecurityType)
-    WLAN_CURRENT_EAP_TYPE = IntProperty(219389952, enum=EapType)
-    WLAN_COUNTRY_CODE = IntProperty(219406336)
-    WLAN_CHANNEL_NUMBER = UnsignedIntProperty(219410432)
-    WLAN_CLIENT_CERTIFICATE = StringProperty(219422720)
-    WLAN_SECURITY_IDENTITY = StringProperty(219414528)
-    WLAN_SECURITY_KEY = StringProperty(219418624)
-    SYSTEM_START_TIME = TimestampProperty(17108992)
-    CURRENT_TIME = TimestampProperty(219279360)
-    TIME_ZONE = StringProperty(219471872)
-    USER_DIRECTED_SAFE_MODE_SWITCH = BoolProperty(219537408)
-    CONSOLE_OUT_SWITCH = BoolProperty(219541504)
-    IP_RESET_SWITCH = BoolProperty(219545600)
-    NUMBER_OF_DISCOVERED_ACCESS_POINTS = UnsignedIntProperty(219365376)
-    NUMBER_OF_EXPERTS = IntProperty(16891904)
-    NUMBER_OF_SERVICES = IntProperty(17010688)
-    NUMBER_OF_AVAILABLE_FIRMWARE_VERSIONS = IntProperty(17088512)
-    NUMBER_OF_CPUS = IntProperty(17137664)
-    NUMBER_OF_FANS = IntProperty(17174528)
-    NUMBER_OF_POWER_SENSORS = IntProperty(17448960)
-    NUMBER_OF_TEMPERATURE_SENSORS = IntProperty(17186816)
-    NUMBER_OF_VOLTAGE_SENSORS = IntProperty(17149952)
-    NUMBER_OF_USER_LED_INDICATORS = IntProperty(17281024)
-    NUMBER_OF_USER_SWITCHES = IntProperty(17293312)
-
-
-class IndexedResource(PropertyGroup):
-    SERVICE_TYPE = IndexedIntProperty(17014784, Resource.NUMBER_OF_SERVICES, enum=ServiceType)
-    AVAILABLE_FIRMWARE_VERSION = IndexedStringProperty(
-        17092608, Resource.NUMBER_OF_AVAILABLE_FIRMWARE_VERSIONS
-    )
-    WLAN_AVAILABLE_SSID = IndexedStringProperty(
-        219336704, Resource.NUMBER_OF_DISCOVERED_ACCESS_POINTS
-    )
-    WLAN_AVAILABLE_BSSID = IndexedStringProperty(
-        219443200, Resource.NUMBER_OF_DISCOVERED_ACCESS_POINTS
-    )
-    WLAN_AVAILABLE_CONNECTION_TYPE = IndexedIntProperty(
-        219340800, Resource.NUMBER_OF_DISCOVERED_ACCESS_POINTS, enum=ConnectionType
-    )
-    WLAN_AVAILABLE_SECURITY_TYPE = IndexedIntProperty(
-        219344896, Resource.NUMBER_OF_DISCOVERED_ACCESS_POINTS, enum=SecurityType
-    )
-    WLAN_AVAILABLE_LINK_QUALITY = IndexedUnsignedIntProperty(
-        219353088, Resource.NUMBER_OF_DISCOVERED_ACCESS_POINTS
-    )
-    WLAN_AVAILABLE_CHANNEL_NUMBER = IndexedUnsignedIntProperty(
-        219357184, Resource.NUMBER_OF_DISCOVERED_ACCESS_POINTS
-    )
-    WLAN_AVAILABLE_LINK_SPEED = IndexedIntProperty(
-        219361280, Resource.NUMBER_OF_DISCOVERED_ACCESS_POINTS, enum=LinkSpeed
-    )
-    CPU_TOTAL_LOAD = IndexedUnsignedIntProperty(17141760, Resource.NUMBER_OF_CPUS)
-    CPU_INTERRUPT_LOAD = IndexedUnsignedIntProperty(17145856, Resource.NUMBER_OF_CPUS)
-    CPU_SPEED = IndexedUnsignedIntProperty(17309696, Resource.NUMBER_OF_CPUS)
-    FAN_NAME = IndexedStringProperty(17178624, Resource.NUMBER_OF_FANS)
-    FAN_READING = IndexedUnsignedIntProperty(17182720, Resource.NUMBER_OF_FANS)
-    POWER_NAME = IndexedStringProperty(17453056, Resource.NUMBER_OF_POWER_SENSORS)
-    POWER_READING = IndexedDoubleProperty(17457152, Resource.NUMBER_OF_POWER_SENSORS)
-    POWER_UPPER_CRITICAL = IndexedDoubleProperty(17461248, Resource.NUMBER_OF_POWER_SENSORS)
-    TEMPERATURE_NAME = IndexedStringProperty(17190912, Resource.NUMBER_OF_TEMPERATURE_SENSORS)
-    TEMPERATURE_READING = IndexedDoubleProperty(16965632, Resource.NUMBER_OF_TEMPERATURE_SENSORS)
-    TEMPERATURE_LOWER_CRITICAL = IndexedDoubleProperty(
-        17195008, Resource.NUMBER_OF_TEMPERATURE_SENSORS
-    )
-    TEMPERATURE_UPPER_CRITICAL = IndexedDoubleProperty(
-        17199104, Resource.NUMBER_OF_TEMPERATURE_SENSORS
-    )
-    VOLTAGE_NAME = IndexedStringProperty(17154048, Resource.NUMBER_OF_VOLTAGE_SENSORS)
-    VOLTAGE_READING = IndexedDoubleProperty(17158144, Resource.NUMBER_OF_VOLTAGE_SENSORS)
-    VOLTAGE_NOMINAL = IndexedDoubleProperty(17162240, Resource.NUMBER_OF_VOLTAGE_SENSORS)
-    VOLTAGE_LOWER_CRITICAL = IndexedDoubleProperty(17166336, Resource.NUMBER_OF_VOLTAGE_SENSORS)
-    VOLTAGE_UPPER_CRITICAL = IndexedDoubleProperty(17170432, Resource.NUMBER_OF_VOLTAGE_SENSORS)
-    USER_LED_NAME = IndexedStringProperty(17285120, Resource.NUMBER_OF_USER_LED_INDICATORS)
-    USER_SWITCH_NAME = IndexedStringProperty(17297408, Resource.NUMBER_OF_USER_SWITCHES)
-    USER_SWITCH_STATE = IndexedIntProperty(
-        17301504, Resource.NUMBER_OF_USER_SWITCHES, enum=SwitchState
-    )
-    USER_LED_STATE = IndexedIntProperty(
-        17289216, Resource.NUMBER_OF_USER_LED_INDICATORS, enum=LedState
-    )
-    EXPERT_NAME = IndexedStringProperty(16900096, Resource.NUMBER_OF_EXPERTS)
-    EXPERT_RESOURCE_NAME = IndexedStringProperty(16896000, Resource.NUMBER_OF_EXPERTS)
-    EXPERT_USER_ALIAS = IndexedStringProperty(16904192, Resource.NUMBER_OF_EXPERTS)
-
-
-class System(PropertyGroup):
-    DEVICE_CLASS = StringProperty(16941057)
-    PRODUCT_ID = IntProperty(16941058)
-    FILE_SYSTEM = IntProperty(16941060, enum=FileSystemMode)
-    FIRMWARE_REVISION = StringProperty(16941061)
-    IS_FACTORY_RESET_SUPPORTED = BoolProperty(16941067)
-    IS_FIRMWARE_UPDATE_SUPPORTED = BoolProperty(16941068)
-    IS_LOCKED = BoolProperty(16941069)
-    IS_LOCKING_SUPPORTED = BoolProperty(16941070)
-    IS_ON_LOCAL_SUBNET = BoolProperty(16941072)
-    IS_RESTART_SUPPORTED = BoolProperty(16941076)
-    MAC_ADDRESS = StringProperty(16941077)
-    PRODUCT_NAME = StringProperty(16941078)
-    OPERATING_SYSTEM = StringProperty(16941079)
-    OPERATING_SYSTEM_VERSION = StringProperty(17100800)
-    OPERATING_SYSTEM_DESCRIPTION = StringProperty(17104896)
-    SERIAL_NUMBER = StringProperty(16941080)
-    SYSTEM_STATE = StringProperty(16941082)
-    MEMORY_PHYS_TOTAL = DoubleProperty(219480064)
-    MEMORY_PHYS_FREE = DoubleProperty(219484160)
-    MEMORY_LARGEST_BLOCK = DoubleProperty(219488256)
-    MEMORY_VIRT_TOTAL = DoubleProperty(219492352)
-    MEMORY_VIRT_FREE = DoubleProperty(219496448)
-    PRIMARY_DISK_TOTAL = DoubleProperty(219291648)
-    PRIMARY_DISK_FREE = DoubleProperty(219295744)
-    # Implemented as a property on nisyscfg.Session
-    # SYSTEM_RESOURCE_HANDLE = IntProperty(16941086, enum=ResourceHandle)
-    IMAGE_DESCRIPTION = StringProperty(219516928)
-    IMAGE_ID = StringProperty(219521024)
-    IMAGE_TITLE = StringProperty(219525120)
-    IMAGE_VERSION = StringProperty(219529216)
-    INSTALLED_API_VERSION = StringProperty(16941087)
-    IS_DST = BoolProperty(16941066)
-    IS_RESTART_PROTECTED = BoolProperty(16941073)
-    HALT_ON_ERROR = BoolProperty(16941074)
-    REPOSITORY_LOCATION = StringProperty(16941084)
-    SYSTEM_COMMENT = StringProperty(16941081)
-    AUTO_RESTART_TIMEOUT = UnsignedIntProperty(16941085)
-    DNS_SERVER = StringProperty(16941059)
-    GATEWAY = StringProperty(16941062)
-    HOSTNAME = StringProperty(16941063)
-    IP_ADDRESS = StringProperty(16941064)
-    IP_ADDRESS_MODE = IntProperty(16941065, enum=IpAddressMode)
-    SUBNET_MASK = StringProperty(16941083)
-
-
-class Filter(PropertyGroup):
-    IS_DEVICE = BoolProperty(16781312)
-    IS_CHASSIS = BoolProperty(16941056)
-    SERVICE_TYPE = IntProperty(17014784, enum=ServiceType)
-    CONNECTS_TO_BUS_TYPE = IntProperty(16785408, enum=BusType)
-    CONNECTS_TO_LINK_NAME = StringProperty(16818176)
-    PROVIDES_BUS_TYPE = IntProperty(16932864, enum=BusType)
-    VENDOR_ID = UnsignedIntProperty(16789504)
-    PRODUCT_ID = UnsignedIntProperty(16797696)
-    SERIAL_NUMBER = StringProperty(16805888)
-    IS_NI_PRODUCT = BoolProperty(16809984)
-    IS_SIMULATED = BoolProperty(16814080)
-    SLOT_NUMBER = IntProperty(16822272)
-    HAS_DRIVER = IntProperty(16920576, enum=HasDriverType)
-    IS_PRESENT = IntProperty(16924672, enum=IsPresentType)
-    SUPPORTS_CALIBRATION = BoolProperty(16908288)
-    SUPPORTS_FIRMWARE_UPDATE = BoolProperty(17080320)
-    PROVIDES_LINK_NAME = StringProperty(16936960)
-    EXPERT_NAME = StringProperty(16900096)
-    RESOURCE_NAME = StringProperty(16896000)
-    USER_ALIAS = StringProperty(16904192)
-
-
-class Property(object):
-
-    __slots__ = ("_type_property",)
-
-    def __init__(self, type_property: TypeProperty):
-        self._type_property = type_property
-
-    def __get__(self, instance, cls):
-        return self._type_property.get(instance._property_accessor)
-
-    def __set__(self, instance, value):
-        return self._type_property.set(instance._property_accessor, value)
-
-    def __delete__(self, instance):
-        raise NotImplementedError
-
-
-class Expert(object):
-    def __init__(self, *property_groups: List[PropertyGroup]):
-        class _ExpertPropertyBag(object):
-            def __init__(self, property_bag):
-                self._property_accessor = property_bag
-
-        self._expert = PropertyBag(*property_groups)(_ExpertPropertyBag)
-
-    def __get__(self, instance, cls):
-        return self._expert(instance._property_accessor)
-
-    def __set__(self, instance, value):
-        raise NotImplementedError
-
-    def __delete__(self, instance):
-        raise NotImplementedError
-
-
-class PropertyBag(object):
-    def __init__(self, *property_groups: List[PropertyGroup], expert: Union[None, str] = None):
-        self._property_groups = property_groups
-        self._expert = expert
-
-    def __call__(self, session):
-        if self._expert:
-            setattr(session, self._expert, Expert(*self._property_groups))
-        else:
-            for group in self._property_groups:
-                for prop in dir(group):
-                    type_property = getattr(group, prop)
-                    if isinstance(type_property, TypeProperty):
-                        setattr(session, prop.lower(), Property(type_property))
-        return session
+import ctypes
+from nisyscfg.enums import (
+    AccessType,
+    AdapterMode,
+    AdapterType,
+    Bool,
+    BusType,
+    ConnectionType,
+    EapType,
+    FileSystemMode,
+    FirmwareUpdateMode,
+    HasDriverType,
+    IpAddressMode,
+    IsPresentType,
+    LedState,
+    LinkSpeed,
+    ModuleProgramMode,
+    PacketDetection,
+    PropertyType,
+    SecurityType,
+    ServiceType,
+    SwitchState,
+)
+import nisyscfg.timestamp
+
+from typing import List, Union
+
+
+class PropertyAccessor(object):
+    __slots__ = "_getter", "_setter", "_indexed_getter"
+
+    def __init__(self, setter=None, getter=None, indexed_getter=None):
+        self._setter = setter
+        self._getter = getter
+        self._indexed_getter = indexed_getter
+
+    def set_bool_property(self, id, value):
+        self._setter(id, value, Bool, PropertyType.BOOL)
+
+    def set_int_property(self, id, value):
+        self._setter(id, value, ctypes.c_int, PropertyType.INT)
+
+    def set_unsigned_int_property(self, id, value):
+        self._setter(id, value, ctypes.c_uint, PropertyType.UNSIGNED_INT)
+
+    def set_double_property(self, id, value):
+        self._setter(id, value, ctypes.c_double, PropertyType.DOUBLE)
+
+    def set_string_property(self, id, value):
+        self._setter(id, value, ctypes.c_char_p, PropertyType.STRING)
+
+    def set_timestamp_property(self, id, value):
+        self._setter(id, value, nisyscfg.types.TimestampUTC, PropertyType.TIMESTAMP)
+
+    def get_bool_property(self, id):
+        return self._getter(id, Bool)
+
+    def get_int_property(self, id):
+        return self._getter(id, ctypes.c_int)
+
+    def get_unsigned_int_property(self, id):
+        return self._getter(id, ctypes.c_uint)
+
+    def get_double_property(self, id):
+        return self._getter(id, ctypes.c_double)
+
+    def get_string_property(self, id):
+        return self._getter(id, ctypes.c_char_p)
+
+    def get_timestamp_property(self, id):
+        return self._getter(id, nisyscfg.types.TimestampUTC)
+
+    def get_indexed_bool_property(self, id, index):
+        return self._indexed_getter(id, index, Bool)
+
+    def get_indexed_int_property(self, id, index):
+        return self._indexed_getter(id, index, ctypes.c_int)
+
+    def get_indexed_unsigned_int_property(self, id, index):
+        return self._indexed_getter(id, index, ctypes.c_uint)
+
+    def get_indexed_double_property(self, id, index):
+        return self._indexed_getter(id, index, ctypes.c_double)
+
+    def get_indexed_string_property(self, id, index):
+        return self._indexed_getter(id, index, ctypes.c_char_p)
+
+    def get_indexed_timestamp_property(self, id, index):
+        return self._indexed_getter(id, index, nisyscfg.types.TimestampUTC)
+
+
+class TypeProperty(object):
+    __slots__ = "_id", "_enum", "_readable", "_writeable"
+
+    def __init__(self, id, enum=None, *, readable: bool = True, writeable: bool = True):
+        self._id = id
+        self._enum = enum
+        self._readable = readable
+        self._writeable = writeable
+
+
+class BoolProperty(TypeProperty):
+    __slots__ = ()
+
+    def get(self, accessor: PropertyAccessor):
+        value = accessor.get_bool_property(self._id)
+        if self._enum:
+            return self._enum(value)
+        return value
+
+    def set(self, accessor: PropertyAccessor, value):
+        accessor.set_bool_property(self._id, value)
+
+
+class IntProperty(TypeProperty):
+    __slots__ = ()
+
+    def get(self, accessor: PropertyAccessor):
+        value = accessor.get_int_property(self._id)
+        if self._enum:
+            return self._enum(value)
+        return value
+
+    def set(self, accessor: PropertyAccessor, value):
+        accessor.set_int_property(self._id, value)
+
+
+class UnsignedIntProperty(TypeProperty):
+    __slots__ = ()
+
+    def get(self, accessor: PropertyAccessor):
+        value = accessor.get_unsigned_int_property(self._id)
+        if self._enum:
+            return self._enum(value)
+        return value
+
+    def set(self, accessor: PropertyAccessor, value):
+        accessor.set_unsigned_int_property(self._id, value)
+
+
+class DoubleProperty(TypeProperty):
+    __slots__ = ()
+
+    def get(self, accessor: PropertyAccessor) -> float:
+        return accessor.get_double_property(self._id)
+
+    def set(self, accessor: PropertyAccessor, value: float):
+        accessor.set_double_property(self._id, value)
+
+
+class StringProperty(TypeProperty):
+    __slots__ = ()
+
+    def get(self, accessor: PropertyAccessor) -> str:
+        return accessor.get_string_property(self._id)
+
+    def set(self, accessor: PropertyAccessor, value: str):
+        accessor.set_string_property(self._id, value)
+
+
+class TimestampProperty(TypeProperty):
+    __slots__ = ()
+
+    def get(self, accessor: PropertyAccessor):
+        return accessor.get_timestamp_property(self._id)
+
+    def set(self, accessor: PropertyAccessor, value):
+        accessor.set_timestamp_property(self._id, value)
+
+
+class IndexedPropertyItems(object):
+    def __init__(self, accessor: PropertyAccessor, tag):
+        self._accessor = accessor
+        self._tag = tag
+
+    def __getitem__(self, index):
+        try:
+            index + 1
+        except TypeError:
+            raise TypeError(index)
+        # The index is stored as a 12-bit number in the driver.
+        if index < 0 and index >= 4096:
+            raise IndexError(index)
+        try:
+            return self._tag.get_index(self._accessor, index)
+        except nisyscfg.errors.LibraryError as err:
+            if err.code == nisyscfg.errors.Status.PROP_DOES_NOT_EXIST:
+                raise IndexError(index)
+            raise
+
+    def __len__(self):
+        if not hasattr(self, "_len"):
+            try:
+                self._len = self._tag.count_property.get(self._accessor)
+
+            # Not all NI System API experts implement the count property. So
+            # if it does not exist, explicitly count each index.
+            except nisyscfg.errors.LibraryError as err:
+                if err.code == nisyscfg.errors.Status.PROP_DOES_NOT_EXIST:
+                    self._len = sum(1 for _ in self)
+        return self._len
+
+    def __iter__(self):
+        class IndexedPropertyItemsIter(object):
+            __slots__ = "_properties", "_index"
+
+            def __init__(self, properties):
+                self._properties = properties
+                self._index = -1
+
+            def __next__(self):
+                self._index += 1
+                try:
+                    return self._properties[self._index]
+                except IndexError:
+                    raise StopIteration()
+
+            def next(self):
+                return self.__next__()
+
+        return IndexedPropertyItemsIter(self)
+
+
+class IndexedProperty(TypeProperty):
+    __slots__ = ("_count_property",)
+
+    def __init__(
+        self, id, count_property, enum=None, *, readable: bool = True, writeable: bool = True
+    ):
+        self._id = id
+        self._count_property = count_property
+        self._enum = enum
+        self._readable = readable
+        self._writeable = writeable
+
+    @property
+    def count_property(self):
+        return self._count_property
+
+    def get(self, accessor: PropertyAccessor):
+        return IndexedPropertyItems(accessor, self)
+
+
+class IndexedBoolProperty(IndexedProperty):
+    __slots__ = ()
+
+    def get_index(self, accessor: PropertyAccessor, index: int):
+        value = accessor.get_indexed_bool_property(self._id, index)
+        if self._enum:
+            return self._enum(value)
+        return value
+
+
+class IndexedIntProperty(IndexedProperty):
+    __slots__ = ()
+
+    def get_index(self, accessor: PropertyAccessor, index: int):
+        value = accessor.get_indexed_int_property(self._id, index)
+        if self._enum:
+            return self._enum(value)
+        return value
+
+
+class IndexedUnsignedIntProperty(IndexedProperty):
+    __slots__ = ()
+
+    def get_index(self, accessor: PropertyAccessor, index: int):
+        value = accessor.get_indexed_unsigned_int_property(self._id, index)
+        if self._enum:
+            return self._enum(value)
+        return value
+
+
+class IndexedDoubleProperty(IndexedProperty):
+    __slots__ = ()
+
+    def get_index(self, accessor: PropertyAccessor, index: int):
+        return accessor.get_indexed_double_property(self._id, index)
+
+
+class IndexedStringProperty(IndexedProperty):
+    __slots__ = ()
+
+    def get_index(self, accessor: PropertyAccessor, index: int):
+        return accessor.get_indexed_string_property(self._id, index)
+
+
+class IndexedTimestampProperty(IndexedProperty):
+    __slots__ = ()
+
+    def get_index(self, accessor: PropertyAccessor, index: int):
+        return accessor.get_indexed_timestamp_property(self._id, index)
+
+
+class PropertyGroup(object):
+    pass
+
+
+class Resource(PropertyGroup):
+    IS_DEVICE = BoolProperty(16781312)
+    IS_CHASSIS = BoolProperty(16941056)
+    CONNECTS_TO_BUS_TYPE = IntProperty(16785408, enum=BusType)
+    VENDOR_ID = UnsignedIntProperty(16789504)
+    VENDOR_NAME = StringProperty(16793600)
+    PRODUCT_ID = UnsignedIntProperty(16797696)
+    PRODUCT_NAME = StringProperty(16801792)
+    SERIAL_NUMBER = StringProperty(16805888)
+    FIRMWARE_REVISION = StringProperty(16969728)
+    IS_NI_PRODUCT = BoolProperty(16809984)
+    IS_SIMULATED = BoolProperty(16814080)
+    CONNECTS_TO_LINK_NAME = StringProperty(16818176)
+    HAS_DRIVER = IntProperty(16920576, enum=HasDriverType)
+    IS_PRESENT = IntProperty(16924672, enum=IsPresentType)
+    SLOT_NUMBER = IntProperty(16822272)
+    SUPPORTS_INTERNAL_CALIBRATION = BoolProperty(16842752)
+    INTERNAL_CALIBRATION_LAST_TIME = TimestampProperty(16846848)
+    INTERNAL_CALIBRATION_LAST_TEMP = DoubleProperty(16850944)
+    SUPPORTS_EXTERNAL_CALIBRATION = BoolProperty(16859136)
+    EXTERNAL_CALIBRATION_LAST_TEMP = DoubleProperty(16867328)
+    CALIBRATION_COMMENTS = StringProperty(16961536)
+    INTERNAL_CALIBRATION_LAST_LIMITED = BoolProperty(17420288)
+    EXTERNAL_CALIBRATION_CHECKSUM = StringProperty(17432576)
+    CURRENT_TEMP = DoubleProperty(16965632)
+    PXI_PCI_BUS_NUMBER = UnsignedIntProperty(16875520)
+    PXI_PCI_DEVICE_NUMBER = UnsignedIntProperty(16879616)
+    PXI_PCI_FUNCTION_NUMBER = UnsignedIntProperty(16883712)
+    PXI_PCI_LINK_WIDTH = IntProperty(16973824)
+    PXI_PCI_MAX_LINK_WIDTH = IntProperty(16977920)
+    USB_INTERFACE = UnsignedIntProperty(16887808)
+    TCP_HOST_NAME = StringProperty(16928768)
+    TCP_MAC_ADDRESS = StringProperty(16986112)
+    TCP_IP_ADDRESS = StringProperty(16957440)
+    TCP_DEVICE_CLASS = StringProperty(17022976)
+    GPIB_PRIMARY_ADDRESS = IntProperty(16994304)
+    GPIB_SECONDARY_ADDRESS = IntProperty(16998400)
+    SERIAL_PORT_BINDING = StringProperty(17076224)
+    PROVIDES_BUS_TYPE = IntProperty(16932864, enum=BusType)
+    PROVIDES_LINK_NAME = StringProperty(16936960)
+    NUMBER_OF_SLOTS = IntProperty(16826368)
+    SUPPORTS_FIRMWARE_UPDATE = BoolProperty(17080320)
+    FIRMWARE_FILE_PATTERN = StringProperty(17084416)
+    RECOMMENDED_CALIBRATION_INTERVAL = IntProperty(17207296)
+    SUPPORTS_CALIBRATION_WRITE = BoolProperty(17215488)
+    HARDWARE_REVISION = StringProperty(17256448)
+    CPU_MODEL_NAME = StringProperty(17313792)
+    CPU_STEPPING_REVISION = IntProperty(17317888)
+    MODEL_NAME_NUMBER = UnsignedIntProperty(17436672)
+    MODULE_PROGRAM_MODE = IntProperty(17440768, enum=ModuleProgramMode)
+    CONNECTS_TO_NUM_SLOTS = IntProperty(17072128)
+    SLOT_OFFSET_LEFT = UnsignedIntProperty(17276928)
+    INTERNAL_CALIBRATION_VALUES_IN_RANGE = BoolProperty(17489920)
+    FIRMWARE_UPDATE_MODE = IntProperty(17354752, enum=FirmwareUpdateMode)
+    EXTERNAL_CALIBRATION_LAST_TIME = TimestampProperty(16863232)
+    RECOMMENDED_NEXT_CALIBRATION_TIME = TimestampProperty(16871424)
+    EXTERNAL_CALIBRATION_LAST_LIMITED = BoolProperty(17428480)
+    CALIBRATION_CURRENT_PASSWORD = StringProperty(17223680)
+    CALIBRATION_NEW_PASSWORD = StringProperty(17227776)
+    SYSTEM_CONFIGURATION_WEB_ACCESS = IntProperty(219504640, enum=AccessType)
+    ADAPTER_TYPE = IntProperty(219332608, enum=AdapterType)
+    MAC_ADDRESS = StringProperty(219168768)
+    ADAPTER_MODE = IntProperty(219160576, enum=AdapterMode)
+    TCP_IP_REQUEST_MODE = IntProperty(219172864, enum=IpAddressMode)
+    TCP_IP_V4_ADDRESS = StringProperty(219181056)
+    TCP_IP_V4_SUBNET = StringProperty(219189248)
+    TCP_IP_V4_GATEWAY = StringProperty(219193344)
+    TCP_IP_V4_DNS_SERVER = StringProperty(219197440)
+    TCP_PREFERRED_LINK_SPEED = IntProperty(219213824, enum=LinkSpeed)
+    TCP_CURRENT_LINK_SPEED = IntProperty(219222016, enum=LinkSpeed)
+    TCP_PACKET_DETECTION = IntProperty(219258880, enum=PacketDetection)
+    TCP_POLLING_INTERVAL = UnsignedIntProperty(219262976)
+    IS_PRIMARY_ADAPTER = BoolProperty(219308032)
+    ETHER_CAT_MASTER_ID = UnsignedIntProperty(219250688)
+    ETHER_CAT_MASTER_REDUNDANCY = BoolProperty(219500544)
+    WLAN_BSSID = StringProperty(219398144)
+    WLAN_CURRENT_LINK_QUALITY = UnsignedIntProperty(219394048)
+    WLAN_CURRENT_SSID = StringProperty(219377664)
+    WLAN_CURRENT_CONNECTION_TYPE = IntProperty(219381760, enum=ConnectionType)
+    WLAN_CURRENT_SECURITY_TYPE = IntProperty(219385856, enum=SecurityType)
+    WLAN_CURRENT_EAP_TYPE = IntProperty(219389952, enum=EapType)
+    WLAN_COUNTRY_CODE = IntProperty(219406336)
+    WLAN_CHANNEL_NUMBER = UnsignedIntProperty(219410432)
+    WLAN_CLIENT_CERTIFICATE = StringProperty(219422720)
+    WLAN_SECURITY_IDENTITY = StringProperty(219414528)
+    WLAN_SECURITY_KEY = StringProperty(219418624)
+    SYSTEM_START_TIME = TimestampProperty(17108992)
+    CURRENT_TIME = TimestampProperty(219279360)
+    TIME_ZONE = StringProperty(219471872)
+    USER_DIRECTED_SAFE_MODE_SWITCH = BoolProperty(219537408)
+    CONSOLE_OUT_SWITCH = BoolProperty(219541504)
+    IP_RESET_SWITCH = BoolProperty(219545600)
+    NUMBER_OF_DISCOVERED_ACCESS_POINTS = UnsignedIntProperty(219365376)
+    NUMBER_OF_EXPERTS = IntProperty(16891904)
+    NUMBER_OF_SERVICES = IntProperty(17010688)
+    NUMBER_OF_AVAILABLE_FIRMWARE_VERSIONS = IntProperty(17088512)
+    NUMBER_OF_CPUS = IntProperty(17137664)
+    NUMBER_OF_FANS = IntProperty(17174528)
+    NUMBER_OF_POWER_SENSORS = IntProperty(17448960)
+    NUMBER_OF_TEMPERATURE_SENSORS = IntProperty(17186816)
+    NUMBER_OF_VOLTAGE_SENSORS = IntProperty(17149952)
+    NUMBER_OF_USER_LED_INDICATORS = IntProperty(17281024)
+    NUMBER_OF_USER_SWITCHES = IntProperty(17293312)
+
+
+class IndexedResource(PropertyGroup):
+    SERVICE_TYPE = IndexedIntProperty(17014784, Resource.NUMBER_OF_SERVICES, enum=ServiceType)
+    AVAILABLE_FIRMWARE_VERSION = IndexedStringProperty(
+        17092608, Resource.NUMBER_OF_AVAILABLE_FIRMWARE_VERSIONS
+    )
+    WLAN_AVAILABLE_SSID = IndexedStringProperty(
+        219336704, Resource.NUMBER_OF_DISCOVERED_ACCESS_POINTS
+    )
+    WLAN_AVAILABLE_BSSID = IndexedStringProperty(
+        219443200, Resource.NUMBER_OF_DISCOVERED_ACCESS_POINTS
+    )
+    WLAN_AVAILABLE_CONNECTION_TYPE = IndexedIntProperty(
+        219340800, Resource.NUMBER_OF_DISCOVERED_ACCESS_POINTS, enum=ConnectionType
+    )
+    WLAN_AVAILABLE_SECURITY_TYPE = IndexedIntProperty(
+        219344896, Resource.NUMBER_OF_DISCOVERED_ACCESS_POINTS, enum=SecurityType
+    )
+    WLAN_AVAILABLE_LINK_QUALITY = IndexedUnsignedIntProperty(
+        219353088, Resource.NUMBER_OF_DISCOVERED_ACCESS_POINTS
+    )
+    WLAN_AVAILABLE_CHANNEL_NUMBER = IndexedUnsignedIntProperty(
+        219357184, Resource.NUMBER_OF_DISCOVERED_ACCESS_POINTS
+    )
+    WLAN_AVAILABLE_LINK_SPEED = IndexedIntProperty(
+        219361280, Resource.NUMBER_OF_DISCOVERED_ACCESS_POINTS, enum=LinkSpeed
+    )
+    CPU_TOTAL_LOAD = IndexedUnsignedIntProperty(17141760, Resource.NUMBER_OF_CPUS)
+    CPU_INTERRUPT_LOAD = IndexedUnsignedIntProperty(17145856, Resource.NUMBER_OF_CPUS)
+    CPU_SPEED = IndexedUnsignedIntProperty(17309696, Resource.NUMBER_OF_CPUS)
+    FAN_NAME = IndexedStringProperty(17178624, Resource.NUMBER_OF_FANS)
+    FAN_READING = IndexedUnsignedIntProperty(17182720, Resource.NUMBER_OF_FANS)
+    POWER_NAME = IndexedStringProperty(17453056, Resource.NUMBER_OF_POWER_SENSORS)
+    POWER_READING = IndexedDoubleProperty(17457152, Resource.NUMBER_OF_POWER_SENSORS)
+    POWER_UPPER_CRITICAL = IndexedDoubleProperty(17461248, Resource.NUMBER_OF_POWER_SENSORS)
+    TEMPERATURE_NAME = IndexedStringProperty(17190912, Resource.NUMBER_OF_TEMPERATURE_SENSORS)
+    TEMPERATURE_READING = IndexedDoubleProperty(16965632, Resource.NUMBER_OF_TEMPERATURE_SENSORS)
+    TEMPERATURE_LOWER_CRITICAL = IndexedDoubleProperty(
+        17195008, Resource.NUMBER_OF_TEMPERATURE_SENSORS
+    )
+    TEMPERATURE_UPPER_CRITICAL = IndexedDoubleProperty(
+        17199104, Resource.NUMBER_OF_TEMPERATURE_SENSORS
+    )
+    VOLTAGE_NAME = IndexedStringProperty(17154048, Resource.NUMBER_OF_VOLTAGE_SENSORS)
+    VOLTAGE_READING = IndexedDoubleProperty(17158144, Resource.NUMBER_OF_VOLTAGE_SENSORS)
+    VOLTAGE_NOMINAL = IndexedDoubleProperty(17162240, Resource.NUMBER_OF_VOLTAGE_SENSORS)
+    VOLTAGE_LOWER_CRITICAL = IndexedDoubleProperty(17166336, Resource.NUMBER_OF_VOLTAGE_SENSORS)
+    VOLTAGE_UPPER_CRITICAL = IndexedDoubleProperty(17170432, Resource.NUMBER_OF_VOLTAGE_SENSORS)
+    USER_LED_NAME = IndexedStringProperty(17285120, Resource.NUMBER_OF_USER_LED_INDICATORS)
+    USER_SWITCH_NAME = IndexedStringProperty(17297408, Resource.NUMBER_OF_USER_SWITCHES)
+    USER_SWITCH_STATE = IndexedIntProperty(
+        17301504, Resource.NUMBER_OF_USER_SWITCHES, enum=SwitchState
+    )
+    USER_LED_STATE = IndexedIntProperty(
+        17289216, Resource.NUMBER_OF_USER_LED_INDICATORS, enum=LedState
+    )
+    EXPERT_NAME = IndexedStringProperty(16900096, Resource.NUMBER_OF_EXPERTS)
+    EXPERT_RESOURCE_NAME = IndexedStringProperty(16896000, Resource.NUMBER_OF_EXPERTS)
+    EXPERT_USER_ALIAS = IndexedStringProperty(16904192, Resource.NUMBER_OF_EXPERTS)
+
+
+class System(PropertyGroup):
+    DEVICE_CLASS = StringProperty(16941057)
+    PRODUCT_ID = IntProperty(16941058)
+    FILE_SYSTEM = IntProperty(16941060, enum=FileSystemMode)
+    FIRMWARE_REVISION = StringProperty(16941061)
+    IS_FACTORY_RESET_SUPPORTED = BoolProperty(16941067)
+    IS_FIRMWARE_UPDATE_SUPPORTED = BoolProperty(16941068)
+    IS_LOCKED = BoolProperty(16941069)
+    IS_LOCKING_SUPPORTED = BoolProperty(16941070)
+    IS_ON_LOCAL_SUBNET = BoolProperty(16941072)
+    IS_RESTART_SUPPORTED = BoolProperty(16941076)
+    MAC_ADDRESS = StringProperty(16941077)
+    PRODUCT_NAME = StringProperty(16941078)
+    OPERATING_SYSTEM = StringProperty(16941079)
+    OPERATING_SYSTEM_VERSION = StringProperty(17100800)
+    OPERATING_SYSTEM_DESCRIPTION = StringProperty(17104896)
+    SERIAL_NUMBER = StringProperty(16941080)
+    SYSTEM_STATE = StringProperty(16941082)
+    MEMORY_PHYS_TOTAL = DoubleProperty(219480064)
+    MEMORY_PHYS_FREE = DoubleProperty(219484160)
+    MEMORY_LARGEST_BLOCK = DoubleProperty(219488256)
+    MEMORY_VIRT_TOTAL = DoubleProperty(219492352)
+    MEMORY_VIRT_FREE = DoubleProperty(219496448)
+    PRIMARY_DISK_TOTAL = DoubleProperty(219291648)
+    PRIMARY_DISK_FREE = DoubleProperty(219295744)
+    # Implemented as a property on nisyscfg.Session
+    # SYSTEM_RESOURCE_HANDLE = IntProperty(16941086, enum=ResourceHandle)
+    IMAGE_DESCRIPTION = StringProperty(219516928)
+    IMAGE_ID = StringProperty(219521024)
+    IMAGE_TITLE = StringProperty(219525120)
+    IMAGE_VERSION = StringProperty(219529216)
+    INSTALLED_API_VERSION = StringProperty(16941087)
+    IS_DST = BoolProperty(16941066)
+    IS_RESTART_PROTECTED = BoolProperty(16941073)
+    HALT_ON_ERROR = BoolProperty(16941074)
+    REPOSITORY_LOCATION = StringProperty(16941084)
+    SYSTEM_COMMENT = StringProperty(16941081)
+    AUTO_RESTART_TIMEOUT = UnsignedIntProperty(16941085)
+    DNS_SERVER = StringProperty(16941059)
+    GATEWAY = StringProperty(16941062)
+    HOSTNAME = StringProperty(16941063)
+    IP_ADDRESS = StringProperty(16941064)
+    IP_ADDRESS_MODE = IntProperty(16941065, enum=IpAddressMode)
+    SUBNET_MASK = StringProperty(16941083)
+
+
+class Filter(PropertyGroup):
+    IS_DEVICE = BoolProperty(16781312)
+    IS_CHASSIS = BoolProperty(16941056)
+    SERVICE_TYPE = IntProperty(17014784, enum=ServiceType)
+    CONNECTS_TO_BUS_TYPE = IntProperty(16785408, enum=BusType)
+    CONNECTS_TO_LINK_NAME = StringProperty(16818176)
+    PROVIDES_BUS_TYPE = IntProperty(16932864, enum=BusType)
+    VENDOR_ID = UnsignedIntProperty(16789504)
+    PRODUCT_ID = UnsignedIntProperty(16797696)
+    SERIAL_NUMBER = StringProperty(16805888)
+    IS_NI_PRODUCT = BoolProperty(16809984)
+    IS_SIMULATED = BoolProperty(16814080)
+    SLOT_NUMBER = IntProperty(16822272)
+    HAS_DRIVER = IntProperty(16920576, enum=HasDriverType)
+    IS_PRESENT = IntProperty(16924672, enum=IsPresentType)
+    SUPPORTS_CALIBRATION = BoolProperty(16908288)
+    SUPPORTS_FIRMWARE_UPDATE = BoolProperty(17080320)
+    PROVIDES_LINK_NAME = StringProperty(16936960)
+    EXPERT_NAME = StringProperty(16900096)
+    RESOURCE_NAME = StringProperty(16896000)
+    USER_ALIAS = StringProperty(16904192)
+
+
+class Property(object):
+    __slots__ = ("_type_property",)
+
+    def __init__(self, type_property: TypeProperty):
+        self._type_property = type_property
+
+    def __get__(self, instance, cls):
+        return self._type_property.get(instance._property_accessor)
+
+    def __set__(self, instance, value):
+        return self._type_property.set(instance._property_accessor, value)
+
+    def __delete__(self, instance):
+        raise NotImplementedError
+
+
+class Expert(object):
+    def __init__(self, *property_groups: List[PropertyGroup]):
+        class _ExpertPropertyBag(object):
+            def __init__(self, property_bag):
+                self._property_accessor = property_bag
+
+        self._expert = PropertyBag(*property_groups)(_ExpertPropertyBag)
+
+    def __get__(self, instance, cls):
+        return self._expert(instance._property_accessor)
+
+    def __set__(self, instance, value):
+        raise NotImplementedError
+
+    def __delete__(self, instance):
+        raise NotImplementedError
+
+
+class PropertyBag(object):
+    def __init__(self, *property_groups: List[PropertyGroup], expert: Union[None, str] = None):
+        self._property_groups = property_groups
+        self._expert = expert
+
+    def __call__(self, session):
+        if self._expert:
+            setattr(session, self._expert, Expert(*self._property_groups))
+        else:
+            for group in self._property_groups:
+                for prop in dir(group):
+                    type_property = getattr(group, prop)
+                    if isinstance(type_property, TypeProperty):
+                        setattr(session, prop.lower(), Property(type_property))
+        return session
```

## nisyscfg/software_feed.py

 * *Ordering differences only*

```diff
@@ -1,53 +1,53 @@
-import ctypes
-import nisyscfg.errors
-import typing
-
-from nisyscfg._lib import c_string_decode
-
-SoftwareFeed = typing.NamedTuple(
-    "SoftwareFeed",
-    [
-        ("name", str),
-        ("uri", str),
-        ("enabled", bool),
-        ("trusted", bool),
-    ],
-)
-
-
-class SoftwareFeedIterator(object):
-    def __init__(self, handle):
-        self._handle = handle
-        self._library = nisyscfg._library_singleton.get()
-
-    def __del__(self):
-        self.close()
-
-    def __iter__(self):
-        return self
-
-    def __next__(self) -> SoftwareFeed:
-        if not self._handle:
-            raise StopIteration()
-        name = nisyscfg.types.simple_string()
-        uri = nisyscfg.types.simple_string()
-        enabled = ctypes.c_int()
-        trusted = ctypes.c_int()
-        error_code = self._library.NextSoftwareFeed(
-            self._handle, name, uri, ctypes.pointer(enabled), ctypes.pointer(trusted)
-        )
-        if error_code == nisyscfg.errors.Status.END_OF_ENUM:
-            raise StopIteration()
-        nisyscfg.errors.handle_error(self, error_code)
-        return SoftwareFeed(
-            name=c_string_decode(name.value),
-            uri=c_string_decode(uri.value),
-            enabled=enabled.value != 0,
-            trusted=trusted.value != 0,
-        )
-
-    def close(self) -> None:
-        if self._handle:
-            error_code = self._library.CloseHandle(self._handle)
-            nisyscfg.errors.handle_error(self, error_code)
-            self._handle = None
+import ctypes
+import nisyscfg.errors
+import typing
+
+from nisyscfg._lib import c_string_decode
+
+SoftwareFeed = typing.NamedTuple(
+    "SoftwareFeed",
+    [
+        ("name", str),
+        ("uri", str),
+        ("enabled", bool),
+        ("trusted", bool),
+    ],
+)
+
+
+class SoftwareFeedIterator(object):
+    def __init__(self, handle):
+        self._handle = handle
+        self._library = nisyscfg._library_singleton.get()
+
+    def __del__(self):
+        self.close()
+
+    def __iter__(self):
+        return self
+
+    def __next__(self) -> SoftwareFeed:
+        if not self._handle:
+            raise StopIteration()
+        name = nisyscfg.types.simple_string()
+        uri = nisyscfg.types.simple_string()
+        enabled = ctypes.c_int()
+        trusted = ctypes.c_int()
+        error_code = self._library.NextSoftwareFeed(
+            self._handle, name, uri, ctypes.pointer(enabled), ctypes.pointer(trusted)
+        )
+        if error_code == nisyscfg.errors.Status.END_OF_ENUM:
+            raise StopIteration()
+        nisyscfg.errors.handle_error(self, error_code)
+        return SoftwareFeed(
+            name=c_string_decode(name.value),
+            uri=c_string_decode(uri.value),
+            enabled=enabled.value != 0,
+            trusted=trusted.value != 0,
+        )
+
+    def close(self) -> None:
+        if self._handle:
+            error_code = self._library.CloseHandle(self._handle)
+            nisyscfg.errors.handle_error(self, error_code)
+            self._handle = None
```

## nisyscfg/system.py

```diff
@@ -1,1062 +1,1068 @@
-import ctypes
-
-import nisyscfg
-import nisyscfg._library_singleton
-import nisyscfg.component_info
-import nisyscfg.dependency_info
-import nisyscfg.expert_info
-import nisyscfg.filter
-import nisyscfg.hardware_resource
-import nisyscfg.properties
-import nisyscfg.pxi.properties
-import nisyscfg.software_feed
-import nisyscfg.system_info
-import nisyscfg.xnet.properties
-
-from nisyscfg._lib import c_string_decode
-from nisyscfg._lib import c_string_encode
-
-from typing import List, NamedTuple, Union
-
-
-InstallAllResult = NamedTuple(
-    "InstallAllResult",
-    [
-        ("installed_components", nisyscfg.component_info.ComponentInfoIterator),
-        ("broken_dependencies", nisyscfg.dependency_info.DependencyInfoIterator),
-    ],
-)
-
-SaveChangesResult = NamedTuple(
-    "SaveChangesResult",
-    [
-        ("restart_required", bool),
-        ("details", str),
-    ],
-)
-
-
-@nisyscfg.properties.PropertyBag(nisyscfg.properties.System)
-class Session(object):
-    """
-    Initializes a system configuration session with a specific system.
-
-    This function communicates to the device at the specified address. If the
-    device is no longer online, but it has previously been discovered in
-    Measurement & Automation Explorer (MAX), this function succeeds, allowing
-    you to retrieve cached information about the device.
-
-    target - Specifies the IP address (ex. "224.102.13.24" ), MAC address
-    (ex. "00:80:12:34:56:AB" ), or DNS name (ex. "myhost" ) of the target on a
-    local or Real-Time system. The target defaults to the local system. Values
-    such as a None, an empty string, and the strings localhost or 127.0.0.1
-    also mean the local system.
-
-    username - Specifies the username for the system you are initializing.
-    Leave this parameter None if your target is running LabWindows/CVI 2009
-    Real-Time Module or earlier or if you are connecting to the local
-    system.
-
-    password - Specifies the password for the system you are initializing.
-    Leave this parameter None if no password has been set or if you are
-    connecting to the local system.
-
-    language - Specifies the language.
-    ================== =========================================================
-    Language           Description
-    ------------------ ---------------------------------------------------------
-    DEFAULT            Automatically chooses the language based on local
-                       Windows settings.
-    ENGLISH            English
-    FRENCH             French
-    GERMAN             German
-    JAPANESE           Japanese
-    KOREAN             Korean
-    CHINESE_SIMPLIFIED Simplified Chinese
-    ================== =========================================================
-
-    force_property_refresh - Forces properties to be refreshed every time they
-    are read by default. If FALSE, properties are queried once and cached in
-    memory, which can optimize performance.
-
-    timeout - Specifies the time, in seconds, that the function waits before the
-    operation times out. When the operation succeeds, the session handle that is
-    returned is set to the default, which is defined as 300 (5 minutes).
-
-    Raises an nisyscfg.errors.LibraryError exception in the event of an error.
-    """
-
-    def __init__(
-        self,
-        target: Union[None, str] = None,
-        username: Union[None, str] = None,
-        password: Union[None, str] = None,
-        language: nisyscfg.enums.Locale = nisyscfg.enums.Locale.DEFAULT,
-        force_property_refresh: bool = True,
-        timeout: float = 300.0,
-    ) -> None:
-        self._children = []
-        self._session = nisyscfg.types.SessionHandle()
-        self._library = nisyscfg._library_singleton.get()
-        self._property_accessor = nisyscfg.properties.PropertyAccessor(
-            setter=self._set_property,
-            getter=self._get_property,
-        )
-        error_code = self._library.InitializeSession(
-            c_string_encode(target),
-            c_string_encode(username),
-            c_string_encode(password),
-            language,
-            force_property_refresh,
-            int(timeout * 1000),
-            None,  # expert_enum_handle
-            ctypes.pointer(self._session),
-        )
-        nisyscfg.errors.handle_error(self, error_code)
-        self.target_name = target
-
-    def __del__(self):
-        self.close()
-
-    def __enter__(self):
-        return self
-
-    def __exit__(self, type, value, traceback):
-        self.close()
-
-    def _get_status_description(self, status):
-        c_detailed_description = ctypes.POINTER(ctypes.c_char)()
-        error_code = self._library.GetStatusDescription(
-            self._session, status, ctypes.pointer(c_detailed_description)
-        )
-        if c_detailed_description:
-            detailed_description = c_string_decode(
-                ctypes.cast(c_detailed_description, ctypes.c_char_p).value
-            )
-            error_code_2 = self._library.FreeDetailedString(c_detailed_description)
-        nisyscfg.errors.handle_error(self, error_code, is_error_handling=True)
-        nisyscfg.errors.handle_error(self, error_code_2, is_error_handling=True)
-        return detailed_description
-
-    def close(self):
-        """
-        Closes references to previously allocated session, filters, resources,
-        and enumerators.
-
-        Raises an nisyscfg.errors.LibraryError exception in the event of an
-        error.
-        """
-        self._children.reverse()
-        for child in self._children:
-            child.close()
-        if self._session:
-            error_code = self._library.CloseHandle(self._session)
-            nisyscfg.errors.handle_error(self, error_code)
-            self._session = None
-
-    def get_system_experts(self, expert_names: str = "") -> nisyscfg.expert_info.ExpertInfoIterator:
-        """
-        Returns the experts available on the system.
-
-        expert_names - This is a case-insensitive comma-separated string
-        specifying which experts to query. If None or empty string, all
-        supported experts are queried.
-
-        Raises an nisyscfg.errors.LibraryError exception in the event of an
-        error.
-        """
-        expert_handle = nisyscfg.types.EnumExpertHandle()
-        if isinstance(expert_names, list):
-            expert_names = ",".join(expert_names)
-        error_code = self._library.GetSystemExperts(
-            self._session, c_string_encode(expert_names), ctypes.pointer(expert_handle)
-        )
-        nisyscfg.errors.handle_error(self, error_code)
-        iter = nisyscfg.expert_info.ExpertInfoIterator(expert_handle)
-        self._children.append(iter)
-        return iter
-
-    def find_hardware(
-        self,
-        filter: Union[None, nisyscfg.filter.Filter] = None,
-        mode: nisyscfg.enums.FilterMode = nisyscfg.enums.FilterMode.MATCH_VALUES_ALL,
-        expert_names: str = "",
-    ) -> nisyscfg.hardware_resource.HardwareResourceIterator:
-        """
-        Returns an iterator of hardware in a specified system.
-
-        filter - Specifies a filter you can use to limit the results to hardware
-        matching specific properties. The default is no filter.
-
-        mode - The enumerated list of filter modes.
-        ==================== ===================================================
-        Mode                 Description
-        -------------------- ---------------------------------------------------
-        MATCH_VALUES_ALL     (default) includes all of the properties specified
-                             in the input filter.
-        MATCH_VALUES_ANY     includes any of the properties specified in the
-                             input filter.
-        MATCH_VALUES_NONE    includes none of the properties specified in the
-                             input filter.
-        ALL_PROPERTIES_EXIST includes all of the properties specified in the
-                             input filter, regardless of the value of each
-                             property.
-        ==================== ===================================================
-
-        expert_names - This is a case-insensitive comma-separated string
-        specifying which experts to query. If None or empty-string, all
-        supported experts are queried.
-
-        Raises an nisyscfg.errors.LibraryError exception in the event of an
-        error.
-        """
-        if filter is None:
-
-            class DummyFilter(object):
-                _handle = None
-
-            filter = DummyFilter()
-        resource_handle = nisyscfg.types.EnumResourceHandle()
-        if isinstance(expert_names, list):
-            expert_names = ",".join(expert_names)
-        error_code = self._library.FindHardware(
-            self._session,
-            mode,
-            filter._handle,
-            c_string_encode(expert_names),
-            ctypes.pointer(resource_handle),
-        )
-        nisyscfg.errors.handle_error(self, error_code)
-        iter = nisyscfg.hardware_resource.HardwareResourceIterator(self._session, resource_handle)
-        self._children.append(iter)
-        return iter
-
-    def find_systems(
-        self,
-        device_class: str = "",
-        detect_online_systems: bool = True,
-        cache_mode: nisyscfg.enums.IncludeCachedResults = nisyscfg.enums.IncludeCachedResults.NONE,
-        find_output_mode: nisyscfg.enums.SystemNameFormat = nisyscfg.enums.SystemNameFormat.HOSTNAME_IP,
-        timeout: float = 4.0,
-        only_installable_systems: bool = False,
-    ) -> nisyscfg.system_info.SystemInfoIterator:
-        """
-        Retrieves systems on the network.
-
-        device_class - Specifies the class of device for which you are
-        searching. Common values are "PXI" and "cRIO". To specify multiple
-        classes, use a comma to separate the values.
-
-        detect_online_systems - Detects systems that are online. This option
-        checks for all local online systems by default. You must set this
-        parameter to TRUE on Real-Time targets. On Windows operating systems,
-        set this parameter to FALSE if you only want to return previously
-        detected results.
-
-        cache_mode - Specifies whether to include cached results.
-        ============== =========================================================
-        Mode           Description
-        -------------- ---------------------------------------------------------
-        NONE           Only return systems discovered from a new scan. If you
-                       have added a system on a remote subnet to MAX, using
-                       NONE for the cached input will not return that system
-                       because it cannot be detected on the local subnet.
-        ONLY_IF_ONLINE Include previously discovered systems if they are online.
-        ALL            Include all previously discovered systems (default).
-        ============== =========================================================
-
-        find_output_mode - Specifies the "preferred" output format of hostname
-        and IP addresses for systems on the network. The Initialize function
-        accepts all of these formats.
-        ============ ===========================================================
-        Mode         Description
-        ------------ -----------------------------------------------------------
-        HOSTNAME     Includes only the hostname.
-        HOSTNAME_IP  (default) Includes both the hostname and IP address.
-        HOSTNAME_MAC Includes both the hostname and MAC address.
-        IP           Includes only the IP address.
-        IP_HOSTNAME  Includes both the IP address and hostname.
-        IP_MAC       Includes both the IP address and MAC address.
-        MAC          Includes only the MAC address.
-        MAC_HOSTNAME Includes both the MAC address and hostname.
-        MAC_IP       Includes both the MAC address and the IP address.
-        ============ ===========================================================
-        Note: In some cases this parameter may return a system that is not in
-        the requested format. For example, if you request the default
-        HOSTNAME_IP but an unconfigured system is detected, that system is
-        returned as IP_MAC.
-
-        timeout - The time, in seconds, the function waits before it times out.
-        The default is 4 s. In some cases, the operation may take longer to
-        time out.
-
-        only_installable_systems - Detects only the systems that support the
-        ability to install software remotely. This includes all Real-Time
-        systems.
-
-        Returns an interator that yields the system names in the format
-        requested from the input parameter
-
-        Raises an nisyscfg.errors.LibraryError exception in the event of an
-        error.
-        """
-        system_handle = nisyscfg.types.EnumSystemHandle()
-        error_code = self._library.FindSystems(
-            self._session,
-            c_string_encode(device_class),
-            nisyscfg.enums.Bool(detect_online_systems),
-            cache_mode,
-            find_output_mode,
-            int(timeout * 1000),
-            nisyscfg.enums.Bool(only_installable_systems),
-            ctypes.pointer(system_handle),
-        )
-        nisyscfg.errors.handle_error(self, error_code)
-
-        return nisyscfg.system_info.SystemInfoIterator(system_handle)
-
-    def create_filter(self) -> nisyscfg.filter.Filter:
-        """
-        Creates a hardware filter object that is used to query for specific
-        resources in a system. After creating a filter, set one or more
-        properties to limit the set of  detected resources.
-
-        Raises an nisyscfg.errors.LibraryError exception in the event of an
-        error.
-        """
-        filter = nisyscfg.filter.Filter(self._session)
-        self._children.append(filter)
-        return filter
-
-    def restart(
-        self,
-        sync_call: bool = True,
-        install_mode: bool = False,
-        flush_dns: bool = False,
-        timeout: float = 90.0,
-    ) -> str:
-        """
-        Reboots a system or network device.
-
-        sync_call - Waits until the reboot has finished before the function
-        operation is completed, by default. Select FALSE to not wait until the
-        reboot is finished before the function completes its operation.
-
-        install_mode - Does not reboot the system into install mode by default.
-        To reboot into install mode, select TRUE. The default is FALSE, reboot
-        into normal mode.
-
-        flush_dns - Does not clear the DNS cache by default. DNS clients
-        temporarily store system hostnames. Flushing the DNS allows you to clear
-        those names from memory. This parameter applies to the local Windows
-        system.
-
-        timeout - The time, in seconds, that the function waits to establish a
-        connection before it returns an error. The default is 90 s.
-
-        Returns the new IP address of the rebooted system. This IP address may
-        differ from the previous IP address if the system acquires a different
-        IP address from the DHCP server.
-
-        Raises an nisyscfg.errors.LibraryError exception in the event of an
-        error.
-        """
-        new_ip_address = nisyscfg.types.simple_string()
-        error_code = self._library.Restart(
-            self._session,
-            sync_call,
-            install_mode,
-            flush_dns,
-            int(timeout * 1000),
-            new_ip_address,
-        )
-        nisyscfg.errors.handle_error(self, error_code)
-        return c_string_decode(new_ip_address.value)
-
-    def get_filtered_base_system_images(
-        self,
-        repository_path: Union[None, str] = None,
-        device_class: Union[None, str] = None,
-        os: Union[None, str] = None,
-        product_id: int = 0,
-    ) -> nisyscfg.component_info.ComponentInfoIterator:
-        """
-        Retrieves a collection of base system images available from a
-        repository path.
-
-        These include a base operating system and are intended to be used
-        with format().
-
-        repository_path - Specifies the location that contains installable
-        components.
-
-        device_class - Specifies the type of device for which you are
-        searching. Common values are PXI and cRIO. To specify multiple classes,
-        use a comma to separate the values.
-
-        os - Specifies the operating system.
-
-        product_id - Specifies the bus-specific product identifier code. This
-        is not the product's sellable model number.
-
-        Raises an nisyscfg.errors.LibraryError exception in the event of an
-        error.
-        """
-        software_component_handle = nisyscfg.types.EnumSoftwareComponentHandle()
-        error_code = self._library.GetFilteredBaseSystemImages(
-            c_string_encode(repository_path),
-            c_string_encode(device_class),
-            c_string_encode(os),
-            ctypes.c_uint(product_id),
-            ctypes.pointer(software_component_handle),
-        )
-        nisyscfg.errors.handle_error(self, error_code)
-        if software_component_handle:
-            iter = nisyscfg.component_info.ComponentInfoIterator(software_component_handle)
-            self._children.append(iter)
-            return iter
-
-    def format(
-        self,
-        auto_restart: bool = True,
-        file_system: nisyscfg.enums.FileSystemMode = nisyscfg.enums.FileSystemMode.DEFAULT,
-        network_settings: nisyscfg.enums.NetworkInterfaceSettings = nisyscfg.enums.NetworkInterfaceSettings.RESET_PRIMARY_RESET_OTHERS,
-        system_image_id: Union[None, str] = None,
-        system_image_version: Union[None, str] = None,
-        timeout: float = 90.0,
-    ) -> None:
-        """
-        Erases all data from the primary hard drive of a system and formats it
-        with the base system image, network settings, and filesystem specified.
-        The operation will fail if you choose not to restart the target
-        automatically and the target's boot flow requires it to be in safe mode
-        or restart after the operation. Refer to the the definition of safe
-        mode to understand the differences between safe mode for different
-        target boot flows. This function can only be used to format Real-Time
-        systems.
-
-        auto_restart - Restarts the system before and/or after the operation as
-        required by the target's boot flow. The operation will fail if you
-        choose not to restart the target automatically and the target's boot
-        flow requires it to be in safe mode or restart after the operation.
-
-        file_system - Formats the primary hard drive into a user-selected file
-        system. Not all systems support all modes.
-        ========= ==============================================================
-        Mode      Description
-        --------- --------------------------------------------------------------
-        DEFAULT   Formats the hard drive into the default format. The default
-                  is whatever format the existing target is already in.
-        FAT       Formats the hard drive with the File Allocation Table (FAT)
-                  file system.
-        RELIANCE  Formats the hard drive with the Reliance file system. Reliance
-                  is a transactional file system, developed by Datalight, that
-                  is tolerant to crashes and power interruptions.
-        UBIFS     Formats the hard drive with the Unsorted Block Image File
-                  System (UBIFS).
-        EXT4      Formats the hard drive with the Ext4 file system.
-        ========= ==============================================================
-
-        network_settings - Resets the primary network adapter and disables
-        secondary adapters by default.
-        ================================ =======================================
-        Mode                             Description
-        -------------------------------- ---------------------------------------
-        RESET_PRIMARY_RESET_OTHERS       Resets the primary network adapter to
-                                         factory settings and disables all other
-                                         network adapters.
-        PRESERVE_PRIMARY_RESET_OTHERS    Preserves the existing settings on the
-                                         primary network adapter and disables
-                                         all other network adapters. This option
-                                         may not be supported for targets on a
-                                         remote subnet.
-        PRESERVE_PRIMARY_PRESERVE_OTHERS Preserves the settings for all network
-                                         adapters. This option may not be
-                                         supported for targets on a remote
-                                         subnet.
-        ================================ =======================================
-
-        system_image_id - The system image ID.
-
-        system_image_version - The system image version.
-
-        timeout - The time, in seconds, that the function waits for the format
-        to time out. The default is 90 s. If restart after format is TRUE, the
-        default increases by 90 s. If the system is not in safe mode, the
-        default increases by another 90 s.
-
-        Raises an nisyscfg.errors.LibraryError exception in the event of an
-        error.
-        """
-        error_code = self._library.FormatWithBaseSystemImage(
-            self._session,
-            nisyscfg.enums.Bool(auto_restart),
-            file_system,
-            network_settings,
-            c_string_encode(system_image_id),
-            c_string_encode(system_image_version),
-            ctypes.c_uint(int(timeout * 1000)),
-        )
-        nisyscfg.errors.handle_error(self, error_code)
-
-    def get_available_software_components(
-        self,
-        item_types: nisyscfg.enums.IncludeComponentTypes = nisyscfg.enums.IncludeComponentTypes.ALL_VISIBLE,
-    ) -> nisyscfg.component_info.ComponentInfoIterator:
-        """
-        Retrieves a list of software components on the local system that are
-        available for installation to the specified target.
-
-        item_types - Allows inclusion of hidden software installed on the target
-        when ALL_VISIBLE_AND_HIDDEN is selected. Hidden software is not listed
-        by default.
-        ====================== =================================================
-        Item Types             Description
-        ---------------------- -------------------------------------------------
-        ALL_VISIBLE            Specifies to return all visible software
-                               components. This includes all standard, startup,
-                               and essential components.
-        ALL_VISIBLE_AND_HIDDEN Specifies to return all visible and hidden
-                               software components.
-        ONLY_STANDARD          Specifies to only return standard software
-                               components.
-        ONLY_STARTUP           Specifies to only return components that are
-                               startup applications.
-        ====================== =================================================
-
-        Raises an nisyscfg.errors.LibraryError exception in the event of an
-        error.
-        """
-        software_component_handle = nisyscfg.types.EnumSoftwareComponentHandle()
-        error_code = self._library.GetAvailableSoftwareComponents(
-            self._session, item_types, ctypes.pointer(software_component_handle)
-        )
-        nisyscfg.errors.handle_error(self, error_code)
-        if software_component_handle:
-            iter = nisyscfg.component_info.ComponentInfoIterator(software_component_handle)
-            self._children.append(iter)
-            return iter
-
-    def get_installed_software_components(
-        self,
-        item_types: nisyscfg.enums.IncludeComponentTypes = nisyscfg.enums.IncludeComponentTypes.ALL_VISIBLE,
-        cached: bool = False,
-    ) -> nisyscfg.component_info.ComponentInfoIterator:
-        """
-        Retrieves a list of software components installed on a system.
-
-        item_types - Allows inclusion of hidden software installed on the target
-        when ALL_VISIBLE_AND_HIDDEN is selected. Hidden software is not listed
-        by default.
-        ====================== =================================================
-        Item Types             Description
-        ---------------------- -------------------------------------------------
-        ALL_VISIBLE            Specifies to return all visible software
-                               components. This includes all standard, startup,
-                               and essential components.
-        ALL_VISIBLE_AND_HIDDEN Specifies to return all visible and hidden
-                               software components.
-        ONLY_STANDARD          Specifies to only return standard software
-                               components.
-        ONLY_STARTUP           Specifies to only return components that are
-                               startup applications.
-        ====================== =================================================
-
-        cached - Returns information that has already been read from the
-        specified real-time system if TRUE. The system is contacted again for
-        the information by default.
-
-        Raises an nisyscfg.errors.LibraryError exception in the event of an
-        error.
-        """
-        software_component_handle = nisyscfg.types.EnumSoftwareComponentHandle()
-        error_code = self._library.GetInstalledSoftwareComponents(
-            self._session, item_types, cached, ctypes.pointer(software_component_handle)
-        )
-        nisyscfg.errors.handle_error(self, error_code)
-        if software_component_handle:
-            iter = nisyscfg.component_info.ComponentInfoIterator(software_component_handle)
-            self._children.append(iter)
-            return iter
-
-    def add_software_feed(self, name: str, uri: str, enabled: bool, trusted: bool) -> None:
-        """
-        Adds a software feed to the system.
-
-        Note: This requires Secure Shell Server (sshd) to be enabled on the
-        target.
-
-        name - Name of the feed for identification purposes.
-
-        uri - Location of the feed, such as "file://..." or "http://...". NI
-        feeds often start with "http://download.ni.com/".
-
-        enabled - Whether the feed is enabled.
-
-        trusted - Whether the feed is trusted. A trusted feed will not be
-        cryptographically verified by the package manager to be a safe and
-        secure source of packages. Feeds are not trusted by default. A system
-        administrator may have reason to trust the feed regardless.
-
-        Raises an nisyscfg.errors.LibraryError exception in the event of an
-        error.
-        """
-        error_code = self._library.AddSoftwareFeed(
-            self._session,
-            c_string_encode(name),
-            c_string_encode(uri),
-            nisyscfg.enums.Bool(enabled),
-            nisyscfg.enums.Bool(trusted),
-        )
-        nisyscfg.errors.handle_error(self, error_code)
-
-    def modify_software_feed(
-        self, old_name: str, new_name: str, uri: str, enabled: bool, trusted: bool
-    ) -> None:
-        """
-        Modifies an existing software feed by name.
-
-        Note: This requires Secure Shell Server (sshd) to be enabled on the
-        target.
-
-        old_name - Name of the feed to modify. This feed must exist on the system.
-
-        new_name - New name of the feed. This feed must not exist on the
-        system. If not specified, the feed name will remain unchanged.
-
-        uri - New location of the feed, such as "file://..." or "http://...".
-        NI feeds often start with "http://download.ni.com/".
-
-        enabled - New enabled state.
-
-        trusted - New trusted state. A trusted feed will not be
-        cryptographically verified by the package manager to be a safe and
-        secure source of packages. Feeds are not trusted by default. A system
-        administrator may have reason to trust the feed regardless.
-
-        Raises an nisyscfg.errors.LibraryError exception in the event of an
-        error.
-        """
-        error_code = self._library.ModifySoftwareFeed(
-            self._session,
-            c_string_encode(old_name),
-            c_string_encode(new_name),
-            c_string_encode(uri),
-            nisyscfg.enums.Bool(enabled),
-            nisyscfg.enums.Bool(trusted),
-        )
-        nisyscfg.errors.handle_error(self, error_code)
-
-    def remove_software_feed(self, name: str):
-        """
-        Removes an existing software feed by name.
-
-        Note: This requires Secure Shell Server (sshd) to be enabled on the
-        target.
-
-        name - Name of the feed to remove. This feed must exist on the system.
-
-        Raises an nisyscfg.errors.LibraryError exception in the event of an
-        error.
-        """
-        error_code = self._library.RemoveSoftwareFeed(self._session, c_string_encode(name))
-        nisyscfg.errors.handle_error(self, error_code)
-
-    def install_all(
-        self, auto_restart: bool = True, deselect_conflicts: bool = True
-    ) -> InstallAllResult:
-        """
-        Installs software on a Real-Time system.
-
-        auto_restart - Restarts the system into install mode by default before
-        the operation is performed, and restarts back to a running state after
-        the operation is complete. If you choose not to restart automatically,
-        the operation will fail if the system is not already in install mode.
-
-        deselect_conflicts - Indicates whether to deselect conflicting software
-        components automatically. Select True to deselect the conflicting
-        software components. If False, installation will fail if the system
-        has conflicting software components.
-
-        Returns tuple (installed_components, broken_dependencies)
-
-            installed_components - An iterator to get information about each
-            component that was just installed.
-
-            broken_dependencies - An iterator to get a list of broken
-            dependencies, which are specific software components that cannot
-            operate without another software component installed.
-
-        Raises an nisyscfg.errors.LibraryError exception in the event of an
-        error.
-        """
-        installed_component_handle = nisyscfg.types.EnumSoftwareFeedHandle()
-        broken_dependency_handle = nisyscfg.types.EnumDependencyHandle()
-        error_code = self._library.InstallAll(
-            self._session,
-            auto_restart,
-            deselect_conflicts,
-            ctypes.pointer(installed_component_handle),
-            ctypes.pointer(broken_dependency_handle),
-        )
-        nisyscfg.errors.handle_error(self, error_code)
-
-        result = InstallAllResult(
-            installed_components=nisyscfg.component_info.ComponentInfoIterator(
-                installed_component_handle
-            ),
-            broken_dependencies=nisyscfg.dependency_info.DependencyInfoIterator(
-                broken_dependency_handle
-            ),
-        )
-
-        self._children.append(result.installed_components)
-        self._children.append(result.broken_dependencies)
-
-        return result
-
-    def uninstall_all(self, auto_restart: bool = True):
-        """
-        Uninstalls all software from a specified system.
-
-        auto_restart - Restarts the system before and/or after the operation as
-        required by the target's boot flow. The operation will fail if you
-        choose not to restart the target automatically and the target's boot
-        flow requires it to be in safe mode or restart after the operation.
-
-        Raises an nisyscfg.errors.LibraryError exception in the event of an
-        error.
-        """
-        error_code = self._library.UninstallAll(self._session, auto_restart)
-        nisyscfg.errors.handle_error(self, error_code)
-
-    def _install_uninstall(
-        self,
-        components_to_install: Union[None, List[str]] = None,
-        components_to_uninstall: Union[None, List[str]] = None,
-        auto_restart: bool = True,
-        auto_select_dependencies: bool = True,
-        auto_select_recommends: bool = True,
-        item_types: nisyscfg.enums.IncludeComponentTypes = nisyscfg.enums.IncludeComponentTypes.ALL_VISIBLE,
-    ) -> nisyscfg.dependency_info.DependencyInfoIterator:
-        """
-        Allows you to install components, uninstall components, or both install
-        and uninstall components simultaneously (as long as two components do
-        not overlap each other).
-
-        components_to_install - List of software components IDs or titles to
-        install.
-
-        components_to_uninstall - List of software components IDs to remove.
-
-        auto_restart - Restarts the system into install mode by default before
-        the operation is performed, and restarts back to a running state after
-        the operation is complete. If you choose not to restart automatically,
-        the operation will fail if the system is not already in install mode.
-
-        auto_select_dependencies - Specifies whether to automatically select
-        software components that are required by the software you have
-        specified to install.
-
-        auto_select_recommends - Specifies whether to automatically select
-        recommended packages.
-
-        Returns tuple  An iterator to get a list of broken dependencies, which
-        are specific software components that cannot operate without another
-        software component installed.
-
-        item_types - Allows inclusion of hidden software installed on the target
-        when ALL_VISIBLE_AND_HIDDEN is selected. Hidden software is not listed
-        by default.
-        ====================== =================================================
-        Item Types             Description
-        ---------------------- -------------------------------------------------
-        ALL_VISIBLE            Specifies to return all visible software
-                               components. This includes all standard, startup,
-                               and essential components.
-        ALL_VISIBLE_AND_HIDDEN Specifies to return all visible and hidden
-                               software components.
-        ONLY_STANDARD          Specifies to only return standard software
-                               components.
-        ONLY_STARTUP           Specifies to only return components that are
-                               startup applications.
-        ====================== =================================================
-
-        Returns An iterator to get a list of broken dependencies, which are
-        specific software components that cannot operate without another
-        software component installed.
-
-        Raises an nisyscfg.errors.LibraryError exception in the event of an
-        error.
-        """
-        software_to_install = nisyscfg.component_info.EnumSoftwareComponent()
-
-        if components_to_install:
-            for component_name in components_to_install:
-                component = self._get_latest_component(component_name, item_types)
-                software_to_install.add_component(
-                    component.id,
-                    component.version,
-                    nisyscfg.enums.VersionSelectionMode.EXACT,
-                )
-
-        if components_to_uninstall:
-            c_components_to_uninstall = (ctypes.c_char_p * len(components_to_uninstall))(
-                *map(c_string_encode, components_to_uninstall)
-            )
-        else:
-            c_components_to_uninstall = (ctypes.c_char_p * 0)()
-
-        broken_dependency_handle = nisyscfg.types.EnumDependencyHandle()
-
-        error_code = self._library.InstallUninstallComponents2(
-            self._session,
-            auto_restart,
-            auto_select_dependencies,
-            auto_select_recommends,
-            software_to_install._handle,
-            len(c_components_to_uninstall),
-            ctypes.cast(c_components_to_uninstall, ctypes.POINTER(ctypes.POINTER(ctypes.c_char))),
-            ctypes.pointer(broken_dependency_handle),
-        )
-        nisyscfg.errors.handle_error(self, error_code)
-
-        broken_dependencies = nisyscfg.dependency_info.DependencyInfoIterator(
-            broken_dependency_handle
-        )
-        self._children.append(broken_dependencies)
-
-        return broken_dependencies
-
-    def install(
-        self,
-        components: Union[None, List[str]] = None,
-        auto_restart: bool = True,
-        auto_select_dependencies: bool = True,
-        auto_select_recommends: bool = True,
-        item_types: nisyscfg.enums.IncludeComponentTypes = nisyscfg.enums.IncludeComponentTypes.ALL_VISIBLE,
-    ) -> nisyscfg.dependency_info.DependencyInfoIterator:
-        """
-        Allows you to install components.
-
-        components - List of software components IDs or titles to install.
-
-        auto_restart - Restarts the system into install mode by default before
-        the operation is performed, and restarts back to a running state after
-        the operation is complete. If you choose not to restart automatically,
-        the operation will fail if the system is not already in install mode.
-
-        auto_select_dependencies - Specifies whether to automatically select
-        software components that are required by the software you have
-        specified to install.
-
-        auto_select_recommends - Specifies whether to automatically select
-        recommended packages.
-
-        Returns tuple  An iterator to get a list of broken dependencies, which
-        are specific software components that cannot operate without another
-        software component installed.
-
-        item_types - Allows inclusion of hidden software installed on the target
-        when ALL_VISIBLE_AND_HIDDEN is selected. Hidden software is not listed
-        by default.
-        ====================== =================================================
-        Item Types             Description
-        ---------------------- -------------------------------------------------
-        ALL_VISIBLE            Specifies to return all visible software
-                               components. This includes all standard, startup,
-                               and essential components.
-        ALL_VISIBLE_AND_HIDDEN Specifies to return all visible and hidden
-                               software components.
-        ONLY_STANDARD          Specifies to only return standard software
-                               components.
-        ONLY_STARTUP           Specifies to only return components that are
-                               startup applications.
-        ====================== =================================================
-
-        Returns An iterator to get a list of broken dependencies, which are
-        specific software components that cannot operate without another
-        software component installed.
-
-        Raises an nisyscfg.errors.LibraryError exception in the event of an
-        error.
-        """
-        return self._install_uninstall(
-            components_to_install=components,
-            auto_restart=auto_restart,
-            auto_select_dependencies=auto_select_dependencies,
-            auto_select_recommends=auto_select_recommends,
-            item_types=item_types,
-        )
-
-    def uninstall(
-        self,
-        components: Union[None, List[str]] = None,
-        auto_restart: bool = True,
-        auto_select_dependencies: bool = True,
-        auto_select_recommends: bool = True,
-        item_types: nisyscfg.enums.IncludeComponentTypes = nisyscfg.enums.IncludeComponentTypes.ALL_VISIBLE,
-    ) -> nisyscfg.dependency_info.DependencyInfoIterator:
-        """
-        Allows you to uninstall components.
-
-        components - List of software components IDs to remove.
-
-        auto_restart - Restarts the system into install mode by default before
-        the operation is performed, and restarts back to a running state after
-        the operation is complete. If you choose not to restart automatically,
-        the operation will fail if the system is not already in install mode.
-
-        auto_select_dependencies - Specifies whether to automatically select
-        software components that are required by the software you have
-        specified to install.
-
-        auto_select_recommends - Specifies whether to automatically select
-        recommended packages.
-
-        Returns tuple  An iterator to get a list of broken dependencies, which
-        are specific software components that cannot operate without another
-        software component installed.
-
-        item_types - Allows inclusion of hidden software installed on the target
-        when ALL_VISIBLE_AND_HIDDEN is selected. Hidden software is not listed
-        by default.
-        ====================== =================================================
-        Item Types             Description
-        ---------------------- -------------------------------------------------
-        ALL_VISIBLE            Specifies to return all visible software
-                               components. This includes all standard, startup,
-                               and essential components.
-        ALL_VISIBLE_AND_HIDDEN Specifies to return all visible and hidden
-                               software components.
-        ONLY_STANDARD          Specifies to only return standard software
-                               components.
-        ONLY_STARTUP           Specifies to only return components that are
-                               startup applications.
-        ====================== =================================================
-
-        Returns An iterator to get a list of broken dependencies, which are
-        specific software components that cannot operate without another
-        software component installed.
-
-        Raises an nisyscfg.errors.LibraryError exception in the event of an
-        error.
-        """
-        return self._install_uninstall(
-            components_to_uninstall=components,
-            auto_restart=auto_restart,
-            auto_select_dependencies=auto_select_dependencies,
-            auto_select_recommends=auto_select_recommends,
-            item_types=item_types,
-        )
-
-    def _get_latest_component(
-        self,
-        component_name: str,
-        item_types: nisyscfg.enums.IncludeComponentTypes = nisyscfg.enums.IncludeComponentTypes.ALL_VISIBLE,
-    ) -> nisyscfg.component_info.ComponentInfo:
-        components = [
-            component
-            for component in self.get_available_software_components(item_types)
-            if (component.title == component_name) or (component.id == component_name)
-        ]
-
-        if not components:
-            raise nisyscfg.errors.Error(
-                'Component "{component_name}" not available for install on target "{self.target_name}".'.format(
-                    component_name=component_name, self=self
-                )
-            )
-
-        return max(components, key=lambda comp: comp.version.split("."))
-
-    def get_software_feeds(self) -> nisyscfg.software_feed.SoftwareFeedIterator:
-        """
-        Retrieves a list of configured software feeds. A feed represents a
-        location that the package manager uses to find and download available
-        software.
-
-        Note: This requires Secure Shell Server (sshd) to be enabled on the
-        target.
-
-        Raises an nisyscfg.errors.LibraryError exception in the event of an
-        error.
-        """
-        software_feed_handle = nisyscfg.types.EnumSoftwareFeedHandle()
-        error_code = self._library.GetSoftwareFeeds(
-            self._session, ctypes.pointer(software_feed_handle)
-        )
-        nisyscfg.errors.handle_error(self, error_code)
-        if software_feed_handle:
-            iter = nisyscfg.software_feed.SoftwareFeedIterator(software_feed_handle)
-            self._children.append(iter)
-            return iter
-
-    @property
-    def resource(self) -> nisyscfg.hardware_resource.HardwareResource:
-        """System resource properties"""
-        if not hasattr(self, "_resource"):
-            resource_handle = self._get_property(16941086, nisyscfg.types.ResourceHandle)
-            self._resource = nisyscfg.hardware_resource.HardwareResource(resource_handle)
-            self._children.append(self._resource)
-        return self._resource
-
-    def _get_property(self, id, c_type):
-        if c_type == ctypes.c_char_p:
-            value = nisyscfg.types.simple_string()
-            value_arg = value
-        elif issubclass(c_type, nisyscfg.enums.BaseEnum):
-            value = ctypes.c_int()
-            value_arg = ctypes.pointer(value)
-        else:
-            value = c_type(0)
-            value_arg = ctypes.pointer(value)
-
-        error_code = self._library.GetSystemProperty(self._session, id, value_arg)
-        nisyscfg.errors.handle_error(self, error_code)
-
-        if issubclass(c_type, nisyscfg.enums.BaseEnum):
-            return c_type(value.value)
-
-        if issubclass(c_type, ctypes.c_void_p):
-            return value
-
-        return c_string_decode(value.value)
-
-    def _set_property(self, id, value, c_type, nisyscfg_type):
-        if c_type == ctypes.c_char_p:
-            value = c_string_encode(value)
-        elif issubclass(c_type, nisyscfg.enums.BaseEnum):
-            value = ctypes.c_int(value)
-        else:
-            value = c_type(value)
-
-        error_code = self._library.SetSystemProperty(self._session, id, value)
-        nisyscfg.errors.handle_error(self, error_code)
-
-    def save_changes(self) -> SaveChangesResult:
-        """
-        Saves changes made to systems.
-
-        Returns tuple (restart_required, details)
-
-            restart_required - Specifies whether the changes require a reboot.
-            If TRUE, call restart().
-
-            details - A string containing results of any errors that may have
-            occurred during execution.
-
-        Raises an nisyscfg.errors.LibraryError exception in the event of an
-        error.
-        """
-        restart_required = ctypes.c_int()
-        c_details = ctypes.POINTER(ctypes.c_char)()
-        error_code = self._library.SaveSystemChanges(
-            self._session, restart_required, ctypes.pointer(c_details)
-        )
-        if c_details:
-            details = c_string_decode(ctypes.cast(c_details, ctypes.c_char_p).value)
-            error_code_2 = self._library.FreeDetailedString(c_details)
-        nisyscfg.errors.handle_error(self, error_code)
-        nisyscfg.errors.handle_error(self, error_code_2)
-        return SaveChangesResult(restart_required=restart_required.value != 0, details=details)
+import ctypes
+
+import nisyscfg
+import nisyscfg._library_singleton
+import nisyscfg.component_info
+import nisyscfg.dependency_info
+import nisyscfg.expert_info
+import nisyscfg.filter
+import nisyscfg.hardware_resource
+import nisyscfg.properties
+import nisyscfg.pxi.properties
+import nisyscfg.software_feed
+import nisyscfg.system_info
+import nisyscfg.xnet.properties
+
+from nisyscfg._lib import c_string_decode
+from nisyscfg._lib import c_string_encode
+
+from typing import List, NamedTuple, Union
+
+
+InstallAllResult = NamedTuple(
+    "InstallAllResult",
+    [
+        ("installed_components", nisyscfg.component_info.ComponentInfoIterator),
+        ("broken_dependencies", nisyscfg.dependency_info.DependencyInfoIterator),
+    ],
+)
+
+SaveChangesResult = NamedTuple(
+    "SaveChangesResult",
+    [
+        ("restart_required", bool),
+        ("details", str),
+    ],
+)
+
+
+@nisyscfg.properties.PropertyBag(nisyscfg.properties.System)
+class Session(object):
+    """
+    Initializes a system configuration session with a specific system.
+
+    This function communicates to the device at the specified address. If the
+    device is no longer online, but it has previously been discovered in
+    Measurement & Automation Explorer (MAX), this function succeeds, allowing
+    you to retrieve cached information about the device.
+
+    target - Specifies the IP address (ex. "224.102.13.24" ), MAC address
+    (ex. "00:80:12:34:56:AB" ), or DNS name (ex. "myhost" ) of the target on a
+    local or Real-Time system. The target defaults to the local system. Values
+    such as a None, an empty string, and the strings localhost or 127.0.0.1
+    also mean the local system.
+
+    username - Specifies the username for the system you are initializing.
+    Leave this parameter None if your target is running LabWindows/CVI 2009
+    Real-Time Module or earlier or if you are connecting to the local
+    system.
+
+    password - Specifies the password for the system you are initializing.
+    Leave this parameter None if no password has been set or if you are
+    connecting to the local system.
+
+    language - Specifies the language.
+    ================== =========================================================
+    Language           Description
+    ------------------ ---------------------------------------------------------
+    DEFAULT            Automatically chooses the language based on local
+                       Windows settings.
+    ENGLISH            English
+    FRENCH             French
+    GERMAN             German
+    JAPANESE           Japanese
+    KOREAN             Korean
+    CHINESE_SIMPLIFIED Simplified Chinese
+    ================== =========================================================
+
+    force_property_refresh - Forces properties to be refreshed every time they
+    are read by default. If FALSE, properties are queried once and cached in
+    memory, which can optimize performance.
+
+    timeout - Specifies the time, in seconds, that the function waits before the
+    operation times out. When the operation succeeds, the session handle that is
+    returned is set to the default, which is defined as 300 (5 minutes).
+
+    Raises an nisyscfg.errors.LibraryError exception in the event of an error.
+    """
+
+    def __init__(
+        self,
+        target: Union[None, str] = None,
+        username: Union[None, str] = None,
+        password: Union[None, str] = None,
+        language: nisyscfg.enums.Locale = nisyscfg.enums.Locale.DEFAULT,
+        force_property_refresh: bool = True,
+        timeout: float = 300.0,
+    ) -> None:
+        self._children = []
+        self._session = nisyscfg.types.SessionHandle()
+        self._library = nisyscfg._library_singleton.get()
+        self._property_accessor = nisyscfg.properties.PropertyAccessor(
+            setter=self._set_property,
+            getter=self._get_property,
+        )
+        error_code = self._library.InitializeSession(
+            c_string_encode(target),
+            c_string_encode(username),
+            c_string_encode(password),
+            language,
+            force_property_refresh,
+            int(timeout * 1000),
+            None,  # expert_enum_handle
+            ctypes.pointer(self._session),
+        )
+        nisyscfg.errors.handle_error(self, error_code)
+        self.target_name = target
+
+    def __del__(self):
+        self.close()
+
+    def __enter__(self):
+        return self
+
+    def __exit__(self, type, value, traceback):
+        self.close()
+
+    def _get_status_description(self, status):
+        c_detailed_description = ctypes.POINTER(ctypes.c_char)()
+        error_code = self._library.GetStatusDescription(
+            self._session, status, ctypes.pointer(c_detailed_description)
+        )
+        if c_detailed_description:
+            detailed_description = c_string_decode(
+                ctypes.cast(c_detailed_description, ctypes.c_char_p).value
+            )
+            error_code_2 = self._library.FreeDetailedString(c_detailed_description)
+        nisyscfg.errors.handle_error(self, error_code, is_error_handling=True)
+        nisyscfg.errors.handle_error(self, error_code_2, is_error_handling=True)
+        return detailed_description
+
+    def close(self):
+        """
+        Closes references to previously allocated session, filters, resources,
+        and enumerators.
+
+        Raises an nisyscfg.errors.LibraryError exception in the event of an
+        error.
+        """
+        self._children.reverse()
+        for child in self._children:
+            child.close()
+        if self._session:
+            error_code = self._library.CloseHandle(self._session)
+            nisyscfg.errors.handle_error(self, error_code)
+            self._session = None
+
+    def get_system_experts(self, expert_names: str = "") -> nisyscfg.expert_info.ExpertInfoIterator:
+        """
+        Returns the experts available on the system.
+
+        expert_names - This is a case-insensitive comma-separated string
+        specifying which experts to query. If None or empty string, all
+        supported experts are queried.
+
+        Raises an nisyscfg.errors.LibraryError exception in the event of an
+        error.
+        """
+        expert_handle = nisyscfg.types.EnumExpertHandle()
+        if isinstance(expert_names, list):
+            expert_names = ",".join(expert_names)
+        error_code = self._library.GetSystemExperts(
+            self._session, c_string_encode(expert_names), ctypes.pointer(expert_handle)
+        )
+        nisyscfg.errors.handle_error(self, error_code)
+        iter = nisyscfg.expert_info.ExpertInfoIterator(expert_handle)
+        self._children.append(iter)
+        return iter
+
+    def find_hardware(
+        self,
+        filter: Union[None, nisyscfg.filter.Filter] = None,
+        mode: nisyscfg.enums.FilterMode = nisyscfg.enums.FilterMode.MATCH_VALUES_ALL,
+        expert_names: str = "",
+    ) -> nisyscfg.hardware_resource.HardwareResourceIterator:
+        """
+        Returns an iterator of hardware in a specified system.
+
+        filter - Specifies a filter you can use to limit the results to hardware
+        matching specific properties. The default is no filter.
+
+        mode - The enumerated list of filter modes.
+        ==================== ===================================================
+        Mode                 Description
+        -------------------- ---------------------------------------------------
+        MATCH_VALUES_ALL     (default) includes all of the properties specified
+                             in the input filter.
+        MATCH_VALUES_ANY     includes any of the properties specified in the
+                             input filter.
+        MATCH_VALUES_NONE    includes none of the properties specified in the
+                             input filter.
+        ALL_PROPERTIES_EXIST includes all of the properties specified in the
+                             input filter, regardless of the value of each
+                             property.
+        ==================== ===================================================
+
+        expert_names - This is a case-insensitive comma-separated string
+        specifying which experts to query. If None or empty-string, all
+        supported experts are queried.
+
+        Raises an nisyscfg.errors.LibraryError exception in the event of an
+        error.
+        """
+        if filter is None:
+
+            class DummyFilter(object):
+                _handle = None
+
+            filter = DummyFilter()
+        resource_handle = nisyscfg.types.EnumResourceHandle()
+        if isinstance(expert_names, list):
+            expert_names = ",".join(expert_names)
+        error_code = self._library.FindHardware(
+            self._session,
+            mode,
+            filter._handle,
+            c_string_encode(expert_names),
+            ctypes.pointer(resource_handle),
+        )
+        nisyscfg.errors.handle_error(self, error_code)
+        iter = nisyscfg.hardware_resource.HardwareResourceIterator(self._session, resource_handle)
+        self._children.append(iter)
+        return iter
+
+    def find_systems(
+        self,
+        device_class: str = "",
+        detect_online_systems: bool = True,
+        cache_mode: nisyscfg.enums.IncludeCachedResults = nisyscfg.enums.IncludeCachedResults.NONE,
+        find_output_mode: nisyscfg.enums.SystemNameFormat = nisyscfg.enums.SystemNameFormat.HOSTNAME_IP,
+        timeout: float = 4.0,
+        only_installable_systems: bool = False,
+    ) -> nisyscfg.system_info.SystemInfoIterator:
+        """
+        Retrieves systems on the network.
+
+        device_class - Specifies the class of device for which you are
+        searching. Common values are "PXI" and "cRIO". To specify multiple
+        classes, use a comma to separate the values.
+
+        detect_online_systems - Detects systems that are online. This option
+        checks for all local online systems by default. You must set this
+        parameter to TRUE on Real-Time targets. On Windows operating systems,
+        set this parameter to FALSE if you only want to return previously
+        detected results.
+
+        cache_mode - Specifies whether to include cached results.
+        ============== =========================================================
+        Mode           Description
+        -------------- ---------------------------------------------------------
+        NONE           Only return systems discovered from a new scan. If you
+                       have added a system on a remote subnet to MAX, using
+                       NONE for the cached input will not return that system
+                       because it cannot be detected on the local subnet.
+        ONLY_IF_ONLINE Include previously discovered systems if they are online.
+        ALL            Include all previously discovered systems (default).
+        ============== =========================================================
+
+        find_output_mode - Specifies the "preferred" output format of hostname
+        and IP addresses for systems on the network. The Initialize function
+        accepts all of these formats.
+        ============ ===========================================================
+        Mode         Description
+        ------------ -----------------------------------------------------------
+        HOSTNAME     Includes only the hostname.
+        HOSTNAME_IP  (default) Includes both the hostname and IP address.
+        HOSTNAME_MAC Includes both the hostname and MAC address.
+        IP           Includes only the IP address.
+        IP_HOSTNAME  Includes both the IP address and hostname.
+        IP_MAC       Includes both the IP address and MAC address.
+        MAC          Includes only the MAC address.
+        MAC_HOSTNAME Includes both the MAC address and hostname.
+        MAC_IP       Includes both the MAC address and the IP address.
+        ============ ===========================================================
+        Note: In some cases this parameter may return a system that is not in
+        the requested format. For example, if you request the default
+        HOSTNAME_IP but an unconfigured system is detected, that system is
+        returned as IP_MAC.
+
+        timeout - The time, in seconds, the function waits before it times out.
+        The default is 4 s. In some cases, the operation may take longer to
+        time out.
+
+        only_installable_systems - Detects only the systems that support the
+        ability to install software remotely. This includes all Real-Time
+        systems.
+
+        Returns an interator that yields the system names in the format
+        requested from the input parameter
+
+        Raises an nisyscfg.errors.LibraryError exception in the event of an
+        error.
+        """
+        system_handle = nisyscfg.types.EnumSystemHandle()
+        error_code = self._library.FindSystems(
+            self._session,
+            c_string_encode(device_class),
+            nisyscfg.enums.Bool(detect_online_systems),
+            cache_mode,
+            find_output_mode,
+            int(timeout * 1000),
+            nisyscfg.enums.Bool(only_installable_systems),
+            ctypes.pointer(system_handle),
+        )
+        nisyscfg.errors.handle_error(self, error_code)
+
+        return nisyscfg.system_info.SystemInfoIterator(system_handle)
+
+    def create_filter(self) -> nisyscfg.filter.Filter:
+        """
+        Creates a hardware filter object that is used to query for specific
+        resources in a system. After creating a filter, set one or more
+        properties to limit the set of  detected resources.
+
+        Raises an nisyscfg.errors.LibraryError exception in the event of an
+        error.
+        """
+        filter = nisyscfg.filter.Filter(self._session)
+        self._children.append(filter)
+        return filter
+
+    def restart(
+        self,
+        sync_call: bool = True,
+        install_mode: bool = False,
+        flush_dns: bool = False,
+        timeout: float = 90.0,
+    ) -> str:
+        """
+        Reboots a system or network device.
+
+        sync_call - Waits until the reboot has finished before the function
+        operation is completed, by default. Select FALSE to not wait until the
+        reboot is finished before the function completes its operation.
+
+        install_mode - Does not reboot the system into install mode by default.
+        To reboot into install mode, select TRUE. The default is FALSE, reboot
+        into normal mode.
+
+        flush_dns - Does not clear the DNS cache by default. DNS clients
+        temporarily store system hostnames. Flushing the DNS allows you to clear
+        those names from memory. This parameter applies to the local Windows
+        system.
+
+        timeout - The time, in seconds, that the function waits to establish a
+        connection before it returns an error. The default is 90 s.
+
+        Returns the new IP address of the rebooted system. This IP address may
+        differ from the previous IP address if the system acquires a different
+        IP address from the DHCP server.
+
+        Raises an nisyscfg.errors.LibraryError exception in the event of an
+        error.
+        """
+        new_ip_address = nisyscfg.types.simple_string()
+        error_code = self._library.Restart(
+            self._session,
+            sync_call,
+            install_mode,
+            flush_dns,
+            int(timeout * 1000),
+            new_ip_address,
+        )
+        nisyscfg.errors.handle_error(self, error_code)
+        return c_string_decode(new_ip_address.value)
+
+    def get_filtered_base_system_images(
+        self,
+        repository_path: Union[None, str] = None,
+        device_class: Union[None, str] = None,
+        os: Union[None, str] = None,
+        product_id: int = 0,
+    ) -> nisyscfg.component_info.ComponentInfoIterator:
+        """
+        Retrieves a collection of base system images available from a
+        repository path.
+
+        These include a base operating system and are intended to be used
+        with format().
+
+        repository_path - Specifies the location that contains installable
+        components.
+
+        device_class - Specifies the type of device for which you are
+        searching. Common values are PXI and cRIO. To specify multiple classes,
+        use a comma to separate the values.
+
+        os - Specifies the operating system.
+
+        product_id - Specifies the bus-specific product identifier code. This
+        is not the product's sellable model number.
+
+        Raises an nisyscfg.errors.LibraryError exception in the event of an
+        error.
+        """
+        software_component_handle = nisyscfg.types.EnumSoftwareComponentHandle()
+        error_code = self._library.GetFilteredBaseSystemImages(
+            c_string_encode(repository_path),
+            c_string_encode(device_class),
+            c_string_encode(os),
+            ctypes.c_uint(product_id),
+            ctypes.pointer(software_component_handle),
+        )
+        nisyscfg.errors.handle_error(self, error_code)
+        if software_component_handle:
+            iter = nisyscfg.component_info.ComponentInfoIterator(software_component_handle)
+            self._children.append(iter)
+            return iter
+
+    def format(
+        self,
+        auto_restart: bool = True,
+        file_system: nisyscfg.enums.FileSystemMode = nisyscfg.enums.FileSystemMode.DEFAULT,
+        network_settings: nisyscfg.enums.NetworkInterfaceSettings = nisyscfg.enums.NetworkInterfaceSettings.RESET_PRIMARY_RESET_OTHERS,
+        system_image_id: Union[None, str] = None,
+        system_image_version: Union[None, str] = None,
+        timeout: float = 90.0,
+    ) -> None:
+        """
+        Erases all data from the primary hard drive of a system and formats it
+        with the base system image, network settings, and filesystem specified.
+        The operation will fail if you choose not to restart the target
+        automatically and the target's boot flow requires it to be in safe mode
+        or restart after the operation. Refer to the the definition of safe
+        mode to understand the differences between safe mode for different
+        target boot flows. This function can only be used to format Real-Time
+        systems.
+
+        auto_restart - Restarts the system before and/or after the operation as
+        required by the target's boot flow. The operation will fail if you
+        choose not to restart the target automatically and the target's boot
+        flow requires it to be in safe mode or restart after the operation.
+
+        file_system - Formats the primary hard drive into a user-selected file
+        system. Not all systems support all modes.
+        ========= ==============================================================
+        Mode      Description
+        --------- --------------------------------------------------------------
+        DEFAULT   Formats the hard drive into the default format. The default
+                  is whatever format the existing target is already in.
+        FAT       Formats the hard drive with the File Allocation Table (FAT)
+                  file system.
+        RELIANCE  Formats the hard drive with the Reliance file system. Reliance
+                  is a transactional file system, developed by Datalight, that
+                  is tolerant to crashes and power interruptions.
+        UBIFS     Formats the hard drive with the Unsorted Block Image File
+                  System (UBIFS).
+        EXT4      Formats the hard drive with the Ext4 file system.
+        ========= ==============================================================
+
+        network_settings - Resets the primary network adapter and disables
+        secondary adapters by default.
+        ================================ =======================================
+        Mode                             Description
+        -------------------------------- ---------------------------------------
+        RESET_PRIMARY_RESET_OTHERS       Resets the primary network adapter to
+                                         factory settings and disables all other
+                                         network adapters.
+        PRESERVE_PRIMARY_RESET_OTHERS    Preserves the existing settings on the
+                                         primary network adapter and disables
+                                         all other network adapters. This option
+                                         may not be supported for targets on a
+                                         remote subnet.
+        PRESERVE_PRIMARY_PRESERVE_OTHERS Preserves the settings for all network
+                                         adapters. This option may not be
+                                         supported for targets on a remote
+                                         subnet.
+        ================================ =======================================
+
+        system_image_id - The system image ID.
+
+        system_image_version - The system image version.
+
+        timeout - The time, in seconds, that the function waits for the format
+        to time out. The default is 90 s. If restart after format is TRUE, the
+        default increases by 90 s. If the system is not in safe mode, the
+        default increases by another 90 s.
+
+        Raises an nisyscfg.errors.LibraryError exception in the event of an
+        error.
+        """
+        error_code = self._library.FormatWithBaseSystemImage(
+            self._session,
+            nisyscfg.enums.Bool(auto_restart),
+            file_system,
+            network_settings,
+            c_string_encode(system_image_id),
+            c_string_encode(system_image_version),
+            ctypes.c_uint(int(timeout * 1000)),
+        )
+        nisyscfg.errors.handle_error(self, error_code)
+
+    def get_available_software_components(
+        self,
+        item_types: nisyscfg.enums.IncludeComponentTypes = nisyscfg.enums.IncludeComponentTypes.ALL_VISIBLE,
+    ) -> nisyscfg.component_info.ComponentInfoIterator:
+        """
+        Retrieves a list of software components on the local system that are
+        available for installation to the specified target.
+
+        item_types - Allows inclusion of hidden software installed on the target
+        when ALL_VISIBLE_AND_HIDDEN is selected. Hidden software is not listed
+        by default.
+        ====================== =================================================
+        Item Types             Description
+        ---------------------- -------------------------------------------------
+        ALL_VISIBLE            Specifies to return all visible software
+                               components. This includes all standard, startup,
+                               and essential components.
+        ALL_VISIBLE_AND_HIDDEN Specifies to return all visible and hidden
+                               software components.
+        ONLY_STANDARD          Specifies to only return standard software
+                               components.
+        ONLY_STARTUP           Specifies to only return components that are
+                               startup applications.
+        ====================== =================================================
+
+        Raises an nisyscfg.errors.LibraryError exception in the event of an
+        error.
+        """
+        software_component_handle = nisyscfg.types.EnumSoftwareComponentHandle()
+        error_code = self._library.GetAvailableSoftwareComponents(
+            self._session, item_types, ctypes.pointer(software_component_handle)
+        )
+        nisyscfg.errors.handle_error(self, error_code)
+        if software_component_handle:
+            iter = nisyscfg.component_info.ComponentInfoIterator(software_component_handle)
+            self._children.append(iter)
+            return iter
+
+    def get_installed_software_components(
+        self,
+        item_types: nisyscfg.enums.IncludeComponentTypes = nisyscfg.enums.IncludeComponentTypes.ALL_VISIBLE,
+        cached: bool = False,
+    ) -> nisyscfg.component_info.ComponentInfoIterator:
+        """
+        Retrieves a list of software components installed on a system.
+
+        item_types - Allows inclusion of hidden software installed on the target
+        when ALL_VISIBLE_AND_HIDDEN is selected. Hidden software is not listed
+        by default.
+        ====================== =================================================
+        Item Types             Description
+        ---------------------- -------------------------------------------------
+        ALL_VISIBLE            Specifies to return all visible software
+                               components. This includes all standard, startup,
+                               and essential components.
+        ALL_VISIBLE_AND_HIDDEN Specifies to return all visible and hidden
+                               software components.
+        ONLY_STANDARD          Specifies to only return standard software
+                               components.
+        ONLY_STARTUP           Specifies to only return components that are
+                               startup applications.
+        ====================== =================================================
+
+        cached - Returns information that has already been read from the
+        specified real-time system if TRUE. The system is contacted again for
+        the information by default.
+
+        Raises an nisyscfg.errors.LibraryError exception in the event of an
+        error.
+        """
+        software_component_handle = nisyscfg.types.EnumSoftwareComponentHandle()
+        error_code = self._library.GetInstalledSoftwareComponents(
+            self._session, item_types, cached, ctypes.pointer(software_component_handle)
+        )
+        nisyscfg.errors.handle_error(self, error_code)
+        if software_component_handle:
+            iter = nisyscfg.component_info.ComponentInfoIterator(software_component_handle)
+            self._children.append(iter)
+            return iter
+
+    def add_software_feed(self, name: str, uri: str, enabled: bool, trusted: bool) -> None:
+        """
+        Adds a software feed to the system.
+
+        Note: This requires Secure Shell Server (sshd) to be enabled on the
+        target.
+
+        name - Name of the feed for identification purposes.
+
+        uri - Location of the feed, such as "file://..." or "http://...". NI
+        feeds often start with "http://download.ni.com/".
+
+        enabled - Whether the feed is enabled.
+
+        trusted - Whether the feed is trusted. A trusted feed will not be
+        cryptographically verified by the package manager to be a safe and
+        secure source of packages. Feeds are not trusted by default. A system
+        administrator may have reason to trust the feed regardless.
+
+        Raises an nisyscfg.errors.LibraryError exception in the event of an
+        error.
+        """
+        error_code = self._library.AddSoftwareFeed(
+            self._session,
+            c_string_encode(name),
+            c_string_encode(uri),
+            nisyscfg.enums.Bool(enabled),
+            nisyscfg.enums.Bool(trusted),
+        )
+        nisyscfg.errors.handle_error(self, error_code)
+
+    def modify_software_feed(
+        self, old_name: str, new_name: str, uri: str, enabled: bool, trusted: bool
+    ) -> None:
+        """
+        Modifies an existing software feed by name.
+
+        Note: This requires Secure Shell Server (sshd) to be enabled on the
+        target.
+
+        old_name - Name of the feed to modify. This feed must exist on the system.
+
+        new_name - New name of the feed. This feed must not exist on the
+        system. If not specified, the feed name will remain unchanged.
+
+        uri - New location of the feed, such as "file://..." or "http://...".
+        NI feeds often start with "http://download.ni.com/".
+
+        enabled - New enabled state.
+
+        trusted - New trusted state. A trusted feed will not be
+        cryptographically verified by the package manager to be a safe and
+        secure source of packages. Feeds are not trusted by default. A system
+        administrator may have reason to trust the feed regardless.
+
+        Raises an nisyscfg.errors.LibraryError exception in the event of an
+        error.
+        """
+        error_code = self._library.ModifySoftwareFeed(
+            self._session,
+            c_string_encode(old_name),
+            c_string_encode(new_name),
+            c_string_encode(uri),
+            nisyscfg.enums.Bool(enabled),
+            nisyscfg.enums.Bool(trusted),
+        )
+        nisyscfg.errors.handle_error(self, error_code)
+
+    def remove_software_feed(self, name: str):
+        """
+        Removes an existing software feed by name.
+
+        Note: This requires Secure Shell Server (sshd) to be enabled on the
+        target.
+
+        name - Name of the feed to remove. This feed must exist on the system.
+
+        Raises an nisyscfg.errors.LibraryError exception in the event of an
+        error.
+        """
+        error_code = self._library.RemoveSoftwareFeed(self._session, c_string_encode(name))
+        nisyscfg.errors.handle_error(self, error_code)
+
+    def install_all(
+        self, auto_restart: bool = True, deselect_conflicts: bool = True
+    ) -> InstallAllResult:
+        """
+        Installs software on a Real-Time system.
+
+        auto_restart - Restarts the system into install mode by default before
+        the operation is performed, and restarts back to a running state after
+        the operation is complete. If you choose not to restart automatically,
+        the operation will fail if the system is not already in install mode.
+
+        deselect_conflicts - Indicates whether to deselect conflicting software
+        components automatically. Select True to deselect the conflicting
+        software components. If False, installation will fail if the system
+        has conflicting software components.
+
+        Returns tuple (installed_components, broken_dependencies)
+
+            installed_components - An iterator to get information about each
+            component that was just installed.
+
+            broken_dependencies - An iterator to get a list of broken
+            dependencies, which are specific software components that cannot
+            operate without another software component installed.
+
+        Raises an nisyscfg.errors.LibraryError exception in the event of an
+        error.
+        """
+        installed_component_handle = nisyscfg.types.EnumSoftwareFeedHandle()
+        broken_dependency_handle = nisyscfg.types.EnumDependencyHandle()
+        error_code = self._library.InstallAll(
+            self._session,
+            auto_restart,
+            deselect_conflicts,
+            ctypes.pointer(installed_component_handle),
+            ctypes.pointer(broken_dependency_handle),
+        )
+        nisyscfg.errors.handle_error(self, error_code)
+
+        result = InstallAllResult(
+            installed_components=nisyscfg.component_info.ComponentInfoIterator(
+                installed_component_handle
+            ),
+            broken_dependencies=nisyscfg.dependency_info.DependencyInfoIterator(
+                broken_dependency_handle
+            ),
+        )
+
+        self._children.append(result.installed_components)
+        self._children.append(result.broken_dependencies)
+
+        return result
+
+    def uninstall_all(self, auto_restart: bool = True):
+        """
+        Uninstalls all software from a specified system.
+
+        auto_restart - Restarts the system before and/or after the operation as
+        required by the target's boot flow. The operation will fail if you
+        choose not to restart the target automatically and the target's boot
+        flow requires it to be in safe mode or restart after the operation.
+
+        Raises an nisyscfg.errors.LibraryError exception in the event of an
+        error.
+        """
+        error_code = self._library.UninstallAll(self._session, auto_restart)
+        nisyscfg.errors.handle_error(self, error_code)
+
+    def _install_uninstall(
+        self,
+        components_to_install: Union[None, List[str]] = None,
+        components_to_uninstall: Union[None, List[str]] = None,
+        auto_restart: bool = True,
+        auto_select_dependencies: bool = True,
+        auto_select_recommends: bool = True,
+        item_types: nisyscfg.enums.IncludeComponentTypes = nisyscfg.enums.IncludeComponentTypes.ALL_VISIBLE,
+    ) -> nisyscfg.dependency_info.DependencyInfoIterator:
+        """
+        Allows you to install components, uninstall components, or both install
+        and uninstall components simultaneously (as long as two components do
+        not overlap each other).
+
+        components_to_install - List of software components IDs or titles to
+        install.
+
+        components_to_uninstall - List of software components IDs to remove.
+
+        auto_restart - Restarts the system into install mode by default before
+        the operation is performed, and restarts back to a running state after
+        the operation is complete. If you choose not to restart automatically,
+        the operation will fail if the system is not already in install mode.
+
+        auto_select_dependencies - Specifies whether to automatically select
+        software components that are required by the software you have
+        specified to install.
+
+        auto_select_recommends - Specifies whether to automatically select
+        recommended packages.
+
+        Returns tuple  An iterator to get a list of broken dependencies, which
+        are specific software components that cannot operate without another
+        software component installed.
+
+        item_types - Allows inclusion of hidden software installed on the target
+        when ALL_VISIBLE_AND_HIDDEN is selected. Hidden software is not listed
+        by default.
+        ====================== =================================================
+        Item Types             Description
+        ---------------------- -------------------------------------------------
+        ALL_VISIBLE            Specifies to return all visible software
+                               components. This includes all standard, startup,
+                               and essential components.
+        ALL_VISIBLE_AND_HIDDEN Specifies to return all visible and hidden
+                               software components.
+        ONLY_STANDARD          Specifies to only return standard software
+                               components.
+        ONLY_STARTUP           Specifies to only return components that are
+                               startup applications.
+        ====================== =================================================
+
+        Returns An iterator to get a list of broken dependencies, which are
+        specific software components that cannot operate without another
+        software component installed.
+
+        Raises an nisyscfg.errors.LibraryError exception in the event of an
+        error.
+        """
+        software_to_install = nisyscfg.component_info.EnumSoftwareComponent()
+
+        if components_to_install:
+            for component_name in components_to_install:
+                component = self._get_latest_component(component_name, item_types)
+                software_to_install.add_component(
+                    component.id,
+                    component.version,
+                    nisyscfg.enums.VersionSelectionMode.EXACT,
+                )
+
+        if components_to_uninstall:
+            c_components_to_uninstall = (ctypes.c_char_p * len(components_to_uninstall))(
+                *map(c_string_encode, components_to_uninstall)
+            )
+        else:
+            c_components_to_uninstall = (ctypes.c_char_p * 0)()
+
+        broken_dependency_handle = nisyscfg.types.EnumDependencyHandle()
+
+        error_code = self._library.InstallUninstallComponents2(
+            self._session,
+            auto_restart,
+            auto_select_dependencies,
+            auto_select_recommends,
+            software_to_install._handle,
+            len(c_components_to_uninstall),
+            ctypes.cast(c_components_to_uninstall, ctypes.POINTER(ctypes.POINTER(ctypes.c_char))),
+            ctypes.pointer(broken_dependency_handle),
+        )
+        nisyscfg.errors.handle_error(self, error_code)
+
+        broken_dependencies = nisyscfg.dependency_info.DependencyInfoIterator(
+            broken_dependency_handle
+        )
+        self._children.append(broken_dependencies)
+
+        return broken_dependencies
+
+    def install(
+        self,
+        components: Union[None, List[str]] = None,
+        auto_restart: bool = True,
+        auto_select_dependencies: bool = True,
+        auto_select_recommends: bool = True,
+        item_types: nisyscfg.enums.IncludeComponentTypes = nisyscfg.enums.IncludeComponentTypes.ALL_VISIBLE,
+    ) -> nisyscfg.dependency_info.DependencyInfoIterator:
+        """
+        Allows you to install components.
+
+        components - List of software components IDs or titles to install.
+
+        auto_restart - Restarts the system into install mode by default before
+        the operation is performed, and restarts back to a running state after
+        the operation is complete. If you choose not to restart automatically,
+        the operation will fail if the system is not already in install mode.
+
+        auto_select_dependencies - Specifies whether to automatically select
+        software components that are required by the software you have
+        specified to install.
+
+        auto_select_recommends - Specifies whether to automatically select
+        recommended packages.
+
+        Returns tuple  An iterator to get a list of broken dependencies, which
+        are specific software components that cannot operate without another
+        software component installed.
+
+        item_types - Allows inclusion of hidden software installed on the target
+        when ALL_VISIBLE_AND_HIDDEN is selected. Hidden software is not listed
+        by default.
+        ====================== =================================================
+        Item Types             Description
+        ---------------------- -------------------------------------------------
+        ALL_VISIBLE            Specifies to return all visible software
+                               components. This includes all standard, startup,
+                               and essential components.
+        ALL_VISIBLE_AND_HIDDEN Specifies to return all visible and hidden
+                               software components.
+        ONLY_STANDARD          Specifies to only return standard software
+                               components.
+        ONLY_STARTUP           Specifies to only return components that are
+                               startup applications.
+        ====================== =================================================
+
+        Returns An iterator to get a list of broken dependencies, which are
+        specific software components that cannot operate without another
+        software component installed.
+
+        Raises an nisyscfg.errors.LibraryError exception in the event of an
+        error.
+        """
+        return self._install_uninstall(
+            components_to_install=components,
+            auto_restart=auto_restart,
+            auto_select_dependencies=auto_select_dependencies,
+            auto_select_recommends=auto_select_recommends,
+            item_types=item_types,
+        )
+
+    def uninstall(
+        self,
+        components: Union[None, List[str]] = None,
+        auto_restart: bool = True,
+        auto_select_dependencies: bool = True,
+        auto_select_recommends: bool = True,
+        item_types: nisyscfg.enums.IncludeComponentTypes = nisyscfg.enums.IncludeComponentTypes.ALL_VISIBLE,
+    ) -> nisyscfg.dependency_info.DependencyInfoIterator:
+        """
+        Allows you to uninstall components.
+
+        components - List of software components IDs to remove.
+
+        auto_restart - Restarts the system into install mode by default before
+        the operation is performed, and restarts back to a running state after
+        the operation is complete. If you choose not to restart automatically,
+        the operation will fail if the system is not already in install mode.
+
+        auto_select_dependencies - Specifies whether to automatically select
+        software components that are required by the software you have
+        specified to install.
+
+        auto_select_recommends - Specifies whether to automatically select
+        recommended packages.
+
+        Returns tuple  An iterator to get a list of broken dependencies, which
+        are specific software components that cannot operate without another
+        software component installed.
+
+        item_types - Allows inclusion of hidden software installed on the target
+        when ALL_VISIBLE_AND_HIDDEN is selected. Hidden software is not listed
+        by default.
+        ====================== =================================================
+        Item Types             Description
+        ---------------------- -------------------------------------------------
+        ALL_VISIBLE            Specifies to return all visible software
+                               components. This includes all standard, startup,
+                               and essential components.
+        ALL_VISIBLE_AND_HIDDEN Specifies to return all visible and hidden
+                               software components.
+        ONLY_STANDARD          Specifies to only return standard software
+                               components.
+        ONLY_STARTUP           Specifies to only return components that are
+                               startup applications.
+        ====================== =================================================
+
+        Returns An iterator to get a list of broken dependencies, which are
+        specific software components that cannot operate without another
+        software component installed.
+
+        Raises an nisyscfg.errors.LibraryError exception in the event of an
+        error.
+        """
+        return self._install_uninstall(
+            components_to_uninstall=components,
+            auto_restart=auto_restart,
+            auto_select_dependencies=auto_select_dependencies,
+            auto_select_recommends=auto_select_recommends,
+            item_types=item_types,
+        )
+
+    def _get_latest_component(
+        self,
+        component_name: str,
+        item_types: nisyscfg.enums.IncludeComponentTypes = nisyscfg.enums.IncludeComponentTypes.ALL_VISIBLE,
+    ) -> nisyscfg.component_info.ComponentInfo:
+        components = [
+            component
+            for component in self.get_available_software_components(item_types)
+            if (component.title == component_name) or (component.id == component_name)
+        ]
+
+        if not components:
+            raise nisyscfg.errors.Error(
+                'Component "{component_name}" not available for install on target "{self.target_name}".'.format(
+                    component_name=component_name, self=self
+                )
+            )
+
+        return max(components, key=lambda comp: comp.version.split("."))
+
+    def get_software_feeds(self) -> nisyscfg.software_feed.SoftwareFeedIterator:
+        """
+        Retrieves a list of configured software feeds. A feed represents a
+        location that the package manager uses to find and download available
+        software.
+
+        Note: This requires Secure Shell Server (sshd) to be enabled on the
+        target.
+
+        Raises an nisyscfg.errors.LibraryError exception in the event of an
+        error.
+        """
+        software_feed_handle = nisyscfg.types.EnumSoftwareFeedHandle()
+        error_code = self._library.GetSoftwareFeeds(
+            self._session, ctypes.pointer(software_feed_handle)
+        )
+        nisyscfg.errors.handle_error(self, error_code)
+        if software_feed_handle:
+            iter = nisyscfg.software_feed.SoftwareFeedIterator(software_feed_handle)
+            self._children.append(iter)
+            return iter
+
+    @property
+    def resource(self) -> nisyscfg.hardware_resource.HardwareResource:
+        """System resource properties"""
+        if not hasattr(self, "_resource"):
+            resource_handle = self._get_property(16941086, nisyscfg.types.ResourceHandle)
+            self._resource = nisyscfg.hardware_resource.HardwareResource(resource_handle)
+            self._children.append(self._resource)
+        return self._resource
+
+    def _get_property(self, id, c_type):
+        if c_type == ctypes.c_char_p:
+            value = nisyscfg.types.simple_string()
+            value_arg = value
+        elif issubclass(c_type, nisyscfg.enums.BaseEnum) or issubclass(
+            c_type, nisyscfg.enums.BaseFlag
+        ):
+            value = ctypes.c_int()
+            value_arg = ctypes.pointer(value)
+        else:
+            value = c_type(0)
+            value_arg = ctypes.pointer(value)
+
+        error_code = self._library.GetSystemProperty(self._session, id, value_arg)
+        nisyscfg.errors.handle_error(self, error_code)
+
+        if issubclass(c_type, nisyscfg.enums.BaseEnum) or issubclass(
+            c_type, nisyscfg.enums.BaseFlag
+        ):
+            return c_type(value.value)
+
+        if issubclass(c_type, ctypes.c_void_p):
+            return value
+
+        return c_string_decode(value.value)
+
+    def _set_property(self, id, value, c_type, nisyscfg_type):
+        if c_type == ctypes.c_char_p:
+            value = c_string_encode(value)
+        elif issubclass(c_type, nisyscfg.enums.BaseEnum) or issubclass(
+            c_type, nisyscfg.enums.BaseFlag
+        ):
+            value = ctypes.c_int(value)
+        else:
+            value = c_type(value)
+
+        error_code = self._library.SetSystemProperty(self._session, id, value)
+        nisyscfg.errors.handle_error(self, error_code)
+
+    def save_changes(self) -> SaveChangesResult:
+        """
+        Saves changes made to systems.
+
+        Returns tuple (restart_required, details)
+
+            restart_required - Specifies whether the changes require a reboot.
+            If TRUE, call restart().
+
+            details - A string containing results of any errors that may have
+            occurred during execution.
+
+        Raises an nisyscfg.errors.LibraryError exception in the event of an
+        error.
+        """
+        restart_required = ctypes.c_int()
+        c_details = ctypes.POINTER(ctypes.c_char)()
+        error_code = self._library.SaveSystemChanges(
+            self._session, restart_required, ctypes.pointer(c_details)
+        )
+        if c_details:
+            details = c_string_decode(ctypes.cast(c_details, ctypes.c_char_p).value)
+            error_code_2 = self._library.FreeDetailedString(c_details)
+        nisyscfg.errors.handle_error(self, error_code)
+        nisyscfg.errors.handle_error(self, error_code_2)
+        return SaveChangesResult(restart_required=restart_required.value != 0, details=details)
```

## nisyscfg/system_info.py

 * *Ordering differences only*

```diff
@@ -1,31 +1,31 @@
-import nisyscfg.errors
-
-from nisyscfg._lib import c_string_decode
-
-
-class SystemInfoIterator(object):
-    def __init__(self, handle):
-        self._handle = handle
-        self._library = nisyscfg._library_singleton.get()
-
-    def __del__(self):
-        self.close()
-
-    def __iter__(self):
-        return self
-
-    def __next__(self) -> str:
-        if not self._handle:
-            raise StopIteration()
-        system_name = nisyscfg.types.simple_string()
-        error_code = self._library.NextSystemInfo(self._handle, system_name)
-        if error_code == nisyscfg.errors.Status.END_OF_ENUM:
-            raise StopIteration()
-        nisyscfg.errors.handle_error(self, error_code)
-        return c_string_decode(system_name.value)
-
-    def close(self) -> None:
-        if self._handle:
-            error_code = self._library.CloseHandle(self._handle)
-            nisyscfg.errors.handle_error(self, error_code)
-            self._handle = None
+import nisyscfg.errors
+
+from nisyscfg._lib import c_string_decode
+
+
+class SystemInfoIterator(object):
+    def __init__(self, handle):
+        self._handle = handle
+        self._library = nisyscfg._library_singleton.get()
+
+    def __del__(self):
+        self.close()
+
+    def __iter__(self):
+        return self
+
+    def __next__(self) -> str:
+        if not self._handle:
+            raise StopIteration()
+        system_name = nisyscfg.types.simple_string()
+        error_code = self._library.NextSystemInfo(self._handle, system_name)
+        if error_code == nisyscfg.errors.Status.END_OF_ENUM:
+            raise StopIteration()
+        nisyscfg.errors.handle_error(self, error_code)
+        return c_string_decode(system_name.value)
+
+    def close(self) -> None:
+        if self._handle:
+            error_code = self._library.CloseHandle(self._handle)
+            nisyscfg.errors.handle_error(self, error_code)
+            self._handle = None
```

## nisyscfg/timestamp.py

```diff
@@ -1,65 +1,65 @@
-from hightime import datetime
-from hightime import timedelta
-import nisyscfg
-import nisyscfg._library_singleton
-import nisyscfg.errors
-import nisyscfg.types
-
-import ctypes
-
-
-# International Atomic Time epoch
-tai_epoch = datetime(year=1970, month=1, day=1)
-
-
-def is_blank_timestamp(timestamp):
-    return all(num == 0 for num in timestamp)
-
-
-def _convert_ctype_to_datetime(timestamp: nisyscfg.types.TimestampUTC) -> datetime:
-    # This method returns 1 Jan 1904 if blank datetime is found(zero timestamp value).
-    # Else it converts the timestamp to datetime and returns
-    if is_blank_timestamp(timestamp):
-        return datetime(year=1904, month=1, day=1)
-    else:
-        library = nisyscfg._library_singleton.get()
-        seconds_since_tai_epoch = ctypes.c_uint64()
-        fractional_seconds = ctypes.c_double()
-
-        error_code = library.ValuesFromTimestamp(
-            timestamp,
-            ctypes.pointer(seconds_since_tai_epoch),
-            ctypes.pointer(fractional_seconds),
-        )
-        nisyscfg.errors.handle_error(None, error_code, is_error_handling=True)
-
-        return (
-            tai_epoch
-            + timedelta(seconds=seconds_since_tai_epoch.value)
-            + timedelta(seconds=fractional_seconds.value)
-        )
-
-
-def _convert_datetime_to_ctype(timestamp: datetime) -> nisyscfg.types.TimestampUTC:
-    if timestamp == datetime(year=1904, month=1, day=1):
-        return nisyscfg.types.TimestampUTC(0, 0, 0, 0)
-    else:
-        library = nisyscfg._library_singleton.get()
-
-        time_since_tai_epoch = timestamp - tai_epoch
-        seconds_since_tai_epoch = time_since_tai_epoch.days * 86400 + time_since_tai_epoch.seconds
-        fractional_seconds = (
-            (time_since_tai_epoch.microseconds / 10 ** 6)
-            + (time_since_tai_epoch.femtoseconds / 10 ** 15)
-            + (time_since_tai_epoch.yoctoseconds / 10 ** 24)
-        )
-        timestamp = nisyscfg.types.TimestampUTC()
-
-        error_code = library.TimestampFromValues(
-            seconds_since_tai_epoch,
-            fractional_seconds,
-            ctypes.pointer(timestamp),
-        )
-        nisyscfg.errors.handle_error(None, error_code, is_error_handling=True)
-
-        return timestamp
+from hightime import datetime
+from hightime import timedelta
+import nisyscfg
+import nisyscfg._library_singleton
+import nisyscfg.errors
+import nisyscfg.types
+
+import ctypes
+
+
+# International Atomic Time epoch
+tai_epoch = datetime(year=1970, month=1, day=1)
+
+
+def is_blank_timestamp(timestamp):
+    return all(num == 0 for num in timestamp)
+
+
+def _convert_ctype_to_datetime(timestamp: nisyscfg.types.TimestampUTC) -> datetime:
+    # This method returns 1 Jan 1904 if blank datetime is found(zero timestamp value).
+    # Else it converts the timestamp to datetime and returns
+    if is_blank_timestamp(timestamp):
+        return datetime(year=1904, month=1, day=1)
+    else:
+        library = nisyscfg._library_singleton.get()
+        seconds_since_tai_epoch = ctypes.c_uint64()
+        fractional_seconds = ctypes.c_double()
+
+        error_code = library.ValuesFromTimestamp(
+            timestamp,
+            ctypes.pointer(seconds_since_tai_epoch),
+            ctypes.pointer(fractional_seconds),
+        )
+        nisyscfg.errors.handle_error(None, error_code, is_error_handling=True)
+
+        return (
+            tai_epoch
+            + timedelta(seconds=seconds_since_tai_epoch.value)
+            + timedelta(seconds=fractional_seconds.value)
+        )
+
+
+def _convert_datetime_to_ctype(timestamp: datetime) -> nisyscfg.types.TimestampUTC:
+    if timestamp == datetime(year=1904, month=1, day=1):
+        return nisyscfg.types.TimestampUTC(0, 0, 0, 0)
+    else:
+        library = nisyscfg._library_singleton.get()
+
+        time_since_tai_epoch = timestamp - tai_epoch
+        seconds_since_tai_epoch = time_since_tai_epoch.days * 86400 + time_since_tai_epoch.seconds
+        fractional_seconds = (
+            (time_since_tai_epoch.microseconds / 10**6)
+            + (time_since_tai_epoch.femtoseconds / 10**15)
+            + (time_since_tai_epoch.yoctoseconds / 10**24)
+        )
+        timestamp = nisyscfg.types.TimestampUTC()
+
+        error_code = library.TimestampFromValues(
+            seconds_since_tai_epoch,
+            fractional_seconds,
+            ctypes.pointer(timestamp),
+        )
+        nisyscfg.errors.handle_error(None, error_code, is_error_handling=True)
+
+        return timestamp
```

## nisyscfg/pxi/enums.py

```diff
@@ -1,111 +1,111 @@
-from nisyscfg.enums import BaseEnum
-
-
-class Clock10Sources(BaseEnum):
-    UNKNOWN = -1  #: Not applicable, or not software-readable
-    INTERNAL = 0  #: Internal Oscillator
-    BUILT_IN_CONNECTOR = 1  #: Supplied by the dedicated 10 MHz REF IN connector (e.g. SMA or SMB)
-    TIMING_MODULE = 2  #: System Timing Module
-    TRIG_10MHZ_PORT0 = 3  #: TRIG / 10 MHz Port 0 / REF IN
-
-
-class ExternalClockOutputSources(BaseEnum):
-    UNKNOWN = -1  #: Not applicable, or not software-readable
-    PXI_CLK10 = 0  #: PXI_CLK10 from the chassis backplane
-    INTERNAL_OSCILLATOR = 1  #: Internal Oscillator
-
-
-class InternalOscillators(BaseEnum):
-    UNSUPPORTED = -1  #: Not software-readable
-    VCXO = 0  #: Voltage-controlled Oscillator
-    OCXO = 1  #: Oven-controlled Oscillator
-
-
-class PxiHighDensityTrigPortState(BaseEnum):
-    DISCONNECTED = 0  #: The port is disconnected
-    CONNECTED = 1  #: The port is connected to another device known to this host
-    CONNECTED_UNKNOWN = 2  #: The port is connected, but the remote device cannot be found
-    LOOPBACK = 3  #: 2 High Density Trigger ports on the device are connected to each other
-
-
-class FanModes(BaseEnum):
-    AUTO = 1  #: Default operating mode
-    SAFE_MANUAL = (
-        2  #: Allows caller to manipulate the fan speed within safe boundaries by setting FanUserRpm
-    )
-    HIGH = 4  #: Fans run at the maximum speed for the current cooling profile
-
-
-class CoolingProfiles(BaseEnum):
-    WATTS_38 = 1  #: Default operating mode
-    WATTS_58 = (
-        2  #: More aggressive cooling profile for cooling modules requiring 58W or less of cooling
-    )
-    WATTS_82 = (
-        4  #: More aggressive cooling profile for cooling modules requiring 82W or less of cooling
-    )
-
-
-class CoolingProfileSource(BaseEnum):
-    UNKNOWN = (-1,)  #: Not software-readable
-    USER_SPECIFIED = (1,)  #: The cooling profile reflects the user configured value
-    MODULE_REQUEST = (2,)  #: A module is requesting the current cooling profile
-    USER_OVERRIDE_OF_MODULE_REQUEST = (
-        3  #: The user is overriding the cooling profile requested by a module
-    )
-
-
-class PowerSupplyStates(BaseEnum):
-    OFF = 0
-    ON = 1
-    FAULTED = 2
-    FAULT_OUTPUT_VOLTAGE_OVERVOLTAGE_12V = 16
-    FAULT_OUTPUT_VOLTAGE_UNDERVOLTAGE_12V = 17
-    FAULT_OUTPUT_VOLTAGE_OVERVOLTAGE_5V_AUX = 18
-    FAULT_OUTPUT_VOLTAGE_UNDERVOLTAGE_5V_AUX = 19
-    FAULT_OUTPUT_CURRENT_OVERCURRENT_12V = 20
-    FAULT_OUTPUT_CURRENT_OVERCURRENT_5V_AUX = 21
-    FAULT_INPUT_VOLTAGE_OVERVOLTAGE = 22
-    FAULT_INPUT_VOLTAGE_UNDERVOLTAGE = 23
-    FAULT_LOWER_AMBIENT_TEMPERATURE = 24
-    FAULT_UPPER_AMBIENT_TEMPERATURE = 25
-    FAULT_LOWER_INTERNAL_TEMPERATURE = 26
-    FAULT_UPPER_INTERNAL_TEMPERATURE = 27
-    FAULT_FAN = 28
-    ALERT_OUTPUT_VOLTAGE_OVERVOLTAGE_12V = 48
-    ALERT_OUTPUT_VOLTAGE_UNDERVOLTAGE_12V = 49
-    ALERT_OUTPUT_VOLTAGE_OVERVOLTAGE_5V_AUX = 50
-    ALERT_OUTPUT_VOLTAGE_UNDERVOLTAGE_5V_AUX = 51
-    ALERT_OUTPUT_CURRENT_OVERCURRENT_12V = 52
-    ALERT_OUTPUT_CURRENT_OVERCURRENT_5V_AUX = 53
-    ALERT_OUTPUT_CURRENT_SHARING = 54
-    ALERT_INPUT_VOLTAGE_OVERVOLTAGE = 55
-    ALERT_INPUT_VOLTAGE_UNDERVOLTAGE = 56
-    ALERT_LOWER_AMBIENT_TEMPERATURE = 57
-    ALERT_UPPER_AMBIENT_TEMPERATURE = 58
-    ALERT_LOWER_INTERNAL_TEMPERATURE = 59
-    ALERT_UPPER_INTERNAL_TEMPERATURE = 60
-    ALERT_FAN = 61
-
-
-class InhibitModes(BaseEnum):
-    DEFAULT = 1  #: Chassis power controlled by the power button and OS
-    MANUAL = 2  #: Chassis power controlled by the Remote Inhibit signal
-
-
-class CalExtActions(BaseEnum):
-    CANCEL = 0
-    OCXO_START = 1
-    COMMIT = 2
-
-
-class ChassisLedBlinkPattern(BaseEnum):
-    CHASSIS_CONTROLLED = 1
-    ONE_BLINK = 2
-    THREE_BLINK_BLINK_BLINK = 4
-    THREE_BLINK_BLINK_STEADY = 8
-    THREE_BLINK_STEADY_BLINK = 16
-    THREE_BLINK_STEADY_STEADY = 32
-    THREE_STEADY_BLINK_BLINK = 64
-    THREE_STEADY_BLINK_STEADY = 128
-    THREE_STEADY_STEADY_BLINK = 256
+from nisyscfg.enums import BaseEnum, BaseFlag
+
+
+class Clock10Sources(BaseEnum):
+    UNKNOWN = -1  #: Not applicable, or not software-readable
+    INTERNAL = 0  #: Internal Oscillator
+    BUILT_IN_CONNECTOR = 1  #: Supplied by the dedicated 10 MHz REF IN connector (e.g. SMA or SMB)
+    TIMING_MODULE = 2  #: System Timing Module
+    TRIG_10MHZ_PORT0 = 3  #: TRIG / 10 MHz Port 0 / REF IN
+
+
+class ExternalClockOutputSources(BaseEnum):
+    UNKNOWN = -1  #: Not applicable, or not software-readable
+    PXI_CLK10 = 0  #: PXI_CLK10 from the chassis backplane
+    INTERNAL_OSCILLATOR = 1  #: Internal Oscillator
+
+
+class InternalOscillators(BaseEnum):
+    UNSUPPORTED = -1  #: Not software-readable
+    VCXO = 0  #: Voltage-controlled Oscillator
+    OCXO = 1  #: Oven-controlled Oscillator
+
+
+class PxiHighDensityTrigPortState(BaseEnum):
+    DISCONNECTED = 0  #: The port is disconnected
+    CONNECTED = 1  #: The port is connected to another device known to this host
+    CONNECTED_UNKNOWN = 2  #: The port is connected, but the remote device cannot be found
+    LOOPBACK = 3  #: 2 High Density Trigger ports on the device are connected to each other
+
+
+class FanModes(BaseFlag):
+    AUTO = 1  #: Default operating mode
+    SAFE_MANUAL = (
+        2  #: Allows caller to manipulate the fan speed within safe boundaries by setting FanUserRpm
+    )
+    HIGH = 4  #: Fans run at the maximum speed for the current cooling profile
+
+
+class CoolingProfiles(BaseFlag):
+    WATTS_38 = 1  #: Default operating mode
+    WATTS_58 = (
+        2  #: More aggressive cooling profile for cooling modules requiring 58W or less of cooling
+    )
+    WATTS_82 = (
+        4  #: More aggressive cooling profile for cooling modules requiring 82W or less of cooling
+    )
+
+
+class CoolingProfileSource(BaseEnum):
+    UNKNOWN = (-1,)  #: Not software-readable
+    USER_SPECIFIED = (1,)  #: The cooling profile reflects the user configured value
+    MODULE_REQUEST = (2,)  #: A module is requesting the current cooling profile
+    USER_OVERRIDE_OF_MODULE_REQUEST = (
+        3  #: The user is overriding the cooling profile requested by a module
+    )
+
+
+class PowerSupplyStates(BaseEnum):
+    OFF = 0
+    ON = 1
+    FAULTED = 2
+    FAULT_OUTPUT_VOLTAGE_OVERVOLTAGE_12V = 16
+    FAULT_OUTPUT_VOLTAGE_UNDERVOLTAGE_12V = 17
+    FAULT_OUTPUT_VOLTAGE_OVERVOLTAGE_5V_AUX = 18
+    FAULT_OUTPUT_VOLTAGE_UNDERVOLTAGE_5V_AUX = 19
+    FAULT_OUTPUT_CURRENT_OVERCURRENT_12V = 20
+    FAULT_OUTPUT_CURRENT_OVERCURRENT_5V_AUX = 21
+    FAULT_INPUT_VOLTAGE_OVERVOLTAGE = 22
+    FAULT_INPUT_VOLTAGE_UNDERVOLTAGE = 23
+    FAULT_LOWER_AMBIENT_TEMPERATURE = 24
+    FAULT_UPPER_AMBIENT_TEMPERATURE = 25
+    FAULT_LOWER_INTERNAL_TEMPERATURE = 26
+    FAULT_UPPER_INTERNAL_TEMPERATURE = 27
+    FAULT_FAN = 28
+    ALERT_OUTPUT_VOLTAGE_OVERVOLTAGE_12V = 48
+    ALERT_OUTPUT_VOLTAGE_UNDERVOLTAGE_12V = 49
+    ALERT_OUTPUT_VOLTAGE_OVERVOLTAGE_5V_AUX = 50
+    ALERT_OUTPUT_VOLTAGE_UNDERVOLTAGE_5V_AUX = 51
+    ALERT_OUTPUT_CURRENT_OVERCURRENT_12V = 52
+    ALERT_OUTPUT_CURRENT_OVERCURRENT_5V_AUX = 53
+    ALERT_OUTPUT_CURRENT_SHARING = 54
+    ALERT_INPUT_VOLTAGE_OVERVOLTAGE = 55
+    ALERT_INPUT_VOLTAGE_UNDERVOLTAGE = 56
+    ALERT_LOWER_AMBIENT_TEMPERATURE = 57
+    ALERT_UPPER_AMBIENT_TEMPERATURE = 58
+    ALERT_LOWER_INTERNAL_TEMPERATURE = 59
+    ALERT_UPPER_INTERNAL_TEMPERATURE = 60
+    ALERT_FAN = 61
+
+
+class InhibitModes(BaseFlag):
+    DEFAULT = 1  #: Chassis power controlled by the power button and OS
+    MANUAL = 2  #: Chassis power controlled by the Remote Inhibit signal
+
+
+class CalExtActions(BaseEnum):
+    CANCEL = 0
+    OCXO_START = 1
+    COMMIT = 2
+
+
+class ChassisLedBlinkPattern(BaseFlag):
+    CHASSIS_CONTROLLED = 1
+    ONE_BLINK = 2
+    THREE_BLINK_BLINK_BLINK = 4
+    THREE_BLINK_BLINK_STEADY = 8
+    THREE_BLINK_STEADY_BLINK = 16
+    THREE_BLINK_STEADY_STEADY = 32
+    THREE_STEADY_BLINK_BLINK = 64
+    THREE_STEADY_BLINK_STEADY = 128
+    THREE_STEADY_STEADY_BLINK = 256
```

## nisyscfg/pxi/properties.py

```diff
@@ -1,94 +1,94 @@
-from nisyscfg.properties import (
-    BitmaskProperty,
-    BoolProperty,
-    IndexedDoubleProperty,
-    IndexedStringProperty,
-    IndexedUnsignedIntProperty,
-    IntProperty,
-    UnsignedIntProperty,
-    PropertyGroup,
-)
-from nisyscfg.pxi.enums import (
-    Clock10Sources,
-    ExternalClockOutputSources,
-    InternalOscillators,
-    PxiHighDensityTrigPortState,
-    FanModes,
-    CoolingProfiles,
-    CoolingProfileSource,
-    PowerSupplyStates,
-    InhibitModes,
-    CalExtActions,
-)
-
-
-class Resource(PropertyGroup):
-    # Chassis attributes
-    PXI_CHASSIS_NUMBER = UnsignedIntProperty(184565760)
-
-    # Clock attributes
-    CLK10_SOURCE = IntProperty(184635392, Clock10Sources)
-    # Sets the source for external CLK10 Reference Clock outputs on the
-    # chassis. The default is PXI_CLK10 from the backplane, which itself may
-    # be sourced from various inputs. To achieve minimal phase offset of the
-    # PXI_CLK10 reference clock between multiple chassis, set this attribute
-    # to NISysCfgPxiExternalClockOutputSourceInternalOscillator, then split
-    # the signal from the 10 MHz REF OUT connector using matched-length
-    # cabling to the 10 Mhz REF IN connector on each chassis requiring minimal
-    # phase offset. For best results, use the same model of chassis. */
-    EXTERNAL_CLOCK_OUTPUT_SOURCE = IntProperty(184639488, ExternalClockOutputSources)
-    INTERNAL_OSCILLATOR = IntProperty(184643584, InternalOscillators)
-    HIGH_DENSITY_TRIG_PORT_COUNT = IntProperty(200286208)
-
-    # Fan control attributes
-    FAN_MODE = UnsignedIntProperty(185597952, FanModes)
-    FAN_USER_RPM = UnsignedIntProperty(185602048)
-    SUPPORTED_FAN_MODES = BitmaskProperty(185606144, FanModes)
-    FAN_MANUAL_RPM_LOWER_BOUND = UnsignedIntProperty(185634816)
-    FAN_MANUAL_RPM_UPPER_BOUND = UnsignedIntProperty(185638912)
-    COOLING_PROFILE = UnsignedIntProperty(185610240, CoolingProfiles)
-    COOLING_PROFILE_SOURCE = IntProperty(185663488, CoolingProfileSource)
-    SUPPORTED_COOLING_PROFILES = BitmaskProperty(185614336, CoolingProfiles)
-    # Honors a cooling profile user setting that is lower than a module
-    # request when the module can accommodate the request by reducing
-    # performance or functionality. A reboot may be required to take effect. */
-    ENABLE_USER_OVERRIDE_OF_COOLING_PROFILE = BoolProperty(185659392)
-
-    # Power supply attributes
-    POWER_SUPPLY_BAY_COUNT = IntProperty(186777600)
-    POWER_SUPPLIES_REDUNDANT = UnsignedIntProperty(186798080)
-    INHIBIT_MODE = UnsignedIntProperty(186806272, InhibitModes)
-    SUPPORTED_INHIBIT_MODES = BitmaskProperty(186810368, InhibitModes)
-
-    # Calibration attributes
-    CAL_EXT_ACTION = UnsignedIntProperty(186908672, CalExtActions)
-    CAL_EXT_DAC_VALUE = UnsignedIntProperty(186925056)
-
-
-class IndexedResource(PropertyGroup):
-    # Power supply index attributes
-    POWER_SUPPLY_NAME = IndexedStringProperty(186781696, Resource.POWER_SUPPLY_BAY_COUNT)
-    POWER_SUPPLY_STATE = IndexedUnsignedIntProperty(
-        186789888, Resource.POWER_SUPPLY_BAY_COUNT, PowerSupplyStates
-    )
-    POWER_SUPPLY_POWER = IndexedUnsignedIntProperty(
-        186793984, Resource.POWER_SUPPLY_BAY_COUNT
-    )  #: (Watts)
-    POWER_SUPPLY_POWER_READING = IndexedDoubleProperty(
-        186822656, Resource.POWER_SUPPLY_BAY_COUNT
-    )  #: (Watts)
-    POWER_SUPPLY_INTAKE_TEMP = IndexedDoubleProperty(
-        186802176, Resource.POWER_SUPPLY_BAY_COUNT
-    )  #: (degrees Celsius)
-    POWER_SUPPLY_POWER_LINE_FREQUENCY = IndexedUnsignedIntProperty(
-        186785792, Resource.POWER_SUPPLY_BAY_COUNT
-    )  #: (Hertz)
-
-    # High Density Trigger Port index Attributes
-    TRIG_PORT_NAME = IndexedStringProperty(200290304, Resource.HIGH_DENSITY_TRIG_PORT_COUNT)
-    TRIG_PORT_STATE = IndexedUnsignedIntProperty(
-        200294400, Resource.HIGH_DENSITY_TRIG_PORT_COUNT, PxiHighDensityTrigPortState
-    )
-    TRIG_PORT_REMOVE_DEVICE_ALIAS = IndexedStringProperty(
-        200298496, Resource.HIGH_DENSITY_TRIG_PORT_COUNT
-    )
+from nisyscfg.properties import (
+    BoolProperty,
+    IndexedDoubleProperty,
+    IndexedStringProperty,
+    IndexedUnsignedIntProperty,
+    IntProperty,
+    UnsignedIntProperty,
+    PropertyGroup,
+)
+from nisyscfg.pxi.enums import (
+    Clock10Sources,
+    ExternalClockOutputSources,
+    InternalOscillators,
+    PxiHighDensityTrigPortState,
+    FanModes,
+    CoolingProfiles,
+    CoolingProfileSource,
+    PowerSupplyStates,
+    InhibitModes,
+    CalExtActions,
+)
+
+
+class Resource(PropertyGroup):
+    # Chassis attributes
+    PXI_CHASSIS_NUMBER = UnsignedIntProperty(184565760)
+    CHASSIS_LED_BLINK_PATTERN = UnsignedIntProperty(184655872)
+
+    # Clock attributes
+    CLK10_SOURCE = IntProperty(184635392, Clock10Sources)
+    # Sets the source for external CLK10 Reference Clock outputs on the
+    # chassis. The default is PXI_CLK10 from the backplane, which itself may
+    # be sourced from various inputs. To achieve minimal phase offset of the
+    # PXI_CLK10 reference clock between multiple chassis, set this attribute
+    # to NISysCfgPxiExternalClockOutputSourceInternalOscillator, then split
+    # the signal from the 10 MHz REF OUT connector using matched-length
+    # cabling to the 10 Mhz REF IN connector on each chassis requiring minimal
+    # phase offset. For best results, use the same model of chassis. */
+    EXTERNAL_CLOCK_OUTPUT_SOURCE = IntProperty(184639488, ExternalClockOutputSources)
+    INTERNAL_OSCILLATOR = IntProperty(184643584, InternalOscillators)
+    HIGH_DENSITY_TRIG_PORT_COUNT = IntProperty(200286208)
+
+    # Fan control attributes
+    FAN_MODE = UnsignedIntProperty(185597952, FanModes)
+    FAN_USER_RPM = UnsignedIntProperty(185602048)
+    SUPPORTED_FAN_MODES = UnsignedIntProperty(185606144, FanModes)
+    FAN_MANUAL_RPM_LOWER_BOUND = UnsignedIntProperty(185634816)
+    FAN_MANUAL_RPM_UPPER_BOUND = UnsignedIntProperty(185638912)
+    COOLING_PROFILE = UnsignedIntProperty(185610240, CoolingProfiles)
+    COOLING_PROFILE_SOURCE = IntProperty(185663488, CoolingProfileSource)
+    SUPPORTED_COOLING_PROFILES = UnsignedIntProperty(185614336, CoolingProfiles)
+    # Honors a cooling profile user setting that is lower than a module
+    # request when the module can accommodate the request by reducing
+    # performance or functionality. A reboot may be required to take effect. */
+    ENABLE_USER_OVERRIDE_OF_COOLING_PROFILE = BoolProperty(185659392)
+
+    # Power supply attributes
+    POWER_SUPPLY_BAY_COUNT = IntProperty(186777600)
+    POWER_SUPPLIES_REDUNDANT = UnsignedIntProperty(186798080)
+    INHIBIT_MODE = UnsignedIntProperty(186806272, InhibitModes)
+    SUPPORTED_INHIBIT_MODES = UnsignedIntProperty(186810368, InhibitModes)
+
+    # Calibration attributes
+    CAL_EXT_ACTION = UnsignedIntProperty(186908672, CalExtActions)
+    CAL_EXT_DAC_VALUE = UnsignedIntProperty(186925056)
+
+
+class IndexedResource(PropertyGroup):
+    # Power supply index attributes
+    POWER_SUPPLY_NAME = IndexedStringProperty(186781696, Resource.POWER_SUPPLY_BAY_COUNT)
+    POWER_SUPPLY_STATE = IndexedUnsignedIntProperty(
+        186789888, Resource.POWER_SUPPLY_BAY_COUNT, PowerSupplyStates
+    )
+    POWER_SUPPLY_POWER = IndexedUnsignedIntProperty(
+        186793984, Resource.POWER_SUPPLY_BAY_COUNT
+    )  #: (Watts)
+    POWER_SUPPLY_POWER_READING = IndexedDoubleProperty(
+        186822656, Resource.POWER_SUPPLY_BAY_COUNT
+    )  #: (Watts)
+    POWER_SUPPLY_INTAKE_TEMP = IndexedDoubleProperty(
+        186802176, Resource.POWER_SUPPLY_BAY_COUNT
+    )  #: (degrees Celsius)
+    POWER_SUPPLY_POWER_LINE_FREQUENCY = IndexedUnsignedIntProperty(
+        186785792, Resource.POWER_SUPPLY_BAY_COUNT
+    )  #: (Hertz)
+
+    # High Density Trigger Port index Attributes
+    TRIG_PORT_NAME = IndexedStringProperty(200290304, Resource.HIGH_DENSITY_TRIG_PORT_COUNT)
+    TRIG_PORT_STATE = IndexedUnsignedIntProperty(
+        200294400, Resource.HIGH_DENSITY_TRIG_PORT_COUNT, PxiHighDensityTrigPortState
+    )
+    TRIG_PORT_REMOVE_DEVICE_ALIAS = IndexedStringProperty(
+        200298496, Resource.HIGH_DENSITY_TRIG_PORT_COUNT
+    )
```

## nisyscfg/xnet/enums.py

```diff
@@ -1,81 +1,81 @@
-from nisyscfg.enums import BaseEnum
-
-
-class EnetPortMode(BaseEnum):
-    DIRECT = 0
-    TAP = 1
-
-
-class EnetPhyState(BaseEnum):
-    SLAVE = 0
-    MASTER = 1
-    AUTO = 2
-
-
-class Blink(BaseEnum):
-    DISABLE = 0
-    ENABLE = 1
-
-
-class Protocol(BaseEnum):
-    CAN = 0
-    FLEXRAY = 1
-    LIN = 2
-    ETHERNET = 3
-    UNKNOWN = 0xFFFFFFFE
-
-
-class CanTransceiverCapability(BaseEnum):
-    HS = 0
-    LS = 1
-    XS = 3
-    XS_WITH_HS_OR_LS = 4
-    UNKNOWN = 0xFFFFFFFF
-
-
-class DongleId(BaseEnum):
-    LS_CAN = 1
-    HS_CAN = 2
-    SW_CAN = 3
-    XS_CAN = 4
-    LIN = 6
-    DONGLELESS_DESIGN = 13
-    UNKNOWN = 14
-
-
-class DongleState(BaseEnum):
-    NO_DONGLE_NO_EXTERNAL_POWER = 1
-    NO_DONGLE_HAS_EXTERNAL_POWER = 2
-    HAS_DONGLE_NO_EXTERNAL_POWER = 3
-    READY = 4
-    BUSY = 5
-    COMM_ERROR = 13
-    OVERCURRENT = 14
-
-
-class EnetLinkSpeed(BaseEnum):
-    LINK_DOWN = 0
-    HUNDRED_MEGABIT = 1
-    GIGABIT = 2
-
-
-class EnetJumboFrames(BaseEnum):
-    DISABLE = 0
-    ENABLE_9018_BYTES = 1
-
-
-class EnetInterruptModeration(BaseEnum):
-    OFF = 0
-    LOW = 1
-    MEDIUM = 2
-    HIGH = 3
-
-
-class EnetSleepCapability(BaseEnum):
-    DISABLED_OR_NOT_AVAILABLE = 0,
-    ENABLED = 1
-
-
-class EnetPhyPowerMode(BaseEnum):
-    NORMAL = 0,
-    SLEEP = 1
+from nisyscfg.enums import BaseEnum
+
+
+class EnetPortMode(BaseEnum):
+    DIRECT = 0
+    TAP = 1
+
+
+class EnetPhyState(BaseEnum):
+    SLAVE = 0
+    MASTER = 1
+    AUTO = 2
+
+
+class Blink(BaseEnum):
+    DISABLE = 0
+    ENABLE = 1
+
+
+class Protocol(BaseEnum):
+    CAN = 0
+    FLEXRAY = 1
+    LIN = 2
+    ETHERNET = 3
+    UNKNOWN = 0xFFFFFFFE
+
+
+class CanTransceiverCapability(BaseEnum):
+    HS = 0
+    LS = 1
+    XS = 3
+    XS_WITH_HS_OR_LS = 4
+    UNKNOWN = 0xFFFFFFFF
+
+
+class DongleId(BaseEnum):
+    LS_CAN = 1
+    HS_CAN = 2
+    SW_CAN = 3
+    XS_CAN = 4
+    LIN = 6
+    DONGLELESS_DESIGN = 13
+    UNKNOWN = 14
+
+
+class DongleState(BaseEnum):
+    NO_DONGLE_NO_EXTERNAL_POWER = 1
+    NO_DONGLE_HAS_EXTERNAL_POWER = 2
+    HAS_DONGLE_NO_EXTERNAL_POWER = 3
+    READY = 4
+    BUSY = 5
+    COMM_ERROR = 13
+    OVERCURRENT = 14
+
+
+class EnetLinkSpeed(BaseEnum):
+    LINK_DOWN = 0
+    HUNDRED_MEGABIT = 1
+    GIGABIT = 2
+
+
+class EnetJumboFrames(BaseEnum):
+    DISABLE = 0
+    ENABLE_9018_BYTES = 1
+
+
+class EnetInterruptModeration(BaseEnum):
+    OFF = 0
+    LOW = 1
+    MEDIUM = 2
+    HIGH = 3
+
+
+class EnetSleepCapability(BaseEnum):
+    DISABLED_OR_NOT_AVAILABLE = 0
+    ENABLED = 1
+
+
+class EnetPhyPowerMode(BaseEnum):
+    NORMAL = 0
+    SLEEP = 1
```

## nisyscfg/xnet/properties.py

```diff
@@ -1,73 +1,73 @@
-from nisyscfg.enums import Bool
-from nisyscfg.properties import (
-    StringProperty,
-    UnsignedIntProperty,
-    IntProperty,
-    PropertyGroup,
-)
-from nisyscfg.xnet.enums import (
-    EnetPortMode,
-    EnetPhyState,
-    Blink,
-    Protocol,
-    CanTransceiverCapability,
-    DongleId,
-    DongleState,
-    EnetLinkSpeed,
-    EnetJumboFrames,
-    EnetInterruptModeration,
-    EnetSleepCapability,
-    EnetPhyPowerMode
-)
-
-
-class Resource(PropertyGroup):
-    # Read-only device properties
-    NUMBER_OF_PORTS = UnsignedIntProperty(167780352)
-    IP_STACK_INFO_JSON = StringProperty(167882752)
-    IP_STACK_INFO_TEXT = StringProperty(167886848)
-
-    # Read-only port properties
-    PORT_NUMBER = UnsignedIntProperty(167845888)
-    PROTOCOL = UnsignedIntProperty(167796737, Protocol)
-    CAN_TERMINATION_CAPABILITY = UnsignedIntProperty(167849984, Bool)
-    CAN_TRANSCEIVER_CAPABILITY = UnsignedIntProperty(167792641, CanTransceiverCapability)
-    DONGLE_ID = UnsignedIntProperty(167813120, DongleId)
-    DONGLE_STATE = UnsignedIntProperty(167809024, DongleState)
-
-    # Write-only port properties
-    BLINK = UnsignedIntProperty(167817216, Blink)
-
-    # Read-only Automotive Ethernet port properties
-    ENET_MAC_ADDR = StringProperty(167841792)
-    ENET_IP_V4_ADDR = StringProperty(167854080)
-    ENET_OS_ADAPTER_NAME = StringProperty(167858176)
-    ENET_OS_ADAPTER_DESC = StringProperty(167862272)
-    ENET_LINK_SPEED = UnsignedIntProperty(167874560, EnetLinkSpeed)
-    ENET_SLEEP_CAPABILITY = UnsignedIntProperty(167911424, EnetSleepCapability)
-    ENET_PHY_POWER_MODE = UnsignedIntProperty(167915520, EnetPhyPowerMode)
-
-    # Read/Write Automotive Ethernet port properties
-    ENET_PHY_STATE = UnsignedIntProperty(167837696, EnetPhyState)
-    ENET_PORT_MODE = UnsignedIntProperty(167833600, EnetPortMode)
-    ENET_LINK_SPEED_CONFIGURED = UnsignedIntProperty(167866368, EnetLinkSpeed)
-    ENET_JUMBO_FRAMES = UnsignedIntProperty(167903232, EnetJumboFrames)
-    ENET_INTERRUPT_MODERATION = IntProperty(167878656, EnetInterruptModeration)
-    ENET_SLEEP_CAPABILITY_CONFIGURED = UnsignedIntProperty(167907328, EnetSleepCapability)
-
-
-class Filter(PropertyGroup):
-    # Write-only device properties
-    NUMBER_OF_PORTS = UnsignedIntProperty(167780352)
-
-    # Write-only port properties
-    PORT_NUMBER = UnsignedIntProperty(167845888)
-    PROTOCOL = UnsignedIntProperty(167796737, Protocol)
-    CAN_TERMINATION_CAPABILITY = UnsignedIntProperty(167849984, Bool)
-    CAN_TRANSCEIVER_CAPABILITY = UnsignedIntProperty(167792641, CanTransceiverCapability)
-    DONGLE_ID = UnsignedIntProperty(167813120, DongleId)
-
-    # Write-only Automotive Ethernet port properties
-    ENET_PHY_STATE = UnsignedIntProperty(167837696, EnetPhyState)
-    ENET_PORT_MODE = UnsignedIntProperty(167833600, EnetPortMode)
-    ENET_LINK_SPEED_CONFIGURED = UnsignedIntProperty(167866368, EnetLinkSpeed)
+from nisyscfg.enums import Bool
+from nisyscfg.properties import (
+    StringProperty,
+    UnsignedIntProperty,
+    IntProperty,
+    PropertyGroup,
+)
+from nisyscfg.xnet.enums import (
+    EnetPortMode,
+    EnetPhyState,
+    Blink,
+    Protocol,
+    CanTransceiverCapability,
+    DongleId,
+    DongleState,
+    EnetLinkSpeed,
+    EnetJumboFrames,
+    EnetInterruptModeration,
+    EnetSleepCapability,
+    EnetPhyPowerMode,
+)
+
+
+class Resource(PropertyGroup):
+    # Read-only device properties
+    NUMBER_OF_PORTS = UnsignedIntProperty(167780352)
+    IP_STACK_INFO_JSON = StringProperty(167882752)
+    IP_STACK_INFO_TEXT = StringProperty(167886848)
+
+    # Read-only port properties
+    PORT_NUMBER = UnsignedIntProperty(167845888)
+    PROTOCOL = UnsignedIntProperty(167796737, Protocol)
+    CAN_TERMINATION_CAPABILITY = UnsignedIntProperty(167849984, Bool)
+    CAN_TRANSCEIVER_CAPABILITY = UnsignedIntProperty(167792641, CanTransceiverCapability)
+    DONGLE_ID = UnsignedIntProperty(167813120, DongleId)
+    DONGLE_STATE = UnsignedIntProperty(167809024, DongleState)
+
+    # Write-only port properties
+    BLINK = UnsignedIntProperty(167817216, Blink)
+
+    # Read-only Automotive Ethernet port properties
+    ENET_MAC_ADDR = StringProperty(167841792)
+    ENET_IP_V4_ADDR = StringProperty(167854080)
+    ENET_OS_ADAPTER_NAME = StringProperty(167858176)
+    ENET_OS_ADAPTER_DESC = StringProperty(167862272)
+    ENET_LINK_SPEED = UnsignedIntProperty(167874560, EnetLinkSpeed)
+    ENET_SLEEP_CAPABILITY = UnsignedIntProperty(167911424, EnetSleepCapability)
+    ENET_PHY_POWER_MODE = UnsignedIntProperty(167915520, EnetPhyPowerMode)
+
+    # Read/Write Automotive Ethernet port properties
+    ENET_PHY_STATE = UnsignedIntProperty(167837696, EnetPhyState)
+    ENET_PORT_MODE = UnsignedIntProperty(167833600, EnetPortMode)
+    ENET_LINK_SPEED_CONFIGURED = UnsignedIntProperty(167866368, EnetLinkSpeed)
+    ENET_JUMBO_FRAMES = UnsignedIntProperty(167903232, EnetJumboFrames)
+    ENET_INTERRUPT_MODERATION = IntProperty(167878656, EnetInterruptModeration)
+    ENET_SLEEP_CAPABILITY_CONFIGURED = UnsignedIntProperty(167907328, EnetSleepCapability)
+
+
+class Filter(PropertyGroup):
+    # Write-only device properties
+    NUMBER_OF_PORTS = UnsignedIntProperty(167780352)
+
+    # Write-only port properties
+    PORT_NUMBER = UnsignedIntProperty(167845888)
+    PROTOCOL = UnsignedIntProperty(167796737, Protocol)
+    CAN_TERMINATION_CAPABILITY = UnsignedIntProperty(167849984, Bool)
+    CAN_TRANSCEIVER_CAPABILITY = UnsignedIntProperty(167792641, CanTransceiverCapability)
+    DONGLE_ID = UnsignedIntProperty(167813120, DongleId)
+
+    # Write-only Automotive Ethernet port properties
+    ENET_PHY_STATE = UnsignedIntProperty(167837696, EnetPhyState)
+    ENET_PORT_MODE = UnsignedIntProperty(167833600, EnetPortMode)
+    ENET_LINK_SPEED_CONFIGURED = UnsignedIntProperty(167866368, EnetLinkSpeed)
```

## tests/test_import.py

 * *Ordering differences only*

```diff
@@ -1,16 +1,16 @@
-import os
-
-parent_dir, _ = os.path.split(os.path.dirname(__file__))
-# Set the current working directory to the parent directory of test_import.py.
-os.chdir(parent_dir)
-
-# Walk all module directories and create import tests for all non-private python
-# modules.
-for root, dirs, files in os.walk("nisyscfg"):
-    base_name = ".".join(root.split(os.path.sep))
-    if "__init__.py" in files:
-        exec("def test_{}(): import {}".format(base_name.replace(".", "_"), base_name))
-    for f in files:
-        if f.endswith(".py") and not f.startswith("_"):
-            mod_name = base_name + "." + f[:-3]
-            exec("def test_{}(): import {}".format(mod_name.replace(".", "_"), mod_name))
+import os
+
+parent_dir, _ = os.path.split(os.path.dirname(__file__))
+# Set the current working directory to the parent directory of test_import.py.
+os.chdir(parent_dir)
+
+# Walk all module directories and create import tests for all non-private python
+# modules.
+for root, dirs, files in os.walk("nisyscfg"):
+    base_name = ".".join(root.split(os.path.sep))
+    if "__init__.py" in files:
+        exec("def test_{}(): import {}".format(base_name.replace(".", "_"), base_name))
+    for f in files:
+        if f.endswith(".py") and not f.startswith("_"):
+            mod_name = base_name + "." + f[:-3]
+            exec("def test_{}(): import {}".format(mod_name.replace(".", "_"), mod_name))
```

## tests/test_session.py

```diff
@@ -1,1087 +1,1088 @@
-import ctypes
-import hightime
-import nisyscfg as nisyscfg
-import nisyscfg.enums
-import nisyscfg.errors
-import nisyscfg.properties
-import nisyscfg.timestamp
-import pytest
-
-try:
-    from unittest import mock
-except ImportError:
-    import mock
-
-
-def test_import():
-    nisyscfg.Session
-
-
-SESSION_HANDLE = 1
-EXPERT_ENUM_HANDLE = 2
-RESOURCE_ENUM_HANDLE = 3
-FILTER_HANDLE = 4
-SOFTWARE_COMPONENT_HANDLE = 5
-RESOURCE_HANDLE = 6
-
-
-STATUS_DESCRIPTION = ctypes.c_char_p(b"description")
-STATUS_DESCRIPTION_VOID_P = ctypes.cast(STATUS_DESCRIPTION, ctypes.c_void_p)
-
-
-class CVoidPMatcher(object):
-    def __init__(self, value):
-        self.value = value
-
-    def __eq__(self, other):
-        return ctypes.cast(other, ctypes.c_void_p).value == self.value
-
-    def __repr__(self):
-        return "c_void_p({})".format(self.value)
-
-
-class CIntPMatcher(object):
-    def __init__(self, value):
-        self.value = value
-
-    def __eq__(self, other):
-        return other.value == self.value
-
-    def __repr__(self):
-        return "{}".format(ctypes.c_int(self.value))
-
-
-class CUIntPMatcher(object):
-    def __init__(self, value):
-        self.value = value
-
-    def __eq__(self, other):
-        return other.value == self.value
-
-    def __repr__(self):
-        return "{}".format(ctypes.c_uint(self.value))
-
-
-class TimestampMatcher(object):
-    def __init__(self, value):
-        self.value = value
-
-    def __eq__(self, other):
-        return other[:] == self.value[:]
-
-    def __repr__(self):
-        return "{:08X}-{:08X}-{:08X}-{:08X}".format(*self.value[:])
-
-
-class ExpertInfoSideEffect(object):
-    def __init__(self, expert_name, display_name, version):
-        self.expert_name = expert_name
-        self.display_name = display_name
-        self.version = version
-
-    def __call__(self, handle, expert_name, display_name, version):
-        expert_name.value = self.expert_name
-        display_name.value = self.display_name
-        version.value = self.version
-        return nisyscfg.errors.Status.OK
-
-
-class NextResourceSideEffect(object):
-    def __init__(self, resource_handle):
-        self.resource_handle = resource_handle
-
-    def __call__(self, session_handle, resource_enum_handle, resource_handle):
-        resource_handle.contents.value = self.resource_handle
-        return nisyscfg.errors.Status.OK
-
-
-def initialize_session_mock(
-    target_name,
-    username,
-    password,
-    language,
-    force_property_refresh,
-    connect_timeout_msec,
-    expert_enum_handle,
-    session_handle,
-):
-    session_handle.contents.value = SESSION_HANDLE
-    if expert_enum_handle:
-        expert_enum_handle.contents.value = EXPERT_ENUM_HANDLE
-    return nisyscfg.errors.Status.OK
-
-
-def _get_status_description_mock(session_handle, status, detailed_description):
-    ctypes.cast(
-        detailed_description, ctypes.POINTER(ctypes.c_void_p)
-    ).contents.value = STATUS_DESCRIPTION_VOID_P.value
-    return nisyscfg.errors.Status.OK
-
-
-def get_system_experts_mock(session_handle, expert_names, expert_enum_handle):
-    expert_enum_handle.contents.value = EXPERT_ENUM_HANDLE
-    return nisyscfg.errors.Status.OK
-
-
-def find_hardware_mock(session_handle, mode, filter_handle, expert_names, resource_enum_handle):
-    resource_enum_handle.contents.value = RESOURCE_ENUM_HANDLE
-    return nisyscfg.errors.Status.OK
-
-
-def create_filter_mock(session_handle, filter_handle):
-    filter_handle.contents.value = FILTER_HANDLE
-    return nisyscfg.errors.Status.OK
-
-
-def get_available_software_components_mock(session_handle, item_types, software_component_handle):
-    software_component_handle.contents.value = SOFTWARE_COMPONENT_HANDLE
-    return nisyscfg.errors.Status.OK
-
-
-def get_installed_software_components_mock(
-    session_handle, item_types, cached, software_component_handle
-):
-    software_component_handle.contents.value = SOFTWARE_COMPONENT_HANDLE
-    return nisyscfg.errors.Status.OK
-
-
-def get_system_property_mock(session_handle, id, value):
-    if id == 16941086:
-        value.contents.value = RESOURCE_HANDLE
-    return nisyscfg.errors.Status.OK
-
-
-@pytest.fixture(scope="function")
-def lib_mock():
-    with mock.patch("platform.system") as platform_system_mock:
-        with mock.patch("platform.architecture") as platform_architecture_mock:
-            with mock.patch("ctypes.CDLL") as ctypes_mock:
-                platform_system_mock.return_value = "Linux"
-                platform_architecture_mock.return_value = ("64bit", "ELF")
-                lib = ctypes_mock.return_value
-                lib.__enter__.return_value = lib
-                lib.NISysCfgInitializeSession.side_effect = initialize_session_mock
-                lib.NISysCfgCloseHandle.return_value = nisyscfg.errors.Status.OK
-                lib.NISysCfgGetStatusDescription.side_effect = _get_status_description_mock
-                lib.NISysCfgFreeDetailedString.return_value = nisyscfg.errors.Status.OK
-                lib.NISysCfgGetSystemExperts.side_effect = get_system_experts_mock
-                lib.NISysCfgNextExpertInfo.return_value = nisyscfg.errors.Status.END_OF_ENUM
-                lib.NISysCfgFindHardware.side_effect = find_hardware_mock
-                lib.NISysCfgNextResource.return_value = nisyscfg.errors.Status.END_OF_ENUM
-                lib.NISysCfgCreateFilter.side_effect = create_filter_mock
-                lib.NISysCfgSetFilterProperty.return_value = nisyscfg.errors.Status.OK
-                lib.NISysCfgSetFilterPropertyWithType.return_value = nisyscfg.errors.Status.OK
-                lib.NISysCfgSetResourceProperty.return_value = nisyscfg.errors.Status.OK
-                lib.NISysCfgRestart.return_value = nisyscfg.errors.Status.OK
-                lib.NISysCfgGetAvailableSoftwareComponents.side_effect = (
-                    get_available_software_components_mock
-                )
-                lib.NISysCfgGetInstalledSoftwareComponents.side_effect = (
-                    get_installed_software_components_mock
-                )
-                lib.NISysCfgNextComponentInfo.return_value = nisyscfg.errors.Status.END_OF_ENUM
-                lib.NISysCfgGetSystemProperty.side_effect = get_system_property_mock
-                yield ctypes_mock
-    nisyscfg._library_singleton._instance = None
-
-
-@pytest.fixture(scope="function")
-def config_next_resource_side_effect_mock(lib_mock):
-    side_effect_functions = (
-        func
-        for func in [
-            NextResourceSideEffect(10),
-            lambda *x: nisyscfg.errors.Status.END_OF_ENUM,
-        ]
-    )
-
-    def next_resource_side_effect(session_handle, resource_enum_handle, resource_handle):
-        return next(side_effect_functions)(session_handle, resource_enum_handle, resource_handle)
-
-    lib_mock.return_value.NISysCfgNextResource.side_effect = next_resource_side_effect
-
-
-@pytest.fixture(scope="function")
-def config_get_resource_property_mock(lib_mock, expected_value):
-    def get_resource_property_mock(resource_handle, property_id, property_value):
-        if property_value.__class__.__name__.startswith("c_char_Array"):
-            property_value.value = expected_value.encode("ascii")
-        else:
-            property_value.contents.value = expected_value
-        return nisyscfg.errors.Status.OK
-
-    lib_mock.return_value.NISysCfgGetResourceProperty.side_effect = get_resource_property_mock
-
-
-def test_open_close_session_invokes_nisyscfg_c_api(lib_mock):
-    session = nisyscfg.Session()
-    session.close()
-    expected_calls = [
-        mock.call(mock.ANY),
-        mock.call().NISysCfgInitializeSession(
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-        ),
-        mock.call().NISysCfgCloseHandle(CVoidPMatcher(SESSION_HANDLE)),
-    ]
-    assert lib_mock.mock_calls == expected_calls
-
-
-def test_session_in_with_statement_invokes_nisyscfg_c_api(lib_mock):
-    with nisyscfg.Session():
-        pass
-    expected_calls = [
-        mock.call(mock.ANY),
-        mock.call().NISysCfgInitializeSession(
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-        ),
-        mock.call().NISysCfgCloseHandle(CVoidPMatcher(SESSION_HANDLE)),
-    ]
-    assert lib_mock.mock_calls == expected_calls
-
-
-def test_session_passes_target_name_to_initialize_session(lib_mock):
-    with nisyscfg.Session("localhost"):
-        pass
-    expected_calls = [
-        mock.call().NISysCfgInitializeSession(
-            b"localhost",
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-        ),
-    ]
-    assert lib_mock().NISysCfgInitializeSession.mock_calls == expected_calls
-
-
-def test_session_passes_username_and_password_to_initialize_session(lib_mock):
-    with nisyscfg.Session("localhost", "username", "password"):
-        pass
-    expected_calls = [
-        mock.call().NISysCfgInitializeSession(
-            mock.ANY,
-            b"username",
-            b"password",
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-        ),
-    ]
-    assert lib_mock().NISysCfgInitializeSession.mock_calls == expected_calls
-
-
-def test__get_status_description(lib_mock):
-    with nisyscfg.Session() as session:
-        assert "description" == session._get_status_description(
-            nisyscfg.errors.Status.OUT_OF_MEMORY
-        )
-    expected_calls = [
-        mock.call(mock.ANY),
-        mock.call().NISysCfgInitializeSession(
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-        ),
-        mock.call().NISysCfgGetStatusDescription(
-            CVoidPMatcher(SESSION_HANDLE),
-            nisyscfg.errors.Status.OUT_OF_MEMORY,
-            mock.ANY,
-        ),
-        mock.call().NISysCfgFreeDetailedString(CVoidPMatcher(STATUS_DESCRIPTION_VOID_P.value)),
-        mock.call().NISysCfgCloseHandle(CVoidPMatcher(SESSION_HANDLE)),
-    ]
-    assert lib_mock.mock_calls == expected_calls
-
-
-def test_get_system_experts_with_no_experts(lib_mock):
-    with nisyscfg.Session() as session:
-        session.get_system_experts()
-    expected_calls = [
-        mock.call(mock.ANY),
-        mock.call().NISysCfgInitializeSession(
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-        ),
-        mock.call().NISysCfgGetSystemExperts(CVoidPMatcher(SESSION_HANDLE), b"", mock.ANY),
-        mock.call().NISysCfgCloseHandle(CVoidPMatcher(EXPERT_ENUM_HANDLE)),
-        mock.call().NISysCfgCloseHandle(CVoidPMatcher(SESSION_HANDLE)),
-    ]
-    assert lib_mock.mock_calls == expected_calls
-
-
-def test_expert_info_iterator_raises_error_after_close(lib_mock):
-    with nisyscfg.Session() as session:
-        expert_info = session.get_system_experts()
-        expert_info.close()
-        with pytest.raises(Exception):
-            expert_info.next()
-
-
-def test_get_system_experts_with_two_experts(lib_mock):
-    side_effect_functions = (
-        func
-        for func in [
-            ExpertInfoSideEffect(b"sync", b"NI-Sync", b"1.2.0"),
-            ExpertInfoSideEffect(b"xnet", b"NI-XNET", b"10.0"),
-            lambda *x: nisyscfg.errors.Status.END_OF_ENUM,
-        ]
-    )
-
-    def expert_info_side_effect(handle, expert_name, display_name, version):
-        return next(side_effect_functions)(handle, expert_name, display_name, version)
-
-    lib_mock.return_value.NISysCfgNextExpertInfo.side_effect = expert_info_side_effect
-
-    with nisyscfg.Session() as session:
-        expert_info = list(session.get_system_experts())
-    expected_calls = [
-        mock.call(mock.ANY),
-        mock.call().NISysCfgInitializeSession(
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-        ),
-        mock.call().NISysCfgGetSystemExperts(CVoidPMatcher(SESSION_HANDLE), b"", mock.ANY),
-        mock.call().NISysCfgNextExpertInfo(
-            CVoidPMatcher(EXPERT_ENUM_HANDLE), mock.ANY, mock.ANY, mock.ANY
-        ),
-        mock.call().NISysCfgNextExpertInfo(
-            CVoidPMatcher(EXPERT_ENUM_HANDLE), mock.ANY, mock.ANY, mock.ANY
-        ),
-        mock.call().NISysCfgNextExpertInfo(
-            CVoidPMatcher(EXPERT_ENUM_HANDLE), mock.ANY, mock.ANY, mock.ANY
-        ),
-        mock.call().NISysCfgCloseHandle(CVoidPMatcher(EXPERT_ENUM_HANDLE)),
-        mock.call().NISysCfgCloseHandle(CVoidPMatcher(SESSION_HANDLE)),
-    ]
-    assert lib_mock.mock_calls == expected_calls
-    assert len(expert_info) == 2
-    assert expert_info[0].expert_name == "sync"
-    assert expert_info[0].display_name == "NI-Sync"
-    assert expert_info[0].version == "1.2.0"
-    assert expert_info[1].expert_name == "xnet"
-    assert expert_info[1].display_name == "NI-XNET"
-    assert expert_info[1].version == "10.0"
-
-
-def test_get_system_experts_with_csv_expert_names(lib_mock):
-    with nisyscfg.Session() as session:
-        session.get_system_experts("xnet,sync")
-    expected_calls = [
-        mock.call().NISysCfgGetSystemExperts(CVoidPMatcher(SESSION_HANDLE), b"xnet,sync", mock.ANY),
-    ]
-    assert lib_mock().NISysCfgGetSystemExperts.mock_calls == expected_calls
-
-
-def test_get_system_experts_with_list_of_expert_names(lib_mock):
-    with nisyscfg.Session() as session:
-        session.get_system_experts(["xnet", "sync"])
-    expected_calls = [
-        mock.call().NISysCfgGetSystemExperts(CVoidPMatcher(SESSION_HANDLE), b"xnet,sync", mock.ANY),
-    ]
-    assert lib_mock().NISysCfgGetSystemExperts.mock_calls == expected_calls
-
-
-def test_find_hardware_with_default_arguments(lib_mock):
-    with nisyscfg.Session() as session:
-        session.find_hardware()
-    expected_calls = [
-        mock.call(mock.ANY),
-        mock.call().NISysCfgInitializeSession(
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-        ),
-        mock.call().NISysCfgFindHardware(
-            CVoidPMatcher(SESSION_HANDLE),
-            nisyscfg.enums.FilterMode.MATCH_VALUES_ALL,
-            None,
-            b"",
-            mock.ANY,
-        ),
-        mock.call().NISysCfgCloseHandle(CVoidPMatcher(RESOURCE_ENUM_HANDLE)),
-        mock.call().NISysCfgCloseHandle(CVoidPMatcher(SESSION_HANDLE)),
-    ]
-    assert lib_mock.mock_calls == expected_calls
-
-
-def test_find_hardware_with_filter_properties_specified(lib_mock):
-    with nisyscfg.Session() as session:
-        filter = session.create_filter()
-        filter.expert_name = "my_expert"
-        session.find_hardware(filter)
-    expected_calls = [
-        mock.call(mock.ANY),
-        mock.call().NISysCfgInitializeSession(
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-        ),
-        mock.call().NISysCfgCreateFilter(CVoidPMatcher(SESSION_HANDLE), mock.ANY),
-        mock.call().NISysCfgSetFilterPropertyWithType(
-            CVoidPMatcher(FILTER_HANDLE),
-            nisyscfg.properties.Filter.EXPERT_NAME._id,
-            nisyscfg.enums.PropertyType.STRING,
-            b"my_expert",
-        ),
-        mock.call().NISysCfgFindHardware(
-            CVoidPMatcher(SESSION_HANDLE),
-            nisyscfg.enums.FilterMode.MATCH_VALUES_ALL,
-            mock.ANY,
-            b"",
-            mock.ANY,
-        ),
-        mock.call().NISysCfgCloseHandle(CVoidPMatcher(RESOURCE_ENUM_HANDLE)),
-        mock.call().NISysCfgCloseHandle(CVoidPMatcher(FILTER_HANDLE)),
-        mock.call().NISysCfgCloseHandle(CVoidPMatcher(SESSION_HANDLE)),
-    ]
-    assert lib_mock.mock_calls == expected_calls
-
-
-def test_find_hardware_with_csv_expert_names(lib_mock):
-    with nisyscfg.Session() as session:
-        session.find_hardware(expert_names="xnet,sync")
-    expected_calls = [
-        mock.call().NISysCfgFindHardware(mock.ANY, mock.ANY, mock.ANY, b"xnet,sync", mock.ANY),
-    ]
-    assert lib_mock().NISysCfgFindHardware.mock_calls == expected_calls
-
-
-def test_find_hardware_with_list_of_expert_names(lib_mock):
-    with nisyscfg.Session() as session:
-        session.find_hardware(expert_names=["xnet", "sync"])
-    expected_calls = [
-        mock.call().NISysCfgFindHardware(mock.ANY, mock.ANY, mock.ANY, b"xnet,sync", mock.ANY),
-    ]
-    assert lib_mock().NISysCfgFindHardware.mock_calls == expected_calls
-
-
-@pytest.mark.parametrize(
-    "property_name, property_type, assigned_value, expected_value",
-    [
-        ("IS_DEVICE", nisyscfg.enums.PropertyType.BOOL, True, CIntPMatcher(1)),
-        ("IS_CHASSIS", nisyscfg.enums.PropertyType.BOOL, False, CIntPMatcher(0)),
-        ("EXPERT_NAME", nisyscfg.enums.PropertyType.STRING, "my_expert", b"my_expert"),
-        ("USER_ALIAS", nisyscfg.enums.PropertyType.STRING, "my_alias", b"my_alias"),
-        (
-            "VENDOR_ID",
-            nisyscfg.enums.PropertyType.UNSIGNED_INT,
-            1337,
-            CUIntPMatcher(1337),
-        ),
-    ],
-)
-def test_find_hardware_with_passed_filter_properties_specified(
-    lib_mock, property_name, property_type, assigned_value, expected_value
-):
-    with nisyscfg.Session() as session:
-        filter = session.create_filter()
-        setattr(filter, property_name.lower(), assigned_value)
-        session.find_hardware(filter)
-        property_id = getattr(nisyscfg.properties.Filter, property_name)._id
-    expected_calls = [
-        mock.call(mock.ANY),
-        mock.call().NISysCfgInitializeSession(
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-        ),
-        mock.call().NISysCfgCreateFilter(CVoidPMatcher(SESSION_HANDLE), mock.ANY),
-        mock.call().NISysCfgSetFilterPropertyWithType(
-            CVoidPMatcher(FILTER_HANDLE), property_id, property_type, expected_value
-        ),
-        mock.call().NISysCfgFindHardware(
-            CVoidPMatcher(SESSION_HANDLE),
-            nisyscfg.enums.FilterMode.MATCH_VALUES_ALL,
-            mock.ANY,
-            b"",
-            mock.ANY,
-        ),
-        mock.call().NISysCfgCloseHandle(CVoidPMatcher(RESOURCE_ENUM_HANDLE)),
-        mock.call().NISysCfgCloseHandle(CVoidPMatcher(FILTER_HANDLE)),
-        mock.call().NISysCfgCloseHandle(CVoidPMatcher(SESSION_HANDLE)),
-    ]
-    assert lib_mock.mock_calls == expected_calls
-
-
-def test_create_filter(lib_mock):
-    with nisyscfg.Session() as session:
-        session.create_filter()
-    expected_calls = [
-        mock.call(mock.ANY),
-        mock.call().NISysCfgInitializeSession(
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-        ),
-        mock.call().NISysCfgCreateFilter(CVoidPMatcher(SESSION_HANDLE), mock.ANY),
-        mock.call().NISysCfgCloseHandle(CVoidPMatcher(FILTER_HANDLE)),
-        mock.call().NISysCfgCloseHandle(CVoidPMatcher(SESSION_HANDLE)),
-    ]
-    assert lib_mock.mock_calls == expected_calls
-
-
-def test_create_filter_and_set_syscfg_filter_property(lib_mock):
-    with nisyscfg.Session() as session:
-        filter = session.create_filter()
-        filter.expert_name = "my_expert"
-    expected_calls = [
-        mock.call(mock.ANY),
-        mock.call().NISysCfgInitializeSession(
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-        ),
-        mock.call().NISysCfgCreateFilter(CVoidPMatcher(SESSION_HANDLE), mock.ANY),
-        mock.call().NISysCfgSetFilterPropertyWithType(
-            CVoidPMatcher(FILTER_HANDLE),
-            nisyscfg.properties.Filter.EXPERT_NAME._id,
-            nisyscfg.enums.PropertyType.STRING,
-            b"my_expert",
-        ),
-        mock.call().NISysCfgCloseHandle(CVoidPMatcher(FILTER_HANDLE)),
-        mock.call().NISysCfgCloseHandle(CVoidPMatcher(SESSION_HANDLE)),
-    ]
-    assert lib_mock.mock_calls == expected_calls
-
-
-def test_restart_with_default_arguments(lib_mock):
-    with nisyscfg.Session() as session:
-        session.restart()
-    expected_calls = [
-        mock.call(mock.ANY),
-        mock.call().NISysCfgInitializeSession(
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-        ),
-        mock.call().NISysCfgRestart(
-            CVoidPMatcher(SESSION_HANDLE), True, False, False, mock.ANY, mock.ANY
-        ),
-        mock.call().NISysCfgCloseHandle(CVoidPMatcher(SESSION_HANDLE)),
-    ]
-    assert lib_mock.mock_calls == expected_calls
-
-
-def test_get_available_software_components_with_default_arguments(lib_mock):
-    with nisyscfg.Session() as session:
-        session.get_available_software_components()
-    expected_calls = [
-        mock.call(mock.ANY),
-        mock.call().NISysCfgInitializeSession(
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-        ),
-        mock.call().NISysCfgGetAvailableSoftwareComponents(
-            CVoidPMatcher(SESSION_HANDLE), mock.ANY, mock.ANY
-        ),
-        mock.call().NISysCfgCloseHandle(CVoidPMatcher(SOFTWARE_COMPONENT_HANDLE)),
-        mock.call().NISysCfgCloseHandle(CVoidPMatcher(SESSION_HANDLE)),
-    ]
-    assert lib_mock.mock_calls == expected_calls
-
-
-def test_get_installed_software_components_with_default_arguments(lib_mock):
-    with nisyscfg.Session() as session:
-        session.get_installed_software_components()
-    expected_calls = [
-        mock.call(mock.ANY),
-        mock.call().NISysCfgInitializeSession(
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-        ),
-        mock.call().NISysCfgGetInstalledSoftwareComponents(
-            CVoidPMatcher(SESSION_HANDLE), mock.ANY, False, mock.ANY
-        ),
-        mock.call().NISysCfgCloseHandle(CVoidPMatcher(SOFTWARE_COMPONENT_HANDLE)),
-        mock.call().NISysCfgCloseHandle(CVoidPMatcher(SESSION_HANDLE)),
-    ]
-    assert lib_mock.mock_calls == expected_calls
-
-
-def test_interating_over_hardware_resources(lib_mock):
-    side_effect_functions = (
-        func
-        for func in [
-            NextResourceSideEffect(10),
-            NextResourceSideEffect(11),
-            NextResourceSideEffect(12),
-            lambda *x: nisyscfg.errors.Status.END_OF_ENUM,
-        ]
-    )
-
-    def next_resource_side_effect(session_handle, resource_enum_handle, resource_handle):
-        return next(side_effect_functions)(session_handle, resource_enum_handle, resource_handle)
-
-    lib_mock.return_value.NISysCfgNextResource.side_effect = next_resource_side_effect
-
-    with nisyscfg.Session() as session:
-        resources = list(session.find_hardware())
-        assert len(resources) == 3
-
-    expected_calls = [
-        mock.call(mock.ANY),
-        mock.call().NISysCfgInitializeSession(
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-        ),
-        mock.call().NISysCfgFindHardware(mock.ANY, mock.ANY, mock.ANY, mock.ANY, mock.ANY),
-        mock.call().NISysCfgNextResource(
-            CVoidPMatcher(SESSION_HANDLE), CVoidPMatcher(RESOURCE_ENUM_HANDLE), mock.ANY
-        ),
-        mock.call().NISysCfgNextResource(
-            CVoidPMatcher(SESSION_HANDLE), CVoidPMatcher(RESOURCE_ENUM_HANDLE), mock.ANY
-        ),
-        mock.call().NISysCfgNextResource(
-            CVoidPMatcher(SESSION_HANDLE), CVoidPMatcher(RESOURCE_ENUM_HANDLE), mock.ANY
-        ),
-        mock.call().NISysCfgNextResource(
-            CVoidPMatcher(SESSION_HANDLE), CVoidPMatcher(RESOURCE_ENUM_HANDLE), mock.ANY
-        ),
-        mock.call().NISysCfgCloseHandle(CVoidPMatcher(12)),
-        mock.call().NISysCfgCloseHandle(CVoidPMatcher(11)),
-        mock.call().NISysCfgCloseHandle(CVoidPMatcher(10)),
-        mock.call().NISysCfgCloseHandle(CVoidPMatcher(RESOURCE_ENUM_HANDLE)),
-        mock.call().NISysCfgCloseHandle(CVoidPMatcher(SESSION_HANDLE)),
-    ]
-    assert lib_mock.mock_calls == expected_calls
-
-
-def test_hardware_resource_raises_error_after_close(lib_mock):
-    with nisyscfg.Session() as session:
-        resource = session.find_hardware()
-        resource.close()
-        with pytest.raises(Exception):
-            resource.next()
-
-
-@pytest.mark.parametrize(
-    "property_name, expected_value",
-    [
-        ("IS_DEVICE", True),
-        ("IS_CHASSIS", False),
-        ("VENDOR_ID", 0x1093),
-        ("VENDOR_NAME", "National Instruments"),
-        ("PRODUCT_ID", 0xABC),
-        ("PRODUCT_NAME", "NI-BubbleGum"),
-    ],
-)
-def test_get_hardware_resource_property(
-    lib_mock,
-    config_next_resource_side_effect_mock,
-    config_get_resource_property_mock,
-    property_name,
-    expected_value,
-):
-    with nisyscfg.Session() as session:
-        resource = next(session.find_hardware())
-        assert expected_value == getattr(resource, property_name.lower())
-        property_id = getattr(nisyscfg.properties.Resource, property_name)._id
-
-    expected_calls = [
-        mock.call(mock.ANY),
-        mock.call().NISysCfgInitializeSession(
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-        ),
-        mock.call().NISysCfgFindHardware(mock.ANY, mock.ANY, mock.ANY, mock.ANY, mock.ANY),
-        mock.call().NISysCfgNextResource(mock.ANY, mock.ANY, mock.ANY),
-        mock.call().NISysCfgGetResourceProperty(CVoidPMatcher(10), property_id, mock.ANY),
-        mock.call().NISysCfgCloseHandle(CVoidPMatcher(10)),
-        mock.call().NISysCfgCloseHandle(CVoidPMatcher(RESOURCE_ENUM_HANDLE)),
-        mock.call().NISysCfgCloseHandle(CVoidPMatcher(SESSION_HANDLE)),
-    ]
-    assert lib_mock.mock_calls == expected_calls
-
-
-def test_get_hardware_resource_timestamp_property(
-    lib_mock,
-    config_next_resource_side_effect_mock,
-):
-    timestamp = nisyscfg.types.TimestampUTC()
-    timestamp[2] = 0x7C25B080
-
-    def get_resource_property_side_effect(resource_handle, property_id, property_value):
-        property_value.contents[:] = timestamp[:]
-        return nisyscfg.errors.Status.OK
-
-    def values_from_timestamp_side_effect(timestamp, secondsSinceEpoch1970, fractionalSeconds):
-        secondsSinceEpoch1970.contents.value = 0
-        fractionalSeconds.contents.value = 0.0
-        return nisyscfg.errors.Status.OK
-
-    lib_mock.return_value.NISysCfgGetResourceProperty.side_effect = (
-        get_resource_property_side_effect
-    )
-    lib_mock.return_value.NISysCfgValuesFromTimestamp.side_effect = (
-        values_from_timestamp_side_effect
-    )
-
-    with nisyscfg.Session() as session:
-        resource = next(session.find_hardware())
-        assert nisyscfg.timestamp.tai_epoch == resource.current_time
-        property_id = nisyscfg.properties.Resource.CURRENT_TIME._id
-
-    expected_calls = [
-        mock.call(mock.ANY),
-        mock.call().NISysCfgInitializeSession(
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-        ),
-        mock.call().NISysCfgFindHardware(mock.ANY, mock.ANY, mock.ANY, mock.ANY, mock.ANY),
-        mock.call().NISysCfgNextResource(mock.ANY, mock.ANY, mock.ANY),
-        mock.call().NISysCfgGetResourceProperty(CVoidPMatcher(10), property_id, mock.ANY),
-        mock.call().NISysCfgValuesFromTimestamp(TimestampMatcher(timestamp), mock.ANY, mock.ANY),
-        mock.call().NISysCfgCloseHandle(CVoidPMatcher(10)),
-        mock.call().NISysCfgCloseHandle(CVoidPMatcher(RESOURCE_ENUM_HANDLE)),
-        mock.call().NISysCfgCloseHandle(CVoidPMatcher(SESSION_HANDLE)),
-    ]
-    assert lib_mock.mock_calls == expected_calls
-
-
-@pytest.mark.parametrize(
-    "user_alias, resource_name, expected_value",
-    [
-        ("My Device", "My Resource", "My Device"),
-        ("", "My Resource", "My Resource"),
-        ("", "", ""),
-    ],
-)
-def test_get_hardware_resource_name(
-    lib_mock,
-    config_next_resource_side_effect_mock,
-    user_alias,
-    resource_name,
-    expected_value,
-):
-    with mock.patch.object(
-        nisyscfg.hardware_resource.HardwareResource, "expert_user_alias"
-    ) as expert_user_alias_mock, mock.patch.object(
-        nisyscfg.hardware_resource.HardwareResource, "expert_resource_name"
-    ) as expert_resource_name_mock:
-        expert_user_alias_mock.__getitem__.return_value = user_alias
-        expert_resource_name_mock.__getitem__.return_value = resource_name
-
-        with nisyscfg.Session() as session:
-            resource = next(session.find_hardware())
-            assert expected_value == resource.name
-
-
-def test_get_hardware_resource_property_catches_prop_does_not_exist_and_raises_attribute_error(
-    lib_mock, config_next_resource_side_effect_mock
-):
-    lib_mock.return_value.NISysCfgGetResourceProperty.return_value = (
-        nisyscfg.errors.Status.PROP_DOES_NOT_EXIST
-    )
-
-    with nisyscfg.Session() as session:
-        resource = next(session.find_hardware())
-        with pytest.raises(AttributeError):
-            getattr(resource, "IsDevice")
-
-
-def test_get_hardware_resource_property_raises_library_error_when_error_code_is_not_prop_does_not_exist(
-    lib_mock, config_next_resource_side_effect_mock
-):
-    lib_mock.return_value.NISysCfgGetResourceProperty.return_value = (
-        nisyscfg.errors.Status.OUT_OF_MEMORY
-    )
-
-    with nisyscfg.Session() as session:
-        resource = next(session.find_hardware())
-        with pytest.raises(nisyscfg.errors.LibraryError):
-            resource.is_device
-
-
-def test_hardware_resource_get_property_raises_library_error_when_error_code_is_not_prop_does_not_exist(
-    lib_mock, config_next_resource_side_effect_mock
-):
-    lib_mock.return_value.NISysCfgGetResourceProperty.return_value = (
-        nisyscfg.errors.Status.PROP_DOES_NOT_EXIST
-    )
-
-    with nisyscfg.Session() as session:
-        resource = next(session.find_hardware())
-        with pytest.raises(nisyscfg.errors.LibraryError):
-            resource.get_property("is_device")
-
-
-def test_hardware_resource_get_property_returns_default_when_error_code_is_not_prop_does_not_exist(
-    lib_mock, config_next_resource_side_effect_mock
-):
-    lib_mock.return_value.NISysCfgGetResourceProperty.return_value = (
-        nisyscfg.errors.Status.PROP_DOES_NOT_EXIST
-    )
-
-    with nisyscfg.Session() as session:
-        resource = next(session.find_hardware())
-        assert resource.get_property("is_device", True) is True
-
-
-@pytest.mark.parametrize(
-    "property_name, count_property, expected_values",
-    [
-        ("EXPERT_NAME", "NUMBER_OF_EXPERTS", ["xnet", "sync"]),
-        ("EXPERT_USER_ALIAS", "NUMBER_OF_EXPERTS", ["myDevice"]),
-        (
-            "AVAILABLE_FIRMWARE_VERSION",
-            "NUMBER_OF_AVAILABLE_FIRMWARE_VERSIONS",
-            ["1.0", "2.1", "3.3.3"],
-        ),
-        (
-            "WLAN_AVAILABLE_CHANNEL_NUMBER",
-            "NUMBER_OF_DISCOVERED_ACCESS_POINTS",
-            [3, 1, 2],
-        ),
-        (
-            "WLAN_AVAILABLE_LINK_SPEED",
-            "NUMBER_OF_DISCOVERED_ACCESS_POINTS",
-            [nisyscfg.enums.LinkSpeed.AUTO],
-        ),
-    ],
-)
-def test_get_hardware_index_property(lib_mock, property_name, count_property, expected_values):
-    side_effect_functions = (
-        func
-        for func in [
-            NextResourceSideEffect(10),
-            lambda *x: nisyscfg.errors.Status.END_OF_ENUM,
-        ]
-    )
-
-    def next_resource_side_effect(session_handle, resource_enum_handle, resource_handle):
-        return next(side_effect_functions)(session_handle, resource_enum_handle, resource_handle)
-
-    def get_resource_property_mock(resource_handle, property_id, property_value):
-        property_value.contents.value = len(expected_values)
-        return nisyscfg.errors.Status.OK
-
-    def get_indexed_property_mock(resource_handle, property_id, index, property_value):
-        try:
-            if property_value.__class__.__name__.startswith("c_char_Array"):
-                property_value.value = expected_values[index].encode("ascii")
-            else:
-                property_value.contents.value = expected_values[index]
-            return nisyscfg.errors.Status.OK
-        except IndexError:
-            return nisyscfg.errors.Status.PROP_DOES_NOT_EXIST
-
-    lib_mock.return_value.NISysCfgNextResource.side_effect = next_resource_side_effect
-    lib_mock.return_value.NISysCfgGetResourceProperty.side_effect = get_resource_property_mock
-    lib_mock.return_value.NISysCfgGetResourceIndexedProperty.side_effect = get_indexed_property_mock
-
-    with nisyscfg.Session() as session:
-        resource = next(session.find_hardware())
-        property = getattr(resource, property_name.lower())
-        assert expected_values == list(property)
-        count_property_id = getattr(nisyscfg.properties.Resource, count_property)._id
-        property_id = getattr(nisyscfg.properties.IndexedResource, property_name)._id
-
-    expected_calls = [
-        mock.call(mock.ANY),
-        mock.call().NISysCfgInitializeSession(
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-        ),
-        mock.call().NISysCfgFindHardware(mock.ANY, mock.ANY, mock.ANY, mock.ANY, mock.ANY),
-        mock.call().NISysCfgNextResource(mock.ANY, mock.ANY, mock.ANY),
-        mock.call().NISysCfgGetResourceProperty(CVoidPMatcher(10), count_property_id, mock.ANY),
-    ]
-    expected_calls += [
-        mock.call().NISysCfgGetResourceIndexedProperty(CVoidPMatcher(10), property_id, i, mock.ANY)
-        for i in range(len(expected_values) + 1)
-    ]
-    expected_calls += [
-        mock.call().NISysCfgCloseHandle(CVoidPMatcher(10)),
-        mock.call().NISysCfgCloseHandle(CVoidPMatcher(RESOURCE_ENUM_HANDLE)),
-        mock.call().NISysCfgCloseHandle(CVoidPMatcher(SESSION_HANDLE)),
-    ]
-    assert lib_mock.mock_calls == expected_calls
-
-
-def test_set_hardware_resource_timestamp_property(
-    lib_mock,
-    config_next_resource_side_effect_mock,
-):
-
-    ctypes_timestamp = nisyscfg.types.TimestampUTC(100, 200, 300, 400)  # random values
-
-    def timestamp_from_values_side_effect(secondsSinceEpoch1970, fractionalSeconds, timestamp):
-        timestamp.contents[:] = ctypes_timestamp
-        return nisyscfg.errors.Status.OK
-
-    lib_mock.NISysCfgSetResourceProperty.return_value = nisyscfg.errors.Status.OK
-
-    lib_mock.return_value.NISysCfgTimestampFromValues.side_effect = (
-        timestamp_from_values_side_effect
-    )
-    property_id = nisyscfg.properties.Resource.CURRENT_TIME._id
-
-    with nisyscfg.Session() as session:
-        resource = next(session.find_hardware())
-        resource.current_time = nisyscfg.timestamp.tai_epoch + hightime.timedelta(seconds=100)
-
-    expected_calls = [
-        mock.call(mock.ANY),
-        mock.call().NISysCfgInitializeSession(
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-            mock.ANY,
-        ),
-        mock.call().NISysCfgFindHardware(mock.ANY, mock.ANY, mock.ANY, mock.ANY, mock.ANY),
-        mock.call().NISysCfgNextResource(mock.ANY, mock.ANY, mock.ANY),
-        mock.call().NISysCfgTimestampFromValues(100, 0.0, mock.ANY),
-        mock.call().NISysCfgSetResourceProperty(CVoidPMatcher(10), property_id, TimestampMatcher(ctypes_timestamp)),
-        mock.call().NISysCfgCloseHandle(CVoidPMatcher(10)),
-        mock.call().NISysCfgCloseHandle(CVoidPMatcher(RESOURCE_ENUM_HANDLE)),
-        mock.call().NISysCfgCloseHandle(CVoidPMatcher(SESSION_HANDLE)),
-    ]
-    assert lib_mock.mock_calls == expected_calls
-
-
-def test_session_has_resource(lib_mock):
-    with nisyscfg.Session() as session:
-        assert "resource" in dir(session)
-
-
-def test_session_resource_has_pxi(lib_mock):
-    with nisyscfg.Session() as session:
-        assert "pxi" in dir(session.resource)
-
-
-def test_sesssion_resource_pxi_has_fan_mode(lib_mock):
-    with nisyscfg.Session() as session:
-        assert "fan_mode" in dir(session.resource.pxi)
-
-
-def test_session_resource_pxi_has_power_supply_name(lib_mock):
-    with nisyscfg.Session() as session:
-        assert "power_supply_name" in dir(session.resource.pxi)
-
-
-def test_session_resource_has_xnet(lib_mock):
-    with nisyscfg.Session() as session:
-        assert "xnet" in dir(session.resource)
-
-
-def test_session_resource_xnet_has_protocol(lib_mock):
-    with nisyscfg.Session() as session:
-        assert "protocol" in dir(session.resource.xnet)
-
-
-def test_filter_has_xnet(lib_mock):
-    with nisyscfg.Session() as session:
-        filter = session.create_filter()
-        assert "xnet" in dir(filter)
-
-
-def test_filter_xnet_has_protocol(lib_mock):
-    with nisyscfg.Session() as session:
-        filter = session.create_filter()
-        assert "protocol" in dir(filter.xnet)
+import ctypes
+import hightime
+import nisyscfg as nisyscfg
+import nisyscfg.enums
+import nisyscfg.errors
+import nisyscfg.properties
+import nisyscfg.timestamp
+import pytest
+
+try:
+    from unittest import mock
+except ImportError:
+    import mock
+
+
+def test_import():
+    nisyscfg.Session
+
+
+SESSION_HANDLE = 1
+EXPERT_ENUM_HANDLE = 2
+RESOURCE_ENUM_HANDLE = 3
+FILTER_HANDLE = 4
+SOFTWARE_COMPONENT_HANDLE = 5
+RESOURCE_HANDLE = 6
+
+
+STATUS_DESCRIPTION = ctypes.c_char_p(b"description")
+STATUS_DESCRIPTION_VOID_P = ctypes.cast(STATUS_DESCRIPTION, ctypes.c_void_p)
+
+
+class CVoidPMatcher(object):
+    def __init__(self, value):
+        self.value = value
+
+    def __eq__(self, other):
+        return ctypes.cast(other, ctypes.c_void_p).value == self.value
+
+    def __repr__(self):
+        return "c_void_p({})".format(self.value)
+
+
+class CIntPMatcher(object):
+    def __init__(self, value):
+        self.value = value
+
+    def __eq__(self, other):
+        return other.value == self.value
+
+    def __repr__(self):
+        return "{}".format(ctypes.c_int(self.value))
+
+
+class CUIntPMatcher(object):
+    def __init__(self, value):
+        self.value = value
+
+    def __eq__(self, other):
+        return other.value == self.value
+
+    def __repr__(self):
+        return "{}".format(ctypes.c_uint(self.value))
+
+
+class TimestampMatcher(object):
+    def __init__(self, value):
+        self.value = value
+
+    def __eq__(self, other):
+        return other[:] == self.value[:]
+
+    def __repr__(self):
+        return "{:08X}-{:08X}-{:08X}-{:08X}".format(*self.value[:])
+
+
+class ExpertInfoSideEffect(object):
+    def __init__(self, expert_name, display_name, version):
+        self.expert_name = expert_name
+        self.display_name = display_name
+        self.version = version
+
+    def __call__(self, handle, expert_name, display_name, version):
+        expert_name.value = self.expert_name
+        display_name.value = self.display_name
+        version.value = self.version
+        return nisyscfg.errors.Status.OK
+
+
+class NextResourceSideEffect(object):
+    def __init__(self, resource_handle):
+        self.resource_handle = resource_handle
+
+    def __call__(self, session_handle, resource_enum_handle, resource_handle):
+        resource_handle.contents.value = self.resource_handle
+        return nisyscfg.errors.Status.OK
+
+
+def initialize_session_mock(
+    target_name,
+    username,
+    password,
+    language,
+    force_property_refresh,
+    connect_timeout_msec,
+    expert_enum_handle,
+    session_handle,
+):
+    session_handle.contents.value = SESSION_HANDLE
+    if expert_enum_handle:
+        expert_enum_handle.contents.value = EXPERT_ENUM_HANDLE
+    return nisyscfg.errors.Status.OK
+
+
+def _get_status_description_mock(session_handle, status, detailed_description):
+    ctypes.cast(
+        detailed_description, ctypes.POINTER(ctypes.c_void_p)
+    ).contents.value = STATUS_DESCRIPTION_VOID_P.value
+    return nisyscfg.errors.Status.OK
+
+
+def get_system_experts_mock(session_handle, expert_names, expert_enum_handle):
+    expert_enum_handle.contents.value = EXPERT_ENUM_HANDLE
+    return nisyscfg.errors.Status.OK
+
+
+def find_hardware_mock(session_handle, mode, filter_handle, expert_names, resource_enum_handle):
+    resource_enum_handle.contents.value = RESOURCE_ENUM_HANDLE
+    return nisyscfg.errors.Status.OK
+
+
+def create_filter_mock(session_handle, filter_handle):
+    filter_handle.contents.value = FILTER_HANDLE
+    return nisyscfg.errors.Status.OK
+
+
+def get_available_software_components_mock(session_handle, item_types, software_component_handle):
+    software_component_handle.contents.value = SOFTWARE_COMPONENT_HANDLE
+    return nisyscfg.errors.Status.OK
+
+
+def get_installed_software_components_mock(
+    session_handle, item_types, cached, software_component_handle
+):
+    software_component_handle.contents.value = SOFTWARE_COMPONENT_HANDLE
+    return nisyscfg.errors.Status.OK
+
+
+def get_system_property_mock(session_handle, id, value):
+    if id == 16941086:
+        value.contents.value = RESOURCE_HANDLE
+    return nisyscfg.errors.Status.OK
+
+
+@pytest.fixture(scope="function")
+def lib_mock():
+    with mock.patch("platform.system") as platform_system_mock:
+        with mock.patch("platform.architecture") as platform_architecture_mock:
+            with mock.patch("ctypes.CDLL") as ctypes_mock:
+                platform_system_mock.return_value = "Linux"
+                platform_architecture_mock.return_value = ("64bit", "ELF")
+                lib = ctypes_mock.return_value
+                lib.__enter__.return_value = lib
+                lib.NISysCfgInitializeSession.side_effect = initialize_session_mock
+                lib.NISysCfgCloseHandle.return_value = nisyscfg.errors.Status.OK
+                lib.NISysCfgGetStatusDescription.side_effect = _get_status_description_mock
+                lib.NISysCfgFreeDetailedString.return_value = nisyscfg.errors.Status.OK
+                lib.NISysCfgGetSystemExperts.side_effect = get_system_experts_mock
+                lib.NISysCfgNextExpertInfo.return_value = nisyscfg.errors.Status.END_OF_ENUM
+                lib.NISysCfgFindHardware.side_effect = find_hardware_mock
+                lib.NISysCfgNextResource.return_value = nisyscfg.errors.Status.END_OF_ENUM
+                lib.NISysCfgCreateFilter.side_effect = create_filter_mock
+                lib.NISysCfgSetFilterProperty.return_value = nisyscfg.errors.Status.OK
+                lib.NISysCfgSetFilterPropertyWithType.return_value = nisyscfg.errors.Status.OK
+                lib.NISysCfgSetResourceProperty.return_value = nisyscfg.errors.Status.OK
+                lib.NISysCfgRestart.return_value = nisyscfg.errors.Status.OK
+                lib.NISysCfgGetAvailableSoftwareComponents.side_effect = (
+                    get_available_software_components_mock
+                )
+                lib.NISysCfgGetInstalledSoftwareComponents.side_effect = (
+                    get_installed_software_components_mock
+                )
+                lib.NISysCfgNextComponentInfo.return_value = nisyscfg.errors.Status.END_OF_ENUM
+                lib.NISysCfgGetSystemProperty.side_effect = get_system_property_mock
+                yield ctypes_mock
+    nisyscfg._library_singleton._instance = None
+
+
+@pytest.fixture(scope="function")
+def config_next_resource_side_effect_mock(lib_mock):
+    side_effect_functions = (
+        func
+        for func in [
+            NextResourceSideEffect(10),
+            lambda *x: nisyscfg.errors.Status.END_OF_ENUM,
+        ]
+    )
+
+    def next_resource_side_effect(session_handle, resource_enum_handle, resource_handle):
+        return next(side_effect_functions)(session_handle, resource_enum_handle, resource_handle)
+
+    lib_mock.return_value.NISysCfgNextResource.side_effect = next_resource_side_effect
+
+
+@pytest.fixture(scope="function")
+def config_get_resource_property_mock(lib_mock, expected_value):
+    def get_resource_property_mock(resource_handle, property_id, property_value):
+        if property_value.__class__.__name__.startswith("c_char_Array"):
+            property_value.value = expected_value.encode("ascii")
+        else:
+            property_value.contents.value = expected_value
+        return nisyscfg.errors.Status.OK
+
+    lib_mock.return_value.NISysCfgGetResourceProperty.side_effect = get_resource_property_mock
+
+
+def test_open_close_session_invokes_nisyscfg_c_api(lib_mock):
+    session = nisyscfg.Session()
+    session.close()
+    expected_calls = [
+        mock.call(mock.ANY),
+        mock.call().NISysCfgInitializeSession(
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+        ),
+        mock.call().NISysCfgCloseHandle(CVoidPMatcher(SESSION_HANDLE)),
+    ]
+    assert lib_mock.mock_calls == expected_calls
+
+
+def test_session_in_with_statement_invokes_nisyscfg_c_api(lib_mock):
+    with nisyscfg.Session():
+        pass
+    expected_calls = [
+        mock.call(mock.ANY),
+        mock.call().NISysCfgInitializeSession(
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+        ),
+        mock.call().NISysCfgCloseHandle(CVoidPMatcher(SESSION_HANDLE)),
+    ]
+    assert lib_mock.mock_calls == expected_calls
+
+
+def test_session_passes_target_name_to_initialize_session(lib_mock):
+    with nisyscfg.Session("localhost"):
+        pass
+    expected_calls = [
+        mock.call().NISysCfgInitializeSession(
+            b"localhost",
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+        ),
+    ]
+    assert lib_mock().NISysCfgInitializeSession.mock_calls == expected_calls
+
+
+def test_session_passes_username_and_password_to_initialize_session(lib_mock):
+    with nisyscfg.Session("localhost", "username", "password"):
+        pass
+    expected_calls = [
+        mock.call().NISysCfgInitializeSession(
+            mock.ANY,
+            b"username",
+            b"password",
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+        ),
+    ]
+    assert lib_mock().NISysCfgInitializeSession.mock_calls == expected_calls
+
+
+def test__get_status_description(lib_mock):
+    with nisyscfg.Session() as session:
+        assert "description" == session._get_status_description(
+            nisyscfg.errors.Status.OUT_OF_MEMORY
+        )
+    expected_calls = [
+        mock.call(mock.ANY),
+        mock.call().NISysCfgInitializeSession(
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+        ),
+        mock.call().NISysCfgGetStatusDescription(
+            CVoidPMatcher(SESSION_HANDLE),
+            nisyscfg.errors.Status.OUT_OF_MEMORY,
+            mock.ANY,
+        ),
+        mock.call().NISysCfgFreeDetailedString(CVoidPMatcher(STATUS_DESCRIPTION_VOID_P.value)),
+        mock.call().NISysCfgCloseHandle(CVoidPMatcher(SESSION_HANDLE)),
+    ]
+    assert lib_mock.mock_calls == expected_calls
+
+
+def test_get_system_experts_with_no_experts(lib_mock):
+    with nisyscfg.Session() as session:
+        session.get_system_experts()
+    expected_calls = [
+        mock.call(mock.ANY),
+        mock.call().NISysCfgInitializeSession(
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+        ),
+        mock.call().NISysCfgGetSystemExperts(CVoidPMatcher(SESSION_HANDLE), b"", mock.ANY),
+        mock.call().NISysCfgCloseHandle(CVoidPMatcher(EXPERT_ENUM_HANDLE)),
+        mock.call().NISysCfgCloseHandle(CVoidPMatcher(SESSION_HANDLE)),
+    ]
+    assert lib_mock.mock_calls == expected_calls
+
+
+def test_expert_info_iterator_raises_error_after_close(lib_mock):
+    with nisyscfg.Session() as session:
+        expert_info = session.get_system_experts()
+        expert_info.close()
+        with pytest.raises(Exception):
+            expert_info.next()
+
+
+def test_get_system_experts_with_two_experts(lib_mock):
+    side_effect_functions = (
+        func
+        for func in [
+            ExpertInfoSideEffect(b"sync", b"NI-Sync", b"1.2.0"),
+            ExpertInfoSideEffect(b"xnet", b"NI-XNET", b"10.0"),
+            lambda *x: nisyscfg.errors.Status.END_OF_ENUM,
+        ]
+    )
+
+    def expert_info_side_effect(handle, expert_name, display_name, version):
+        return next(side_effect_functions)(handle, expert_name, display_name, version)
+
+    lib_mock.return_value.NISysCfgNextExpertInfo.side_effect = expert_info_side_effect
+
+    with nisyscfg.Session() as session:
+        expert_info = list(session.get_system_experts())
+    expected_calls = [
+        mock.call(mock.ANY),
+        mock.call().NISysCfgInitializeSession(
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+        ),
+        mock.call().NISysCfgGetSystemExperts(CVoidPMatcher(SESSION_HANDLE), b"", mock.ANY),
+        mock.call().NISysCfgNextExpertInfo(
+            CVoidPMatcher(EXPERT_ENUM_HANDLE), mock.ANY, mock.ANY, mock.ANY
+        ),
+        mock.call().NISysCfgNextExpertInfo(
+            CVoidPMatcher(EXPERT_ENUM_HANDLE), mock.ANY, mock.ANY, mock.ANY
+        ),
+        mock.call().NISysCfgNextExpertInfo(
+            CVoidPMatcher(EXPERT_ENUM_HANDLE), mock.ANY, mock.ANY, mock.ANY
+        ),
+        mock.call().NISysCfgCloseHandle(CVoidPMatcher(EXPERT_ENUM_HANDLE)),
+        mock.call().NISysCfgCloseHandle(CVoidPMatcher(SESSION_HANDLE)),
+    ]
+    assert lib_mock.mock_calls == expected_calls
+    assert len(expert_info) == 2
+    assert expert_info[0].expert_name == "sync"
+    assert expert_info[0].display_name == "NI-Sync"
+    assert expert_info[0].version == "1.2.0"
+    assert expert_info[1].expert_name == "xnet"
+    assert expert_info[1].display_name == "NI-XNET"
+    assert expert_info[1].version == "10.0"
+
+
+def test_get_system_experts_with_csv_expert_names(lib_mock):
+    with nisyscfg.Session() as session:
+        session.get_system_experts("xnet,sync")
+    expected_calls = [
+        mock.call().NISysCfgGetSystemExperts(CVoidPMatcher(SESSION_HANDLE), b"xnet,sync", mock.ANY),
+    ]
+    assert lib_mock().NISysCfgGetSystemExperts.mock_calls == expected_calls
+
+
+def test_get_system_experts_with_list_of_expert_names(lib_mock):
+    with nisyscfg.Session() as session:
+        session.get_system_experts(["xnet", "sync"])
+    expected_calls = [
+        mock.call().NISysCfgGetSystemExperts(CVoidPMatcher(SESSION_HANDLE), b"xnet,sync", mock.ANY),
+    ]
+    assert lib_mock().NISysCfgGetSystemExperts.mock_calls == expected_calls
+
+
+def test_find_hardware_with_default_arguments(lib_mock):
+    with nisyscfg.Session() as session:
+        session.find_hardware()
+    expected_calls = [
+        mock.call(mock.ANY),
+        mock.call().NISysCfgInitializeSession(
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+        ),
+        mock.call().NISysCfgFindHardware(
+            CVoidPMatcher(SESSION_HANDLE),
+            nisyscfg.enums.FilterMode.MATCH_VALUES_ALL,
+            None,
+            b"",
+            mock.ANY,
+        ),
+        mock.call().NISysCfgCloseHandle(CVoidPMatcher(RESOURCE_ENUM_HANDLE)),
+        mock.call().NISysCfgCloseHandle(CVoidPMatcher(SESSION_HANDLE)),
+    ]
+    assert lib_mock.mock_calls == expected_calls
+
+
+def test_find_hardware_with_filter_properties_specified(lib_mock):
+    with nisyscfg.Session() as session:
+        filter = session.create_filter()
+        filter.expert_name = "my_expert"
+        session.find_hardware(filter)
+    expected_calls = [
+        mock.call(mock.ANY),
+        mock.call().NISysCfgInitializeSession(
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+        ),
+        mock.call().NISysCfgCreateFilter(CVoidPMatcher(SESSION_HANDLE), mock.ANY),
+        mock.call().NISysCfgSetFilterPropertyWithType(
+            CVoidPMatcher(FILTER_HANDLE),
+            nisyscfg.properties.Filter.EXPERT_NAME._id,
+            nisyscfg.enums.PropertyType.STRING,
+            b"my_expert",
+        ),
+        mock.call().NISysCfgFindHardware(
+            CVoidPMatcher(SESSION_HANDLE),
+            nisyscfg.enums.FilterMode.MATCH_VALUES_ALL,
+            mock.ANY,
+            b"",
+            mock.ANY,
+        ),
+        mock.call().NISysCfgCloseHandle(CVoidPMatcher(RESOURCE_ENUM_HANDLE)),
+        mock.call().NISysCfgCloseHandle(CVoidPMatcher(FILTER_HANDLE)),
+        mock.call().NISysCfgCloseHandle(CVoidPMatcher(SESSION_HANDLE)),
+    ]
+    assert lib_mock.mock_calls == expected_calls
+
+
+def test_find_hardware_with_csv_expert_names(lib_mock):
+    with nisyscfg.Session() as session:
+        session.find_hardware(expert_names="xnet,sync")
+    expected_calls = [
+        mock.call().NISysCfgFindHardware(mock.ANY, mock.ANY, mock.ANY, b"xnet,sync", mock.ANY),
+    ]
+    assert lib_mock().NISysCfgFindHardware.mock_calls == expected_calls
+
+
+def test_find_hardware_with_list_of_expert_names(lib_mock):
+    with nisyscfg.Session() as session:
+        session.find_hardware(expert_names=["xnet", "sync"])
+    expected_calls = [
+        mock.call().NISysCfgFindHardware(mock.ANY, mock.ANY, mock.ANY, b"xnet,sync", mock.ANY),
+    ]
+    assert lib_mock().NISysCfgFindHardware.mock_calls == expected_calls
+
+
+@pytest.mark.parametrize(
+    "property_name, property_type, assigned_value, expected_value",
+    [
+        ("IS_DEVICE", nisyscfg.enums.PropertyType.BOOL, True, CIntPMatcher(1)),
+        ("IS_CHASSIS", nisyscfg.enums.PropertyType.BOOL, False, CIntPMatcher(0)),
+        ("EXPERT_NAME", nisyscfg.enums.PropertyType.STRING, "my_expert", b"my_expert"),
+        ("USER_ALIAS", nisyscfg.enums.PropertyType.STRING, "my_alias", b"my_alias"),
+        (
+            "VENDOR_ID",
+            nisyscfg.enums.PropertyType.UNSIGNED_INT,
+            1337,
+            CUIntPMatcher(1337),
+        ),
+    ],
+)
+def test_find_hardware_with_passed_filter_properties_specified(
+    lib_mock, property_name, property_type, assigned_value, expected_value
+):
+    with nisyscfg.Session() as session:
+        filter = session.create_filter()
+        setattr(filter, property_name.lower(), assigned_value)
+        session.find_hardware(filter)
+        property_id = getattr(nisyscfg.properties.Filter, property_name)._id
+    expected_calls = [
+        mock.call(mock.ANY),
+        mock.call().NISysCfgInitializeSession(
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+        ),
+        mock.call().NISysCfgCreateFilter(CVoidPMatcher(SESSION_HANDLE), mock.ANY),
+        mock.call().NISysCfgSetFilterPropertyWithType(
+            CVoidPMatcher(FILTER_HANDLE), property_id, property_type, expected_value
+        ),
+        mock.call().NISysCfgFindHardware(
+            CVoidPMatcher(SESSION_HANDLE),
+            nisyscfg.enums.FilterMode.MATCH_VALUES_ALL,
+            mock.ANY,
+            b"",
+            mock.ANY,
+        ),
+        mock.call().NISysCfgCloseHandle(CVoidPMatcher(RESOURCE_ENUM_HANDLE)),
+        mock.call().NISysCfgCloseHandle(CVoidPMatcher(FILTER_HANDLE)),
+        mock.call().NISysCfgCloseHandle(CVoidPMatcher(SESSION_HANDLE)),
+    ]
+    assert lib_mock.mock_calls == expected_calls
+
+
+def test_create_filter(lib_mock):
+    with nisyscfg.Session() as session:
+        session.create_filter()
+    expected_calls = [
+        mock.call(mock.ANY),
+        mock.call().NISysCfgInitializeSession(
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+        ),
+        mock.call().NISysCfgCreateFilter(CVoidPMatcher(SESSION_HANDLE), mock.ANY),
+        mock.call().NISysCfgCloseHandle(CVoidPMatcher(FILTER_HANDLE)),
+        mock.call().NISysCfgCloseHandle(CVoidPMatcher(SESSION_HANDLE)),
+    ]
+    assert lib_mock.mock_calls == expected_calls
+
+
+def test_create_filter_and_set_syscfg_filter_property(lib_mock):
+    with nisyscfg.Session() as session:
+        filter = session.create_filter()
+        filter.expert_name = "my_expert"
+    expected_calls = [
+        mock.call(mock.ANY),
+        mock.call().NISysCfgInitializeSession(
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+        ),
+        mock.call().NISysCfgCreateFilter(CVoidPMatcher(SESSION_HANDLE), mock.ANY),
+        mock.call().NISysCfgSetFilterPropertyWithType(
+            CVoidPMatcher(FILTER_HANDLE),
+            nisyscfg.properties.Filter.EXPERT_NAME._id,
+            nisyscfg.enums.PropertyType.STRING,
+            b"my_expert",
+        ),
+        mock.call().NISysCfgCloseHandle(CVoidPMatcher(FILTER_HANDLE)),
+        mock.call().NISysCfgCloseHandle(CVoidPMatcher(SESSION_HANDLE)),
+    ]
+    assert lib_mock.mock_calls == expected_calls
+
+
+def test_restart_with_default_arguments(lib_mock):
+    with nisyscfg.Session() as session:
+        session.restart()
+    expected_calls = [
+        mock.call(mock.ANY),
+        mock.call().NISysCfgInitializeSession(
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+        ),
+        mock.call().NISysCfgRestart(
+            CVoidPMatcher(SESSION_HANDLE), True, False, False, mock.ANY, mock.ANY
+        ),
+        mock.call().NISysCfgCloseHandle(CVoidPMatcher(SESSION_HANDLE)),
+    ]
+    assert lib_mock.mock_calls == expected_calls
+
+
+def test_get_available_software_components_with_default_arguments(lib_mock):
+    with nisyscfg.Session() as session:
+        session.get_available_software_components()
+    expected_calls = [
+        mock.call(mock.ANY),
+        mock.call().NISysCfgInitializeSession(
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+        ),
+        mock.call().NISysCfgGetAvailableSoftwareComponents(
+            CVoidPMatcher(SESSION_HANDLE), mock.ANY, mock.ANY
+        ),
+        mock.call().NISysCfgCloseHandle(CVoidPMatcher(SOFTWARE_COMPONENT_HANDLE)),
+        mock.call().NISysCfgCloseHandle(CVoidPMatcher(SESSION_HANDLE)),
+    ]
+    assert lib_mock.mock_calls == expected_calls
+
+
+def test_get_installed_software_components_with_default_arguments(lib_mock):
+    with nisyscfg.Session() as session:
+        session.get_installed_software_components()
+    expected_calls = [
+        mock.call(mock.ANY),
+        mock.call().NISysCfgInitializeSession(
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+        ),
+        mock.call().NISysCfgGetInstalledSoftwareComponents(
+            CVoidPMatcher(SESSION_HANDLE), mock.ANY, False, mock.ANY
+        ),
+        mock.call().NISysCfgCloseHandle(CVoidPMatcher(SOFTWARE_COMPONENT_HANDLE)),
+        mock.call().NISysCfgCloseHandle(CVoidPMatcher(SESSION_HANDLE)),
+    ]
+    assert lib_mock.mock_calls == expected_calls
+
+
+def test_interating_over_hardware_resources(lib_mock):
+    side_effect_functions = (
+        func
+        for func in [
+            NextResourceSideEffect(10),
+            NextResourceSideEffect(11),
+            NextResourceSideEffect(12),
+            lambda *x: nisyscfg.errors.Status.END_OF_ENUM,
+        ]
+    )
+
+    def next_resource_side_effect(session_handle, resource_enum_handle, resource_handle):
+        return next(side_effect_functions)(session_handle, resource_enum_handle, resource_handle)
+
+    lib_mock.return_value.NISysCfgNextResource.side_effect = next_resource_side_effect
+
+    with nisyscfg.Session() as session:
+        resources = list(session.find_hardware())
+        assert len(resources) == 3
+
+    expected_calls = [
+        mock.call(mock.ANY),
+        mock.call().NISysCfgInitializeSession(
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+        ),
+        mock.call().NISysCfgFindHardware(mock.ANY, mock.ANY, mock.ANY, mock.ANY, mock.ANY),
+        mock.call().NISysCfgNextResource(
+            CVoidPMatcher(SESSION_HANDLE), CVoidPMatcher(RESOURCE_ENUM_HANDLE), mock.ANY
+        ),
+        mock.call().NISysCfgNextResource(
+            CVoidPMatcher(SESSION_HANDLE), CVoidPMatcher(RESOURCE_ENUM_HANDLE), mock.ANY
+        ),
+        mock.call().NISysCfgNextResource(
+            CVoidPMatcher(SESSION_HANDLE), CVoidPMatcher(RESOURCE_ENUM_HANDLE), mock.ANY
+        ),
+        mock.call().NISysCfgNextResource(
+            CVoidPMatcher(SESSION_HANDLE), CVoidPMatcher(RESOURCE_ENUM_HANDLE), mock.ANY
+        ),
+        mock.call().NISysCfgCloseHandle(CVoidPMatcher(12)),
+        mock.call().NISysCfgCloseHandle(CVoidPMatcher(11)),
+        mock.call().NISysCfgCloseHandle(CVoidPMatcher(10)),
+        mock.call().NISysCfgCloseHandle(CVoidPMatcher(RESOURCE_ENUM_HANDLE)),
+        mock.call().NISysCfgCloseHandle(CVoidPMatcher(SESSION_HANDLE)),
+    ]
+    assert lib_mock.mock_calls == expected_calls
+
+
+def test_hardware_resource_raises_error_after_close(lib_mock):
+    with nisyscfg.Session() as session:
+        resource = session.find_hardware()
+        resource.close()
+        with pytest.raises(Exception):
+            resource.next()
+
+
+@pytest.mark.parametrize(
+    "property_name, expected_value",
+    [
+        ("IS_DEVICE", True),
+        ("IS_CHASSIS", False),
+        ("VENDOR_ID", 0x1093),
+        ("VENDOR_NAME", "National Instruments"),
+        ("PRODUCT_ID", 0xABC),
+        ("PRODUCT_NAME", "NI-BubbleGum"),
+    ],
+)
+def test_get_hardware_resource_property(
+    lib_mock,
+    config_next_resource_side_effect_mock,
+    config_get_resource_property_mock,
+    property_name,
+    expected_value,
+):
+    with nisyscfg.Session() as session:
+        resource = next(session.find_hardware())
+        assert expected_value == getattr(resource, property_name.lower())
+        property_id = getattr(nisyscfg.properties.Resource, property_name)._id
+
+    expected_calls = [
+        mock.call(mock.ANY),
+        mock.call().NISysCfgInitializeSession(
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+        ),
+        mock.call().NISysCfgFindHardware(mock.ANY, mock.ANY, mock.ANY, mock.ANY, mock.ANY),
+        mock.call().NISysCfgNextResource(mock.ANY, mock.ANY, mock.ANY),
+        mock.call().NISysCfgGetResourceProperty(CVoidPMatcher(10), property_id, mock.ANY),
+        mock.call().NISysCfgCloseHandle(CVoidPMatcher(10)),
+        mock.call().NISysCfgCloseHandle(CVoidPMatcher(RESOURCE_ENUM_HANDLE)),
+        mock.call().NISysCfgCloseHandle(CVoidPMatcher(SESSION_HANDLE)),
+    ]
+    assert lib_mock.mock_calls == expected_calls
+
+
+def test_get_hardware_resource_timestamp_property(
+    lib_mock,
+    config_next_resource_side_effect_mock,
+):
+    timestamp = nisyscfg.types.TimestampUTC()
+    timestamp[2] = 0x7C25B080
+
+    def get_resource_property_side_effect(resource_handle, property_id, property_value):
+        property_value.contents[:] = timestamp[:]
+        return nisyscfg.errors.Status.OK
+
+    def values_from_timestamp_side_effect(timestamp, secondsSinceEpoch1970, fractionalSeconds):
+        secondsSinceEpoch1970.contents.value = 0
+        fractionalSeconds.contents.value = 0.0
+        return nisyscfg.errors.Status.OK
+
+    lib_mock.return_value.NISysCfgGetResourceProperty.side_effect = (
+        get_resource_property_side_effect
+    )
+    lib_mock.return_value.NISysCfgValuesFromTimestamp.side_effect = (
+        values_from_timestamp_side_effect
+    )
+
+    with nisyscfg.Session() as session:
+        resource = next(session.find_hardware())
+        assert nisyscfg.timestamp.tai_epoch == resource.current_time
+        property_id = nisyscfg.properties.Resource.CURRENT_TIME._id
+
+    expected_calls = [
+        mock.call(mock.ANY),
+        mock.call().NISysCfgInitializeSession(
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+        ),
+        mock.call().NISysCfgFindHardware(mock.ANY, mock.ANY, mock.ANY, mock.ANY, mock.ANY),
+        mock.call().NISysCfgNextResource(mock.ANY, mock.ANY, mock.ANY),
+        mock.call().NISysCfgGetResourceProperty(CVoidPMatcher(10), property_id, mock.ANY),
+        mock.call().NISysCfgValuesFromTimestamp(TimestampMatcher(timestamp), mock.ANY, mock.ANY),
+        mock.call().NISysCfgCloseHandle(CVoidPMatcher(10)),
+        mock.call().NISysCfgCloseHandle(CVoidPMatcher(RESOURCE_ENUM_HANDLE)),
+        mock.call().NISysCfgCloseHandle(CVoidPMatcher(SESSION_HANDLE)),
+    ]
+    assert lib_mock.mock_calls == expected_calls
+
+
+@pytest.mark.parametrize(
+    "user_alias, resource_name, expected_value",
+    [
+        ("My Device", "My Resource", "My Device"),
+        ("", "My Resource", "My Resource"),
+        ("", "", ""),
+    ],
+)
+def test_get_hardware_resource_name(
+    lib_mock,
+    config_next_resource_side_effect_mock,
+    user_alias,
+    resource_name,
+    expected_value,
+):
+    with mock.patch.object(
+        nisyscfg.hardware_resource.HardwareResource, "expert_user_alias"
+    ) as expert_user_alias_mock, mock.patch.object(
+        nisyscfg.hardware_resource.HardwareResource, "expert_resource_name"
+    ) as expert_resource_name_mock:
+        expert_user_alias_mock.__getitem__.return_value = user_alias
+        expert_resource_name_mock.__getitem__.return_value = resource_name
+
+        with nisyscfg.Session() as session:
+            resource = next(session.find_hardware())
+            assert expected_value == resource.name
+
+
+def test_get_hardware_resource_property_catches_prop_does_not_exist_and_raises_attribute_error(
+    lib_mock, config_next_resource_side_effect_mock
+):
+    lib_mock.return_value.NISysCfgGetResourceProperty.return_value = (
+        nisyscfg.errors.Status.PROP_DOES_NOT_EXIST
+    )
+
+    with nisyscfg.Session() as session:
+        resource = next(session.find_hardware())
+        with pytest.raises(AttributeError):
+            getattr(resource, "IsDevice")
+
+
+def test_get_hardware_resource_property_raises_library_error_when_error_code_is_not_prop_does_not_exist(
+    lib_mock, config_next_resource_side_effect_mock
+):
+    lib_mock.return_value.NISysCfgGetResourceProperty.return_value = (
+        nisyscfg.errors.Status.OUT_OF_MEMORY
+    )
+
+    with nisyscfg.Session() as session:
+        resource = next(session.find_hardware())
+        with pytest.raises(nisyscfg.errors.LibraryError):
+            resource.is_device
+
+
+def test_hardware_resource_get_property_raises_library_error_when_error_code_is_not_prop_does_not_exist(
+    lib_mock, config_next_resource_side_effect_mock
+):
+    lib_mock.return_value.NISysCfgGetResourceProperty.return_value = (
+        nisyscfg.errors.Status.PROP_DOES_NOT_EXIST
+    )
+
+    with nisyscfg.Session() as session:
+        resource = next(session.find_hardware())
+        with pytest.raises(nisyscfg.errors.LibraryError):
+            resource.get_property("is_device")
+
+
+def test_hardware_resource_get_property_returns_default_when_error_code_is_not_prop_does_not_exist(
+    lib_mock, config_next_resource_side_effect_mock
+):
+    lib_mock.return_value.NISysCfgGetResourceProperty.return_value = (
+        nisyscfg.errors.Status.PROP_DOES_NOT_EXIST
+    )
+
+    with nisyscfg.Session() as session:
+        resource = next(session.find_hardware())
+        assert resource.get_property("is_device", True) is True
+
+
+@pytest.mark.parametrize(
+    "property_name, count_property, expected_values",
+    [
+        ("EXPERT_NAME", "NUMBER_OF_EXPERTS", ["xnet", "sync"]),
+        ("EXPERT_USER_ALIAS", "NUMBER_OF_EXPERTS", ["myDevice"]),
+        (
+            "AVAILABLE_FIRMWARE_VERSION",
+            "NUMBER_OF_AVAILABLE_FIRMWARE_VERSIONS",
+            ["1.0", "2.1", "3.3.3"],
+        ),
+        (
+            "WLAN_AVAILABLE_CHANNEL_NUMBER",
+            "NUMBER_OF_DISCOVERED_ACCESS_POINTS",
+            [3, 1, 2],
+        ),
+        (
+            "WLAN_AVAILABLE_LINK_SPEED",
+            "NUMBER_OF_DISCOVERED_ACCESS_POINTS",
+            [nisyscfg.enums.LinkSpeed.AUTO],
+        ),
+    ],
+)
+def test_get_hardware_index_property(lib_mock, property_name, count_property, expected_values):
+    side_effect_functions = (
+        func
+        for func in [
+            NextResourceSideEffect(10),
+            lambda *x: nisyscfg.errors.Status.END_OF_ENUM,
+        ]
+    )
+
+    def next_resource_side_effect(session_handle, resource_enum_handle, resource_handle):
+        return next(side_effect_functions)(session_handle, resource_enum_handle, resource_handle)
+
+    def get_resource_property_mock(resource_handle, property_id, property_value):
+        property_value.contents.value = len(expected_values)
+        return nisyscfg.errors.Status.OK
+
+    def get_indexed_property_mock(resource_handle, property_id, index, property_value):
+        try:
+            if property_value.__class__.__name__.startswith("c_char_Array"):
+                property_value.value = expected_values[index].encode("ascii")
+            else:
+                property_value.contents.value = expected_values[index]
+            return nisyscfg.errors.Status.OK
+        except IndexError:
+            return nisyscfg.errors.Status.PROP_DOES_NOT_EXIST
+
+    lib_mock.return_value.NISysCfgNextResource.side_effect = next_resource_side_effect
+    lib_mock.return_value.NISysCfgGetResourceProperty.side_effect = get_resource_property_mock
+    lib_mock.return_value.NISysCfgGetResourceIndexedProperty.side_effect = get_indexed_property_mock
+
+    with nisyscfg.Session() as session:
+        resource = next(session.find_hardware())
+        property = getattr(resource, property_name.lower())
+        assert expected_values == list(property)
+        count_property_id = getattr(nisyscfg.properties.Resource, count_property)._id
+        property_id = getattr(nisyscfg.properties.IndexedResource, property_name)._id
+
+    expected_calls = [
+        mock.call(mock.ANY),
+        mock.call().NISysCfgInitializeSession(
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+        ),
+        mock.call().NISysCfgFindHardware(mock.ANY, mock.ANY, mock.ANY, mock.ANY, mock.ANY),
+        mock.call().NISysCfgNextResource(mock.ANY, mock.ANY, mock.ANY),
+        mock.call().NISysCfgGetResourceProperty(CVoidPMatcher(10), count_property_id, mock.ANY),
+    ]
+    expected_calls += [
+        mock.call().NISysCfgGetResourceIndexedProperty(CVoidPMatcher(10), property_id, i, mock.ANY)
+        for i in range(len(expected_values) + 1)
+    ]
+    expected_calls += [
+        mock.call().NISysCfgCloseHandle(CVoidPMatcher(10)),
+        mock.call().NISysCfgCloseHandle(CVoidPMatcher(RESOURCE_ENUM_HANDLE)),
+        mock.call().NISysCfgCloseHandle(CVoidPMatcher(SESSION_HANDLE)),
+    ]
+    assert lib_mock.mock_calls == expected_calls
+
+
+def test_set_hardware_resource_timestamp_property(
+    lib_mock,
+    config_next_resource_side_effect_mock,
+):
+    ctypes_timestamp = nisyscfg.types.TimestampUTC(100, 200, 300, 400)  # random values
+
+    def timestamp_from_values_side_effect(secondsSinceEpoch1970, fractionalSeconds, timestamp):
+        timestamp.contents[:] = ctypes_timestamp
+        return nisyscfg.errors.Status.OK
+
+    lib_mock.NISysCfgSetResourceProperty.return_value = nisyscfg.errors.Status.OK
+
+    lib_mock.return_value.NISysCfgTimestampFromValues.side_effect = (
+        timestamp_from_values_side_effect
+    )
+    property_id = nisyscfg.properties.Resource.CURRENT_TIME._id
+
+    with nisyscfg.Session() as session:
+        resource = next(session.find_hardware())
+        resource.current_time = nisyscfg.timestamp.tai_epoch + hightime.timedelta(seconds=100)
+
+    expected_calls = [
+        mock.call(mock.ANY),
+        mock.call().NISysCfgInitializeSession(
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+            mock.ANY,
+        ),
+        mock.call().NISysCfgFindHardware(mock.ANY, mock.ANY, mock.ANY, mock.ANY, mock.ANY),
+        mock.call().NISysCfgNextResource(mock.ANY, mock.ANY, mock.ANY),
+        mock.call().NISysCfgTimestampFromValues(100, 0.0, mock.ANY),
+        mock.call().NISysCfgSetResourceProperty(
+            CVoidPMatcher(10), property_id, TimestampMatcher(ctypes_timestamp)
+        ),
+        mock.call().NISysCfgCloseHandle(CVoidPMatcher(10)),
+        mock.call().NISysCfgCloseHandle(CVoidPMatcher(RESOURCE_ENUM_HANDLE)),
+        mock.call().NISysCfgCloseHandle(CVoidPMatcher(SESSION_HANDLE)),
+    ]
+    assert lib_mock.mock_calls == expected_calls
+
+
+def test_session_has_resource(lib_mock):
+    with nisyscfg.Session() as session:
+        assert "resource" in dir(session)
+
+
+def test_session_resource_has_pxi(lib_mock):
+    with nisyscfg.Session() as session:
+        assert "pxi" in dir(session.resource)
+
+
+def test_sesssion_resource_pxi_has_fan_mode(lib_mock):
+    with nisyscfg.Session() as session:
+        assert "fan_mode" in dir(session.resource.pxi)
+
+
+def test_session_resource_pxi_has_power_supply_name(lib_mock):
+    with nisyscfg.Session() as session:
+        assert "power_supply_name" in dir(session.resource.pxi)
+
+
+def test_session_resource_has_xnet(lib_mock):
+    with nisyscfg.Session() as session:
+        assert "xnet" in dir(session.resource)
+
+
+def test_session_resource_xnet_has_protocol(lib_mock):
+    with nisyscfg.Session() as session:
+        assert "protocol" in dir(session.resource.xnet)
+
+
+def test_filter_has_xnet(lib_mock):
+    with nisyscfg.Session() as session:
+        filter = session.create_filter()
+        assert "xnet" in dir(filter)
+
+
+def test_filter_xnet_has_protocol(lib_mock):
+    with nisyscfg.Session() as session:
+        filter = session.create_filter()
+        assert "protocol" in dir(filter.xnet)
```

## Comparing `nisyscfg-0.0.5.dist-info/LICENSE` & `nisyscfg-0.1.0.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `nisyscfg-0.0.5.dist-info/METADATA` & `nisyscfg-0.1.0.dist-info/METADATA`

 * *Files 9% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: nisyscfg
-Version: 0.0.5
+Version: 0.1.0
 Summary: NI System Configuration Python API
 Home-page: https://github.com/tkrebes/nisyscfg-python
 Author: National Instruments
 Maintainer: Tyler Krehbiel
 Maintainer-email: tyler.krehbiel@ni.com
 License: MIT
 Keywords: nisyscfg,syscfg
@@ -13,21 +13,21 @@
 Classifier: Intended Audience :: Developers
 Classifier: Intended Audience :: Manufacturing
 Classifier: Intended Audience :: Science/Research
 Classifier: License :: OSI Approved :: MIT License
 Classifier: Operating System :: Microsoft :: Windows
 Classifier: Operating System :: POSIX
 Classifier: Programming Language :: Python :: 3
-Classifier: Programming Language :: Python :: 3.5
-Classifier: Programming Language :: Python :: 3.6
 Classifier: Programming Language :: Python :: 3.7
 Classifier: Programming Language :: Python :: 3.8
 Classifier: Programming Language :: Python :: 3.9
 Classifier: Programming Language :: Python :: 3.10
+Classifier: Programming Language :: Python :: 3.11
 Classifier: Topic :: System :: Hardware :: Hardware Drivers
+Requires-Python: >=3.7
 Description-Content-Type: text/x-rst
 Requires-Dist: hightime
 Requires-Dist: six
 
 NI System Configuration Python API
 ==================================
 Python bindings for NI System Configuration. See `GitHub <https://github.com/tkrebes/nisyscfg-python/>`_ for the latest source.
@@ -41,15 +41,15 @@
 for interacting with NI System Configuration. The package is implemented in Python.
 This package was created by NI. The package is implemented as a complex, highly
 object-oriented wrapper around the NI System Configuration C API using the
 `ctypes <https://docs.python.org/2/library/ctypes.html>`_ Python library.
 
 **nisyscfg** supports only the Windows and Linux operating systems.
 
-**nisyscfg** supports CPython 3.5+ and PyPy3.
+**nisyscfg** supports CPython 3.7+.
 
 Installation
 ============
 
 Note: Running **nisyscfg** requires the NI System Configuration Runtime. Visit the
 `ni.com/downloads <http://www.ni.com/downloads/>`_ to download the latest version
 of NI System Configuration.
@@ -75,13 +75,13 @@
 .. code-block:: python
 
   >>> import nisyscfg
   >>> with nisyscfg.Session() as session:
   >>>     # Print user aliases for all National Instruments devices in the local system
   >>>     filter = session.create_filter()
   >>>     filter.is_present = True
-  >>>     filter.is_in_product = True
+  >>>     filter.is_ni_product = True
   >>>     filter.is_device = True
   >>>     for resource in session.find_hardware(filter):
   >>>         print(resource.expert_user_alias[0])
```

## Comparing `nisyscfg-0.0.5.dist-info/RECORD` & `nisyscfg-0.1.0.dist-info/RECORD`

 * *Files 24% similar despite different names*

```diff
@@ -1,33 +1,33 @@
-nisyscfg/VERSION,sha256=robnkGeKzH_BTxjlWcL4xJcmNNWxt0oqKXVluMkPgEo,6
+nisyscfg/VERSION,sha256=6d2FB_S_DG9CRY5BrqgzrQvT9hJycjNe7pv01YVB7Wc,6
 nisyscfg/__init__.py,sha256=f13QhESauNExT4fsErYQC0rArv5aijI0UN_ubvwCADU,175
-nisyscfg/_lib.py,sha256=XqppaMsqOdjg-Ia0CrOl3MJt5QfRvnmgj2EimaU8S4o,731
-nisyscfg/_library.py,sha256=mhpaFRmyvMZ3wgHo3zVx0CV7zrNuDjpRMjVc6EmZ6E4,53119
-nisyscfg/_library_singleton.py,sha256=HsLYtwWaisW3F5y0Efm2A9DB17y910PBkN1BpY7BZmM,1897
-nisyscfg/component_info.py,sha256=o0W7HD69Xw88-M8YLV6ADTFcS6zuMr_cJxileqN7u2w,3658
-nisyscfg/dependency_info.py,sha256=a0HKeELWw1yM77d678dkRWG-iweqogYW6SbJGpE4kjc,3595
-nisyscfg/enums.py,sha256=3W6mu8yqKAWVFcB6LtDTH43ZnmqcDPWpZoO7nCCodlQ,5094
-nisyscfg/errors.py,sha256=VMR9EGELdN2spcE6Sy9-OhEZ1jQk7otCbB7Z-xpI76k,10017
-nisyscfg/expert_info.py,sha256=dG4G7f2qhODmr4m5H2PQTbqsH36HGb-DBjh1o_FHta8,1474
-nisyscfg/filter.py,sha256=QiJcWBVXIKPLIkvmKrc53rbpwkfQkFXWbNdwrtY6EpY,1466
-nisyscfg/hardware_resource.py,sha256=QsZPxmqqWolRJjp7Ha9ATKtapJwOXoQyXvXI9WmnWKY,20318
-nisyscfg/properties.py,sha256=K08TZ1je9Ll87XwdB8_txJWkoi7ELWB6PwZMhK48TIU,23403
-nisyscfg/software_feed.py,sha256=HHhHazmIv89t8gm-FdzDAi3vDpphubceIkoxeeyJEnE,1544
-nisyscfg/system.py,sha256=Hj0Xm8ItnfrcW6Q5ej50l4ys0BsnMDfomxzASgiILIQ,47756
-nisyscfg/system_info.py,sha256=qsH4sySkyzZIcFVX9y5T7qpyxU1SXzH-rYA2mMHT6ug,979
-nisyscfg/timestamp.py,sha256=2WZMSxvn14Ce_eN75IXcP8liOyhFu5gVRpS9ji6RGKM,2281
+nisyscfg/_lib.py,sha256=gLe3Hor_SvW5hVNIFKthVVaufCP9T0Dgw5Jve5FA7Yo,730
+nisyscfg/_library.py,sha256=T27h3jVjkgWrZ3eA87KPojsqvqsyukA9p302Kuvplhk,52439
+nisyscfg/_library_singleton.py,sha256=dkBCGzpcuuigCaM46QQNtAxCdvarsUV9aAsiK7LXFrg,1828
+nisyscfg/component_info.py,sha256=vdLKU3CP8a0jzhYD5VdiDlxMrF1rZAbrWGulBYxIXpU,3549
+nisyscfg/dependency_info.py,sha256=3dlamELHycv-jqJe1xG3YrzmCOUb1bQpSp2sokXpINY,3499
+nisyscfg/enums.py,sha256=7zsF_UPOO546BiN3mx-blqTsk5AiNVyhdoWplIuL3tY,4925
+nisyscfg/errors.py,sha256=xnF2XibAD9f3mVj4NnJOjvOl8zlwVHAYZx-rHZvwSP8,9734
+nisyscfg/expert_info.py,sha256=9OxJtw__bhGKFT9mPjDOhU5nnPYQ7yFwho-wSr3OGzo,1425
+nisyscfg/filter.py,sha256=W0f3mosAQokXwcKg6OeF-VQaKBWflqZibPg0Qb0VnCc,1496
+nisyscfg/hardware_resource.py,sha256=1Zx-_KejXaIayv_-MfYNuSJ0dMCMIVtsbUWtzvpe4ag,21622
+nisyscfg/properties.py,sha256=RTVeGWV0s55nPmvULdQXCDPigPQpsYwmVyVVW-NrR_4,22498
+nisyscfg/software_feed.py,sha256=-RXRsYGgyU116RCYRHZ9Gu3ws_BdJUSvZdehGEMLqpg,1491
+nisyscfg/system.py,sha256=RFnD1LNdeZU-ehaSjz-25oUs-0WpadSz1ie_qoz8PwU,46901
+nisyscfg/system_info.py,sha256=nKGlfBpbr5OWdEtOn8hCxovWYsiHlO0T4ETle2_UKb8,948
+nisyscfg/timestamp.py,sha256=PBjj7GDlAFYqRi9xLQi_Zq8XwxyuGU9qsFbiKiihd6o,2210
 nisyscfg/types.py,sha256=bV-0KQUNS6r7c9CIIHi2xEBW_xpcw6AULUjRo7msFA4,550
 nisyscfg/pxi/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-nisyscfg/pxi/enums.py,sha256=3Dky2PbwywBIrlAC6ztm0PyI3K6QlL2fn99cf_IHP_w,4030
-nisyscfg/pxi/properties.py,sha256=i2lrl1boYYQFrPFSsID2Yt69XZDEf3AP33Fmhs2ZUps,4085
+nisyscfg/pxi/enums.py,sha256=qYS5-Fs0sQeLSky01pSWmmg_fiowZvkALPSeiiLP_-c,3929
+nisyscfg/pxi/properties.py,sha256=ExTbfF0jCk1HGeM3pi3PpEX5Hu0vo9Z2xr8_EAd70q8,4045
 nisyscfg/xnet/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-nisyscfg/xnet/enums.py,sha256=VJvPDiItFx3oya3bJRLXWvEXMmivcpmJetvLNbPejOM,1315
-nisyscfg/xnet/properties.py,sha256=fl3-P79-B0V8L680GE6bBX2W8RXEuFBamp-9eYp8NZM,2943
+nisyscfg/xnet/enums.py,sha256=EdmAI0O2BrVNTjZFVgOChc_iq35AJs4UNsBr4FthT7E,1232
+nisyscfg/xnet/properties.py,sha256=3JZomtZz7REs2_7YPtJJ1v5VCoYbsurgBDgH_rr2Mfw,2871
 tests/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-tests/test_import.py,sha256=vmgwqfQ3JzYEX2SnDYCL3-t1vzy6N2snWjUdF8IM4ew,706
-tests/test_session.py,sha256=sHAwFBu5BNFf3PWqNP4cUZuqsnGF58NaC_Uz1a3_nmg,38753
-nisyscfg-0.0.5.dist-info/LICENSE,sha256=AwPkANfrAZOM5SlTY-jdHwmn7_TYnZAAYEABLb46iUM,1071
-nisyscfg-0.0.5.dist-info/METADATA,sha256=Tb_9BF1UuHiWhU6jbNYBwLlZPZKD4VBVoaZgfewuvxU,2881
-nisyscfg-0.0.5.dist-info/WHEEL,sha256=G16H4A3IeoQmnOrYV4ueZGKSjhipXx8zc8nu9FGlvMA,92
-nisyscfg-0.0.5.dist-info/top_level.txt,sha256=ViVoX6-R1WH7_GfEoDx1CncIHmNcxfRIgqxtyiDBtok,15
-nisyscfg-0.0.5.dist-info/zip-safe,sha256=AbpHGcgLb-kRsJGnwFEktk7uzpZOCcBY74-YBdrKVGs,1
-nisyscfg-0.0.5.dist-info/RECORD,,
+tests/test_import.py,sha256=xcff2OZCe6PJBszoClmm5QPo-74OKFhu6iid_DArGJ0,690
+tests/test_session.py,sha256=cbPaFBgvhv23YB6NoxpUGq6g7rUdw-zy13RQIfyXHFA,37687
+nisyscfg-0.1.0.dist-info/LICENSE,sha256=AwPkANfrAZOM5SlTY-jdHwmn7_TYnZAAYEABLb46iUM,1071
+nisyscfg-0.1.0.dist-info/METADATA,sha256=CME67x-dvHf1qxolNNHYv40SqS3p3cEjNA0rR8ntz9I,2845
+nisyscfg-0.1.0.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
+nisyscfg-0.1.0.dist-info/top_level.txt,sha256=ViVoX6-R1WH7_GfEoDx1CncIHmNcxfRIgqxtyiDBtok,15
+nisyscfg-0.1.0.dist-info/zip-safe,sha256=AbpHGcgLb-kRsJGnwFEktk7uzpZOCcBY74-YBdrKVGs,1
+nisyscfg-0.1.0.dist-info/RECORD,,
```

