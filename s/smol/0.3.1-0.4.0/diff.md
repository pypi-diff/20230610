# Comparing `tmp/smol-0.3.1.tar.gz` & `tmp/smol-0.4.0.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "smol-0.3.1.tar", last modified: Tue Feb  7 21:36:46 2023, max compression
+gzip compressed data, was "smol-0.4.0.tar", last modified: Sat Jun 10 00:41:39 2023, max compression
```

## Comparing `smol-0.3.1.tar` & `smol-0.4.0.tar`

### file list

```diff
@@ -1,234 +1,278 @@
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-02-07 21:36:46.719416 smol-0.3.1/
--rw-r--r--   0 runner    (1001) docker     (123)      338 2023-02-07 21:36:28.000000 smol-0.3.1/.coveragerc
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-02-07 21:36:46.583415 smol-0.3.1/.github/
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-02-07 21:36:46.583415 smol-0.3.1/.github/ISSUE_TEMPLATE/
--rw-r--r--   0 runner    (1001) docker     (123)     1235 2023-02-07 21:36:28.000000 smol-0.3.1/.github/ISSUE_TEMPLATE/bug_report.md
--rw-r--r--   0 runner    (1001) docker     (123)     1550 2023-02-07 21:36:28.000000 smol-0.3.1/.github/ISSUE_TEMPLATE/code_review.md
--rw-r--r--   0 runner    (1001) docker     (123)      531 2023-02-07 21:36:28.000000 smol-0.3.1/.github/ISSUE_TEMPLATE/feature_request.md
--rw-r--r--   0 runner    (1001) docker     (123)      315 2023-02-07 21:36:28.000000 smol-0.3.1/.github/dependabot.yml
--rw-r--r--   0 runner    (1001) docker     (123)     1350 2023-02-07 21:36:28.000000 smol-0.3.1/.github/pull_request_template.md
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-02-07 21:36:46.587415 smol-0.3.1/.github/workflows/
--rw-r--r--   0 runner    (1001) docker     (123)     1625 2023-02-07 21:36:28.000000 smol-0.3.1/.github/workflows/build.yml
--rw-r--r--   0 runner    (1001) docker     (123)      724 2023-02-07 21:36:28.000000 smol-0.3.1/.github/workflows/docs.yml
--rw-r--r--   0 runner    (1001) docker     (123)     1187 2023-02-07 21:36:28.000000 smol-0.3.1/.github/workflows/lint.yml
--rw-r--r--   0 runner    (1001) docker     (123)     3194 2023-02-07 21:36:28.000000 smol-0.3.1/.github/workflows/release.yml
--rw-r--r--   0 runner    (1001) docker     (123)     1444 2023-02-07 21:36:28.000000 smol-0.3.1/.github/workflows/test.yml
--rw-r--r--   0 runner    (1001) docker     (123)      859 2023-02-07 21:36:28.000000 smol-0.3.1/.github/workflows/update-precommit.yaml
--rw-r--r--   0 runner    (1001) docker     (123)      669 2023-02-07 21:36:28.000000 smol-0.3.1/.gitignore
--rw-r--r--   0 runner    (1001) docker     (123)     2000 2023-02-07 21:36:28.000000 smol-0.3.1/.pre-commit-config.yaml
--rw-r--r--   0 runner    (1001) docker     (123)    19121 2023-02-07 21:36:28.000000 smol-0.3.1/CHANGES.md
--rw-r--r--   0 runner    (1001) docker     (123)     2662 2023-02-07 21:36:28.000000 smol-0.3.1/LICENSE
--rw-r--r--   0 runner    (1001) docker     (123)     7291 2023-02-07 21:36:46.719416 smol-0.3.1/PKG-INFO
--rw-r--r--   0 runner    (1001) docker     (123)     5837 2023-02-07 21:36:28.000000 smol-0.3.1/README.md
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-02-07 21:36:46.587415 smol-0.3.1/binder/
--rw-r--r--   0 runner    (1001) docker     (123)       26 2023-02-07 21:36:28.000000 smol-0.3.1/binder/postBuild
--rw-r--r--   0 runner    (1001) docker     (123)      110 2023-02-07 21:36:28.000000 smol-0.3.1/binder/requirements.txt
--rw-r--r--   0 runner    (1001) docker     (123)       11 2023-02-07 21:36:28.000000 smol-0.3.1/binder/runtime.txt
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-02-07 21:36:46.587415 smol-0.3.1/docs/
--rw-r--r--   0 runner    (1001) docker     (123)      635 2023-02-07 21:36:28.000000 smol-0.3.1/docs/Makefile
--rw-r--r--   0 runner    (1001) docker     (123)      799 2023-02-07 21:36:28.000000 smol-0.3.1/docs/make.bat
--rw-r--r--   0 runner    (1001) docker     (123)       47 2023-02-07 21:36:28.000000 smol-0.3.1/docs/requirements.txt
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-02-07 21:36:46.587415 smol-0.3.1/docs/src/
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-02-07 21:36:46.591415 smol-0.3.1/docs/src/_static/
--rw-r--r--   0 runner    (1001) docker     (123)     6097 2023-02-07 21:36:28.000000 smol-0.3.1/docs/src/_static/api.svg
--rw-r--r--   0 runner    (1001) docker     (123)    10564 2023-02-07 21:36:28.000000 smol-0.3.1/docs/src/_static/banner.svg
--rw-r--r--   0 runner    (1001) docker     (123)     5533 2023-02-07 21:36:28.000000 smol-0.3.1/docs/src/_static/contribute.svg
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-02-07 21:36:46.591415 smol-0.3.1/docs/src/_static/css/
--rw-r--r--   0 runner    (1001) docker     (123)      635 2023-02-07 21:36:28.000000 smol-0.3.1/docs/src/_static/css/smol.css
--rw-r--r--   0 runner    (1001) docker     (123)      139 2023-02-07 21:36:28.000000 smol-0.3.1/docs/src/_static/custom.js
--rw-r--r--   0 runner    (1001) docker     (123)   523405 2023-02-07 21:36:28.000000 smol-0.3.1/docs/src/_static/logo.png
--rw-r--r--   0 runner    (1001) docker     (123)     8969 2023-02-07 21:36:28.000000 smol-0.3.1/docs/src/_static/logo.svg
--rw-r--r--   0 runner    (1001) docker     (123)    17696 2023-02-07 21:36:28.000000 smol-0.3.1/docs/src/_static/require.js
--rw-r--r--   0 runner    (1001) docker     (123)    19531 2023-02-07 21:36:28.000000 smol-0.3.1/docs/src/_static/smol_cofe.svg
--rw-r--r--   0 runner    (1001) docker     (123)    22202 2023-02-07 21:36:28.000000 smol-0.3.1/docs/src/_static/smol_moca.svg
--rw-r--r--   0 runner    (1001) docker     (123)    24033 2023-02-07 21:36:28.000000 smol-0.3.1/docs/src/_static/smol_workflow.svg
--rw-r--r--   0 runner    (1001) docker     (123)     6539 2023-02-07 21:36:28.000000 smol-0.3.1/docs/src/_static/starting.svg
--rw-r--r--   0 runner    (1001) docker     (123)     9664 2023-02-07 21:36:28.000000 smol-0.3.1/docs/src/_static/user.svg
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-02-07 21:36:46.591415 smol-0.3.1/docs/src/api_reference/
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-02-07 21:36:46.591415 smol-0.3.1/docs/src/api_reference/autogen/
--rw-r--r--   0 runner    (1001) docker     (123)      319 2023-02-07 21:36:28.000000 smol-0.3.1/docs/src/api_reference/autogen/cofe.extern.rst
--rw-r--r--   0 runner    (1001) docker     (123)      392 2023-02-07 21:36:28.000000 smol-0.3.1/docs/src/api_reference/autogen/cofe.rst
--rw-r--r--   0 runner    (1001) docker     (123)     1040 2023-02-07 21:36:28.000000 smol-0.3.1/docs/src/api_reference/autogen/cofe.space.rst
--rw-r--r--   0 runner    (1001) docker     (123)      647 2023-02-07 21:36:28.000000 smol-0.3.1/docs/src/api_reference/autogen/cofe.wrangling.rst
--rw-r--r--   0 runner    (1001) docker     (123)      644 2023-02-07 21:36:28.000000 smol-0.3.1/docs/src/api_reference/autogen/moca.ensemble.rst
--rw-r--r--   0 runner    (1001) docker     (123)      805 2023-02-07 21:36:28.000000 smol-0.3.1/docs/src/api_reference/autogen/moca.processor.rst
--rw-r--r--   0 runner    (1001) docker     (123)      399 2023-02-07 21:36:28.000000 smol-0.3.1/docs/src/api_reference/autogen/moca.rst
--rw-r--r--   0 runner    (1001) docker     (123)      921 2023-02-07 21:36:28.000000 smol-0.3.1/docs/src/api_reference/autogen/moca.sampler.rst
--rw-r--r--   0 runner    (1001) docker     (123)       46 2023-02-07 21:36:28.000000 smol-0.3.1/docs/src/api_reference/autogen/modules.rst
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-02-07 21:36:46.591415 smol-0.3.1/docs/src/api_reference/cofe/
--rw-r--r--   0 runner    (1001) docker     (123)     1107 2023-02-07 21:36:28.000000 smol-0.3.1/docs/src/api_reference/cofe/clusterexpansion.rst
--rw-r--r--   0 runner    (1001) docker     (123)      916 2023-02-07 21:36:28.000000 smol-0.3.1/docs/src/api_reference/cofe/clusterspace.rst
--rw-r--r--   0 runner    (1001) docker     (123)      732 2023-02-07 21:36:28.000000 smol-0.3.1/docs/src/api_reference/cofe/extern.ewald.rst
--rw-r--r--   0 runner    (1001) docker     (123)      346 2023-02-07 21:36:28.000000 smol-0.3.1/docs/src/api_reference/cofe/index.rst
--rw-r--r--   0 runner    (1001) docker     (123)      111 2023-02-07 21:36:28.000000 smol-0.3.1/docs/src/api_reference/cofe/space.basis.rst
--rw-r--r--   0 runner    (1001) docker     (123)      119 2023-02-07 21:36:28.000000 smol-0.3.1/docs/src/api_reference/cofe/space.cluster.rst
--rw-r--r--   0 runner    (1001) docker     (123)      127 2023-02-07 21:36:28.000000 smol-0.3.1/docs/src/api_reference/cofe/space.constants.rst
--rw-r--r--   0 runner    (1001) docker     (123)      115 2023-02-07 21:36:28.000000 smol-0.3.1/docs/src/api_reference/cofe/space.domain.rst
--rw-r--r--   0 runner    (1001) docker     (123)      114 2023-02-07 21:36:28.000000 smol-0.3.1/docs/src/api_reference/cofe/space.orbit.rst
--rw-r--r--   0 runner    (1001) docker     (123)      234 2023-02-07 21:36:28.000000 smol-0.3.1/docs/src/api_reference/cofe/space.rst
--rw-r--r--   0 runner    (1001) docker     (123)      500 2023-02-07 21:36:28.000000 smol-0.3.1/docs/src/api_reference/cofe/wrangling.rst
--rw-r--r--   0 runner    (1001) docker     (123)      128 2023-02-07 21:36:28.000000 smol-0.3.1/docs/src/api_reference/cofe/wrangling.select.rst
--rw-r--r--   0 runner    (1001) docker     (123)      182 2023-02-07 21:36:28.000000 smol-0.3.1/docs/src/api_reference/cofe/wrangling.sw.rst
--rw-r--r--   0 runner    (1001) docker     (123)      142 2023-02-07 21:36:28.000000 smol-0.3.1/docs/src/api_reference/cofe/wrangling.tools.rst
--rw-r--r--   0 runner    (1001) docker     (123)      137 2023-02-07 21:36:28.000000 smol-0.3.1/docs/src/api_reference/constants.rst
--rw-r--r--   0 runner    (1001) docker     (123)      120 2023-02-07 21:36:28.000000 smol-0.3.1/docs/src/api_reference/exceptions.rst
--rw-r--r--   0 runner    (1001) docker     (123)      355 2023-02-07 21:36:28.000000 smol-0.3.1/docs/src/api_reference/index.rst
--rw-r--r--   0 runner    (1001) docker     (123)      151 2023-02-07 21:36:28.000000 smol-0.3.1/docs/src/api_reference/io.rst
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-02-07 21:36:46.595415 smol-0.3.1/docs/src/api_reference/moca/
--rw-r--r--   0 runner    (1001) docker     (123)      610 2023-02-07 21:36:28.000000 smol-0.3.1/docs/src/api_reference/moca/ensemble.rst
--rw-r--r--   0 runner    (1001) docker     (123)      364 2023-02-07 21:36:28.000000 smol-0.3.1/docs/src/api_reference/moca/index.rst
--rw-r--r--   0 runner    (1001) docker     (123)      141 2023-02-07 21:36:28.000000 smol-0.3.1/docs/src/api_reference/moca/processors.base.rst
--rw-r--r--   0 runner    (1001) docker     (123)      161 2023-02-07 21:36:28.000000 smol-0.3.1/docs/src/api_reference/moca/processors.composite.rst
--rw-r--r--   0 runner    (1001) docker     (123)      145 2023-02-07 21:36:28.000000 smol-0.3.1/docs/src/api_reference/moca/processors.ewald.rst
--rw-r--r--   0 runner    (1001) docker     (123)      236 2023-02-07 21:36:28.000000 smol-0.3.1/docs/src/api_reference/moca/processors.expansion.rst
--rw-r--r--   0 runner    (1001) docker     (123)     1175 2023-02-07 21:36:28.000000 smol-0.3.1/docs/src/api_reference/moca/processors.rst
--rw-r--r--   0 runner    (1001) docker     (123)      136 2023-02-07 21:36:28.000000 smol-0.3.1/docs/src/api_reference/moca/sampler.bias.rst
--rw-r--r--   0 runner    (1001) docker     (123)      645 2023-02-07 21:36:28.000000 smol-0.3.1/docs/src/api_reference/moca/sampler.container.rst
--rw-r--r--   0 runner    (1001) docker     (123)      144 2023-02-07 21:36:28.000000 smol-0.3.1/docs/src/api_reference/moca/sampler.kernel.rst
--rw-r--r--   0 runner    (1001) docker     (123)      121 2023-02-07 21:36:28.000000 smol-0.3.1/docs/src/api_reference/moca/sampler.mcusher.rst
--rw-r--r--   0 runner    (1001) docker     (123)      760 2023-02-07 21:36:28.000000 smol-0.3.1/docs/src/api_reference/moca/sampler.rst
--rw-r--r--   0 runner    (1001) docker     (123)      595 2023-02-07 21:36:28.000000 smol-0.3.1/docs/src/api_reference/moca/sampler.sampler.rst
--rw-r--r--   0 runner    (1001) docker     (123)      125 2023-02-07 21:36:28.000000 smol-0.3.1/docs/src/api_reference/moca/sublattice.rst
--rw-r--r--   0 runner    (1001) docker     (123)      136 2023-02-07 21:36:28.000000 smol-0.3.1/docs/src/api_reference/utils.rst
--rw-r--r--   0 runner    (1001) docker     (123)     6176 2023-02-07 21:36:28.000000 smol-0.3.1/docs/src/citing.rst
--rw-r--r--   0 runner    (1001) docker     (123)     7273 2023-02-07 21:36:28.000000 smol-0.3.1/docs/src/conf.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-02-07 21:36:46.595415 smol-0.3.1/docs/src/developer_guide/
--rw-r--r--   0 runner    (1001) docker     (123)    10867 2023-02-07 21:36:28.000000 smol-0.3.1/docs/src/developer_guide/design.rst
--rw-r--r--   0 runner    (1001) docker     (123)     5230 2023-02-07 21:36:28.000000 smol-0.3.1/docs/src/developer_guide/guide.rst
--rw-r--r--   0 runner    (1001) docker     (123)      377 2023-02-07 21:36:28.000000 smol-0.3.1/docs/src/developer_guide/index.rst
--rw-r--r--   0 runner    (1001) docker     (123)     7505 2023-02-07 21:36:28.000000 smol-0.3.1/docs/src/getting_started.rst
--rw-r--r--   0 runner    (1001) docker     (123)     4032 2023-02-07 21:36:28.000000 smol-0.3.1/docs/src/index.rst
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-02-07 21:36:46.603415 smol-0.3.1/docs/src/notebooks/
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-02-07 21:36:46.603415 smol-0.3.1/docs/src/notebooks/.ipynb_checkpoints/
--rw-r--r--   0 runner    (1001) docker     (123)   138795 2023-02-07 21:36:28.000000 smol-0.3.1/docs/src/notebooks/.ipynb_checkpoints/ce-fit-w-centering-checkpoint.ipynb
--rw-r--r--   0 runner    (1001) docker     (123)     6172 2023-02-07 21:36:28.000000 smol-0.3.1/docs/src/notebooks/adding-structures-in-parallel.ipynb
--rw-r--r--   0 runner    (1001) docker     (123)   138674 2023-02-07 21:36:28.000000 smol-0.3.1/docs/src/notebooks/ce-fit-w-centering.ipynb
--rw-r--r--   0 runner    (1001) docker     (123)  3864843 2023-02-07 21:36:28.000000 smol-0.3.1/docs/src/notebooks/cluster-visualization.ipynb
--rw-r--r--   0 runner    (1001) docker     (123)     9967 2023-02-07 21:36:28.000000 smol-0.3.1/docs/src/notebooks/creating-a-ce-w-electrostatics.ipynb
--rw-r--r--   0 runner    (1001) docker     (123)    18732 2023-02-07 21:36:28.000000 smol-0.3.1/docs/src/notebooks/creating-a-ce.ipynb
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-02-07 21:36:46.703416 smol-0.3.1/docs/src/notebooks/data/
--rw-r--r--   0 runner    (1001) docker     (123) 21341490 2023-02-07 21:36:28.000000 smol-0.3.1/docs/src/notebooks/data/LMTO.mson
--rw-r--r--   0 runner    (1001) docker     (123)    12439 2023-02-07 21:36:28.000000 smol-0.3.1/docs/src/notebooks/data/LiMn2O4_drx_tutorial.json
--rw-r--r--   0 runner    (1001) docker     (123)  9777379 2023-02-07 21:36:28.000000 smol-0.3.1/docs/src/notebooks/data/MnTi_O.json
--rw-r--r--   0 runner    (1001) docker     (123)   489611 2023-02-07 21:36:28.000000 smol-0.3.1/docs/src/notebooks/data/basic_ce.mson
--rw-r--r--   0 runner    (1001) docker     (123)   491616 2023-02-07 21:36:28.000000 smol-0.3.1/docs/src/notebooks/data/basic_ce_ewald.mson
--rw-r--r--   0 runner    (1001) docker     (123)  3685773 2023-02-07 21:36:28.000000 smol-0.3.1/docs/src/notebooks/data/lmo_drx_entries.json
--rw-r--r--   0 runner    (1001) docker     (123)     1503 2023-02-07 21:36:28.000000 smol-0.3.1/docs/src/notebooks/data/lmo_drx_prim.json
--rw-r--r--   0 runner    (1001) docker     (123)   339273 2023-02-07 21:36:28.000000 smol-0.3.1/docs/src/notebooks/data/lmof_entries.json
--rw-r--r--   0 runner    (1001) docker     (123)     1678 2023-02-07 21:36:28.000000 smol-0.3.1/docs/src/notebooks/data/lmof_prim.json
--rw-r--r--   0 runner    (1001) docker     (123)  9777379 2023-02-07 21:36:28.000000 smol-0.3.1/docs/src/notebooks/data/lmto_entries.json
--rw-r--r--   0 runner    (1001) docker     (123) 20338901 2023-02-07 21:36:28.000000 smol-0.3.1/docs/src/notebooks/data/lmto_indicator.json
--rw-r--r--   0 runner    (1001) docker     (123)      971 2023-02-07 21:36:28.000000 smol-0.3.1/docs/src/notebooks/data/lmto_prim.json
--rw-r--r--   0 runner    (1001) docker     (123) 21733181 2023-02-07 21:36:28.000000 smol-0.3.1/docs/src/notebooks/data/lmto_sinusoid.mson
--rw-r--r--   0 runner    (1001) docker     (123)   197770 2023-02-07 21:36:28.000000 smol-0.3.1/docs/src/notebooks/data/lno_entries.json
--rw-r--r--   0 runner    (1001) docker     (123)     1284 2023-02-07 21:36:28.000000 smol-0.3.1/docs/src/notebooks/data/lno_prim.json
--rw-r--r--   0 runner    (1001) docker     (123)     4162 2023-02-07 21:36:28.000000 smol-0.3.1/docs/src/notebooks/index.ipynb
--rw-r--r--   0 runner    (1001) docker     (123)    73835 2023-02-07 21:36:28.000000 smol-0.3.1/docs/src/notebooks/lmo-drx-ce-mc.ipynb
--rw-r--r--   0 runner    (1001) docker     (123)    13547 2023-02-07 21:36:28.000000 smol-0.3.1/docs/src/notebooks/running-canonical-mc.ipynb
--rw-r--r--   0 runner    (1001) docker     (123)    11165 2023-02-07 21:36:28.000000 smol-0.3.1/docs/src/notebooks/running-charge-balanced-gcmc.ipynb
--rw-r--r--   0 runner    (1001) docker     (123)    57828 2023-02-07 21:36:28.000000 smol-0.3.1/docs/src/notebooks/running-ewald-sim_anneal.ipynb
--rw-r--r--   0 runner    (1001) docker     (123)    21709 2023-02-07 21:36:28.000000 smol-0.3.1/docs/src/notebooks/running-semigrand-mc.ipynb
--rw-r--r--   0 runner    (1001) docker     (123)    11098 2023-02-07 21:36:28.000000 smol-0.3.1/docs/src/notebooks/training-data-preparation.ipynb
--rw-r--r--   0 runner    (1001) docker     (123)   108917 2023-02-07 21:36:28.000000 smol-0.3.1/docs/src/notebooks/wang-landau-ising.ipynb
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-02-07 21:36:46.703416 smol-0.3.1/docs/src/notebooks/wip/
--rw-r--r--   0 runner    (1001) docker     (123)    47797 2023-02-07 21:36:28.000000 smol-0.3.1/docs/src/notebooks/wip/basis-orthogonalization.ipynb
--rw-r--r--   0 runner    (1001) docker     (123)    12308 2023-02-07 21:36:28.000000 smol-0.3.1/docs/src/user_guide.rst
--rw-r--r--   0 runner    (1001) docker     (123)      185 2023-02-07 21:36:28.000000 smol-0.3.1/environment.yml
--rw-r--r--   0 runner    (1001) docker     (123)       54 2023-02-07 21:36:28.000000 smol-0.3.1/requirements-optional.txt
--rw-r--r--   0 runner    (1001) docker     (123)      108 2023-02-07 21:36:28.000000 smol-0.3.1/requirements.txt
--rw-r--r--   0 runner    (1001) docker     (123)     2505 2023-02-07 21:36:46.719416 smol-0.3.1/setup.cfg
--rw-r--r--   0 runner    (1001) docker     (123)     3271 2023-02-07 21:36:28.000000 smol-0.3.1/setup.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-02-07 21:36:46.707416 smol-0.3.1/smol/
--rw-r--r--   0 runner    (1001) docker     (123)      249 2023-02-07 21:36:28.000000 smol-0.3.1/smol/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-02-07 21:36:46.707416 smol-0.3.1/smol/cofe/
--rw-r--r--   0 runner    (1001) docker     (123)      521 2023-02-07 21:36:28.000000 smol-0.3.1/smol/cofe/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    18534 2023-02-07 21:36:28.000000 smol-0.3.1/smol/cofe/expansion.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-02-07 21:36:46.707416 smol-0.3.1/smol/cofe/extern/
--rw-r--r--   0 runner    (1001) docker     (123)      402 2023-02-07 21:36:28.000000 smol-0.3.1/smol/cofe/extern/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     8298 2023-02-07 21:36:28.000000 smol-0.3.1/smol/cofe/extern/ewald.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-02-07 21:36:46.711416 smol-0.3.1/smol/cofe/space/
--rw-r--r--   0 runner    (1001) docker     (123)      537 2023-02-07 21:36:28.000000 smol-0.3.1/smol/cofe/space/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    20682 2023-02-07 21:36:28.000000 smol-0.3.1/smol/cofe/space/basis.py
--rw-r--r--   0 runner    (1001) docker     (123)    12001 2023-02-07 21:36:28.000000 smol-0.3.1/smol/cofe/space/cluster.py
--rw-r--r--   0 runner    (1001) docker     (123)    76849 2023-02-07 21:36:28.000000 smol-0.3.1/smol/cofe/space/clusterspace.py
--rw-r--r--   0 runner    (1001) docker     (123)      437 2023-02-07 21:36:28.000000 smol-0.3.1/smol/cofe/space/constants.py
--rw-r--r--   0 runner    (1001) docker     (123)    10229 2023-02-07 21:36:28.000000 smol-0.3.1/smol/cofe/space/domain.py
--rw-r--r--   0 runner    (1001) docker     (123)    21351 2023-02-07 21:36:28.000000 smol-0.3.1/smol/cofe/space/orbit.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-02-07 21:36:46.711416 smol-0.3.1/smol/cofe/wrangling/
--rw-r--r--   0 runner    (1001) docker     (123)      583 2023-02-07 21:36:28.000000 smol-0.3.1/smol/cofe/wrangling/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     5218 2023-02-07 21:36:28.000000 smol-0.3.1/smol/cofe/wrangling/select.py
--rw-r--r--   0 runner    (1001) docker     (123)     7911 2023-02-07 21:36:28.000000 smol-0.3.1/smol/cofe/wrangling/tools.py
--rw-r--r--   0 runner    (1001) docker     (123)    36012 2023-02-07 21:36:28.000000 smol-0.3.1/smol/cofe/wrangling/wrangler.py
--rw-r--r--   0 runner    (1001) docker     (123)      130 2023-02-07 21:36:28.000000 smol-0.3.1/smol/constants.py
--rw-r--r--   0 runner    (1001) docker     (123)   983950 2023-02-07 21:36:28.000000 smol-0.3.1/smol/correlations.c
--rw-r--r--   0 runner    (1001) docker     (123)    10764 2023-02-07 21:36:28.000000 smol-0.3.1/smol/correlations.pyx
--rw-r--r--   0 runner    (1001) docker     (123)      919 2023-02-07 21:36:28.000000 smol-0.3.1/smol/exceptions.py
--rw-r--r--   0 runner    (1001) docker     (123)     1478 2023-02-07 21:36:28.000000 smol-0.3.1/smol/io.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-02-07 21:36:46.711416 smol-0.3.1/smol/moca/
--rw-r--r--   0 runner    (1001) docker     (123)      837 2023-02-07 21:36:28.000000 smol-0.3.1/smol/moca/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    30563 2023-02-07 21:36:28.000000 smol-0.3.1/smol/moca/composition.py
--rw-r--r--   0 runner    (1001) docker     (123)    15638 2023-02-07 21:36:28.000000 smol-0.3.1/smol/moca/ensemble.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-02-07 21:36:46.711416 smol-0.3.1/smol/moca/processor/
--rw-r--r--   0 runner    (1001) docker     (123)      624 2023-02-07 21:36:28.000000 smol-0.3.1/smol/moca/processor/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    10957 2023-02-07 21:36:28.000000 smol-0.3.1/smol/moca/processor/base.py
--rw-r--r--   0 runner    (1001) docker     (123)     6396 2023-02-07 21:36:28.000000 smol-0.3.1/smol/moca/processor/composite.py
--rw-r--r--   0 runner    (1001) docker     (123)     6508 2023-02-07 21:36:28.000000 smol-0.3.1/smol/moca/processor/ewald.py
--rw-r--r--   0 runner    (1001) docker     (123)    12347 2023-02-07 21:36:28.000000 smol-0.3.1/smol/moca/processor/expansion.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-02-07 21:36:46.711416 smol-0.3.1/smol/moca/sampler/
--rw-r--r--   0 runner    (1001) docker     (123)      346 2023-02-07 21:36:28.000000 smol-0.3.1/smol/moca/sampler/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    14996 2023-02-07 21:36:28.000000 smol-0.3.1/smol/moca/sampler/bias.py
--rw-r--r--   0 runner    (1001) docker     (123)    27406 2023-02-07 21:36:28.000000 smol-0.3.1/smol/moca/sampler/container.py
--rw-r--r--   0 runner    (1001) docker     (123)    22894 2023-02-07 21:36:28.000000 smol-0.3.1/smol/moca/sampler/kernel.py
--rw-r--r--   0 runner    (1001) docker     (123)    27711 2023-02-07 21:36:28.000000 smol-0.3.1/smol/moca/sampler/mcusher.py
--rw-r--r--   0 runner    (1001) docker     (123)     4472 2023-02-07 21:36:28.000000 smol-0.3.1/smol/moca/sampler/namespace.py
--rw-r--r--   0 runner    (1001) docker     (123)    16117 2023-02-07 21:36:28.000000 smol-0.3.1/smol/moca/sampler/sampler.py
--rw-r--r--   0 runner    (1001) docker     (123)     8116 2023-02-07 21:36:28.000000 smol-0.3.1/smol/moca/sublattice.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-02-07 21:36:46.715416 smol-0.3.1/smol/moca/utils/
--rw-r--r--   0 runner    (1001) docker     (123)       62 2023-02-07 21:36:28.000000 smol-0.3.1/smol/moca/utils/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    29177 2023-02-07 21:36:28.000000 smol-0.3.1/smol/moca/utils/math.py
--rw-r--r--   0 runner    (1001) docker     (123)     6040 2023-02-07 21:36:28.000000 smol-0.3.1/smol/moca/utils/occu.py
--rw-r--r--   0 runner    (1001) docker     (123)     3648 2023-02-07 21:36:28.000000 smol-0.3.1/smol/utils.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-02-07 21:36:46.707416 smol-0.3.1/smol.egg-info/
--rw-r--r--   0 runner    (1001) docker     (123)     7291 2023-02-07 21:36:46.000000 smol-0.3.1/smol.egg-info/PKG-INFO
--rw-r--r--   0 runner    (1001) docker     (123)     6596 2023-02-07 21:36:46.000000 smol-0.3.1/smol.egg-info/SOURCES.txt
--rw-r--r--   0 runner    (1001) docker     (123)        1 2023-02-07 21:36:46.000000 smol-0.3.1/smol.egg-info/dependency_links.txt
--rw-r--r--   0 runner    (1001) docker     (123)      440 2023-02-07 21:36:46.000000 smol-0.3.1/smol.egg-info/requires.txt
--rw-r--r--   0 runner    (1001) docker     (123)       11 2023-02-07 21:36:46.000000 smol-0.3.1/smol.egg-info/top_level.txt
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-02-07 21:36:46.715416 smol-0.3.1/tests/
--rw-r--r--   0 runner    (1001) docker     (123)      291 2023-02-07 21:36:28.000000 smol-0.3.1/tests/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     6384 2023-02-07 21:36:28.000000 smol-0.3.1/tests/conftest.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-02-07 21:36:46.715416 smol-0.3.1/tests/data/
--rw-r--r--   0 runner    (1001) docker     (123)      616 2023-02-07 21:36:28.000000 smol-0.3.1/tests/data/AuPd_prim.json
--rw-r--r--   0 runner    (1001) docker     (123)      685 2023-02-07 21:36:28.000000 smol-0.3.1/tests/data/CrFeW_prim.json
--rw-r--r--   0 runner    (1001) docker     (123)     1183 2023-02-07 21:36:28.000000 smol-0.3.1/tests/data/LiCaBr_prim.json
--rw-r--r--   0 runner    (1001) docker     (123)     1000 2023-02-07 21:36:28.000000 smol-0.3.1/tests/data/LiMOF_prim.json
--rw-r--r--   0 runner    (1001) docker     (123)     1066 2023-02-07 21:36:28.000000 smol-0.3.1/tests/data/LiMnTiVOF_prim.json
--rw-r--r--   0 runner    (1001) docker     (123)     1016 2023-02-07 21:36:28.000000 smol-0.3.1/tests/data/LiTiMnPO_prim.json
--rw-r--r--   0 runner    (1001) docker     (123)     2941 2023-02-07 21:36:28.000000 smol-0.3.1/tests/data/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)      172 2023-02-07 21:36:28.000000 smol-0.3.1/tests/pytest.ini
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-02-07 21:36:46.715416 smol-0.3.1/tests/test_cofe/
--rw-r--r--   0 runner    (1001) docker     (123)     8090 2023-02-07 21:36:28.000000 smol-0.3.1/tests/test_cofe/test_basis.py
--rw-r--r--   0 runner    (1001) docker     (123)     2836 2023-02-07 21:36:28.000000 smol-0.3.1/tests/test_cofe/test_cluster.py
--rw-r--r--   0 runner    (1001) docker     (123)    34257 2023-02-07 21:36:28.000000 smol-0.3.1/tests/test_cofe/test_clusterspace.py
--rw-r--r--   0 runner    (1001) docker     (123)     3582 2023-02-07 21:36:28.000000 smol-0.3.1/tests/test_cofe/test_domain.py
--rw-r--r--   0 runner    (1001) docker     (123)     3142 2023-02-07 21:36:28.000000 smol-0.3.1/tests/test_cofe/test_ewald.py
--rw-r--r--   0 runner    (1001) docker     (123)     5421 2023-02-07 21:36:28.000000 smol-0.3.1/tests/test_cofe/test_expansion.py
--rw-r--r--   0 runner    (1001) docker     (123)    18053 2023-02-07 21:36:28.000000 smol-0.3.1/tests/test_cofe/test_orbit.py
--rw-r--r--   0 runner    (1001) docker     (123)     1908 2023-02-07 21:36:28.000000 smol-0.3.1/tests/test_cofe/test_select.py
--rw-r--r--   0 runner    (1001) docker     (123)     8613 2023-02-07 21:36:28.000000 smol-0.3.1/tests/test_cofe/test_tools.py
--rw-r--r--   0 runner    (1001) docker     (123)    15870 2023-02-07 21:36:28.000000 smol-0.3.1/tests/test_cofe/test_wrangler.py
--rw-r--r--   0 runner    (1001) docker     (123)      877 2023-02-07 21:36:28.000000 smol-0.3.1/tests/test_io.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-02-07 21:36:46.719416 smol-0.3.1/tests/test_moca/
--rw-r--r--   0 runner    (1001) docker     (123)     5531 2023-02-07 21:36:28.000000 smol-0.3.1/tests/test_moca/test_bias.py
--rw-r--r--   0 runner    (1001) docker     (123)    19686 2023-02-07 21:36:28.000000 smol-0.3.1/tests/test_moca/test_comp_space.py
--rw-r--r--   0 runner    (1001) docker     (123)    18218 2023-02-07 21:36:28.000000 smol-0.3.1/tests/test_moca/test_ensemble.py
--rw-r--r--   0 runner    (1001) docker     (123)     5729 2023-02-07 21:36:28.000000 smol-0.3.1/tests/test_moca/test_kernel.py
--rw-r--r--   0 runner    (1001) docker     (123)    21942 2023-02-07 21:36:28.000000 smol-0.3.1/tests/test_moca/test_math_utils.py
--rw-r--r--   0 runner    (1001) docker     (123)    11882 2023-02-07 21:36:28.000000 smol-0.3.1/tests/test_moca/test_mcushers.py
--rw-r--r--   0 runner    (1001) docker     (123)     6365 2023-02-07 21:36:28.000000 smol-0.3.1/tests/test_moca/test_occu_utils.py
--rw-r--r--   0 runner    (1001) docker     (123)    10339 2023-02-07 21:36:28.000000 smol-0.3.1/tests/test_moca/test_processor.py
--rw-r--r--   0 runner    (1001) docker     (123)    15222 2023-02-07 21:36:28.000000 smol-0.3.1/tests/test_moca/test_samplecontainer.py
--rw-r--r--   0 runner    (1001) docker     (123)     4159 2023-02-07 21:36:28.000000 smol-0.3.1/tests/test_moca/test_sampler.py
--rw-r--r--   0 runner    (1001) docker     (123)     6867 2023-02-07 21:36:28.000000 smol-0.3.1/tests/test_moca/test_sublattice.py
--rw-r--r--   0 runner    (1001) docker     (123)     1253 2023-02-07 21:36:28.000000 smol-0.3.1/tests/test_utils.py
--rw-r--r--   0 runner    (1001) docker     (123)     5101 2023-02-07 21:36:28.000000 smol-0.3.1/tests/utils.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-10 00:41:39.195389 smol-0.4.0/
+-rw-r--r--   0 runner    (1001) docker     (123)      338 2023-06-10 00:41:20.000000 smol-0.4.0/.coveragerc
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-10 00:41:39.083390 smol-0.4.0/.github/
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-10 00:41:39.083390 smol-0.4.0/.github/ISSUE_TEMPLATE/
+-rw-r--r--   0 runner    (1001) docker     (123)     1235 2023-06-10 00:41:20.000000 smol-0.4.0/.github/ISSUE_TEMPLATE/bug_report.md
+-rw-r--r--   0 runner    (1001) docker     (123)     1550 2023-06-10 00:41:20.000000 smol-0.4.0/.github/ISSUE_TEMPLATE/code_review.md
+-rw-r--r--   0 runner    (1001) docker     (123)      531 2023-06-10 00:41:20.000000 smol-0.4.0/.github/ISSUE_TEMPLATE/feature_request.md
+-rw-r--r--   0 runner    (1001) docker     (123)      315 2023-06-10 00:41:20.000000 smol-0.4.0/.github/dependabot.yml
+-rw-r--r--   0 runner    (1001) docker     (123)     1350 2023-06-10 00:41:20.000000 smol-0.4.0/.github/pull_request_template.md
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-10 00:41:39.083390 smol-0.4.0/.github/workflows/
+-rw-r--r--   0 runner    (1001) docker     (123)     4944 2023-06-10 00:41:20.000000 smol-0.4.0/.github/workflows/build.yml
+-rw-r--r--   0 runner    (1001) docker     (123)      724 2023-06-10 00:41:20.000000 smol-0.4.0/.github/workflows/docs.yml
+-rw-r--r--   0 runner    (1001) docker     (123)     1273 2023-06-10 00:41:20.000000 smol-0.4.0/.github/workflows/lint.yml
+-rw-r--r--   0 runner    (1001) docker     (123)     6564 2023-06-10 00:41:20.000000 smol-0.4.0/.github/workflows/release.yml
+-rw-r--r--   0 runner    (1001) docker     (123)     1443 2023-06-10 00:41:20.000000 smol-0.4.0/.github/workflows/test.yml
+-rw-r--r--   0 runner    (1001) docker     (123)      859 2023-06-10 00:41:20.000000 smol-0.4.0/.github/workflows/update-precommit.yaml
+-rw-r--r--   0 runner    (1001) docker     (123)      669 2023-06-10 00:41:20.000000 smol-0.4.0/.gitignore
+-rw-r--r--   0 runner    (1001) docker     (123)     2077 2023-06-10 00:41:20.000000 smol-0.4.0/.pre-commit-config.yaml
+-rw-r--r--   0 runner    (1001) docker     (123)    19748 2023-06-10 00:41:20.000000 smol-0.4.0/CHANGES.md
+-rw-r--r--   0 runner    (1001) docker     (123)     2662 2023-06-10 00:41:20.000000 smol-0.4.0/LICENSE
+-rw-r--r--   0 runner    (1001) docker     (123)    10426 2023-06-10 00:41:39.195389 smol-0.4.0/PKG-INFO
+-rw-r--r--   0 runner    (1001) docker     (123)     5980 2023-06-10 00:41:20.000000 smol-0.4.0/README.md
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-10 00:41:39.083390 smol-0.4.0/binder/
+-rw-r--r--   0 runner    (1001) docker     (123)       26 2023-06-10 00:41:20.000000 smol-0.4.0/binder/postBuild
+-rw-r--r--   0 runner    (1001) docker     (123)      110 2023-06-10 00:41:20.000000 smol-0.4.0/binder/requirements.txt
+-rw-r--r--   0 runner    (1001) docker     (123)       11 2023-06-10 00:41:20.000000 smol-0.4.0/binder/runtime.txt
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-10 00:41:39.083390 smol-0.4.0/docs/
+-rw-r--r--   0 runner    (1001) docker     (123)      635 2023-06-10 00:41:20.000000 smol-0.4.0/docs/Makefile
+-rw-r--r--   0 runner    (1001) docker     (123)      799 2023-06-10 00:41:20.000000 smol-0.4.0/docs/make.bat
+-rw-r--r--   0 runner    (1001) docker     (123)       47 2023-06-10 00:41:20.000000 smol-0.4.0/docs/requirements.txt
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-10 00:41:39.083390 smol-0.4.0/docs/src/
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-10 00:41:39.087390 smol-0.4.0/docs/src/_static/
+-rw-r--r--   0 runner    (1001) docker     (123)     6097 2023-06-10 00:41:20.000000 smol-0.4.0/docs/src/_static/api.svg
+-rw-r--r--   0 runner    (1001) docker     (123)    10564 2023-06-10 00:41:20.000000 smol-0.4.0/docs/src/_static/banner.svg
+-rw-r--r--   0 runner    (1001) docker     (123)     5533 2023-06-10 00:41:20.000000 smol-0.4.0/docs/src/_static/contribute.svg
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-10 00:41:39.087390 smol-0.4.0/docs/src/_static/css/
+-rw-r--r--   0 runner    (1001) docker     (123)      635 2023-06-10 00:41:20.000000 smol-0.4.0/docs/src/_static/css/smol.css
+-rw-r--r--   0 runner    (1001) docker     (123)      139 2023-06-10 00:41:20.000000 smol-0.4.0/docs/src/_static/custom.js
+-rw-r--r--   0 runner    (1001) docker     (123)   523405 2023-06-10 00:41:20.000000 smol-0.4.0/docs/src/_static/logo.png
+-rw-r--r--   0 runner    (1001) docker     (123)     8969 2023-06-10 00:41:20.000000 smol-0.4.0/docs/src/_static/logo.svg
+-rw-r--r--   0 runner    (1001) docker     (123)    17696 2023-06-10 00:41:20.000000 smol-0.4.0/docs/src/_static/require.js
+-rw-r--r--   0 runner    (1001) docker     (123)    19531 2023-06-10 00:41:20.000000 smol-0.4.0/docs/src/_static/smol_cofe.svg
+-rw-r--r--   0 runner    (1001) docker     (123)    22202 2023-06-10 00:41:20.000000 smol-0.4.0/docs/src/_static/smol_moca.svg
+-rw-r--r--   0 runner    (1001) docker     (123)    24033 2023-06-10 00:41:20.000000 smol-0.4.0/docs/src/_static/smol_workflow.svg
+-rw-r--r--   0 runner    (1001) docker     (123)     6539 2023-06-10 00:41:20.000000 smol-0.4.0/docs/src/_static/starting.svg
+-rw-r--r--   0 runner    (1001) docker     (123)     9664 2023-06-10 00:41:20.000000 smol-0.4.0/docs/src/_static/user.svg
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-10 00:41:39.087390 smol-0.4.0/docs/src/api_reference/
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-10 00:41:39.087390 smol-0.4.0/docs/src/api_reference/autogen/
+-rw-r--r--   0 runner    (1001) docker     (123)      319 2023-06-10 00:41:20.000000 smol-0.4.0/docs/src/api_reference/autogen/cofe.extern.rst
+-rw-r--r--   0 runner    (1001) docker     (123)      392 2023-06-10 00:41:20.000000 smol-0.4.0/docs/src/api_reference/autogen/cofe.rst
+-rw-r--r--   0 runner    (1001) docker     (123)     1040 2023-06-10 00:41:20.000000 smol-0.4.0/docs/src/api_reference/autogen/cofe.space.rst
+-rw-r--r--   0 runner    (1001) docker     (123)      647 2023-06-10 00:41:20.000000 smol-0.4.0/docs/src/api_reference/autogen/cofe.wrangling.rst
+-rw-r--r--   0 runner    (1001) docker     (123)      805 2023-06-10 00:41:20.000000 smol-0.4.0/docs/src/api_reference/autogen/moca.processor.rst
+-rw-r--r--   0 runner    (1001) docker     (123)      511 2023-06-10 00:41:20.000000 smol-0.4.0/docs/src/api_reference/autogen/moca.rst
+-rw-r--r--   0 runner    (1001) docker     (123)      921 2023-06-10 00:41:20.000000 smol-0.4.0/docs/src/api_reference/autogen/moca.sampler.rst
+-rw-r--r--   0 runner    (1001) docker     (123)       46 2023-06-10 00:41:20.000000 smol-0.4.0/docs/src/api_reference/autogen/modules.rst
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-10 00:41:39.087390 smol-0.4.0/docs/src/api_reference/capp/
+-rw-r--r--   0 runner    (1001) docker     (123)      130 2023-06-10 00:41:20.000000 smol-0.4.0/docs/src/api_reference/capp/generate.enumerate.rst
+-rw-r--r--   0 runner    (1001) docker     (123)      118 2023-06-10 00:41:20.000000 smol-0.4.0/docs/src/api_reference/capp/generate.random.rst
+-rw-r--r--   0 runner    (1001) docker     (123)      261 2023-06-10 00:41:20.000000 smol-0.4.0/docs/src/api_reference/capp/generate.rst
+-rw-r--r--   0 runner    (1001) docker     (123)      220 2023-06-10 00:41:20.000000 smol-0.4.0/docs/src/api_reference/capp/generate.special.rst
+-rw-r--r--   0 runner    (1001) docker     (123)      280 2023-06-10 00:41:20.000000 smol-0.4.0/docs/src/api_reference/capp/index.rst
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-10 00:41:39.091390 smol-0.4.0/docs/src/api_reference/cofe/
+-rw-r--r--   0 runner    (1001) docker     (123)     1107 2023-06-10 00:41:20.000000 smol-0.4.0/docs/src/api_reference/cofe/clusterexpansion.rst
+-rw-r--r--   0 runner    (1001) docker     (123)      916 2023-06-10 00:41:20.000000 smol-0.4.0/docs/src/api_reference/cofe/clusterspace.rst
+-rw-r--r--   0 runner    (1001) docker     (123)      732 2023-06-10 00:41:20.000000 smol-0.4.0/docs/src/api_reference/cofe/extern.ewald.rst
+-rw-r--r--   0 runner    (1001) docker     (123)      346 2023-06-10 00:41:20.000000 smol-0.4.0/docs/src/api_reference/cofe/index.rst
+-rw-r--r--   0 runner    (1001) docker     (123)      111 2023-06-10 00:41:20.000000 smol-0.4.0/docs/src/api_reference/cofe/space.basis.rst
+-rw-r--r--   0 runner    (1001) docker     (123)      119 2023-06-10 00:41:20.000000 smol-0.4.0/docs/src/api_reference/cofe/space.cluster.rst
+-rw-r--r--   0 runner    (1001) docker     (123)      127 2023-06-10 00:41:20.000000 smol-0.4.0/docs/src/api_reference/cofe/space.constants.rst
+-rw-r--r--   0 runner    (1001) docker     (123)      115 2023-06-10 00:41:20.000000 smol-0.4.0/docs/src/api_reference/cofe/space.domain.rst
+-rw-r--r--   0 runner    (1001) docker     (123)      114 2023-06-10 00:41:20.000000 smol-0.4.0/docs/src/api_reference/cofe/space.orbit.rst
+-rw-r--r--   0 runner    (1001) docker     (123)      234 2023-06-10 00:41:20.000000 smol-0.4.0/docs/src/api_reference/cofe/space.rst
+-rw-r--r--   0 runner    (1001) docker     (123)      500 2023-06-10 00:41:20.000000 smol-0.4.0/docs/src/api_reference/cofe/wrangling.rst
+-rw-r--r--   0 runner    (1001) docker     (123)      128 2023-06-10 00:41:20.000000 smol-0.4.0/docs/src/api_reference/cofe/wrangling.select.rst
+-rw-r--r--   0 runner    (1001) docker     (123)      182 2023-06-10 00:41:20.000000 smol-0.4.0/docs/src/api_reference/cofe/wrangling.sw.rst
+-rw-r--r--   0 runner    (1001) docker     (123)      142 2023-06-10 00:41:20.000000 smol-0.4.0/docs/src/api_reference/cofe/wrangling.tools.rst
+-rw-r--r--   0 runner    (1001) docker     (123)      333 2023-06-10 00:41:20.000000 smol-0.4.0/docs/src/api_reference/index.rst
+-rw-r--r--   0 runner    (1001) docker     (123)      151 2023-06-10 00:41:20.000000 smol-0.4.0/docs/src/api_reference/io.rst
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-10 00:41:39.091390 smol-0.4.0/docs/src/api_reference/moca/
+-rw-r--r--   0 runner    (1001) docker     (123)      619 2023-06-10 00:41:20.000000 smol-0.4.0/docs/src/api_reference/moca/ensemble.rst
+-rw-r--r--   0 runner    (1001) docker     (123)      344 2023-06-10 00:41:20.000000 smol-0.4.0/docs/src/api_reference/moca/index.rst
+-rw-r--r--   0 runner    (1001) docker     (123)      161 2023-06-10 00:41:20.000000 smol-0.4.0/docs/src/api_reference/moca/processors.composite.rst
+-rw-r--r--   0 runner    (1001) docker     (123)      145 2023-06-10 00:41:20.000000 smol-0.4.0/docs/src/api_reference/moca/processors.ewald.rst
+-rw-r--r--   0 runner    (1001) docker     (123)      236 2023-06-10 00:41:20.000000 smol-0.4.0/docs/src/api_reference/moca/processors.expansion.rst
+-rw-r--r--   0 runner    (1001) docker     (123)     1156 2023-06-10 00:41:20.000000 smol-0.4.0/docs/src/api_reference/moca/processors.rst
+-rw-r--r--   0 runner    (1001) docker     (123)      136 2023-06-10 00:41:20.000000 smol-0.4.0/docs/src/api_reference/moca/sampler.bias.rst
+-rw-r--r--   0 runner    (1001) docker     (123)      645 2023-06-10 00:41:20.000000 smol-0.4.0/docs/src/api_reference/moca/sampler.container.rst
+-rw-r--r--   0 runner    (1001) docker     (123)      144 2023-06-10 00:41:20.000000 smol-0.4.0/docs/src/api_reference/moca/sampler.kernel.rst
+-rw-r--r--   0 runner    (1001) docker     (123)      121 2023-06-10 00:41:20.000000 smol-0.4.0/docs/src/api_reference/moca/sampler.mcusher.rst
+-rw-r--r--   0 runner    (1001) docker     (123)      760 2023-06-10 00:41:20.000000 smol-0.4.0/docs/src/api_reference/moca/sampler.rst
+-rw-r--r--   0 runner    (1001) docker     (123)      595 2023-06-10 00:41:20.000000 smol-0.4.0/docs/src/api_reference/moca/sampler.sampler.rst
+-rw-r--r--   0 runner    (1001) docker     (123)      125 2023-06-10 00:41:20.000000 smol-0.4.0/docs/src/api_reference/moca/sublattice.rst
+-rw-r--r--   0 runner    (1001) docker     (123)     6818 2023-06-10 00:41:20.000000 smol-0.4.0/docs/src/citing.rst
+-rw-r--r--   0 runner    (1001) docker     (123)     7280 2023-06-10 00:41:20.000000 smol-0.4.0/docs/src/conf.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-10 00:41:39.091390 smol-0.4.0/docs/src/developer_guide/
+-rw-r--r--   0 runner    (1001) docker     (123)    10867 2023-06-10 00:41:20.000000 smol-0.4.0/docs/src/developer_guide/design.rst
+-rw-r--r--   0 runner    (1001) docker     (123)     7123 2023-06-10 00:41:20.000000 smol-0.4.0/docs/src/developer_guide/guide.rst
+-rw-r--r--   0 runner    (1001) docker     (123)      377 2023-06-10 00:41:20.000000 smol-0.4.0/docs/src/developer_guide/index.rst
+-rw-r--r--   0 runner    (1001) docker     (123)     7781 2023-06-10 00:41:20.000000 smol-0.4.0/docs/src/getting_started.rst
+-rw-r--r--   0 runner    (1001) docker     (123)     4146 2023-06-10 00:41:20.000000 smol-0.4.0/docs/src/index.rst
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-10 00:41:39.095389 smol-0.4.0/docs/src/notebooks/
+-rw-r--r--   0 runner    (1001) docker     (123)     6172 2023-06-10 00:41:20.000000 smol-0.4.0/docs/src/notebooks/adding-structures-in-parallel.ipynb
+-rw-r--r--   0 runner    (1001) docker     (123)   138674 2023-06-10 00:41:20.000000 smol-0.4.0/docs/src/notebooks/ce-fit-w-centering.ipynb
+-rw-r--r--   0 runner    (1001) docker     (123)  3864843 2023-06-10 00:41:21.000000 smol-0.4.0/docs/src/notebooks/cluster-visualization.ipynb
+-rw-r--r--   0 runner    (1001) docker     (123)     9967 2023-06-10 00:41:21.000000 smol-0.4.0/docs/src/notebooks/creating-a-ce-w-electrostatics.ipynb
+-rw-r--r--   0 runner    (1001) docker     (123)    18733 2023-06-10 00:41:21.000000 smol-0.4.0/docs/src/notebooks/creating-a-ce.ipynb
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-10 00:41:39.179389 smol-0.4.0/docs/src/notebooks/data/
+-rw-r--r--   0 runner    (1001) docker     (123) 21341490 2023-06-10 00:41:21.000000 smol-0.4.0/docs/src/notebooks/data/LMTO.mson
+-rw-r--r--   0 runner    (1001) docker     (123)    12439 2023-06-10 00:41:21.000000 smol-0.4.0/docs/src/notebooks/data/LiMn2O4_drx_tutorial.json
+-rw-r--r--   0 runner    (1001) docker     (123)  9777379 2023-06-10 00:41:21.000000 smol-0.4.0/docs/src/notebooks/data/MnTi_O.json
+-rw-r--r--   0 runner    (1001) docker     (123)   489611 2023-06-10 00:41:21.000000 smol-0.4.0/docs/src/notebooks/data/basic_ce.mson
+-rw-r--r--   0 runner    (1001) docker     (123)   491616 2023-06-10 00:41:21.000000 smol-0.4.0/docs/src/notebooks/data/basic_ce_ewald.mson
+-rw-r--r--   0 runner    (1001) docker     (123)  3685773 2023-06-10 00:41:21.000000 smol-0.4.0/docs/src/notebooks/data/lmo_drx_entries.json
+-rw-r--r--   0 runner    (1001) docker     (123)     1503 2023-06-10 00:41:21.000000 smol-0.4.0/docs/src/notebooks/data/lmo_drx_prim.json
+-rw-r--r--   0 runner    (1001) docker     (123)   339273 2023-06-10 00:41:21.000000 smol-0.4.0/docs/src/notebooks/data/lmof_entries.json
+-rw-r--r--   0 runner    (1001) docker     (123)     1678 2023-06-10 00:41:21.000000 smol-0.4.0/docs/src/notebooks/data/lmof_prim.json
+-rw-r--r--   0 runner    (1001) docker     (123)  9777379 2023-06-10 00:41:21.000000 smol-0.4.0/docs/src/notebooks/data/lmto_entries.json
+-rw-r--r--   0 runner    (1001) docker     (123) 20338901 2023-06-10 00:41:21.000000 smol-0.4.0/docs/src/notebooks/data/lmto_indicator.json
+-rw-r--r--   0 runner    (1001) docker     (123)      971 2023-06-10 00:41:21.000000 smol-0.4.0/docs/src/notebooks/data/lmto_prim.json
+-rw-r--r--   0 runner    (1001) docker     (123) 21733181 2023-06-10 00:41:21.000000 smol-0.4.0/docs/src/notebooks/data/lmto_sinusoid.mson
+-rw-r--r--   0 runner    (1001) docker     (123)   197770 2023-06-10 00:41:21.000000 smol-0.4.0/docs/src/notebooks/data/lno_entries.json
+-rw-r--r--   0 runner    (1001) docker     (123)     1284 2023-06-10 00:41:21.000000 smol-0.4.0/docs/src/notebooks/data/lno_prim.json
+-rw-r--r--   0 runner    (1001) docker     (123)   187064 2023-06-10 00:41:21.000000 smol-0.4.0/docs/src/notebooks/generating-sqs.ipynb
+-rw-r--r--   0 runner    (1001) docker     (123)     4612 2023-06-10 00:41:21.000000 smol-0.4.0/docs/src/notebooks/index.ipynb
+-rw-r--r--   0 runner    (1001) docker     (123)    73835 2023-06-10 00:41:21.000000 smol-0.4.0/docs/src/notebooks/lmo-drx-ce-mc.ipynb
+-rw-r--r--   0 runner    (1001) docker     (123)    97528 2023-06-10 00:41:21.000000 smol-0.4.0/docs/src/notebooks/openmp-parallelism.ipynb
+-rw-r--r--   0 runner    (1001) docker     (123)    13547 2023-06-10 00:41:21.000000 smol-0.4.0/docs/src/notebooks/running-canonical-mc.ipynb
+-rw-r--r--   0 runner    (1001) docker     (123)    11165 2023-06-10 00:41:21.000000 smol-0.4.0/docs/src/notebooks/running-charge-balanced-gcmc.ipynb
+-rw-r--r--   0 runner    (1001) docker     (123)    57828 2023-06-10 00:41:21.000000 smol-0.4.0/docs/src/notebooks/running-ewald-sim_anneal.ipynb
+-rw-r--r--   0 runner    (1001) docker     (123)    21729 2023-06-10 00:41:21.000000 smol-0.4.0/docs/src/notebooks/running-semigrand-mc.ipynb
+-rw-r--r--   0 runner    (1001) docker     (123)    11098 2023-06-10 00:41:21.000000 smol-0.4.0/docs/src/notebooks/training-data-preparation.ipynb
+-rw-r--r--   0 runner    (1001) docker     (123)   108917 2023-06-10 00:41:21.000000 smol-0.4.0/docs/src/notebooks/wang-landau-ising.ipynb
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-10 00:41:39.179389 smol-0.4.0/docs/src/notebooks/wip/
+-rw-r--r--   0 runner    (1001) docker     (123)    47797 2023-06-10 00:41:21.000000 smol-0.4.0/docs/src/notebooks/wip/basis-orthogonalization.ipynb
+-rw-r--r--   0 runner    (1001) docker     (123)    12351 2023-06-10 00:41:21.000000 smol-0.4.0/docs/src/user_guide.rst
+-rw-r--r--   0 runner    (1001) docker     (123)      185 2023-06-10 00:41:21.000000 smol-0.4.0/environment.yml
+-rw-r--r--   0 runner    (1001) docker     (123)     2824 2023-06-10 00:41:21.000000 smol-0.4.0/pyproject.toml
+-rw-r--r--   0 runner    (1001) docker     (123)       54 2023-06-10 00:41:21.000000 smol-0.4.0/requirements-optional.txt
+-rw-r--r--   0 runner    (1001) docker     (123)       50 2023-06-10 00:41:21.000000 smol-0.4.0/requirements.txt
+-rw-r--r--   0 runner    (1001) docker     (123)       38 2023-06-10 00:41:39.195389 smol-0.4.0/setup.cfg
+-rw-r--r--   0 runner    (1001) docker     (123)     4276 2023-06-10 00:41:21.000000 smol-0.4.0/setup.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-10 00:41:39.179389 smol-0.4.0/smol/
+-rw-r--r--   0 runner    (1001) docker     (123)      249 2023-06-10 00:41:21.000000 smol-0.4.0/smol/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-10 00:41:39.179389 smol-0.4.0/smol/capp/
+-rw-r--r--   0 runner    (1001) docker     (123)      123 2023-06-10 00:41:21.000000 smol-0.4.0/smol/capp/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-10 00:41:39.179389 smol-0.4.0/smol/capp/generate/
+-rw-r--r--   0 runner    (1001) docker     (123)      391 2023-06-10 00:41:21.000000 smol-0.4.0/smol/capp/generate/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1430 2023-06-10 00:41:21.000000 smol-0.4.0/smol/capp/generate/enumerate.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8691 2023-06-10 00:41:21.000000 smol-0.4.0/smol/capp/generate/random.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-10 00:41:39.179389 smol-0.4.0/smol/capp/generate/special/
+-rw-r--r--   0 runner    (1001) docker     (123)      171 2023-06-10 00:41:21.000000 smol-0.4.0/smol/capp/generate/special/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    23479 2023-06-10 00:41:21.000000 smol-0.4.0/smol/capp/generate/special/sqs.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-10 00:41:39.179389 smol-0.4.0/smol/cofe/
+-rw-r--r--   0 runner    (1001) docker     (123)      521 2023-06-10 00:41:21.000000 smol-0.4.0/smol/cofe/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    20806 2023-06-10 00:41:21.000000 smol-0.4.0/smol/cofe/expansion.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-10 00:41:39.179389 smol-0.4.0/smol/cofe/extern/
+-rw-r--r--   0 runner    (1001) docker     (123)      402 2023-06-10 00:41:21.000000 smol-0.4.0/smol/cofe/extern/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8298 2023-06-10 00:41:21.000000 smol-0.4.0/smol/cofe/extern/ewald.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-10 00:41:39.183389 smol-0.4.0/smol/cofe/space/
+-rw-r--r--   0 runner    (1001) docker     (123)      537 2023-06-10 00:41:21.000000 smol-0.4.0/smol/cofe/space/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    20694 2023-06-10 00:41:21.000000 smol-0.4.0/smol/cofe/space/basis.py
+-rw-r--r--   0 runner    (1001) docker     (123)    12001 2023-06-10 00:41:21.000000 smol-0.4.0/smol/cofe/space/cluster.py
+-rw-r--r--   0 runner    (1001) docker     (123)    81440 2023-06-10 00:41:21.000000 smol-0.4.0/smol/cofe/space/clusterspace.py
+-rw-r--r--   0 runner    (1001) docker     (123)      437 2023-06-10 00:41:21.000000 smol-0.4.0/smol/cofe/space/constants.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10229 2023-06-10 00:41:21.000000 smol-0.4.0/smol/cofe/space/domain.py
+-rw-r--r--   0 runner    (1001) docker     (123)    21357 2023-06-10 00:41:21.000000 smol-0.4.0/smol/cofe/space/orbit.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-10 00:41:39.183389 smol-0.4.0/smol/cofe/wrangling/
+-rw-r--r--   0 runner    (1001) docker     (123)      583 2023-06-10 00:41:21.000000 smol-0.4.0/smol/cofe/wrangling/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5218 2023-06-10 00:41:21.000000 smol-0.4.0/smol/cofe/wrangling/select.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7911 2023-06-10 00:41:21.000000 smol-0.4.0/smol/cofe/wrangling/tools.py
+-rw-r--r--   0 runner    (1001) docker     (123)    36058 2023-06-10 00:41:21.000000 smol-0.4.0/smol/cofe/wrangling/wrangler.py
+-rw-r--r--   0 runner    (1001) docker     (123)      130 2023-06-10 00:41:21.000000 smol-0.4.0/smol/constants.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1478 2023-06-10 00:41:21.000000 smol-0.4.0/smol/io.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-10 00:41:39.183389 smol-0.4.0/smol/moca/
+-rw-r--r--   0 runner    (1001) docker     (123)      837 2023-06-10 00:41:21.000000 smol-0.4.0/smol/moca/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    30558 2023-06-10 00:41:21.000000 smol-0.4.0/smol/moca/composition.py
+-rw-r--r--   0 runner    (1001) docker     (123)    15623 2023-06-10 00:41:21.000000 smol-0.4.0/smol/moca/ensemble.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-10 00:41:39.183389 smol-0.4.0/smol/moca/kernel/
+-rw-r--r--   0 runner    (1001) docker     (123)     1406 2023-06-10 00:41:21.000000 smol-0.4.0/smol/moca/kernel/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    25655 2023-06-10 00:41:21.000000 smol-0.4.0/smol/moca/kernel/base.py
+-rw-r--r--   0 runner    (1001) docker     (123)    13972 2023-06-10 00:41:21.000000 smol-0.4.0/smol/moca/kernel/bias.py
+-rw-r--r--   0 runner    (1001) docker     (123)    27692 2023-06-10 00:41:21.000000 smol-0.4.0/smol/moca/kernel/mcusher.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5611 2023-06-10 00:41:21.000000 smol-0.4.0/smol/moca/kernel/metropolis.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1030 2023-06-10 00:41:21.000000 smol-0.4.0/smol/moca/kernel/random.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11301 2023-06-10 00:41:21.000000 smol-0.4.0/smol/moca/kernel/wanglandau.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1844 2023-06-10 00:41:21.000000 smol-0.4.0/smol/moca/metadata.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6040 2023-06-10 00:41:21.000000 smol-0.4.0/smol/moca/occu_utils.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-10 00:41:39.183389 smol-0.4.0/smol/moca/processor/
+-rw-r--r--   0 runner    (1001) docker     (123)      624 2023-06-10 00:41:21.000000 smol-0.4.0/smol/moca/processor/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11982 2023-06-10 00:41:21.000000 smol-0.4.0/smol/moca/processor/base.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6324 2023-06-10 00:41:21.000000 smol-0.4.0/smol/moca/processor/composite.py
+-rw-r--r--   0 runner    (1001) docker     (123)    17001 2023-06-10 00:41:21.000000 smol-0.4.0/smol/moca/processor/distance.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6515 2023-06-10 00:41:21.000000 smol-0.4.0/smol/moca/processor/ewald.py
+-rw-r--r--   0 runner    (1001) docker     (123)    18642 2023-06-10 00:41:21.000000 smol-0.4.0/smol/moca/processor/expansion.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-10 00:41:39.183389 smol-0.4.0/smol/moca/sampler/
+-rw-r--r--   0 runner    (1001) docker     (123)      258 2023-06-10 00:41:21.000000 smol-0.4.0/smol/moca/sampler/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    27633 2023-06-10 00:41:21.000000 smol-0.4.0/smol/moca/sampler/container.py
+-rw-r--r--   0 runner    (1001) docker     (123)    17279 2023-06-10 00:41:21.000000 smol-0.4.0/smol/moca/sampler/sampler.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8246 2023-06-10 00:41:21.000000 smol-0.4.0/smol/moca/sublattice.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2713 2023-06-10 00:41:21.000000 smol-0.4.0/smol/moca/trace.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-10 00:41:39.187389 smol-0.4.0/smol/utils/
+-rw-r--r--   0 runner    (1001) docker     (123)      133 2023-06-10 00:41:21.000000 smol-0.4.0/smol/utils/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)   166678 2023-06-10 00:41:33.000000 smol-0.4.0/smol/utils/_openmp_helpers.c
+-rw-r--r--   0 runner    (1001) docker     (123)     2468 2023-06-10 00:41:21.000000 smol-0.4.0/smol/utils/_openmp_helpers.pyx
+-rw-r--r--   0 runner    (1001) docker     (123)     2218 2023-06-10 00:41:21.000000 smol-0.4.0/smol/utils/class_utils.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-10 00:41:39.191389 smol-0.4.0/smol/utils/cluster/
+-rw-r--r--   0 runner    (1001) docker     (123)      416 2023-06-10 00:41:21.000000 smol-0.4.0/smol/utils/cluster/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)  1118200 2023-06-10 00:41:34.000000 smol-0.4.0/smol/utils/cluster/container.c
+-rw-r--r--   0 runner    (1001) docker     (123)     1675 2023-06-10 00:41:21.000000 smol-0.4.0/smol/utils/cluster/container.pxd
+-rw-r--r--   0 runner    (1001) docker     (123)     9988 2023-06-10 00:41:21.000000 smol-0.4.0/smol/utils/cluster/container.pyx
+-rw-r--r--   0 runner    (1001) docker     (123)  1020317 2023-06-10 00:41:35.000000 smol-0.4.0/smol/utils/cluster/correlations.c
+-rw-r--r--   0 runner    (1001) docker     (123)    13062 2023-06-10 00:41:21.000000 smol-0.4.0/smol/utils/cluster/correlations.pyx
+-rw-r--r--   0 runner    (1001) docker     (123)  1151333 2023-06-10 00:41:36.000000 smol-0.4.0/smol/utils/cluster/evaluator.c
+-rw-r--r--   0 runner    (1001) docker     (123)     2326 2023-06-10 00:41:21.000000 smol-0.4.0/smol/utils/cluster/evaluator.pxd
+-rw-r--r--   0 runner    (1001) docker     (123)    17154 2023-06-10 00:41:21.000000 smol-0.4.0/smol/utils/cluster/evaluator.pyx
+-rw-r--r--   0 runner    (1001) docker     (123)   785867 2023-06-10 00:41:37.000000 smol-0.4.0/smol/utils/cluster/ewald.c
+-rw-r--r--   0 runner    (1001) docker     (123)     2021 2023-06-10 00:41:21.000000 smol-0.4.0/smol/utils/cluster/ewald.pyx
+-rw-r--r--   0 runner    (1001) docker     (123)     1619 2023-06-10 00:41:21.000000 smol-0.4.0/smol/utils/cluster/numthreads.py
+-rw-r--r--   0 runner    (1001) docker     (123)      538 2023-06-10 00:41:21.000000 smol-0.4.0/smol/utils/cluster/struct.pxd
+-rw-r--r--   0 runner    (1001) docker     (123)      919 2023-06-10 00:41:21.000000 smol-0.4.0/smol/utils/exceptions.py
+-rw-r--r--   0 runner    (1001) docker     (123)    29876 2023-06-10 00:41:21.000000 smol-0.4.0/smol/utils/math.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1500 2023-06-10 00:41:21.000000 smol-0.4.0/smol/utils/progressbar.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2262 2023-06-10 00:41:21.000000 smol-0.4.0/smol/utils/setmany.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-10 00:41:39.179389 smol-0.4.0/smol.egg-info/
+-rw-r--r--   0 runner    (1001) docker     (123)    10426 2023-06-10 00:41:38.000000 smol-0.4.0/smol.egg-info/PKG-INFO
+-rw-r--r--   0 runner    (1001) docker     (123)     7698 2023-06-10 00:41:39.000000 smol-0.4.0/smol.egg-info/SOURCES.txt
+-rw-r--r--   0 runner    (1001) docker     (123)        1 2023-06-10 00:41:38.000000 smol-0.4.0/smol.egg-info/dependency_links.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      437 2023-06-10 00:41:38.000000 smol-0.4.0/smol.egg-info/requires.txt
+-rw-r--r--   0 runner    (1001) docker     (123)       34 2023-06-10 00:41:38.000000 smol-0.4.0/smol.egg-info/top_level.txt
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-10 00:41:39.191389 smol-0.4.0/tests/
+-rw-r--r--   0 runner    (1001) docker     (123)      291 2023-06-10 00:41:21.000000 smol-0.4.0/tests/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8150 2023-06-10 00:41:21.000000 smol-0.4.0/tests/conftest.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-10 00:41:39.191389 smol-0.4.0/tests/data/
+-rw-r--r--   0 runner    (1001) docker     (123)      616 2023-06-10 00:41:21.000000 smol-0.4.0/tests/data/AuPd_prim.json
+-rw-r--r--   0 runner    (1001) docker     (123)      685 2023-06-10 00:41:21.000000 smol-0.4.0/tests/data/CrFeW_prim.json
+-rw-r--r--   0 runner    (1001) docker     (123)     1183 2023-06-10 00:41:21.000000 smol-0.4.0/tests/data/LiCaBr_prim.json
+-rw-r--r--   0 runner    (1001) docker     (123)     1000 2023-06-10 00:41:21.000000 smol-0.4.0/tests/data/LiMOF_prim.json
+-rw-r--r--   0 runner    (1001) docker     (123)     1066 2023-06-10 00:41:21.000000 smol-0.4.0/tests/data/LiMnTiVOF_prim.json
+-rw-r--r--   0 runner    (1001) docker     (123)     1016 2023-06-10 00:41:21.000000 smol-0.4.0/tests/data/LiTiMnPO_prim.json
+-rw-r--r--   0 runner    (1001) docker     (123)     2941 2023-06-10 00:41:21.000000 smol-0.4.0/tests/data/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)      172 2023-06-10 00:41:21.000000 smol-0.4.0/tests/pytest.ini
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-10 00:41:39.191389 smol-0.4.0/tests/test_capp/
+-rw-r--r--   0 runner    (1001) docker     (123)     1153 2023-06-10 00:41:21.000000 smol-0.4.0/tests/test_capp/test_enumerate.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1420 2023-06-10 00:41:21.000000 smol-0.4.0/tests/test_capp/test_random.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2856 2023-06-10 00:41:21.000000 smol-0.4.0/tests/test_capp/test_sqs.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-10 00:41:39.195389 smol-0.4.0/tests/test_cofe/
+-rw-r--r--   0 runner    (1001) docker     (123)     8102 2023-06-10 00:41:21.000000 smol-0.4.0/tests/test_cofe/test_basis.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2836 2023-06-10 00:41:21.000000 smol-0.4.0/tests/test_cofe/test_cluster.py
+-rw-r--r--   0 runner    (1001) docker     (123)    34909 2023-06-10 00:41:21.000000 smol-0.4.0/tests/test_cofe/test_clusterspace.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3582 2023-06-10 00:41:21.000000 smol-0.4.0/tests/test_cofe/test_domain.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3157 2023-06-10 00:41:21.000000 smol-0.4.0/tests/test_cofe/test_ewald.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6311 2023-06-10 00:41:21.000000 smol-0.4.0/tests/test_cofe/test_expansion.py
+-rw-r--r--   0 runner    (1001) docker     (123)    18053 2023-06-10 00:41:21.000000 smol-0.4.0/tests/test_cofe/test_orbit.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1908 2023-06-10 00:41:21.000000 smol-0.4.0/tests/test_cofe/test_select.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8613 2023-06-10 00:41:21.000000 smol-0.4.0/tests/test_cofe/test_tools.py
+-rw-r--r--   0 runner    (1001) docker     (123)    15817 2023-06-10 00:41:21.000000 smol-0.4.0/tests/test_cofe/test_wrangler.py
+-rw-r--r--   0 runner    (1001) docker     (123)      877 2023-06-10 00:41:21.000000 smol-0.4.0/tests/test_io.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-10 00:41:39.195389 smol-0.4.0/tests/test_moca/
+-rw-r--r--   0 runner    (1001) docker     (123)     5481 2023-06-10 00:41:21.000000 smol-0.4.0/tests/test_moca/test_bias.py
+-rw-r--r--   0 runner    (1001) docker     (123)    19687 2023-06-10 00:41:21.000000 smol-0.4.0/tests/test_moca/test_comp_space.py
+-rw-r--r--   0 runner    (1001) docker     (123)    15795 2023-06-10 00:41:21.000000 smol-0.4.0/tests/test_moca/test_container.py
+-rw-r--r--   0 runner    (1001) docker     (123)    18590 2023-06-10 00:41:21.000000 smol-0.4.0/tests/test_moca/test_ensemble.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8122 2023-06-10 00:41:21.000000 smol-0.4.0/tests/test_moca/test_kernel.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11905 2023-06-10 00:41:21.000000 smol-0.4.0/tests/test_moca/test_mcushers.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6412 2023-06-10 00:41:21.000000 smol-0.4.0/tests/test_moca/test_occu_utils.py
+-rw-r--r--   0 runner    (1001) docker     (123)    18055 2023-06-10 00:41:21.000000 smol-0.4.0/tests/test_moca/test_processor.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4279 2023-06-10 00:41:21.000000 smol-0.4.0/tests/test_moca/test_sampler.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6867 2023-06-10 00:41:21.000000 smol-0.4.0/tests/test_moca/test_sublattice.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-10 00:41:39.195389 smol-0.4.0/tests/test_utils/
+-rw-r--r--   0 runner    (1001) docker     (123)     3300 2023-06-10 00:41:21.000000 smol-0.4.0/tests/test_utils/test_class_utils.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5242 2023-06-10 00:41:21.000000 smol-0.4.0/tests/test_utils/test_cluster_utils.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6728 2023-06-10 00:41:21.000000 smol-0.4.0/tests/test_utils/test_evaluator.py
+-rw-r--r--   0 runner    (1001) docker     (123)    22327 2023-06-10 00:41:21.000000 smol-0.4.0/tests/test_utils/test_math_utils.py
+-rw-r--r--   0 runner    (1001) docker     (123)      961 2023-06-10 00:41:21.000000 smol-0.4.0/tests/test_utils/test_setmany.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3301 2023-06-10 00:41:21.000000 smol-0.4.0/tests/utils.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-10 00:41:39.195389 smol-0.4.0/tools/
+-rw-r--r--   0 runner    (1001) docker     (123)     6803 2023-06-10 00:41:21.000000 smol-0.4.0/tools/build_helpers.py
```

### Comparing `smol-0.3.1/.github/ISSUE_TEMPLATE/bug_report.md` & `smol-0.4.0/.github/ISSUE_TEMPLATE/bug_report.md`

 * *Files identical despite different names*

### Comparing `smol-0.3.1/.github/ISSUE_TEMPLATE/code_review.md` & `smol-0.4.0/.github/ISSUE_TEMPLATE/code_review.md`

 * *Files identical despite different names*

### Comparing `smol-0.3.1/.github/ISSUE_TEMPLATE/feature_request.md` & `smol-0.4.0/.github/ISSUE_TEMPLATE/feature_request.md`

 * *Files identical despite different names*

### Comparing `smol-0.3.1/.github/pull_request_template.md` & `smol-0.4.0/.github/pull_request_template.md`

 * *Files identical despite different names*

### Comparing `smol-0.3.1/.github/workflows/docs.yml` & `smol-0.4.0/.github/workflows/docs.yml`

 * *Files identical despite different names*

### Comparing `smol-0.3.1/.github/workflows/lint.yml` & `smol-0.4.0/.github/workflows/lint.yml`

 * *Files 12% similar despite different names*

```diff
@@ -24,18 +24,18 @@
       - name: Install dependencies
         run: |
           python -m pip install --upgrade pip
           pip install -r requirements.txt
           pip install -e .[dev]
       - name: flake8
         run: |
-            flake8 --version
-            flake8 --count --show-source --statistics smol
-            # exit-zero treats all errors as warnings.
-            flake8 --count --exit-zero --max-complexity=20 --statistics smol
+          flake8 --version
+          flake8 --count --show-source --statistics --extend-ignore E203,E501 --max-line-length 88 smol
+          # exit-zero treats all errors as warnings.
+          flake8 --count --exit-zero --max-complexity=20 --statistics --extend-ignore E203,E501 --max-line-length 88 smol
       - name: black
         run: |
           black --version
           black --check --diff --color smol
       - name: pydocstyle
         run: |
           pydocstyle --version
```

### Comparing `smol-0.3.1/.github/workflows/test.yml` & `smol-0.4.0/.github/workflows/test.yml`

 * *Files 1% similar despite different names*

```diff
@@ -35,15 +35,15 @@
             ${{ runner.os }}-
 
       - name: Install dependencies and package
         run: |
           python -m pip install --upgrade pip
           pip install -r requirements.txt
           pip install -r requirements-optional.txt
-          pip install -e .[tests]
+          pip install -e .[test]
 
       - name: Test with pytest
         run: |
           pytest tests --cov=smol --cov-report=xml
 
       - if: ${{ matrix.python_version == 3.9 && github.event_name == 'push' }}
         name: codacy-coverage-reporter
```

### Comparing `smol-0.3.1/.github/workflows/update-precommit.yaml` & `smol-0.4.0/.github/workflows/update-precommit.yaml`

 * *Files 1% similar despite different names*

```diff
@@ -19,15 +19,15 @@
       - name: Install pre-commit
         run: pip install pre-commit
 
       - name: Run pre-commit autoupdate
         run: pre-commit autoupdate
 
       - name: Create Pull Request
-        uses: peter-evans/create-pull-request@v4.2.3
+        uses: peter-evans/create-pull-request@v5.0.1
         with:
           token: ${{ secrets.GITHUB_TOKEN }}
           branch: update/pre-commit-autoupdate
           title: auto-update pre-commit hooks
           commit-message: auto-update pre-commit hooks
           body: Update versions of tools in pre-commit hooks to latest versions.
           labels: dependencies
```

### Comparing `smol-0.3.1/.gitignore` & `smol-0.4.0/.gitignore`

 * *Files identical despite different names*

### Comparing `smol-0.3.1/.pre-commit-config.yaml` & `smol-0.4.0/.pre-commit-config.yaml`

 * *Files 14% similar despite different names*

```diff
@@ -2,87 +2,88 @@
 # See https://pre-commit.com/hooks.html for more hooks
 
 ci:
   autoupdate_schedule: monthly
 
 repos:
 - repo: https://github.com/pre-commit/pre-commit-hooks
-  rev: v4.3.0
+  rev: v4.4.0
   hooks:
   - id: check-yaml
   - id: fix-encoding-pragma
     args:
     - --remove
   - id: end-of-file-fixer
   - id: trailing-whitespace
   - id: check-added-large-files
     args: ['--maxkb=600']
 
 - repo: https://github.com/psf/black
-  rev: 22.10.0
+  rev: 23.3.0
   hooks:
   - id: black
 
 - repo: https://github.com/asottile/blacken-docs
-  rev: v1.12.1
+  rev: 1.13.0
   hooks:
   - id: blacken-docs
-    additional_dependencies: [black==21.5b0]
+    additional_dependencies: [black==23.1.0]
     exclude: README.md
 
 - repo: https://github.com/pycqa/isort
   rev: 5.12.0
   hooks:
   - id: isort
     name: isort (python)
     args:
     - --profile=black
 
 - repo: https://github.com/asottile/pyupgrade
-  rev: v3.2.2
+  rev: v3.4.0
   hooks:
     - id: pyupgrade
       args: [--py38-plus]
 
 - repo: https://github.com/PyCQA/autoflake
-  rev: v1.7.7
+  rev: v2.1.1
   hooks:
     - id: autoflake
       args:
         - --in-place
         - --remove-unused-variables
         - --remove-all-unused-imports
         - --expand-star-imports
         - --ignore-init-module-imports
 
-- repo: https://github.com/PyCQA/flake8
-  rev: 5.0.4
-  hooks:
-  - id: flake8
-    files: ^smol/
-    language_version: python3
-    additional_dependencies:
-    - flake8-typing-imports==1.10.1
+# removing for now since it cant be configured with a pyproject.toml
+#- repo: https://github.com/PyCQA/flake8
+#  rev: 6.0.0
+#  hooks:
+#  - id: flake8
+#    files: ^smol/
+#    language_version: python3
+#    additional_dependencies:
+#    - flake8-typing-imports==1.14.0
+#    - flake8-rst==0.8.0
     # - flake8-docstrings==1.6.0  # fix these
     # - flake8-rst-docstrings==0.2.3
-    - flake8-rst==0.8.0
 
 - repo: https://github.com/pycqa/pydocstyle
-  rev: 6.1.1  # pick a git hash / tag to point to
+  rev: 6.3.0  # pick a git hash / tag to point to
   hooks:
   - id: pydocstyle
     files: ^smol/
 
 - repo: https://github.com/pre-commit/pygrep-hooks
-  rev: v1.9.0
+  rev: v1.10.0
   hooks:
   - id: rst-backticks
   - id: rst-directive-colons
   - id: rst-inline-touching-normal
 
 - repo: https://github.com/codespell-project/codespell
-  rev: v2.2.2
+  rev: v2.2.4
   hooks:
     - id: codespell
       stages: [commit, commit-msg]
       exclude_types: [html]
       args: [--ignore-words-list, 'nd, tread, mater', --skip, "*.ipynb"]
```

### Comparing `smol-0.3.1/CHANGES.md` & `smol-0.4.0/CHANGES.md`

 * *Files 2% similar despite different names*

```diff
@@ -8,14 +8,25 @@
 Use this section to keep track of changes in the works.
 ### Added
 ### Changed
 ### Fixed
 ### Removed
 ### Deprecated
 
+# [v0.4.0](https://github.com/CederGroupHub/smol/releases/tag/v0.4.0) (2023-06-09)
+### Added
+* openmp parallelization when computing correlation and cluster interaction vectors. #338 @lbluque
+* stochastic SQS generation functionality. #344 @lbluque
+* enumeration of symmetrically distinct supercell matrices. #344 @lbluque
+### Fixed
+* Fix #334 getting subclasses of non-abstract classes. #335 @lbluque
+* Fix #353 appending in `Sublattice.restricted_sites` property. #355 @qchempku2017
+* Use jsanitize to serialize dicts/lists of msonables. #354 @lbluque
+* Use site_mappings in `StructureWrangler.process_entry`. #363 @lbluque
+
 # [v0.3.1](https://github.com/CederGroupHub/smol/releases/tag/v0.3.1) (2023-02-07)
 ### Changed
 * Save ensemble as attributed in `SampleContainer` add `get_sampled_structures`. #326 @lbluque
 ### Fixed
 * `ClusterExpansion.cluster_interaction_tensors` as a cached property and reset when pruning. #330 @lbluque
 * Fix flakey unit tests. #328 @lbluque & @qchempku2017
```

### Comparing `smol-0.3.1/LICENSE` & `smol-0.4.0/LICENSE`

 * *Files identical despite different names*

### Comparing `smol-0.3.1/PKG-INFO` & `smol-0.4.0/PKG-INFO`

 * *Files 23% similar despite different names*

```diff
@@ -1,38 +1,81 @@
 Metadata-Version: 2.1
 Name: smol
-Version: 0.3.1
+Version: 0.4.0
 Summary: Lighthweight but caffeinated Python implementation of computational methods for statistical mechanical calculations of configurational states in crystalline material systems.
-Home-page: https://cedergrouphub.github.io/smol
-Author: Luis Barroso-Luque
-Author-email: lbluque@berkeley.edu
-Maintainer: Luis Barroso-Luque
-Maintainer-email: lbluque@berkeley.edu
-License: Modified BSD
-Project-URL: Documentation, https://cedergrouphub.github.io/smol
-Project-URL: Code, https://github.com/CederGroupHub/smol
-Project-URL: Issue tracker, https://github.com/CederGroupHub/smol/issues
+Author-email: Luis Barroso-Luque <lbluque@berkeley.edu>, Fengyu Xie <lbluque@berkeley.edu>
+Maintainer-email: Luis Barroso-Luque <lbluque@berkeley.edu>
+License: ::
+        
+            Statistical Mechanics on Lattices (smol) Copyright (c) 2022, The Regents
+            of the University of California, through Lawrence Berkeley National
+            Laboratory (subject to receipt of any required approvals from the U.S.
+            Dept. of Energy) and the University of California, Berkeley. All rights reserved.
+        
+            Redistribution and use in source and binary forms, with or without
+            modification, are permitted provided that the following conditions are met:
+        
+            (1) Redistributions of source code must retain the above copyright notice,
+            this list of conditions and the following disclaimer.
+        
+            (2) Redistributions in binary form must reproduce the above copyright
+            notice, this list of conditions and the following disclaimer in the
+            documentation and/or other materials provided with the distribution.
+        
+            (3) Neither the name of the University of California, Lawrence Berkeley
+            National Laboratory, U.S. Dept. of Energy, University of California,
+            Berkeley nor the names of its contributors may be used to endorse or
+            promote products derived from this software without specific prior written
+            permission.
+        
+        
+            THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+            AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+            IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+            ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+            LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+            CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+            SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+            INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+            CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+            ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+            POSSIBILITY OF SUCH DAMAGE.
+        
+            You are under no obligation whatsoever to provide any bug fixes, patches,
+            or upgrades to the features, functionality or performance of the source
+            code ("Enhancements") to anyone; however, if you choose to make your
+            Enhancements available either publicly, or directly to Lawrence Berkeley
+            National Laboratory, without imposing a separate written license agreement
+            for such Enhancements, then you hereby grant the following license: a
+            non-exclusive, royalty-free perpetual license to install, use, modify,
+            prepare derivative works, incorporate into other computer software,
+            distribute, and sublicense such enhancements or derivative works thereof,
+            in binary and source code form.
+        
+Project-URL: documentation, https://cedergrouphub.github.io/smol
+Project-URL: repository, https://github.com/CederGroupHub/smol
+Project-URL: changelog, https://cedergrouphub.github.io/smol/CHANGES.md
+Project-URL: tracker, https://github.com/CederGroupHub/smol/issues
 Classifier: Development Status :: 4 - Beta
 Classifier: Programming Language :: Python :: 3 :: Only
 Classifier: Programming Language :: Python :: 3.8
 Classifier: Programming Language :: Python :: 3.9
 Classifier: Programming Language :: Python :: 3.10
 Classifier: Intended Audience :: Science/Research
 Classifier: License :: OSI Approved :: BSD License
 Classifier: Operating System :: OS Independent
-Classifier: Topic :: Scientific/Engineering :: Information Analysis
 Classifier: Topic :: Scientific/Engineering :: Physics
 Classifier: Topic :: Scientific/Engineering :: Chemistry
 Classifier: Topic :: Software Development :: Libraries :: Python Modules
 Requires-Python: >=3.8
 Description-Content-Type: text/markdown
+Provides-Extra: optional
 Provides-Extra: docs
-Provides-Extra: tests
+Provides-Extra: test
 Provides-Extra: dev
-Provides-Extra: optional
 License-File: LICENSE
 
 <img src="docs/src/_static/logo.png" width="500px" alt=" ">
 
 Statistical Mechanics on Lattices
 =================================
 
@@ -54,41 +97,45 @@
 statistical mechanical and thermodynamic properties of crystalline
 material systems based on the *cluster expansion* method from alloy theory and
 related methods. Although **smol** is intentionally lightweight---in terms of
 dependencies and built-in functionality---it has a modular design that closely
 follows underlying mathematical formalism and provides useful abstractions to
 easily extend existing methods or implement and test new ones.
 
-
 Functionality
 -------------
 **smol** currently includes the following functionality:
 
-- Defining cluster expansion functions for a given disordered structure using a
-  variety of available site basis functions with and without explicit
-  redundancy.
-- Option to include explicit electrostatics in expansions using the Ewald
-  summation method.
-- Computing correlation vectors for a set of training structures with a variety
-  of functionality to inspect the resulting feature matrix.
-- Defining fitted cluster expansions for subsequent property prediction.
-- Fast evaluation of correlation vectors and differences in correlation vectors
-  from local updates in order to quickly compute properties and changes in
-  properties for specified supercell sizes.
-- Flexible toolset to sample cluster expansions using Monte Carlo with
-  canonical, semigrand canonical, and charge neutral semigrand canonical ensembles
-  using a Metropolis or a Wang-Landau sampler.
+-   Defining cluster expansion functions for a given disordered structure using a
+    variety of available site basis functions with and without explicit
+    redundancy.
+
+-   Option to include explicit electrostatics in expansions using the Ewald summation
+    method.
+-   Computing correlation vectors for a set of training structures with a variety
+    of functionality to inspect the resulting feature matrix.
+
+-   Defining fitted cluster expansions for subsequent property prediction.
+-   Fast evaluation of correlation vectors and differences in correlation vectors
+    from local updates in order to quickly compute properties and changes in
+    properties for specified supercell sizes.
+
+-   Flexible toolset to sample cluster expansions using Monte Carlo with
+    canonical, semigrand canonical, and charge neutral semigrand canonical ensembles
+    using a Metropolis or a Wang-Landau sampler.
+
+-   Special quasi-random structure generation based on either correlation vectors or
+    cluster interaction vectors.
 
 **smol** is built on top of [pymatgen](https://pymatgen.org) so any pre/post
 structure analysis can be done seamlessly using the various functionality
 supported there.
 
 Installation
 ------------
-
 From pypi:
 
     pip install smol
 
 From source:
 
 `Clone` the repository. The latest tag in the `main` branch is the stable version of the
@@ -106,44 +153,39 @@
     pip install smol
 
 You can also simply use the *environment.yml* file in the repository to install `smol`:
 
     conda env create -f environment.yml
     source activate smol-env
 
-
 Usage
 -----
 Refer to the [documentation](https://cedergrouphub.github.io/smol/) for details on using
 **smol**. Going through the [example notebooks](https://github.com/CederGroupHub/smol/tree/main/docs/src/notebooks)
 will also help you get started. You can run the example notebooks interactively in
 [binder](https://mybinder.org/v2/gh/CederGroupHub/smol/HEAD?labpath=docs%2Fsrc%2Fnotebooks%2Findex.ipynb).
 
-
 Citing
 ------
 If you use **smol** in your research, please give the repo a star :star: and refer to
 the [citing](https://cedergrouphub.github.io/smol/citing.html) page in the documentation
 for formal citation information.
 
-
 Contributing
 ------------
 We welcome all your contributions with open arms! Please fork and pull request any contributions.
 See the
 [developing](https://cedergrouphub.github.io/smol/developer_guide/index.html)
 page in the documentation for how to contribute.
 
-
 Changes
 -------
 The most recent changes are detailed in the
 [change log](https://github.com/CederGroupHub/smol/blob/master/CHANGES.md).
 
-
 Copyright Notice
 ----------------
     Statistical Mechanics on Lattices (smol) Copyright (c) 2022, The Regents
     of the University of California, through Lawrence Berkeley National
     Laboratory (subject to receipt of any required approvals from the U.S.
     Dept. of Energy) and the University of California, Berkeley. All rights reserved.
```

### Comparing `smol-0.3.1/README.md` & `smol-0.4.0/README.md`

 * *Files 3% similar despite different names*

```diff
@@ -21,41 +21,45 @@
 statistical mechanical and thermodynamic properties of crystalline
 material systems based on the *cluster expansion* method from alloy theory and
 related methods. Although **smol** is intentionally lightweight---in terms of
 dependencies and built-in functionality---it has a modular design that closely
 follows underlying mathematical formalism and provides useful abstractions to
 easily extend existing methods or implement and test new ones.
 
-
 Functionality
 -------------
 **smol** currently includes the following functionality:
 
-- Defining cluster expansion functions for a given disordered structure using a
-  variety of available site basis functions with and without explicit
-  redundancy.
-- Option to include explicit electrostatics in expansions using the Ewald
-  summation method.
-- Computing correlation vectors for a set of training structures with a variety
-  of functionality to inspect the resulting feature matrix.
-- Defining fitted cluster expansions for subsequent property prediction.
-- Fast evaluation of correlation vectors and differences in correlation vectors
-  from local updates in order to quickly compute properties and changes in
-  properties for specified supercell sizes.
-- Flexible toolset to sample cluster expansions using Monte Carlo with
-  canonical, semigrand canonical, and charge neutral semigrand canonical ensembles
-  using a Metropolis or a Wang-Landau sampler.
+-   Defining cluster expansion functions for a given disordered structure using a
+    variety of available site basis functions with and without explicit
+    redundancy.
+
+-   Option to include explicit electrostatics in expansions using the Ewald summation
+    method.
+-   Computing correlation vectors for a set of training structures with a variety
+    of functionality to inspect the resulting feature matrix.
+
+-   Defining fitted cluster expansions for subsequent property prediction.
+-   Fast evaluation of correlation vectors and differences in correlation vectors
+    from local updates in order to quickly compute properties and changes in
+    properties for specified supercell sizes.
+
+-   Flexible toolset to sample cluster expansions using Monte Carlo with
+    canonical, semigrand canonical, and charge neutral semigrand canonical ensembles
+    using a Metropolis or a Wang-Landau sampler.
+
+-   Special quasi-random structure generation based on either correlation vectors or
+    cluster interaction vectors.
 
 **smol** is built on top of [pymatgen](https://pymatgen.org) so any pre/post
 structure analysis can be done seamlessly using the various functionality
 supported there.
 
 Installation
 ------------
-
 From pypi:
 
     pip install smol
 
 From source:
 
 `Clone` the repository. The latest tag in the `main` branch is the stable version of the
@@ -73,44 +77,39 @@
     pip install smol
 
 You can also simply use the *environment.yml* file in the repository to install `smol`:
 
     conda env create -f environment.yml
     source activate smol-env
 
-
 Usage
 -----
 Refer to the [documentation](https://cedergrouphub.github.io/smol/) for details on using
 **smol**. Going through the [example notebooks](https://github.com/CederGroupHub/smol/tree/main/docs/src/notebooks)
 will also help you get started. You can run the example notebooks interactively in
 [binder](https://mybinder.org/v2/gh/CederGroupHub/smol/HEAD?labpath=docs%2Fsrc%2Fnotebooks%2Findex.ipynb).
 
-
 Citing
 ------
 If you use **smol** in your research, please give the repo a star :star: and refer to
 the [citing](https://cedergrouphub.github.io/smol/citing.html) page in the documentation
 for formal citation information.
 
-
 Contributing
 ------------
 We welcome all your contributions with open arms! Please fork and pull request any contributions.
 See the
 [developing](https://cedergrouphub.github.io/smol/developer_guide/index.html)
 page in the documentation for how to contribute.
 
-
 Changes
 -------
 The most recent changes are detailed in the
 [change log](https://github.com/CederGroupHub/smol/blob/master/CHANGES.md).
 
-
 Copyright Notice
 ----------------
     Statistical Mechanics on Lattices (smol) Copyright (c) 2022, The Regents
     of the University of California, through Lawrence Berkeley National
     Laboratory (subject to receipt of any required approvals from the U.S.
     Dept. of Energy) and the University of California, Berkeley. All rights reserved.
```

### Comparing `smol-0.3.1/docs/Makefile` & `smol-0.4.0/docs/Makefile`

 * *Files identical despite different names*

### Comparing `smol-0.3.1/docs/make.bat` & `smol-0.4.0/docs/make.bat`

 * *Files identical despite different names*

### Comparing `smol-0.3.1/docs/src/_static/api.svg` & `smol-0.4.0/docs/src/_static/api.svg`

 * *Files identical despite different names*

### Comparing `smol-0.3.1/docs/src/_static/banner.svg` & `smol-0.4.0/docs/src/_static/banner.svg`

 * *Files identical despite different names*

### Comparing `smol-0.3.1/docs/src/_static/contribute.svg` & `smol-0.4.0/docs/src/_static/contribute.svg`

 * *Files identical despite different names*

### Comparing `smol-0.3.1/docs/src/_static/css/smol.css` & `smol-0.4.0/docs/src/_static/css/smol.css`

 * *Files identical despite different names*

### Comparing `smol-0.3.1/docs/src/_static/logo.png` & `smol-0.4.0/docs/src/_static/logo.png`

 * *Files identical despite different names*

### Comparing `smol-0.3.1/docs/src/_static/logo.svg` & `smol-0.4.0/docs/src/_static/logo.svg`

 * *Files identical despite different names*

### Comparing `smol-0.3.1/docs/src/_static/require.js` & `smol-0.4.0/docs/src/_static/require.js`

 * *Files identical despite different names*

### Comparing `smol-0.3.1/docs/src/_static/smol_cofe.svg` & `smol-0.4.0/docs/src/_static/smol_cofe.svg`

 * *Files identical despite different names*

### Comparing `smol-0.3.1/docs/src/_static/smol_moca.svg` & `smol-0.4.0/docs/src/_static/smol_moca.svg`

 * *Files identical despite different names*

### Comparing `smol-0.3.1/docs/src/_static/smol_workflow.svg` & `smol-0.4.0/docs/src/_static/smol_workflow.svg`

 * *Files identical despite different names*

### Comparing `smol-0.3.1/docs/src/_static/starting.svg` & `smol-0.4.0/docs/src/_static/starting.svg`

 * *Files identical despite different names*

### Comparing `smol-0.3.1/docs/src/_static/user.svg` & `smol-0.4.0/docs/src/_static/user.svg`

 * *Files identical despite different names*

### Comparing `smol-0.3.1/docs/src/api_reference/autogen/cofe.space.rst` & `smol-0.4.0/docs/src/api_reference/autogen/cofe.space.rst`

 * *Files identical despite different names*

### Comparing `smol-0.3.1/docs/src/api_reference/autogen/cofe.wrangling.rst` & `smol-0.4.0/docs/src/api_reference/autogen/cofe.wrangling.rst`

 * *Files identical despite different names*

### Comparing `smol-0.3.1/docs/src/api_reference/autogen/moca.ensemble.rst` & `smol-0.4.0/docs/src/api_reference/autogen/moca.sampler.rst`

 * *Files 20% similar despite different names*

```diff
@@ -1,37 +1,53 @@
-moca.ensemble package
-=====================
+moca.sampler package
+====================
 
 Submodules
 ----------
 
-moca.ensemble.base module
--------------------------
+moca.sampler.bias module
+------------------------
 
-.. automodule:: moca.ensemble.base
+.. automodule:: moca.sampler.bias
    :members:
    :undoc-members:
    :show-inheritance:
 
-moca.ensemble.canonical module
-------------------------------
+moca.sampler.container module
+-----------------------------
 
-.. automodule:: moca.ensemble.canonical
+.. automodule:: moca.sampler.container
    :members:
    :undoc-members:
    :show-inheritance:
 
-moca.ensemble.semigrand module
-------------------------------
+moca.sampler.kernel module
+--------------------------
 
-.. automodule:: moca.ensemble.semigrand
+.. automodule:: moca.sampler.kernel
+   :members:
+   :undoc-members:
+   :show-inheritance:
+
+moca.sampler.mcusher module
+---------------------------
+
+.. automodule:: moca.sampler.mcusher
+   :members:
+   :undoc-members:
+   :show-inheritance:
+
+moca.sampler.sampler module
+---------------------------
+
+.. automodule:: moca.sampler.sampler
    :members:
    :undoc-members:
    :show-inheritance:
 
 Module contents
 ---------------
 
-.. automodule:: moca.ensemble
+.. automodule:: moca.sampler
    :members:
    :undoc-members:
    :show-inheritance:
```

### Comparing `smol-0.3.1/docs/src/api_reference/autogen/moca.processor.rst` & `smol-0.4.0/docs/src/api_reference/autogen/moca.processor.rst`

 * *Files identical despite different names*

### Comparing `smol-0.3.1/docs/src/api_reference/cofe/clusterexpansion.rst` & `smol-0.4.0/docs/src/api_reference/cofe/clusterexpansion.rst`

 * *Files identical despite different names*

### Comparing `smol-0.3.1/docs/src/api_reference/cofe/clusterspace.rst` & `smol-0.4.0/docs/src/api_reference/cofe/clusterspace.rst`

 * *Files identical despite different names*

### Comparing `smol-0.3.1/docs/src/api_reference/cofe/extern.ewald.rst` & `smol-0.4.0/docs/src/api_reference/cofe/extern.ewald.rst`

 * *Files identical despite different names*

### Comparing `smol-0.3.1/docs/src/api_reference/moca/ensemble.rst` & `smol-0.4.0/docs/src/api_reference/moca/ensemble.rst`

 * *Files 24% similar despite different names*

```diff
@@ -10,10 +10,10 @@
 the system) should have ``chemical_potentials`` set to ``None`` and choose an
 appropriate step type (i.e. a swap).
 Systems at constant temperature and constant applied chemical potential
 (species flow allowed) should simple set the ``chemical_potentials``
 property.
 
 .. automodule:: smol.moca.ensemble
-   :members:
+   :members: Ensemble
    :undoc-members:
    :show-inheritance:
```

### Comparing `smol-0.3.1/docs/src/api_reference/moca/processors.rst` & `smol-0.4.0/docs/src/api_reference/moca/processors.rst`

 * *Files 6% similar despite different names*

```diff
@@ -21,11 +21,10 @@
 This class should generally be instantiated with
 :meth:`from_cluster_expansion`, which will automatically
 identify what type of processor is needed.
 
 .. toctree::
    :maxdepth: 2
 
-   processors.base
-   processors.composite
-   processors.ewald
    processors.expansion
+   processors.ewald
+   processors.composite
```

### Comparing `smol-0.3.1/docs/src/api_reference/moca/sampler.container.rst` & `smol-0.4.0/docs/src/api_reference/moca/sampler.container.rst`

 * *Files identical despite different names*

### Comparing `smol-0.3.1/docs/src/api_reference/moca/sampler.rst` & `smol-0.4.0/docs/src/api_reference/moca/sampler.rst`

 * *Files identical despite different names*

### Comparing `smol-0.3.1/docs/src/api_reference/moca/sampler.sampler.rst` & `smol-0.4.0/docs/src/api_reference/moca/sampler.sampler.rst`

 * *Files identical despite different names*

### Comparing `smol-0.3.1/docs/src/citing.rst` & `smol-0.4.0/docs/src/citing.rst`

 * *Files 12% similar despite different names*

```diff
@@ -72,14 +72,33 @@
     Barroso-Luque, L., Yang, J. H. & Ceder, G.
     `Sparse expansions of multicomponent oxide configuration energy using
     coherency and redundancy
     <https://link.aps.org/doi/10.1103/PhysRevB.104.224203>`_.
     Phys. Rev. B 104, 224203 (2021).
 
 
+Special quasi-random structures (SQS)
+=====================================
+
+When generating special quasi-random structures (SQS), please cite the original
+publication,
+
+    Zunger, A., Wei, S.-H., Ferreira, L. G. & Bernard, J. E.
+    `Special quasirandom structures. <https://doi.org/10.1103/PhysRevLett.65.353>`_
+    Phys. Rev. Lett. 65, 353356 (1990).
+
+If you use the :class:`StochasticSQSGenerator` class, please cite the following
+publication,
+
+    van de Walle, A. et al.
+    `Efficient stochastic generation of special quasirandom structures.
+    <https://doi.org/10.1016/j.calphad.2013.06.006>`_
+    Calphad 42, 1318 (2013).
+
+
 Coulomb electrostatic interactions
 ==================================
 When using an :class:`EwaldTerm` as an additional term in a lattice Hamiltonian, please
 cite the following publications,
 
     Seko, A. & Tanaka, I. `Cluster expansion of multicomponent ionic systems with
     controlled accuracy: importance of long-range interactions in heterovalent ionic
```

### Comparing `smol-0.3.1/docs/src/conf.py` & `smol-0.4.0/docs/src/conf.py`

 * *Files 2% similar despite different names*

```diff
@@ -35,24 +35,24 @@
 
 # Add any Sphinx extension module names here, as strings. They can be
 # extensions coming with Sphinx (named 'sphinx.ext.*') or your custom
 # ones.
 extensions = [
     "sphinx.ext.autodoc",
     "sphinx.ext.napoleon",
-    # "sphinx.ext.intersphinx",
+    "sphinx.ext.intersphinx",
     "sphinx.ext.mathjax",
     "sphinx.ext.autosummary",
     # "sphinx.ext.coverage",
     # "sphinx.ext.doctest",
     # "sphinx.ext.todo",
-    # "sphinx.ext.viewcode",
+    "sphinx.ext.viewcode",
     # "sphinx.ext.linkcode",
     "nbsphinx",
-    "nb2plots",
+    "sphinx_copybutton",
     "IPython.sphinxext.ipython_console_highlighting",
 ]
 
 # Generate the API documentation when building
 autosummary_generate = True
 add_module_names = False
 autoclass_content = "both"
@@ -111,15 +111,15 @@
     "navbar_end": ["version-switcher", "theme-switcher", "navbar-icon-links"],  #
     # "left_sidebar_end": ["custom-template.html", "sidebar-ethical-ads.html"],
     # "footer_items": ["copyright", "sphinx-version", ""]
     "switcher": {
         # "json_url": "/_static/switcher.json",
         "json_url": "https://pydata-sphinx-theme.readthedocs.io/en/latest/_static/"
         "switcher.json",
-        "url_template": "https://pydata-sphinx-theme.readthedocs.io/en/v{version}/",
+        # "url_template": "https://pydata-sphinx-theme.readthedocs.io/en/v{version}/",
         "version_match": version,
     },
     "external_links": [
         {
             "name": "Changes",
             "url": "https://github.com/CederGroupHub/smol/blob/master/CHANGES.md",
         },
```

### Comparing `smol-0.3.1/docs/src/developer_guide/design.rst` & `smol-0.4.0/docs/src/developer_guide/design.rst`

 * *Files identical despite different names*

### Comparing `smol-0.3.1/docs/src/developer_guide/guide.rst` & `smol-0.4.0/docs/src/developer_guide/guide.rst`

 * *Files 20% similar despite different names*

```diff
@@ -40,21 +40,59 @@
 * All code should pass the pre-commit hook. The code follows the `black code style <https://black.readthedocs.io/en/stable/>`_.
 * Additional dependencies should only be added when they are critical or if they are
   already a :mod:`pymatgen` dependency. More often than not it is best to avoid adding
   a new dependency by simply delegating to directly using the external packages rather
   than adding them to the source code.
 * Implementing new features should be more fun than tedious.
 
+Installing a development version
+--------------------------------
+
+#. *Clone* the main repository or *fork* it and *clone* clone your fork using git.
+   If you plan to contribute back to the project, then you should create a fork and
+   clone that::
+
+        git clone https://github.com/<USER>/smol.git
+
+   Where ``<USER>`` is your github username, or if you are cloning the main repository
+   directly then ``<USER> = CederGroupHub``.
+
+#. Install Python 3.8 or higher. We recommend using
+   `conda <https://docs.conda.io/en/latest/>`_.
+
+#. We recommend developing using a virtual environment. You can do so using
+   `conda <https://docs.conda.io/projects/conda/en/latest/user-guide/tasks/manage-environments.html>`_
+   or using `virtualenv <https://docs.python.org/3/tutorial/venv.html>`_.
+
+#. Install a C compiler with `OpenMP <https://en.wikipedia.org/wiki/OpenMP>`_ support.
+   You can find helpful instructions to do so for
+   `Linux <https://scikit-learn.org/dev/developers/advanced_installation.html#compiler-linux>`_,
+   `MacOS <https://scikit-learn.org/dev/developers/advanced_installation.html#compiler-macos>`_,
+   `Windows <https://scikit-learn.org/dev/developers/advanced_installation.html#compiler-windows>`_,
+   and `FreeBSD <https://scikit-learn.org/dev/developers/advanced_installation.html#compiler-freebsd>`_.
+   system in the
+   `scikit-learn's <https://scikit-learn.org/dev/index.html>`_ package documentation.
+   You can still install *smol* without OpenMP support for development, but you will
+   not benefit from parallelization when computing correlations and cluster
+   interactions.
+
+#. Install the development version of *smol* in *editable* mode::
+
+    pip install --verbose --editable .[dev,test]
+
+   This will install the package in *editable* mode, meaning that any changes
+   you make to the source code will be reflected in the installed package.
+
 Adding code contributions
 -------------------------
 
 #.  If you are contributing for the first time:
 
-    * *Fork* the repository and then *clone* your fork to your local workspace.
-    * Make sure to add the *upstream* repository as a remote::
+    * Install a development version of *smol* in *editable* mode as described above.
+    * Make sure to also add the *upstream* repository as a remote::
 
         git remote add upstream https://github.com/CederGroupHub/smol.git
 
     * You should always keep your ``main`` branch or any feature branch up to date
       with the upstream repository ``main`` branch. Be good about doing *fast forward*
       merges of the upstream ``main`` into your fork branches while developing.
```

### Comparing `smol-0.3.1/docs/src/getting_started.rst` & `smol-0.4.0/docs/src/getting_started.rst`

 * *Files 16% similar despite different names*

```diff
@@ -30,127 +30,137 @@
 Creating a cluster subspace
 ---------------------------
 Create a cluster subspace for a AuCu binary FCC alloy to define the cluster
 expansion terms and compute the corresponding correlation functions.
 
 Start by creating a disordered primitive structure.
 
-.. nbplot::
+.. code-block:: python
 
-    >>> from pymatgen.core.structure import Structure, Lattice
-    >>> species = {"Au": 0.5, "Cu": 0.5}
-    >>> prim = Structure.from_spacegroup("Fm-3m", Lattice.cubic(3.6), [species], [[0, 0, 0]])
+    from pymatgen.core.structure import Structure, Lattice
+
+    species = {"Au": 0.5, "Cu": 0.5}
+    prim = Structure.from_spacegroup("Fm-3m", Lattice.cubic(3.6), [species], [[0, 0, 0]])
 
 Now create a cluster subspace for that structure including pair, triplet and
 quadruplet clusters up to given cluster diameter cutoffs.
 
-.. nbplot::
+.. code-block:: python
+
+    from smol.cofe import ClusterSubspace
 
-    >>> from smol.cofe import ClusterSubspace
-    >>> cutoffs = {2: 6, 3: 5, 4: 4}
-    >>> subspace = ClusterSubspace.from_cutoffs(prim, cutoffs=cutoffs)
+    cutoffs = {2: 6, 3: 5, 4: 4}
+    subspace = ClusterSubspace.from_cutoffs(prim, cutoffs=cutoffs)
 
 Preparing training data
 -----------------------
 
 Load and use data computed for a training set of ordered structures to
 generate the necessary fitting data (formation energy and correlation vector
 for each training structure). Training data is added as instances of
 `ComputedStructureEntry <https://pymatgen.org/pymatgen.entries.computed_entries.html?highlight=computedstructureentry#pymatgen.entries.computed_entries.ComputedStructureEntry>`_
 
-.. nbplot::
+.. code-block:: python
+
+    from monty.serialization import loadfn
+    from smol.cofe import StructureWrangler
 
-    >>> from monty.serialization import loadfn
-    >>> from smol.cofe import StructureWrangler
-    >>> entries = loadfn("path_to_file.json")
-    >>> wrangler = StructureWrangler(subspace)
-    >>> for entry in entries:
-            wrangler.add_entry(entry)
+    entries = loadfn("path_to_file.json")
+    wrangler = StructureWrangler(subspace)
+    for entry in entries:
+        wrangler.add_entry(entry)
 
 Fitting and creating a cluster expansion
 ----------------------------------------
 
 Using the generated feature matrix and property vector fit a cluster expansion.
 In this case we use simple linear regression, although for most cases this will
 not be appropriate and a regularized regression model will yield a much better
 fit.
 
-.. nbplot::
+.. code-block:: python
 
-    >>> from sklearn.linear_model import LinearRegression
-    >>> reg = LinearRegression(fit_intercept=False)
-    >>> reg.fit(wrangler.feature_matrix, wrangler.get_property_vector("energy"))
+    from sklearn.linear_model import LinearRegression
+
+    reg = LinearRegression(fit_intercept=False)
+    reg.fit(wrangler.feature_matrix, wrangler.get_property_vector("energy"))
 
 Finally, create a cluster expansion for prediction of new structures and
 eventual Monte Carlo sampling. We recommend saving the details used to fit the
 expansion for future reproducibility (although this is not strictly necessary).
 
-.. nbplot::
+.. code-block:: python
+
+    from smol.cofe import ClusterExpansion, RegressionData
 
-    >>> from smol.cofe import ClusterExpansion, RegressionData
-    >>> reg_data = RegressionData.from_sklearn(
-            estimator=reg,
-            feature_matrix=wrangler.feature_matrix,
-            property_vector=wrangler.get_property_vector('energy')
-        )
-    >>> expansion = ClusterExpansion(subspace, coefficients=reg.coef_, regression_data=reg_data)
+    reg_data = RegressionData.from_sklearn(
+        estimator=reg,
+        feature_matrix=wrangler.feature_matrix,
+        property_vector=wrangler.get_property_vector("energy"),
+    )
+    expansion = ClusterExpansion(subspace, coefficients=reg.coef_, regression_data=reg_data)
 
 Creating an ensemble for Monte Carlo Sampling
 ---------------------------------------------
 
 Creating an ensemble only requires the cluster expansion and a supercell matrix
 to define the sampling domain.
 
-.. nbplot::
+.. code-block:: python
 
-    >>> from smol.moca import Ensemble
-    >>> sc_matrix = [[5, 0, 0], [0, 5, 0], [0, 0, 5]]
-    >>> ensemble = Ensemble.from_cluster_expansion(expansion, supercell_matrix=sc_matrix)
+    from smol.moca import Ensemble
+
+    sc_matrix = [[5, 0, 0], [0, 5, 0], [0, 0, 5]]
+    ensemble = Ensemble.from_cluster_expansion(expansion, supercell_matrix=sc_matrix)
 
 Running Monte Carlo sampling
 ----------------------------
 To generate MC samples for the ensemble, we need to create a sampler
 object.
 
-.. nbplot::
+.. code-block:: python
+
+    from smol.moca import Sampler
 
-    >>> from smol.moca import Sampler
-    >>> sampler = Sampler.from_ensemble(ensemble, temperature=1000)
+    sampler = Sampler.from_ensemble(ensemble, temperature=1000)
 
 In order to begin an MC simulation, an initial configuration must be provided.
 In this case we use pymatgen's functionality to provide an ordered structure
 given a disordered one.
 
-.. nbplot::
+.. code-block:: python
 
-    >>> from pymatgen.transformations.standard_transformations import OrderDisorderedStructureTransformation
-    >>> transformation = OrderDisorderedStructureTransformation()
-    >>> structure = expansion.cluster_subspace.structure.copy()
-    >>> structure.make_supercell(sc_matrix)
-    >>> structure = transformation.apply_transformation(structure)
+    from pymatgen.transformations.standard_transformations import (
+        OrderDisorderedStructureTransformation,
+    )
+
+    transformation = OrderDisorderedStructureTransformation()
+    structure = expansion.cluster_subspace.structure.copy()
+    structure.make_supercell(sc_matrix)
+    structure = transformation.apply_transformation(structure)
 
 Finally, the ordered structure can be used to generate an initial configuration
 to run MC sampling.
 
-.. nbplot::
+.. code-block:: python
 
-    >>> init_occu = ensemble.processor.occupancy_from_structure(structure)
-    >>> sampler.run(100000, initial_occupancy=init_occu)
+    init_occu = ensemble.processor.occupancy_from_structure(structure)
+    sampler.run(100000, initial_occupancy=init_occu)
 
 Saving the generated objects and data
 -------------------------------------
 To save the generated objects for the previous workflow we can simply use the
 provided convenience io functionality. However, all main classes are
 serializable just as pymatgen and so can be saved as json dictionaries or
 using the `monty <https://guide.materialsvirtuallab.org/monty//>`_ python
 package.
 
-.. nbplot::
+.. code-block:: python
 
-    >>> save_work("CuAu_ce_mc.json", wrangler, expansion, ensemble, sampler.samples)
+    save_work("CuAu_ce_mc.json", wrangler, expansion, ensemble, sampler.samples)
 
 
 .. code-links:: python
 .. code-links:: clear
 
 
 Example Notebooks
@@ -169,43 +179,51 @@
 
 - `Creating a basic cluster expansion`_
 - `Creating a cluster expansion with electrostatics`_
 - `Visualizing clusters`_
 - `Running canonical Monte Carlo`_
 - `Running semigrand canonical Monte Carlo`_
 - `Running charge neutral semigrand canonical Monte Carlo`_
-- `Wang-Landau sampling of an FCC Ising model`_
-- `Preparing cluster expansion training data`_
+- `Setting number of threads for OpenMP parallelization`_
+
 
 .. _Creating a basic cluster expansion: notebooks/creating-a-ce.ipynb
 
 .. _Creating a cluster expansion with electrostatics: notebooks/creating-a-ce-w-electrostatics.ipynb
 
 .. _Visualizing clusters: notebooks/cluster-visualization.ipynb
 
 .. _Running Canonical Monte Carlo: notebooks/running-canonical-mc.ipynb
 
 .. _Running Semigrand Canonical Monte Carlo: notebooks/running-semigrand-mc.ipynb
 
 .. _Running Charge Neutral Semigrand Canonical Monte Carlo: notebooks/running-charge-balanced-gcmc.ipynb
 
-.. _Wang-Landau sampling of an FCC Ising model: notebooks/wang-landau-ising.ipynb
+.. _Setting number of threads for OpenMP parallelization: notebooks/openmp-parallelism.ipynb
 
-.. _Preparing cluster expansion training data: notebooks/training-data-preparation.ipynb
 
 Advanced Examples
 -----------------
 
+- `Preparing cluster expansion training data`_
 - `Centering training data in stage-wise fit with electrostatics`_
 - `Adding structures to a StructureWrangler in parallel`_
 - `Simulated annealing with point electrostatics`_
+- `Wang-Landau sampling of an FCC Ising model`_
+- `Generating special quasirandom structures`_
 - `Li-Mn-O DRX cluster expansion and sampling`_
 
+.. _Preparing cluster expansion training data: notebooks/training-data-preparation.ipynb
+
 .. _Centering training data in stage-wise fit with electrostatics: notebooks/ce-fit-w-centering.ipynb
 
 .. _Adding structures to a StructureWrangler in parallel: notebooks/adding-structures-in-parallel.ipynb
 
 .. _Simulated annealing with point electrostatics: notebooks/running-ewald-sim_anneal.ipynb
 
+.. _Wang-Landau sampling of an FCC Ising model: notebooks/wang-landau-ising.ipynb
+
+.. _Generating special quasirandom structures: notebooks/generating-sqs.ipynb
+
 .. _Li-Mn-O DRX cluster expansion and sampling: notebooks/lmo-drx-ce-mc.ipynb
 
 More to come...
```

### Comparing `smol-0.3.1/docs/src/index.rst` & `smol-0.4.0/docs/src/index.rst`

 * *Files 4% similar despite different names*

```diff
@@ -61,14 +61,16 @@
 - Defining cluster expansions for subsequent property prediction.
 - Fast evaluation of correlation vectors and differences in correlation vectors
   from local updates in order to quickly compute properties and changes in
   properties for specified supercells.
 - Flexible toolset to sample cluster expansions using Monte Carlo with
   canonical, semigrand canonical, and charge neutral semigrand canonical ensembles
   using a Metropolis or a Wang-Landau sampler.
+- Special quasi-random structure generation based on either correlation vectors or
+  cluster interaction vectors.
 
 **smol** is built on top of `pymatgen <https://pymatgen.org/>`_ so any pre/post
 structure analysis can be done seamlessly using the various functionality
 supported there.
 
 Citing
 ======
```

### Comparing `smol-0.3.1/docs/src/notebooks/.ipynb_checkpoints/ce-fit-w-centering-checkpoint.ipynb` & `smol-0.4.0/docs/src/notebooks/ce-fit-w-centering.ipynb`

 * *Files 4% similar despite different names*

#### Pretty-printed

 * *Similarity: 0.9994149250664961%*

 * *Differences: {"'cells'": "{13: {'source': ['#### Determine the feature matrix column indices of Points and "*

 * *            "Ewald features']}, 14: {'outputs': {0: {'text': ['The point indices are [1, 2, 3, 4, "*

 * *            '5, 6], while the Ewald index is 386\\n\']}}, \'source\': {insert: [(2, "print(f\'The '*

 * *            'point indices are {point_inds}, while the Ewald index is {ewald_ind}\')\\n")], '*

 * *            "delete: [2]}}, 29: {'outputs': {0: {'data': {'text/plain': "*

 * *            "['<matplotlib.legend.Legend at 0x7f []*

```diff
@@ -1179,28 +1179,28 @@
             ]
         },
         {
             "cell_type": "markdown",
             "id": "59c60e16-b76b-4262-b5d6-ff2745005e32",
             "metadata": {},
             "source": [
-                "#### Determine the feature matrix column indeces of Points and Ewald features"
+                "#### Determine the feature matrix column indices of Points and Ewald features"
             ]
         },
         {
             "cell_type": "code",
             "execution_count": 9,
             "id": "0a6509aa-9dfc-408e-b5a8-d7afca5d9360",
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "The point indeces are [1, 2, 3, 4, 5, 6], while the Ewald index is 386\n"
+                        "The point indices are [1, 2, 3, 4, 5, 6], while the Ewald index is 386\n"
                     ]
                 },
                 {
                     "data": {
                         "text/plain": [
                             "array([  1,   2,   3,   4,   5,   6, 386])"
                         ]
@@ -1209,15 +1209,15 @@
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
             "source": [
                 "point_inds = sw.cluster_subspace.function_inds_by_size[1]\n",
                 "ewald_ind = sw.feature_matrix.shape[1] - 1\n",
-                "print(f'The point indeces are {point_inds}, while the Ewald index is {ewald_ind}')\n",
+                "print(f'The point indices are {point_inds}, while the Ewald index is {ewald_ind}')\n",
                 "initial_fit_cols = np.concatenate([point_inds, [ewald_ind]])\n",
                 "initial_fit_cols"
             ]
         },
         {
             "cell_type": "markdown",
             "id": "ed9587fb-9add-45b8-ad5b-90f83b73321a",
@@ -1471,24 +1471,24 @@
             "execution_count": 20,
             "id": "190d317e-c67d-4ee4-989d-fcb11441ce6c",
             "metadata": {},
             "outputs": [
                 {
                     "data": {
                         "text/plain": [
-                            "<matplotlib.legend.Legend at 0x7f91c8ce9bb0>"
+                            "<matplotlib.legend.Legend at 0x7f2fba2a44c0>"
                         ]
                     },
                     "execution_count": 20,
                     "metadata": {},
                     "output_type": "execute_result"
                 },
                 {
                     "data": {
-                        "image/png": "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\n",
+                        "image/png": "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\n",
                         "text/plain": [
                             "<Figure size 432x288 with 1 Axes>"
                         ]
                     },
                     "metadata": {
                         "needs_background": "light"
                     },
@@ -1532,15 +1532,15 @@
             "id": "546a18ee-f16d-4079-883d-f10c8f0dda3e",
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "The optimal hyperparameter is 5.4555947811685143e-05\n"
+                        "The optimal hyperparameter is 3.5564803062231285e-06\n"
                     ]
                 }
             ],
             "source": [
                 "opt_alpha = alpha_scan[sorted_mean_cvs[0][0]]\n",
                 "print(f'The optimal hyperparameter is {opt_alpha}')"
             ]
@@ -1605,18 +1605,18 @@
             "id": "86234fa6-02b2-487a-9ac4-4d9662bc7d7a",
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "Out-of-sample RMSE is: 0.019308613402414722 eV/prim\n",
-                        "In-sample RMSE is: 0.019432700410810556 eV/prim\n",
-                        "Number of Features > 1E-5: 50/387\n",
-                        "Point correlation coeficients: [-23.11136312  -6.80864145   9.17087773   1.23408451   4.73489259\n",
+                        "Out-of-sample RMSE is: 0.010216714533226853 eV/prim\n",
+                        "In-sample RMSE is: 0.014394358793882608 eV/prim\n",
+                        "Number of Features > 1E-5: 76/387\n",
+                        "Point correlation coefficients: [-23.11136312  -6.80864145   9.17087773   1.23408451   4.73489259\n",
                         "  -3.1117202   -0.46576228]\n"
                     ]
                 },
                 {
                     "data": {
                         "text/plain": [
                             "Text(0, 0.5, 'Magnitude |$w_i$| eV/prim')"
@@ -1624,15 +1624,15 @@
                     },
                     "execution_count": 26,
                     "metadata": {},
                     "output_type": "execute_result"
                 },
                 {
                     "data": {
-                        "image/png": "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\n",
+                        "image/png": "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\n",
                         "text/plain": [
                             "<Figure size 432x288 with 1 Axes>"
                         ]
                     },
                     "metadata": {
                         "needs_background": "light"
                     },
@@ -1653,15 +1653,15 @@
                 "y_predict = np.dot(X_test, all_coefs)\n",
                 "y_train_predict = np.dot(X_train, all_coefs)\n",
                 "print(f'Out-of-sample RMSE is: {mean_squared_error(y_test, y_predict, squared=False)} eV/prim')\n",
                 "print(f'In-sample RMSE is: {mean_squared_error(y_train, y_train_predict, squared=False)} eV/prim')\n",
                 "print(f'Number of Features > 1E-5: {sum(np.abs(all_coefs) > 1E-5)}/{len(all_coefs)}')\n",
                 "\n",
                 "first_pair = sw.cluster_subspace.orbits_by_size[2][0].bit_id\n",
-                "print(f'Point correlation coeficients: {all_coefs[:first_pair]}')\n",
+                "print(f'Point correlation coefficients: {all_coefs[:first_pair]}')\n",
                 "# plot the coefficients (excluding those for points))\n",
                 "plt.stem(range(len(all_coefs) - first_pair), all_coefs[first_pair:],\n",
                 "         linefmt='-', markerfmt=' ')#, basefmt=' ')\n",
                 "plt.xlabel('Coefficient index (i in $w_i$)')\n",
                 "plt.ylabel('Magnitude |$w_i$| eV/prim')"
             ]
         },
@@ -1713,15 +1713,15 @@
                     },
                     "execution_count": 28,
                     "metadata": {},
                     "output_type": "execute_result"
                 },
                 {
                     "data": {
-                        "image/png": "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\n",
+                        "image/png": "iVBORw0KGgoAAAANSUhEUgAAAZcAAAENCAYAAADDmygoAAAAOXRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjUuMiwgaHR0cHM6Ly9tYXRwbG90bGliLm9yZy8qNh9FAAAACXBIWXMAAAsTAAALEwEAmpwYAAAnP0lEQVR4nO3de7wcdX3/8df7nJPLIRdCTEQ4AgkICQSE1Ai1gBekRGmtKZGLWG3rz4IgttSaFn7VGlELNv60PwpYsChoAEENoYBt+GFAKgJ6IFyMJMgtwAnICbmY+/Xz+2Nmw57N7rnO7s6e834+HvNIdmZ29rOT7Hzme5nvVxGBmZlZlprqHYCZmQ0+Ti5mZpY5JxczM8uck4uZmWXOycXMzDLXUu8AamHChAkxadKkPr/v2c6NABw8cVTGEQ1dPqdmjePhhx9eFRET+/PeIZFcJk2aRHt7e5/fd+bVDwBw87nvyDqkIcvn1KxxSFrR3/e6WszMzDLn5GJmZpnLZXKRNEnSjyWtkfSKpCsktaTbjpH0sKRN6Z/H1DlcMzMrkcvkAlwFvArsBxwDvAs4X9Jw4DZgPrAPcD1wW7rezMxyIq/JZTJwS0RsiYhXgP8GpgHvJumE8K8RsTUiLgcEnFS3SM3MbA95TS7/CpwlaS9JbcD7eT3BPB5dR9t8PF3fhaRzJLVLau/s7KxFzFWxcEkHx1+2mMkX3cnxly1m4ZKOeodkZtajvCaX+0gSxu+Al4B2YCEwGlhXsu86YEzpASLimoiYEREzJk7sVzftulu4pIOLFzxBx9rNBNCxdjMXL3jCCcbMci93yUVSE0kpZQEwCphA0r7yVWADMLbkLWOB9bWMsVbmLVrO5u07u6zbvH0n8xYtr1NEZma9k7vkAowHDgSuSNtVXgO+A5wKLAXeKklF+781XT/orFy7uU/rzczyInfJJSJWAc8B50lqkTQO+HOStpV7gZ3AX0saIemC9G2L6xFrte0/rrVP683M8iJ3ySV1GvA+oBN4GtgO/G1EbANmAR8D1gIfB2al6wedOTOn0Dqsucu61mHNzJk5pU4RmZn1Ti7HFouIR0m6HZfbtgR4Wy3jqZdZ09sA+PsfPs62nbtoG9fKnJlTdq83M8urXCYXe92s6W3c9IsXAA/2aGaNI6/VYmZm1sCcXMzMLHNOLmZmljknFzMzy5yTi5mZZc7JxczMMufkYmZmmXNyMTOzzDm5mJlZ5pxczMwsc04uZmaWOScXMzPLnJOLmZllzsnFzMwy5+RiZmaZc3IxM7PMObmYmVnmnFzMzCxzTi5mZpY5JxczM8uck4uZmWUut8lF0lmSnpS0UdIzkk5M179X0jJJmyTdI+mgesdqZmZd5TK5SPpD4KvAXwJjgHcCz0qaACwAPg+MB9qBm+sVp5mZlddS7wAq+CJwSUQ8mL7uAJB0DrA0In6Qvp4LrJI0NSKW1SVSMzPbQ+5KLpKagRnARElPS3pJ0hWSWoFpwGOFfSNiI/BMur70OOdIapfU3tnZWavwzcyMHCYXYF9gGPAh4ETgGGA68DlgNLCuZP91JFVnXUTENRExIyJmTJw4saoBm5lZV3lMLpvTP/8tIl6OiFXA14FTgQ3A2JL9xwLraxifmZn1IHfJJSLWAC8BUbw6/XMpcHRhpaRRwCHpejMzy4ncJZfUd4BPS3qjpH2AvwXuAG4FjpQ0W9JI4J+Ax92Yb2aWL3lNLl8Cfgk8BTwJLAG+EhGdwGzgK8Aa4DjgrHoFaWZm5eWyK3JEbAfOT5fSbXcDU2selJmZ9VpeSy5mZtbAnFzMzCxzTi5mZpY5JxczM8uck4uZmWXOycXMzDLn5GJmZplzcjEzs8w5uZiZWeacXMzMLHNOLmZmljknFzMzy5yTi5mZZc7JxczMMufkYmZmmXNyMTOzzDm5mJlZ5pxczMwsc04uZmaWOScXMzPLnJOLmZllLtfJRdKhkrZIml+07mxJKyRtlLRQ0vh6xmhmZnvKdXIBrgR+WXghaRpwNfBRYF9gE3BVfUIzM7NKWuodQCWSzgLWAj8H3pKu/ghwe0Tcl+7zeeBJSWMiYn1dAjUzsz3ksuQiaSxwCfCZkk3TgMcKLyLiGWAbcFiZY5wjqV1Se2dnZzXDNTOzErlMLsCXgGsj4qWS9aOBdSXr1gFjSg8QEddExIyImDFx4sQqhWlmZuXkrlpM0jHAycD0Mps3AGNL1o0FXCVmZpYjuUsuwLuBScALkiAprTRLOgL4b+Dowo6SDgZGAE/VPEozM6soj8nlGuD7Ra8/S5JszgPeCDwg6UTgEZJ2mQVuzDczy5fcJZeI2ETSxRgASRuALRHRCXRK+iRwA/AG4G7gL+sSaBUsXNLBvEXLWbl2M/uPa2XOzCnMmt5W77DMzPosd8mlVETMLXl9I3BjfaKpnoVLOrh4wRNs3r4TgI61m7l4wRN1jsrMrH96lVwkNZG0hbyLpIqqFegkqZq6KyJerFJ8Q8a8Rct3J5aCzdt3Mm/Rct68T2udompcLgWa1Ve3XZEltUr6R+BF4E7gFJIG9m3AZOALwHOSfizp96sd7GC2cu3mPq23ygqlwI61mwleLwUuXNJR79DMhoyennP5DXAMcA4wNiLeERGzI+LPIuLUiDgQOAT4H+BmSX9V3XAHr/3HlS+dVFpvlXVXCjSz2ugpubwvIk6PiDsjYnu5HSJiRURcChwK3Jt1gEPFnJlTaB3W3GVd67Bm5sycUqeIGpdLgWb1121yiYhfSXpLd/sU7bstIn6TTVhDz6zpbVx62lEMb07+SdrGtXLpaUe5naAfXAo0q7/eNOg/Jek+4FvAjyJiS5VjGrJmTW/jpl+8AMDN576jztHUXlaN8HNmTunS8w5cCjSrtd6MLfZHJD3Dvg2slHSFpHJDs5j1W5aN8C4FmtVfj8klIv4rIk4H2oAvk3RHbpf0iKTzJO1d7SBt8Mu6EX7W9DamHziO4yaP5/6LTnJiMauxXo+KHBGrIuLrEXEU8AdAO3AZSWnmu9UK0IYGN8KbDS79GnI/Ih4CziXporyFZBIvs35zI7zZ4NLn5CLpLZL+meTByvnAg8CHsg7MhhZ3xTYbXHo7/EsrcAbwceAE4Hng34HvRIQfe7YBK7SJ/P0PH2fbzl20ecgWs4bWY3KR9C2SxDIcWAicEhE/qXJc1o3BOm7WUO+KbTaY9KbkcizweeB7EbGmyvFYD7obPXkwJBgzGxx60xX56Ii4vDixSNo3HSnZaszjZplZI+h1gpA0TNK/SFoPdJAMvY+kr0o6v0rxWQl32TWzRtCX0scXgA8AfwZsLVr/C+AvMozJuuEuu2bWCPqSXD4MfDIibgN2Fa3/FXBYplFZRe6ya2aNoC/THO8PrKhwjNxPlzxYuMuumTWCviSFpcA7SZ5xKXYG8HBWAVnP3GXXzPKuL8nli8B8SQcAzcDpkqYCZ5OMnGxmZgb0beDK20lKKaeQtLl8gWT2yQ9ExN3VCc/MzBpRn55ViYhFEfGuiBgdEXtFxAkRcVeWAUkaIelaSSskrZf0qKT3F21/r6RlkjZJukfSQVl+vpmZDVy/HoSUNFLSXsVLhjG1kAyK+S5gb+BzwC2SJkmaACwgGTFgPMmw/zdn+NlmZpaBXre5pCWEy4H3AKPK7NJcZl2fRcRGYG7RqjskPQe8DXgDsDQifpDGNBdYJWlqRCzL4vPNzGzg+tKgPx8YCXwa+C0QVYmohKR9SZ6jWQqcBzxW2BYRGyU9A0wDlpW87xyS+WY48MADaxGqWU0M1oFLbXDpS3KZDrw9Ip6sVjClJA0DbgCuj4hlkkYDnSW7rQPGlL43Iq4BrgGYMWNGTRKhWbV54FJrFH1pc3kMmFitQEqlA2N+D9gGXJCu3gCMLdl1LLC+VnGZ1ZMHLrVG0ZeSyznA5ZIuJxnyZXvxxoh4IaugJAm4FtgXODUiCp+1FPjzov1GAYek6y2HSqtwRg5rYsLoEfUOq2F54FJrFH1JLk0kF/tb6dreovR1Jg36qW8ChwMnR0Txr+ZWYJ6k2cCdwD8Bj7sxPx9KE8l7pk7kRw93dKnCAVi/ZUfFY6xav5UX12xm8kV3uj2hjP3Hte4+j6XrzfKkL9Vi1wOvkoyMfBzJJGLHAm9P/8xE2ivtXOAY4BVJG9LlIxHRCcwGvgKsSeM4K6vPtv4rtAV0rN1MkCSSGx58YY8qHIBX129l4ZI9Z8deuKSD517byLadu3Yf4+IFT5Tdd6jywKXWKPpScpkKHBMRT1UrGICIWEFSGqq0/e40FhuArHsclWsL6K4XxbxFy/f4vHmLlrOr5E2F9gSXXhIeuNQaRV+Syy+AyUBVk4tVXzV6HPW1zr/c/m5P6B0PXGqNoC/VYt8E/lXSJyQdJ+n3ipdqBWjZq0aPo77W+Zfb3xOhmQ0efUkuNwFTSJ4deYBk6JXC8svsQ7NqqUYJoVJbwPGHjC+7/3um7tmrfc7MKTSVVIi6PcGsMfUluUzuZjk4+9CsWqpRQpg1vY1LTzuK4c3Jf6m2ca1cetpR3PBX7+CNo4fvsf+PHu7Yo6F+1vQ2Jr9h1O4Gt8Ix3J5g1nh63eaSNrTbIDBn5pQubS6QTQmhUlvA2s17dj2u1FA/YcwIXt2wlSP2G+v2BLMG1m3JRdIJvT2QpNGSjhp4SFZtlUoZ1SohbNu5q+x6N9SbDV49VYv9h6SfSPqwpNJhVwCQ9FZJ/wI8DRydeYRWFbOmtzH9wHEcN3k89190UlWrngpJrJQb6s0Gr56qxY4keaDxC8D30hGIVwJbgH1IGvhHksyxclJE/LqKsVqRRnqS/YB9Wnlm1cYu69xQbza4dZtcImIHcCVwpaQZwAnAQUAr8DAwD7gnIlZXO1B7XeFJ9sIDh3kfGXfCmBG8tHYT23YEQVKScUP94OUpAQz61qBf6HZsdVbpSfa5/7m0xx9x8Q9/WHMTB+xTm6qp4S3NDE//tx2x31hfbAYpTwlgBf2a5tjqq1JD+NrN27sdh6t0/K9tO3fxzKqNfG7hE1WK1IYaTwlgBX0Z/sVyotLIuFB+zK7ibeUGkrzhwReYcdB431nmVLlqprzyED5W4JJLA+ru4tLdj7jStoCq3lmuWr+VDVt2sH7LDjZs2cGqDVur9lnVsnBJB8dftpjJF93J8Zct7vVIzf19X/H7S0ebvnjBE6xan89z6CF8rMDJpQHNmt5GS+k4KanufsTdbavWnWWh80GhiSiA51ZtbKhh9Ctd4Hv6Dv19X7FK1UwvrslnScBTAliBk0uDOmj8Xnus6+lHPGfmlIpzGVTrzrJc54NdUd2SUtb6246QRftDpaRf6cHUeqv1A7qWXz22ufR2xOOIeGTg4VhvlXbv7c28HrOmt9G+YjXzH+w6I3U17ywHQx18f79DFt+9UvtapQdT88BTAhj0rkG/naQ2o+IEXmQ/zbH1QqF7b1/G4fryrKN44OnXeHbVxpo8czIYpuXtzXco1+iexXevNA7c/nuP7OO3MKut3tz+FEY99qjIg8SEMSMYPbKFMSNbmH7guKpWWZQbRr9J3XdKyIPihviNW3cwrLnrlygu7VVqW3nP1IkDbn+oVM00YcyIgX1BsyrrMblExIreLLUI1hpPYRj9AgGTJ4zKdR18abJYu3k7BLs7UZS2I1RqW7lnWWcm7Q+1HAfOLCs9JhdJR0q6vdzAlZL2TrcdXp3wbDCYMGYEzYJmweiRLUwYne+77nLJYvuuoEkqe4Gv1IbSsXYz8xYtZ9vOXQxvbqrKMCgD7epsVi29aXP5O+DxiPhd6YaIWCdpCTAH+HjWwZlB7ceq6msPrUptK4Ld67ft3JX5MCir1m/1UCuWW71pczke+FE3228FTswmHLOusnhWpK8qNbhX6qFV7tkOASU9sDMfBuXFNZs91EqDGUolTUWU/gRKdpC2AFMqtatIOghYFhE16/4jaTxwLXAKsAq4OCJurLT/jBkzor2972NuHvuVu3k1J09CtzSJr51+NO0rVnPTQy+ys4d/t94Y0SLePG4vXtu4LWlXAPYa1sT2nbvYPoDHKJoEXz/jmN13z2de/QDtz69mV+x5wbX+KZe8hrJmwU6fkIr22WsYX/jAtD6XaCU9HBEz+vOZvakWWwMcAlRqtD8UWNufDx+AK4FtwL7AMcCdkh6LiKVZfcDnFj6Rm8QCsGNXcOHNj2Z6zK07Yo95VjYNJKukdgX83Q8eo33Fau5Z1llxHDTrP19Hu3Ji6d6aTduZ88PHgNpVmfYmufwUuBBYXGH7hcB9GcXTI0mjgNnAkRGxAfiZpP8EPgpclNXn3PTQiwDst2EVFy65JavDDi0/hdJ5r68+6oMAnPvEbbWPx2wIenbvNq5+6wfZvjO6Hdg2a71pc7kMOEXSrZKOS3uI7S3p9yUtBE5O96mVw4AdEfFU0brHgGnFO0k6R1K7pPbOzs4+f0gW1U5mZnlSy5Exeiy5RMSjkj4EfBv4ecnm14AzImJJNYKrYDRQ2nNtHTCmeEVEXANcA0mbS18/pFliZwQvj57AP5x4fn9jtQp8Ts1qr5YjY/RqPpeIuCNtuH8f8BaS9sSngLsiYlMV4ytnA1D6zM1YYH2WH/Lh4w7YYwwuM7NGNaxZNR0Zoy/THG8m6XZcb08BLZIOjYjfpOuOBjJrzIdkDK67lv42V436I1rEjp2xu/GyWeLgiXvx9KsbG6aBt0nsMUpyOe79Y5ad/vYWG4jejIr8c+DUiFibvr4UmBcRq9PXE4BHIuLAagZaEBEbJS0ALpH0CZLeYh8E/iDrz5o8YRSTJ4yq+8iuZ179AL9++Xds27Fz94W5N6Mgd3e8Veu3snLdlj2ekxjRIo45YJ8BfefD/vG/yj5wOK51GFPelNRe1vucljr+ssVle7W1jWvl/otOKvue0vniK+nuGKXOvPoBIDk/lWLqi758dn8Ux1vQl4dei99f7liVTL7ozoo3VM9f9kddXg/0IdwsHuLtz/+v3urLeaul3pRcfh8YXvT6U8C3gNXp62ag1o8Dn0/SBvQqSbvPeVl2Q86jbTt2snXH6z+ngT6NPWHMCD793kN3/2ia0pLC1h3BQ8+tZvold/X7TueAfVr36OLcOqyZuX8ybfdQ7HlTafTh7qoRKk0bXWwg0xmUi6kv6jVJ16zpbVW/Q640KkJbmTaFgcaTxffpz/+vRtefSSG6G3q/JiJidUTMiohREXFgdw9QDhbbdux5nzbQp7FnTW/j/otO4htnHrNHFVShX3x/niCeMGYEgt1LI0wYVRh9uG1ca69j7q7nTRbfuzSmnn54w5rEPnsNa5hzPhCNNuNlf/5/Nbpet7lYfVWqAsiia2GlBDWQfvFNgr1GtPDE3JkDDa9m+nqH2t3dc1ZVUcUxLVzSwZwfPMb2Mo1WA6kmbUTFI1LXasy5gapFiS5PepNcgj2vbW5qrbFKw31k0bWwuwTVSDNG1lqtqzoa8YLanYVLOljywlq27dzF8ZctZmRLU5/mqRlqF+tG05vkImC+pEK3qZHAtyQVuiDne/z0QWJ4i7q0uUB2F7JKd+CFbVZe4cI29z+X7h6bbeSw6k4/PFguqIXOEIWOHx1pu58NHr35JVwPrCRpOH8NmA+8WPR6JfDdagVoieEtzYxoEcObmzKvs62UoGrdL75Rbd3xes+4NZu2V33U5sGgXGeIXZGM9GyDQ2+e0P/LWgRiPRve0swR+43NvMvhrOlt/NtPfsPzr23c3bBfj37xjajSLJS1HMOpEfV1zhxrPG7QNyDp4TVhzIgBJ66FSzpof341OwPWb9kxoC7NjaDSRdJtVd2rVBVbac4cazz+l7TMFHozFXdrHkiX5kZQqU3KbVXdK9eVuEnJM1I2ODi5WGbmLVpetptsoUvzYNRoz1vkRbnnPia/YVSfeotZvrlazDIzFLs0Z9k9uLRrbiN3M+6N0p5vhWFMbHBwcrHMDNUuzVl0Dy7XNXcgw/uY1ZurxSwzc2ZOYViZhxXcpbln3fU6M2tETi6WmVnT25h3+tG0Fj1I2CQ48+0H+O67B+51ZoONk4tVweull10BP3q4Y9D2FsuKe53ZYOPkYply9U7/uNeZ9UehE8hDz63m+MsW5+omzg36lilX7/TPYBuU0qov751AnFwsU5V6jLl6p2eNNijlUOs6nTd5H3rI1WKWKVfvDA2V7przVC0z2OW9lsDJxTKttx2KM+4NRW5bq7+8dwJxtdgQV41620ar3rG+y/td81BQ68nq+sollyHOd6DWH3m/ax4K8l5L4JLLEOc7UOuPvN81DxV5riVwyWWI8x2o9Ufe75qt/nJTcpE0ArgKOBkYDzwDXBwR/1W0z3uBK4EDgYeAv4iIFXUId9DwHaj1V57vmq3+8lRyaQFeBN4F7A18DrhF0iQASROABcDnSZJPO3BzXSJtYKU9wwDfgZpZ5nJTcomIjcDcolV3SHoOeBvwPHAasDQifgAgaS6wStLUiFhW22gbU6WeYZeedhT3X3RSnaMzs8EkTyWXLiTtCxwGLE1XTQMeK2xPk9Ez6fpy7z9HUruk9s7OzmqH2xDcM8zMaiWXyUXSMOAG4PqiUsloYF3JruuAMeWOERHXRMSMiJgxceLE6gXbQNwzzMxqpWbJRdK9kqLC8rOi/ZqA7wHbgAuKDrEBGFty2LHA+qoHX0eFNpL1W3awYcsOVq3f2u9juWeYmdVKzZJLRLw7IlRhOQFAkoBrgX2B2RGxvegQS4GjCy8kjQIO4fVqs0GntI0kgOde29jv4Vk87pflVZ6Hjrf+yVu12DeBw4EPRERpXc2twJGSZksaCfwT8Phgbswv10ayK+h3G4mfTbA88iCYg1NueotJOgg4F9gKvJIUYgA4NyJuiIhOSbOBK4D5JM+5nFWXYGukGm0kfjbB8ibvQ8db/+QmuaQPQ6qHfe4GptYmovrz3Cg2FLijyeCUt2oxK1KujaRJuI3EBhV3NBmcnFxyrLiNBJJi3eQ3jHJVgQ0q7mgyODm55Nys6W3cf9FJHDd5PKNHtjBhzIh6h2SWKXc0GZxy0+ZiZkOXO5oMPi65mJlZ5pxczMwsc04uZmaWOScXMzPLnJOLmZllzsnFzMwy5+RiZmaZc3IxM7PMObmYmVnmnFzMzCxzTi5mZpY5JxczM8uck4uZmWXOycXMzDLn5GJmZplzcjEzs8w5uZiZWeacXMzMLHO5TS6SDpW0RdL8kvVnS1ohaaOkhZLG1ytGMzMrL7fJBbgS+GXxCknTgKuBjwL7ApuAq2ofmpmZdael3gGUI+ksYC3wc+AtRZs+AtweEfel+30eeFLSmIhYX/NAzcysrNyVXCSNBS4BPlNm8zTgscKLiHgG2AYcVuY450hql9Te2dlZrXDNzKyM3CUX4EvAtRHxUplto4F1JevWAWNKd4yIayJiRkTMmDhxYhXCNDOzSmqaXCTdKykqLD+TdAxwMvCNCofYAIwtWTcWcJWYmVmO1LTNJSLe3d12SRcCk4AXJEFSUmmWdERE/B6wFDi6aP+DgRHAU9WJ2MzM+iNvDfrXAN8vev1ZkmRzXvr6BuABSScCj5C0zSxwY76ZWb7kqs0lIjZFxCuFhaQabEtEdKbblwKfJEkyr5K0tZxft4BraNX6rWzYsoOHnlvN8ZctZuGSjnqHZGZWUd5KLl1ExNwy624Ebqx9NPWzcEkHz722kUhfd6zdzMULngBg1vS2+gVmZlZBrkouVt4Xb1/Krui6bvP2ncxbtLw+AZmZ9cDJJecWLulgzabtZbetXLu5xtGYmfWOk0vOdVc62X9caw0jMTPrPSeXnOuudDJn5pQaRmJm1ntOLjlXqXQyrnWYG/PNLLecXHJuzswptA5r7rKudVgzc/9kWp0iMjPrWa67ItvrXY3nLVrOyrWb2X9cK3NmTnGpxcxyzcmlAcya3uZkYmYNxdViZmaWOScXMzPLnJOLmZllzsnFzMwy5+RiZmaZU0T0vFeDk9QJrOjFrhOAVVUOZyAc38DlPUbHNzB5jw/yH2NxfAdFRL/miR8SyaW3JLVHxIx6x1GJ4xu4vMfo+AYm7/FB/mPMKj5Xi5mZWeacXMzMLHNOLl1dU+8AeuD4Bi7vMTq+gcl7fJD/GDOJz20uZmaWOZdczMwsc04uZmaWOScXMzPLnJMLIGm8pFslbZS0QtLZOYjpXklbJG1Il+VF285O49woaaGk8VWO5QJJ7ZK2SrquZNt7JS2TtEnSPZIOKto2QtK3Jf1O0iuSPlPrGCVNkhRF53GDpM/XOsb0c65N/93WS3pU0vuLttf1PHYXX47O4XxJL6ef85SkTxRtq/v/w0rx5eX8FX3eoem1ZX7RuorXlH5fHyNiyC/ATcDNwGjgBGAdMK3OMd0LfKLM+mnAeuCdabw3At+vciynAbOAbwLXFa2fkJ6r04GRwDzgwaLtlwL/A+wDHA68AryvxjFOAgJoqfC+msQIjALmpvE0AX+c/jtOysN57CG+vJzDacCI9O9T0895Wx7OXw/x5eL8FX3eXennzS+Ku+I1hX5eH6sSfCMt6Y9qG3BY0brvAZfVOa57KZ9c/hm4sej1IWn8Y2oQ05fpeuE+B/h5ybncDExNX68ETina/iWqnwhLY+zph13zGIs+63Fgdh7PY0l8uTuHwBTgZeCMPJ6/kvhyc/6As4BbSG4kCsml4jVlINdHV4vBYcCOiHiqaN1jJNm83i6VtErS/ZLena6bRhIfABHxDOk/fu3D2yOWjcAzwDRJ+wD7FW+nvud1haSXJH1H0gSAesYoaV+Sf7Ol5PA8lsRXUPdzKOkqSZuAZSQX7x+To/NXIb6Cup4/SWOBS4DSarfurin9vj46uSRFvd+VrFtHkrXr6R+Ag4E2koeabpd0CEm860r2rVe83cUyuuh16bZaWgW8HTiIpIpiDHBDuq0uMUoalsZwfUQsI2fnsUx8uTmHEXF+euwTgQXAVnJ0/irEl5fz9yXg2oh4qWR9T+evX9dHJxfYAIwtWTeWpA6ybiLioYhYHxFbI+J64H7gVPIVb3exbCh6XbqtZiJiQ0S0R8SOiPgtcAFwiqQx9YhRUhNJtcK2NBbI0XksF1/ezmFE7IyInwFvBs4jR+evXHx5OH+SjgFOBr5RZnNP569f1xsnF3gKaJF0aNG6o+laHZAHAYgkrqMLKyUdDIwg+R61VhrLKJL62qURsYakWuDoov3zcF4LQ1I01TpGSQKuBfYFZkfE9nRTLs5jN/GVqts5LNFCep7IwfnrJr5S9Th/7yZp+3lB0ivAZ4HZkh6h+2tK/6+P1WzUapQF+D5Jj4hRwPHUubcYMA6YSdLzpQX4CLCRpP5zGkkx9cQ03vlUv3GyJY3lUpK72kJcE9NzNTtd91W69tK5DPgpSS+YqSQ/omr1FqsU43EkjatNwBtIer3cU6cY/x14EBhdsj4X57Gb+Op+DoE3kjRGjwaa09/HRuBP8nD+eogvD+dvL+BNRcvXgB+m567bawr9vD5m/gNqxAUYDyxM/zO8AJxd53gmAr8kKXquTX/wf1i0/ew0zo3AbcD4Ksczl+Ruq3iZm247maTxcjNJD7dJRe8bAXw7/Y/7W+AztY4R+DDwXHquXga+C7yp1jGS1LcHsIWkqqGwfCQP57G7+PJwDtPfxE/T38PvgCeAvyraXu/zVzG+PJy/Cr+X+UWvK15T6Of10QNXmplZ5tzmYmZmmXNyMTOzzDm5mJlZ5pxczMwsc04uZmaWOScXMzPLnJOLGSBpL0k/lLQunXtjUoV190q6opfHLMzjMaPa8Vf4/Osk3ZHBcX4laW4GIdkQ0lLvAMy6k47O+79J5hd5M8kggI8D/xYRP+7uvX30cZL5LE4AOtPlvDLrTgMqDYtS6kWSEW9XZRgnku4FfhURF/Sw69+QDBlkVnNOLpZbkiaRDNi5HriYZKjvJuC9JEOVHJjhx70FeDIinij6/D3WAat7e8CI2Eky8VNdRETpSLdmNeNqMcuzq9I/Z0TELRGxPCKejIgrgLcWdpJ0YDoN6/p0WSDpzcUHkvQBSQ+n07s+J+krkoan2+4luct/Z1qNdW+5dYV9i6vFJA2X9M/p9K9bJT0r6a/TbXtUi0k6QtKdaZyvSrpJ0puKtl8n6Q5JfyOpQ9KadP6PvQrbgXcBn0qPHWkS3kNptVga+1VpvKvSz/9aOhJyYZ83SrpN0ub0O328zHH3lnRN+v71kn5a+I6SRqbVaN8p2n//9PPmlIvTBicnF8slJXN4vw+4MiI2lG6PiLXpfk0kYyHtC7wnXfYHFqaj/CJpJsn8GVeQDNL3ceBDJDPwQVLV9R3gAZJqrNMqrCvneuBjJBMwHQ78L5Lxpcp9p/2A+4BfAceSjIc1Grit+AJPMoDgken2M4E/JUl0pH8+kMa2X7q8WCG2cj4C7AD+gGTo9wvTzyi4jqQUdzLJtNEfIxlNt/AdBNxJMs/QHwPT0++0WNJ+EbGFZJyqD0s6Pd3/uySlzq/1IU5rdNUeIM2Ll/4sJBffAP60h/3+ENhJ14EKDwZ2ASenr+8DPl/yvlkkAzMWxte7Ari3ZJ9y6+4Frkj/fmgaY9kRbHl9etsZ6etLgJ+U7LNPus+x6evrSJJFc9E+3wLuLhdDD+fmOuCOkvc9ULLP/wP+I/37YWksxxdtPyg9v3PT1yel56215DiPAn9f9PpCkirErwOvAW31/j/lpbaL21wsr3rbEH04sDIini+siIhnJa0EjgDuJpn971hJ/1D0viaglWT48Zf7GeN0kiR2Ty/3fxtJNdseJTGSeT9+kf7915G01xSsJBm2PQuPl7xeSTJcPCTncldRHETEivRcFryNZPj2zrRgWDCSrnOX/F+S4eb/FjgjIjoyid4ahpOL5dVvSO6iDwdu7ecxdk/KBHwR+EGZfTr7eez+aCKpUvpsmW2/Lfp7aW+0ILsq7N4cu7uh0ptIYj2xzLbi6XAnkCT3nSTVbDbEOLlYLkXEakmLgAskXR4l7S6SxkXS7vIksL+kSYXSSzqT3v7Ar9PdHwGmRsTTGYf5KMnF9j3Af/di/0eAM4AVUXmWx97YRjIhVdaWkXyfY4GfQ9JZguRcFjxC0r61KyKe7eZY1wJPA58CbpJ0V0Q8XIWYLafcoG959imS6rH2tHF4iqSpks7j9eqdu9O/3yBpRtpr6QaSi+DidJ9LgLMlXSLpyPQYH5L0LwMJLiKeAm4B/kPSbEmTJZ0o6aMV3nIlsDdws6TjJB0s6eS059WYPnz08yTVfJMkTSjpDNBvEbGcJEleLekdSuZdv45kAq6Cu0m6h98m6f3pd36HpC9KOhFA0idJerT9WUT8KD3GDYUebzY0OLlYbqV3xr9H0uj8VZIkspikLv+cdJ8APkhSvXVPurwCzEq3ERGLgD8iKWH8Il0uIplVb6A+BtwIXE5y538dSQIp931WkkwTu4vkIr6UJOFsTZfe+hpJ6eXXJN87y+d9/oJk1sTFwO0k3+35wsb0nJ6abv8WsJwkwU4BVkqaAvwf4NNF7WAXpn9+I8M4Lec8E6WZmWXOJRczM8uck4uZmWXOycXMzDLn5GJmZplzcjEzs8w5uZiZWeacXMzMLHNOLmZmlrn/D78/R3d1EcKPAAAAAElFTkSuQmCC\n",
                         "text/plain": [
                             "<Figure size 432x288 with 1 Axes>"
                         ]
                     },
                     "metadata": {
                         "needs_background": "light"
                     },
```

### Comparing `smol-0.3.1/docs/src/notebooks/adding-structures-in-parallel.ipynb` & `smol-0.4.0/docs/src/notebooks/adding-structures-in-parallel.ipynb`

 * *Files identical despite different names*

### Comparing `smol-0.3.1/docs/src/notebooks/cluster-visualization.ipynb` & `smol-0.4.0/docs/src/notebooks/cluster-visualization.ipynb`

 * *Files identical despite different names*

### Comparing `smol-0.3.1/docs/src/notebooks/creating-a-ce-w-electrostatics.ipynb` & `smol-0.4.0/docs/src/notebooks/creating-a-ce-w-electrostatics.ipynb`

 * *Files identical despite different names*

### Comparing `smol-0.3.1/docs/src/notebooks/creating-a-ce.ipynb` & `smol-0.4.0/docs/src/notebooks/creating-a-ce.ipynb`

 * *Files 0% similar despite different names*

#### Pretty-printed

 * *Similarity: 0.9977678571428572%*

 * *Differences: {"'metadata'": "{'language_info': {'version': '3.10.11'}}"}*

```diff
@@ -441,13 +441,13 @@
                 "version": 3
             },
             "file_extension": ".py",
             "mimetype": "text/x-python",
             "name": "python",
             "nbconvert_exporter": "python",
             "pygments_lexer": "ipython3",
-            "version": "3.8.11"
+            "version": "3.10.11"
         }
     },
     "nbformat": 4,
     "nbformat_minor": 4
 }
```

### Comparing `smol-0.3.1/docs/src/notebooks/data/LMTO.mson` & `smol-0.4.0/docs/src/notebooks/data/LMTO.mson`

 * *Files identical despite different names*

### Comparing `smol-0.3.1/docs/src/notebooks/data/LiMn2O4_drx_tutorial.json` & `smol-0.4.0/docs/src/notebooks/data/LiMn2O4_drx_tutorial.json`

 * *Files identical despite different names*

### Comparing `smol-0.3.1/docs/src/notebooks/data/MnTi_O.json` & `smol-0.4.0/docs/src/notebooks/data/MnTi_O.json`

 * *Files identical despite different names*

### Comparing `smol-0.3.1/docs/src/notebooks/data/basic_ce.mson` & `smol-0.4.0/docs/src/notebooks/data/basic_ce.mson`

 * *Files identical despite different names*

### Comparing `smol-0.3.1/docs/src/notebooks/data/basic_ce_ewald.mson` & `smol-0.4.0/docs/src/notebooks/data/basic_ce_ewald.mson`

 * *Files identical despite different names*

### Comparing `smol-0.3.1/docs/src/notebooks/data/lmo_drx_entries.json` & `smol-0.4.0/docs/src/notebooks/data/lmo_drx_entries.json`

 * *Files identical despite different names*

### Comparing `smol-0.3.1/docs/src/notebooks/data/lmo_drx_prim.json` & `smol-0.4.0/docs/src/notebooks/data/lmo_drx_prim.json`

 * *Files identical despite different names*

### Comparing `smol-0.3.1/docs/src/notebooks/data/lmof_entries.json` & `smol-0.4.0/docs/src/notebooks/data/lmof_entries.json`

 * *Files identical despite different names*

### Comparing `smol-0.3.1/docs/src/notebooks/data/lmof_prim.json` & `smol-0.4.0/docs/src/notebooks/data/lmof_prim.json`

 * *Files identical despite different names*

### Comparing `smol-0.3.1/docs/src/notebooks/data/lmto_entries.json` & `smol-0.4.0/docs/src/notebooks/data/lmto_entries.json`

 * *Files identical despite different names*

### Comparing `smol-0.3.1/docs/src/notebooks/data/lmto_indicator.json` & `smol-0.4.0/docs/src/notebooks/data/lmto_indicator.json`

 * *Files identical despite different names*

### Comparing `smol-0.3.1/docs/src/notebooks/data/lmto_prim.json` & `smol-0.4.0/docs/src/notebooks/data/lmto_prim.json`

 * *Files identical despite different names*

### Comparing `smol-0.3.1/docs/src/notebooks/data/lmto_sinusoid.mson` & `smol-0.4.0/docs/src/notebooks/data/lmto_sinusoid.mson`

 * *Files identical despite different names*

### Comparing `smol-0.3.1/docs/src/notebooks/data/lno_entries.json` & `smol-0.4.0/docs/src/notebooks/data/lno_entries.json`

 * *Files identical despite different names*

### Comparing `smol-0.3.1/docs/src/notebooks/data/lno_prim.json` & `smol-0.4.0/docs/src/notebooks/data/lno_prim.json`

 * *Files identical despite different names*

### Comparing `smol-0.3.1/docs/src/notebooks/index.ipynb` & `smol-0.4.0/docs/src/notebooks/index.ipynb`

 * *Files 14% similar despite different names*

#### Pretty-printed

 * *Similarity: 0.9925334821428572%*

 * *Differences: {"'cells'": "{3: {'metadata': {replace: OrderedDict([('jp-MarkdownHeadingCollapsed', True), "*

 * *            "('tags', [])])}, 'source': {insert: [(7, '* [Setting number of threads for OpenMP "*

 * *            'parallelization](openmp-parallelism.ipynb): Illustrates how to set the number of '*

 * *            'threads for optimal performance when computing correlation vectors or cluster '*

 * *            "interactions.')], delete: [8, 7]}}, 4: {'source': {insert: [(1, '* [Preparing cluster "*

 * *            'expansion training []*

```diff
@@ -28,36 +28,41 @@
             "source": [
                 "## Notebook examples"
             ]
         },
         {
             "cell_type": "markdown",
             "id": "7a6ea86c-3353-42f9-a14c-135c9bf5ecbd",
-            "metadata": {},
+            "metadata": {
+                "jp-MarkdownHeadingCollapsed": true,
+                "tags": []
+            },
             "source": [
                 "### Basic examples\n",
                 "* [Creating a basic cluster expansion](creating-a-ce.ipynb): Shows how to set up, create and fit a basic cluster expansion.\n",
                 "* [Creating a cluster expansion with electrostatics](creating-a-ce-w-electrostatics.ipynb): Shows how to set up, create and fit a basic cluster expansion of an ionic system with an additional Ewald electrostatic term.\n",
                 "* [Visualizing clusters](cluster-visualization.ipynb): Demonstrates how to use the **crystal-toolkit** package to visualize structures and clusters.\n",
                 "* [Running canonical Monte Carlo](running-canonical-mc.ipynb): Shows an example of running simple canonical Monte Carlo sampling using a cluster expansion.\n",
                 "* [Running semigrand canonical Monte Carlo](running-semigrand-mc.ipynb): Shows an example of running simple semigrand canonical Monte Carlo sampling using a cluster expansion.\n",
                 "* [Running charge neutral semigrand canonical Monte Carlo](running-charge-balanced-gcmc.ipynb): An example of running charge neutral semigrand canonical Monte Carlo sampling using a cluster expansion with ionic species.\n",
-                "* [Wang-Landau sampling of an FCC Ising model](wang-landau-ising.ipynb): An example of using Wang-Landau sampling to estimate the DOS of an anti-ferromagnetic FCC Ising model.\n",
-                "* [Preparing cluster expansion training data](training-data-preparation.ipynb): Shows how to modify training data and use weights for additional cluster expansion fitting control."
+                "* [Setting number of threads for OpenMP parallelization](openmp-parallelism.ipynb): Illustrates how to set the number of threads for optimal performance when computing correlation vectors or cluster interactions."
             ]
         },
         {
             "cell_type": "markdown",
             "id": "32a2fd3c-2222-46cd-b935-11693c6bf6d4",
             "metadata": {},
             "source": [
                 "### Advanced examples\n",
+                "* [Preparing cluster expansion training data](training-data-preparation.ipynb): Shows how to modify training data and use weights for additional cluster expansion fitting control.\n",
                 "* [Centering fitting data in a piece-wise fit](ce-fit-w-centering.ipynb): An example showing how to center fitting data when doing a \"piece-wise\" fit with electrostatics.\n",
                 "* [Adding structures to a StructureWrangler in parallel](adding-structures-in-parallel.ipynb): Adding structures to fit a cluster expansion can be time-consuming one way to improve performance is to add them in parallel.\n",
                 "* [Simulated annealing with point electrostatics](running-ewald-sim_anneal.ipynb): This example shows how to run simulated annealing using a point electrostatic potential which can be useful to obtain initial training structures for ionic systems.\n",
+                "* [Wang-Landau sampling of an FCC Ising model](wang-landau-ising.ipynb): An example of using Wang-Landau sampling to estimate the DOS of an anti-ferromagnetic FCC Ising model.\n",
+                "* [Generating special quasirandom structures](generating-sqs.ipynb): This example shows how to generate special quasi-random structures for a ternary alloy.\n",
                 "* [Li-Mn-O DRX cluster expansion and sampling](lmo-drx-ce-mc.ipynb): Demonstrates how to use the **crystal-toolkit** package to visualize structures and clusters."
             ]
         }
     ],
     "metadata": {
         "kernelspec": {
             "display_name": "matx",
@@ -70,13 +75,13 @@
                 "version": 3
             },
             "file_extension": ".py",
             "mimetype": "text/x-python",
             "name": "python",
             "nbconvert_exporter": "python",
             "pygments_lexer": "ipython3",
-            "version": "3.7.3"
+            "version": "3.10.11"
         }
     },
     "nbformat": 4,
     "nbformat_minor": 5
 }
```

### Comparing `smol-0.3.1/docs/src/notebooks/lmo-drx-ce-mc.ipynb` & `smol-0.4.0/docs/src/notebooks/lmo-drx-ce-mc.ipynb`

 * *Files identical despite different names*

### Comparing `smol-0.3.1/docs/src/notebooks/running-canonical-mc.ipynb` & `smol-0.4.0/docs/src/notebooks/running-canonical-mc.ipynb`

 * *Files identical despite different names*

### Comparing `smol-0.3.1/docs/src/notebooks/running-charge-balanced-gcmc.ipynb` & `smol-0.4.0/docs/src/notebooks/running-charge-balanced-gcmc.ipynb`

 * *Files identical despite different names*

### Comparing `smol-0.3.1/docs/src/notebooks/running-ewald-sim_anneal.ipynb` & `smol-0.4.0/docs/src/notebooks/running-ewald-sim_anneal.ipynb`

 * *Files identical despite different names*

### Comparing `smol-0.3.1/docs/src/notebooks/running-semigrand-mc.ipynb` & `smol-0.4.0/docs/src/notebooks/running-semigrand-mc.ipynb`

 * *Files 1% similar despite different names*

#### Pretty-printed

 * *Similarity: 0.9962797619047619%*

 * *Differences: {"'cells'": "{2: {'metadata': {replace: OrderedDict([('tags', [])])}}}",*

 * * "'metadata'": "{'language_info': {'version': '3.10.10'}}"}*

```diff
@@ -17,15 +17,17 @@
                 "import json\n",
                 "from pymatgen.core.structure import Structure\n",
                 "from smol.io import load_work"
             ]
         },
         {
             "cell_type": "markdown",
-            "metadata": {},
+            "metadata": {
+                "tags": []
+            },
             "source": [
                 "### 0) Load the previous LNO CE with electrostatics"
             ]
         },
         {
             "cell_type": "code",
             "execution_count": 2,
@@ -301,13 +303,13 @@
                 "version": 3
             },
             "file_extension": ".py",
             "mimetype": "text/x-python",
             "name": "python",
             "nbconvert_exporter": "python",
             "pygments_lexer": "ipython3",
-            "version": "3.9.13"
+            "version": "3.10.10"
         }
     },
     "nbformat": 4,
     "nbformat_minor": 4
 }
```

### Comparing `smol-0.3.1/docs/src/notebooks/training-data-preparation.ipynb` & `smol-0.4.0/docs/src/notebooks/training-data-preparation.ipynb`

 * *Files identical despite different names*

### Comparing `smol-0.3.1/docs/src/notebooks/wang-landau-ising.ipynb` & `smol-0.4.0/docs/src/notebooks/wang-landau-ising.ipynb`

 * *Files identical despite different names*

### Comparing `smol-0.3.1/docs/src/notebooks/wip/basis-orthogonalization.ipynb` & `smol-0.4.0/docs/src/notebooks/wip/basis-orthogonalization.ipynb`

 * *Files identical despite different names*

### Comparing `smol-0.3.1/docs/src/user_guide.rst` & `smol-0.4.0/docs/src/user_guide.rst`

 * *Files 1% similar despite different names*

```diff
@@ -175,14 +175,15 @@
 prim).
 
 The core classes are:
 
 - :ref:`processors ug`
 
   - :class:`ClusterExpansionProcessor`
+  - :class:`ClusterDecompositionProcessor`
   - :class:`EwaldProcessor`
   - :class:`CompositeProcessor`
 
 - :ref:`ensemble ug`
 - :ref:`sampler ug`
 - :ref:`samplecontainer ug`
```

### Comparing `smol-0.3.1/smol/cofe/__init__.py` & `smol-0.4.0/smol/cofe/__init__.py`

 * *Files identical despite different names*

### Comparing `smol-0.3.1/smol/cofe/expansion.py` & `smol-0.4.0/smol/cofe/expansion.py`

 * *Files 11% similar despite different names*

```diff
@@ -16,14 +16,15 @@
 from dataclasses import asdict, dataclass
 from functools import cached_property
 
 import numpy as np
 from monty.json import MSONable, jsanitize
 
 from smol.cofe.space.clusterspace import ClusterSubspace
+from smol.utils.cluster import get_orbit_data
 
 
 @dataclass
 class RegressionData:
     """Dataclass used to store regression model details.
 
     This class is used to store the details used in fitting a cluster expansion
@@ -153,15 +154,17 @@
             raise AttributeError(
                 f"The size of the give subspace {len(cluster_subspace)} does "
                 f"not match the number of coefficients {len(coefficients)}"
             )
 
         self.coefs = coefficients
         self.regression_data = regression_data
-        self._subspace = cluster_subspace
+        self._subspace = cluster_subspace.copy()
+        self._set_evaluator_data()
+
         # make copy for possible changes/pruning
         self._feat_matrix = (
             regression_data.feature_matrix.copy()
             if regression_data is not None
             else None
         )
 
@@ -249,64 +252,88 @@
     def feature_matrix(self):
         """Get the feature matrix used in fit.
 
         If not given, returns an identity matrix of len num_corrs
         """
         return self._feat_matrix
 
-    def predict(self, structure, normalize=False, scmatrix=None):
+    def predict(self, structure, normalized=False, scmatrix=None, site_mapping=None):
         """Predict the fitted property for a given set of structures.
 
         Args:
             structure (Structure):
                 Structures to predict from
-            normalize (bool): optional
+            normalized (bool): optional
                 Whether to return the predicted property normalized
                 by the prim cell size.
-            scmatrix (Arraylike): optional
-                3 x 3 Supercell matrix of structure.
+            scmatrix (ndarray): optional
+                supercell matrix relating the prim structure to the given
+                structure. Passing this if it has already been matched will
+                make things much quicker. You are responsible that the
+                supercell matrix is correct.
+            site_mapping (list): optional
+                Site mapping as obtained by
+                :code:`StructureMatcher.get_mapping` such that the elements of
+                site_mapping represent the indices of the matching sites to the prim
+                structure. If you pass this option, you are fully responsible that the
+                mappings are correct!
         Returns:
             float
         """
         corrs = self.cluster_subspace.corr_from_structure(
-            structure, scmatrix=scmatrix, normalized=normalize
+            structure,
+            scmatrix=scmatrix,
+            normalized=normalized,
+            site_mapping=site_mapping,
         )
         return np.dot(self.coefs, corrs)
 
-    def compute_cluster_interactions(self, structure, normalize=True):
+    def cluster_interactions_from_structure(
+        self, structure, normalized=True, scmatrix=None, site_mapping=None
+    ):
         """Compute the vector of cluster interaction values for given structure.
 
         A cluster interaction is simply a vector made up of the sum of all cluster
         expansion terms over the same orbit.
 
         Args:
             structure (Structure):
                 Structures to predict from
-            normalize (bool):
+            normalized (bool):
                 Whether to return the predicted property normalized by
                 the prim cell size.
+            scmatrix (ndarray): optional
+                supercell matrix relating the prim structure to the given
+                structure. Passing this if it has already been matched will
+                make things much quicker. You are responsible that the
+                supercell matrix is correct.
+            site_mapping (list): optional
+                Site mapping as obtained by
+                :code:`StructureMatcher.get_mapping` such that the elements of
+                site_mapping represent the indices of the matching sites to the prim
+                structure. If you pass this option, you are fully responsible that the
+                mappings are correct!
 
         Returns: ndarray
             vector of cluster interaction values
         """
-        corrs = self.cluster_subspace.corr_from_structure(
-            structure, normalized=normalize
+        if scmatrix is None:
+            scmatrix = self._subspace.scmatrix_from_structure(structure)
+
+        occu = self.cluster_subspace.occupancy_from_structure(
+            structure, scmatrix=scmatrix, site_mapping=site_mapping, encode=True
         )
-        vals = self.eci * corrs
-        interactions = np.array(
-            [
-                np.sum(
-                    vals[self.eci_orbit_ids == i]
-                    * self._subspace.function_ordering_multiplicities[
-                        self.eci_orbit_ids == i
-                    ]
-                )  # noqa
-                for i in range(len(self._subspace.orbits) + 1)
-            ]
+        indices = self._subspace.get_orbit_indices(scmatrix)
+        interactions = self._subspace.evaluator.interactions_from_occupancy(
+            occu, indices.container
         )
+
+        if not normalized:
+            interactions *= self._subspace.num_prims_from_matrix(scmatrix)
+
         return interactions
 
     def prune(self, threshold=0, with_multiplicity=False):
         """Remove fit coefficients or ECI's with small values.
 
         Removes ECI's and orbits in the ClusterSubspaces that have
         ECI/parameter values smaller than the given threshold.
@@ -340,18 +367,38 @@
 
         if hasattr(self, "eci"):  # reset cache
             del self.eci
 
         if hasattr(self, "cluster_interaction_tensors"):  # reset cache
             del self.cluster_interaction_tensors
 
+        # reset the evaluator
+        self._set_evaluator_data(set_orbits=True)
+
     def copy(self):
         """Return a copy of self."""
         return ClusterExpansion.from_dict(self.as_dict())
 
+    def _set_evaluator_data(self, set_orbits=False):
+        """Set the orbit and cluster interaction data in evaluator."""
+        if set_orbits:
+            self._subspace.evaluator.reset_data(
+                get_orbit_data(self._subspace.orbits),
+                self._subspace.num_orbits,
+                self._subspace.num_corr_functions,
+            )
+
+        flat_interaction_tensors = tuple(
+            np.ravel(tensor, order="C")
+            for tensor in self.cluster_interaction_tensors[1:]
+        )
+        self._subspace.evaluator.set_cluster_interactions(
+            flat_interaction_tensors, offset=self.cluster_interaction_tensors[0]
+        )
+
     def __str__(self):
         """Pretty string for printing."""
         outs = str(self.cluster_subspace).split("\n")[:6]
 
         if self.regression_data is not None:
             # This might need to be redefined to take "expectation" using measure
             feature_avg = np.average(self.feature_matrix, axis=0)
```

### Comparing `smol-0.3.1/smol/cofe/extern/ewald.py` & `smol-0.4.0/smol/cofe/extern/ewald.py`

 * *Files identical despite different names*

### Comparing `smol-0.3.1/smol/cofe/space/__init__.py` & `smol-0.4.0/smol/cofe/space/__init__.py`

 * *Files identical despite different names*

### Comparing `smol-0.3.1/smol/cofe/space/basis.py` & `smol-0.4.0/smol/cofe/space/basis.py`

 * *Files 0% similar despite different names*

```diff
@@ -15,15 +15,15 @@
 
 import numpy as np
 from monty.json import MSONable
 from numpy.polynomial.chebyshev import chebval
 from numpy.polynomial.legendre import legval
 from numpy.polynomial.polynomial import polyval
 
-from smol.utils import derived_class_factory, get_subclasses
+from smol.utils.class_utils import derived_class_factory, get_subclasses
 
 from .domain import SiteSpace
 
 EPS_MULT = 10  # eps precision multiplier
 
 
 __author__ = "Luis Barroso-Luque"
```

### Comparing `smol-0.3.1/smol/cofe/space/cluster.py` & `smol-0.4.0/smol/cofe/space/cluster.py`

 * *Files identical despite different names*

### Comparing `smol-0.3.1/smol/cofe/space/clusterspace.py` & `smol-0.4.0/smol/cofe/space/clusterspace.py`

 * *Files 3% similar despite different names*

```diff
@@ -5,21 +5,24 @@
 
 The PottsSubspace class is an (experimental) class that is similar, but
 diverges from the CE mathematic formalism.
 """
 # pylint: disable=too-many-lines
 
 
-import itertools
 import warnings
+from collections import namedtuple
 from copy import deepcopy
+from functools import cached_property
 from importlib import import_module
+from itertools import chain, groupby
 
 import numpy as np
-from monty.json import MSONable
+from monty.dev import deprecated
+from monty.json import MSONable, jsanitize
 from pymatgen.analysis.structure_matcher import (
     OrderDisorderElementComparator,
     StructureMatcher,
 )
 from pymatgen.core import PeriodicSite, Structure
 from pymatgen.symmetry.analyzer import SpacegroupAnalyzer, SymmOp
 from pymatgen.util.coord import (
@@ -35,19 +38,29 @@
     Vacancy,
     basis_factory,
     get_allowed_species,
     get_site_spaces,
 )
 from smol.cofe.space.basis import IndicatorBasis
 from smol.cofe.space.constants import SITE_TOL
-from smol.correlations import corr_from_occupancy
-from smol.exceptions import SYMMETRY_ERROR_MESSAGE, StructureMatchError, SymmetryError
+from smol.utils.cluster import get_orbit_data
+from smol.utils.cluster.container import IntArray2DContainer
+from smol.utils.cluster.evaluator import ClusterSpaceEvaluator
+from smol.utils.cluster.numthreads import SetNumThreads
+from smol.utils.exceptions import (
+    SYMMETRY_ERROR_MESSAGE,
+    StructureMatchError,
+    SymmetryError,
+)
 
 __author__ = "Luis Barroso-Luque, William Davidson Richards"
 
+# a named tuple to hold ndarray orbit indices and their corresponding cython containers
+OrbitIndices = namedtuple("OrbitIndices", ["arrays", "container"])
+
 
 class ClusterSubspace(MSONable):
     """ClusterSubspace represents a subspace of functions of configuration.
 
     A :class:`ClusterSubspace` is the main work horse used in constructing a
     cluster expansion. It is necessary to define the terms to be included in a
     cluster expansion. A cluster subspace holds a finite set of orbits that
@@ -76,22 +89,25 @@
             Total number of crystallographic orbits included in the subspace.
             This includes the empty orbit.
         num_clusters (int):
             Total number of clusters in the primitive cell that are included
             in the subspace.
     """
 
+    num_threads = SetNumThreads("_evaluator")
+
     def __init__(
         self,
         structure,
         expansion_structure,
         symops,
         orbits,
         supercell_matcher=None,
         site_matcher=None,
+        num_threads=None,
         **matcher_kwargs,
     ):
         """Initialize a ClusterSubspace.
 
         You rarely will need to create a ClusterSubspace using the main
         constructor.
         Look at the class method :code:`from_cutoffs` for the "better" way to
@@ -116,14 +132,19 @@
                 otherwise matching your relaxed structures can fail, a lot.
             site_matcher (StructureMatcher): optional
                 StructureMatcher used to find site mappings
                 relating the sites of a given structure to an appropriate
                 supercell of the prim structure . If you pass this directly you
                 should know how to set the matcher up, otherwise matching your
                 relaxed structures can fail, a lot.
+            num_threads (int): optional
+                Number of threads to use to compute a correlation vector. Note that
+                this is not saved when serializing the ClusterSubspace with the
+                as_dict method, so if you are loading a ClusterSubspace from a
+                file then make sure to set the number of threads as desired.
             matcher_kwargs:
                 ltol, stol, angle_tol, supercell_size: parameters to pass
                 through to the StructureMatchers. Structures that don't match
                 to the primitive cell under these tolerances won't be included
                 in the expansion. Easiest option for supercell_size is usually
                 to use a species that has a constant amount per formula unit.
                 See pymatgen documentation of :class:`StructureMatcher` for
@@ -178,32 +199,40 @@
             )
         else:
             self._site_matcher = site_matcher
 
         self._orbits = orbits
         self._external_terms = []  # List will hold external terms (i.e. Ewald)
 
-        # Dict to cache orbit index mappings, this prevents doing another
-        # structure match with the _site_matcher for structures that have
-        # already been matched
-        self._supercell_orb_inds = {}
-
         # assign the cluster ids
         self._assign_orbit_ids()
 
+        # create evaluator
+        self._evaluator = ClusterSpaceEvaluator(
+            get_orbit_data(self.orbits), self.num_orbits, self.num_corr_functions
+        )
+        # set the number of threads to use
+        self.num_threads = num_threads
+
+        # Dict to cache orbit index mappings, as OrbitIndices named tuples
+        # this prevents doing another structure match with the _site_matcher for
+        # structures that have already been matched
+        self._supercell_orbit_inds = {}
+
     @classmethod
     def from_cutoffs(
         cls,
         structure,
         cutoffs,
         basis="indicator",
         orthonormal=False,
         use_concentration=False,
         supercell_matcher=None,
         site_matcher=None,
+        num_threads=None,
         **matcher_kwargs,
     ):
         """Create a ClusterSubspace from diameter cutoffs.
 
         Creates a :class:`ClusterSubspace` with orbits of the given size and
         diameter smaller than or equal to the given value. The diameter of an
         orbit is the maximum distance between any two sites of a cluster of
@@ -229,27 +258,32 @@
                 a string specifying the site basis functions
             orthonormal (bool):
                 whether to enforce an orthonormal basis. From the current
                 available bases only the indicator basis is not orthogonal out
                 of the box
             use_concentration (bool):
                 if True, the concentrations in the prim structure sites will be
-                used to orthormalize site bases. This gives gives a cluster
+                used to orthormalize site bases. This gives a cluster
                 subspace centered about the prim composition.
             supercell_matcher (StructureMatcher): optional
                 StructureMatcher used to find supercell matrices
                 relating the prim structure to other structures. If you pass
                 this directly you should know how to set the matcher up,
                 otherwise matching your relaxed structures will fail, a lot.
             site_matcher (StructureMatcher): optional
                 StructureMatcher used to find site mappings
                 relating the sites of a given structure to an appropriate
                 supercell of the prim structure . If you pass this directly you
                 should know how to set the matcher up, otherwise matching your
                 relaxed structures will fail, a lot.
+            num_threads (int): optional
+                Number of threads to use to compute a correlation vector. Note that
+                this is not saved when serializing the ClusterSubspace with the
+                as_dict method, so if you are loading a ClusterSubspace from a
+                file then make sure to set the number of threads as desired.
             matcher_kwargs:
                 ltol, stol, angle_tol, supercell_size: parameters to pass
                 through to the StructureMatchers. Structures that don't match
                 to the primitive cell under these tolerances won't be included
                 in the expansion. Easiest option for supercell_size is usually
                 to use a species that has a constant amount per formula unit.
 
@@ -272,18 +306,30 @@
         return cls(
             structure=structure,
             expansion_structure=expansion_structure,
             symops=symops,
             orbits=orbits,
             supercell_matcher=supercell_matcher,
             site_matcher=site_matcher,
+            num_threads=num_threads,
             **matcher_kwargs,
         )
 
     @property
+    def evaluator(self):
+        """Get the instance of cluster space evaluator extension type.
+
+        The evaluator is used to compute correlations quickly. You should not use this
+        directly, instead use the :meth:`corr_from_structure` method. If you do attempt
+        to use directly make sure you understand the code, otherwise you will crash
+        your python interpreter. You have been warned...
+        """
+        return self._evaluator
+
+    @property
     def basis_type(self):
         """Get the type of site basis set used."""
         return self.orbits[0].basis_type
 
     @property
     def structure(self):
         """Get the underlying primitive structure including inactive sites."""
@@ -313,14 +359,30 @@
         return [orbit for _, orbits in sorted(self._orbits.items()) for orbit in orbits]
 
     @property
     def orbits_by_size(self):
         """Get dictionary of orbits with key being the orbit size."""
         return self._orbits
 
+    @cached_property
+    def orbits_by_diameter(self):
+        """Get dictionary of orbits with key being the orbit diameter.
+
+        Diameters are rounded to 6 decimal places.
+        """
+        return {
+            size: tuple(orbits)
+            for size, orbits in groupby(
+                sorted(
+                    self.orbits, key=lambda orb: np.round(orb.base_cluster.diameter, 6)
+                ),
+                key=lambda orb: np.round(orb.base_cluster.diameter, 6),
+            )
+        }
+
     @property
     def orbit_multiplicities(self):
         """Get the crystallographic multiplicities for each orbit."""
         mults = [1] + [orb.multiplicity for orb in self.orbits]
         return np.array(mults)
 
     @property
@@ -619,19 +681,16 @@
         """
         if scmatrix is None:
             scmatrix = self.scmatrix_from_structure(structure)
 
         occu = self.occupancy_from_structure(
             structure, scmatrix=scmatrix, site_mapping=site_mapping, encode=True
         )
-        occu = np.array(occu, dtype=int)
-
-        corr = corr_from_occupancy(
-            occu, self.num_corr_functions, self.gen_orbit_list(scmatrix)
-        )
+        indices = self.get_orbit_indices(scmatrix)
+        corr = self._evaluator.correlations_from_occupancy(occu, indices.container)
         size = self.num_prims_from_matrix(scmatrix)
 
         if self.external_terms:
             supercell = self.structure.copy()
             supercell.make_supercell(scmatrix)
             extras = [
                 term.value_from_occupancy(occu, supercell) / size
@@ -784,29 +843,22 @@
         structure represented by the given matrix
 
         Args:
             scmatrix (array):
                 array relating a supercell with the primitive matrix
 
         Returns:
-            list of tuples:
-                (orbit, indices) list of tuples with orbits and the
-                site indices for all equivalent orbits in a supercell obtained
-                from the given matrix.
+            tuple of ndarray:
+                tuple of 2D ndarrays where each array has the site indices for all
+                equivalent orbits in a supercell obtained from the given matrix.
+                First dimension are clusters and 2nd dimensiuon are site indices for
+                that cluster
         """
-        # np.arrays are not hashable and can't be used as dict keys.
-        scmatrix = np.array(scmatrix)
-        scm = tuple(sorted(tuple(s.tolist()) for s in scmatrix))
-        indices = self._supercell_orb_inds.get(scm)
-
-        if indices is None:
-            indices = self._gen_orbit_indices(scmatrix)
-            self._supercell_orb_inds[scm] = indices
-
-        return indices
+        orbit_indices = self.get_orbit_indices(scmatrix)
+        return orbit_indices.arrays
 
     def get_aliased_orbits(self, sc_matrix):
         """Get the aliased orbits for a given supercell shape.
 
         Detect the orbits that will be aliased due to translational symmetry imposed by
         the supercell lattice. Orbits i and j are aliased when a geometric cluster in
         orbit i is identically mapped to another geometric cluster in orbit j.
@@ -829,23 +881,23 @@
                 that are aliased.
 
         """
         sc_orb_map = self.supercell_orbit_mappings(sc_matrix)
         aliased_orbits = []
         for orb_i, orb_map_i in enumerate(sc_orb_map):
             # +1 because ECI index takes the null cluster as index 0.
-            if orb_i + 1 in itertools.chain(*aliased_orbits):
+            if orb_i + 1 in chain(*aliased_orbits):
                 continue
             orb_i_id = orb_i + 1
             aliased = False
             orbit_i_aliased = [orb_i_id]
             sorted_orb_map_i = {tuple(sorted(c_map)) for c_map in orb_map_i}
 
             for orb_j, orb_map_j in enumerate(sc_orb_map):
-                if orb_i >= orb_j or (orb_j + 1 in itertools.chain(*aliased_orbits)):
+                if orb_i >= orb_j or (orb_j + 1 in chain(*aliased_orbits)):
                     continue
                 orb_j_id = orb_j + 1
                 sorted_orb_map_j = {tuple(sorted(c_map)) for c_map in orb_map_j}
 
                 if sorted_orb_map_i == sorted_orb_map_j:
                     aliased = True
                     orbit_i_aliased.append(orb_j_id)
@@ -864,14 +916,18 @@
             new_basis (str):
                 name of new basis for all site bases
             orthonormal (bool):
                 option to orthonormalize all new site basis sets
         """
         for orbit in self.orbits:
             orbit.transform_site_bases(new_basis, orthonormal)
+        # rest the evaluator
+        self._evaluator.reset_data(
+            get_orbit_data(self.orbits), self.num_orbits, self.num_corr_functions
+        )
 
     def rotate_site_basis(self, singlet_id, angle, index1=0, index2=1):
         """Apply a rotation to a site basis.
 
         The rotation is applied around an axis normal to the span of the two
         site functions given by index1 and index 2 (the constant function is
         not included, i.e. index 0 corresponds to the first non constant
@@ -902,30 +958,34 @@
                 if (
                     site_basis.site_space == basis.site_space
                     and site_basis not in rotated
                 ):  # maybe clean this up?
                     site_basis.rotate(angle, index1, index2)
                     rotated.append(site_basis)
             orbit.reset_bases()
+        # rest the evaluator
+        self._evaluator.reset_data(
+            get_orbit_data(self.orbits), self.num_orbits, self.num_corr_functions
+        )
 
     def remove_orbits(self, orbit_ids):
         """Remove whole orbits by their ids.
 
-        Removes orbits from cluster spaces. It is helpful to print a
-        ClusterSubspace or ClusterExpansion to obtain orbit ids. After removing
-        orbits, orbit ID's and orbit bit ID's are re-assigned.
-
-        This is useful to prune a ClusterExpansion by removing orbits with
-        small associated coefficients or ECI. Note that this will remove a full
-        orbit, which for the case of sites with only two species is the same as
-        removing a single correlation vector element (only one ECI). For cases
-        with sites having more than 2 species allowed per site there is more
-        than one orbit functions (for all the possible bit orderings or function-
-        labeled orbit configurations) and removing an orbit will remove more than
-        one element in the correlation vector.
+        Remove orbits from cluster spaces. It is helpful to print a ClusterSubspace or
+        ClusterExpansion to obtain orbit ids. After removing orbits, orbit ID's and
+        orbit bit ID's are re-assigned.
+
+        This is useful to prune a ClusterExpansion by removing orbits with small
+        associated coefficients or ECI. Note that this will remove a full orbit,
+        which for the case of sites with only two species is the same as removing a
+        single correlation vector element (only one ECI). For cases with sites having
+        more than 2 species allowed per site there is more than one orbit functions
+        (for all the possible bit orderings or function- labeled orbit configurations)
+        and removing an orbit will remove more than one element in the correlation
+        vector.
 
         Args:
             orbit_ids (list):
                 list of orbit ids to be removed
         """
         if min(orbit_ids) < 0:
             raise ValueError("Index out of range. Negative inds are not allowed.")
@@ -951,15 +1011,23 @@
             self._orbits.keys()
         ):  # cast to list bc .keys() behaves like an iterator
             if len(self._orbits[size]) == 0:
                 del self._orbits[size]
 
         self._assign_orbit_ids()  # Re-assign ids
         # Clear the cached supercell orbit mappings
-        self._supercell_orb_inds = {}
+        # TODO instead of resetting this, just remove the orbit ids
+        self._supercell_orbit_inds = {}
+        # reset the evaluator
+        self._evaluator.reset_data(
+            get_orbit_data(self.orbits), self.num_orbits, self.num_corr_functions
+        )
+        # clear the cached orbits_by_diameter
+        if hasattr(self, "orbits_by_diameter"):
+            delattr(self, "orbits_by_diameter")
 
     def remove_corr_functions(self, corr_ids):
         """Remove correlation functions by their ID's.
 
         This allows more granular removal of terms involved in fitting/evaluating a
         cluster expansion. Similar to remove_orbits this is useful to prune a cluster
         expansion and actually allows to remove a single term (ie one with small
@@ -993,17 +1061,21 @@
                     empty_orbit_ids.append(orbit.id)
                     warnings.warn(
                         "All bit combos have been removed from orbit with id "
                         f"{orbit.id}. This orbit will be fully removed."
                     )
 
         if empty_orbit_ids:
+            # ids are reassigned and evaluator reset in remove_orbits
             self.remove_orbits(empty_orbit_ids)
         else:
             self._assign_orbit_ids()  # Re-assign ids
+            self._evaluator.reset_data(
+                get_orbit_data(self.orbits), self.num_orbits, self.num_corr_functions
+            )
 
     def copy(self):
         """Deep copy of instance."""
         return ClusterSubspace.from_dict(self.as_dict())
 
     def structure_site_mapping(self, supercell, structure):
         """Get structure site mapping.
@@ -1091,14 +1163,20 @@
             inds = orbit.sub_orbit_mappings(sub_orbit)
             for i, sub_bit_combo in enumerate(sub_orbit.bit_combos):
                 if np.any(np.all(sub_bit_combo[0] == bit_combo[:, inds], axis=2)):
                     sub_fun_ids.append(sub_orbit.bit_id + i)
 
         return sub_fun_ids
 
+    @deprecated(
+        message=(
+            "This function is deprecated and will be removed in version 0.4.0.\n"
+            "You should not have really been using this function anyway..."
+        )
+    )
     def gen_orbit_list(self, scmatrix):
         """
         Generate list of data to compute correlation vectors.
 
         List includes orbit bit ids, flat correlation tensors and their indices,
         and array of cluster indices for supercell corresponding to given
         supercell matrix.
@@ -1138,14 +1216,69 @@
             for orbit in self._orbits[key]:
                 counts = orbit.assign_ids(*counts)
 
         self.num_orbits = counts[0]
         self.num_corr_functions = counts[1]
         self.num_clusters = counts[2]
 
+    def get_orbit_indices(self, scmatrix):
+        """Get the OrbitIndices named tuple for a given supercell matrix.
+
+        If the indices have not been cached then they are generated by generating
+        the site mappings for the given supercell.e
+        """
+        # np.arrays are not hashable and can't be used as dict keys.
+        scmatrix = np.array(scmatrix)
+        scm = tuple(sorted(tuple(s.tolist()) for s in scmatrix))
+        orbit_indices = self._supercell_orbit_inds.get(scm)
+
+        if orbit_indices is None:
+            orbit_indices = self._gen_orbit_indices(scmatrix)
+            self._supercell_orbit_inds[scm] = orbit_indices
+
+        return orbit_indices
+
+    def _gen_orbit_indices(self, scmatrix):
+        """Find all the cluster site indices associated with each orbit in structure.
+
+        The structure corresponding to the given supercell matrix w.r.t prim.
+        """
+        supercell = self.structure.copy()
+        supercell.make_supercell(scmatrix)
+        prim_to_supercell = np.linalg.inv(scmatrix)
+        supercell_fcoords = np.array(supercell.frac_coords)
+
+        pts = lattice_points_in_supercell(scmatrix)
+        orbit_indices = []
+        for orbit in self.orbits:
+            prim_fcoords = np.array([c.frac_coords for c in orbit.clusters])
+            fcoords = np.dot(prim_fcoords, prim_to_supercell)
+            # tcoords contains all the coordinates of the symmetrically
+            # equivalent clusters the indices are: [equivalent cluster
+            # (primitive cell), translational image, index of site in cluster,
+            # coordinate index]
+            tcoords = fcoords[:, None, :, :] + pts[None, :, None, :]
+            tcs = tcoords.shape
+            inds = coord_list_mapping_pbc(
+                tcoords.reshape((-1, 3)), supercell_fcoords, atol=SITE_TOL
+            ).reshape((tcs[0] * tcs[1], tcs[2]))
+            # orbit_ids holds orbit, and 2d array of index groups that
+            # correspond to the orbit
+            # the 2d array may have some duplicates. This is due to
+            # symmetrically equivalent groups being matched to the same sites
+            # (eg in simply cubic all 6 nn interactions will all be [0, 0]
+            # indices. This multiplicity disappears as supercell_structure size
+            # increases, so I haven't implemented a more efficient method
+
+            # assure contiguous C order
+            orbit_indices.append(np.ascontiguousarray(inds, dtype=int))
+
+        orbit_indices = tuple(orbit_indices)
+        return OrbitIndices(orbit_indices, IntArray2DContainer(orbit_indices))
+
     @staticmethod
     def _gen_orbits_from_cutoffs(
         exp_struct, cutoffs, symops, basis, orthonorm, use_conc
     ):
         """Generate orbits from diameter cutoffs.
 
         The diameter of a cluster is the maximum distance between any two
@@ -1337,49 +1470,14 @@
                         np.round(x.base_cluster.diameter, 6),
                         -x.multiplicity,
                         len(x),
                     ),
                 )
         return orbits
 
-    def _gen_orbit_indices(self, scmatrix):
-        """Find all the site indices associated with each orbit in structure.
-
-        The structure corresponding to the given supercell matrix w.r.t prim.
-        """
-        supercell = self.structure.copy()
-        supercell.make_supercell(scmatrix)
-        prim_to_supercell = np.linalg.inv(scmatrix)
-        supercell_fcoords = np.array(supercell.frac_coords)
-
-        pts = lattice_points_in_supercell(scmatrix)
-        orbit_indices = []
-        for orbit in self.orbits:
-            prim_fcoords = np.array([c.frac_coords for c in orbit.clusters])
-            fcoords = np.dot(prim_fcoords, prim_to_supercell)
-            # tcoords contains all the coordinates of the symmetrically
-            # equivalent clusters the indices are: [equivalent cluster
-            # (primitive cell), translational image, index of site in cluster,
-            # coordinate index]
-            tcoords = fcoords[:, None, :, :] + pts[None, :, None, :]
-            tcs = tcoords.shape
-            inds = coord_list_mapping_pbc(
-                tcoords.reshape((-1, 3)), supercell_fcoords, atol=SITE_TOL
-            ).reshape((tcs[0] * tcs[1], tcs[2]))
-            # orbit_ids holds orbit, and 2d array of index groups that
-            # correspond to the orbit
-            # the 2d array may have some duplicates. This is due to
-            # symmetrically equivalent groups being matched to the same sites
-            # (eg in simply cubic all 6 nn interactions will all be [0, 0]
-            # indices. This multiplicity disappears as supercell_structure size
-            # increases, so I haven't implemented a more efficient method
-            orbit_indices.append(inds)
-
-        return orbit_indices
-
     def __eq__(self, other):
         """Check equality between cluster subspaces."""
         if not isinstance(other, ClusterSubspace):
             return False
         if other.num_corr_functions != self.num_corr_functions:
             return False
         if len(self.external_terms) != len(other.external_terms):
@@ -1479,52 +1577,59 @@
             except ImportError:
                 warnings.warn(
                     f"Module {term['@module']} for class {term['@class']} was "
                     f"not found. You will have to add this yourself.",
                     ImportWarning,
                 )
         # re-create supercell orb inds cache
-        _supercell_orb_inds = {}
+        _supercell_orbit_inds = {}
         for scm, indices in d["_supercell_orb_inds"]:
             scm = tuple(tuple(s) for s in scm)
             if isinstance(indices[0][0], int) and isinstance(indices[0][1], list):
                 warnings.warn(
                     "This ClusterSubspace was created with a previous version "
                     "of smol. Please resave it to avoid this warning.",
                     FutureWarning,
                 )
-                _supercell_orb_inds[scm] = [np.array(ind) for o_id, ind in indices]
+                _supercell_orbit_inds[scm] = tuple(
+                    np.array(ind) for o_id, ind in indices
+                )
             else:
-                _supercell_orb_inds[scm] = [np.array(ind) for ind in indices]
-        cluster_subspace._supercell_orb_inds = _supercell_orb_inds
+                _supercell_orbit_inds[scm] = tuple(np.array(ind) for ind in indices)
+        # now generate the containers
+        _supercell_orbit_inds = {
+            scm: OrbitIndices(indices, IntArray2DContainer(indices))
+            for scm, indices in _supercell_orbit_inds.items()
+        }
+        cluster_subspace._supercell_orbit_inds = _supercell_orbit_inds
         return cluster_subspace
 
     def as_dict(self):
         """
         Json-serialization dict representation.
 
         Returns:
             MSONable dict
         """
-        # modify cached sc orb inds so it can be serialized
+        # modify cached sc orbit indices so it can be serialized
         _supercell_orb_inds = [
-            (scm, [ind.tolist() for ind in orb_inds])
-            for scm, orb_inds in self._supercell_orb_inds.items()
+            (scm, [indices.tolist() for indices in orbit_inds.arrays])
+            for scm, orbit_inds in self._supercell_orbit_inds.items()
         ]
 
         cs_dict = {
             "@module": self.__class__.__module__,
             "@class": self.__class__.__name__,
             "structure": self.structure.as_dict(),
             "expansion_structure": self.expansion_structure.as_dict(),
-            "symops": [so.as_dict() for so in self.symops],
-            "orbits": {s: [o.as_dict() for o in v] for s, v in self._orbits.items()},
             "sc_matcher": self._sc_matcher.as_dict(),
             "site_matcher": self._site_matcher.as_dict(),
-            "external_terms": [et.as_dict() for et in self.external_terms],
+            "symops": jsanitize(self.symops, strict=True),
+            "orbits": jsanitize(self._orbits, strict=True),
+            "external_terms": jsanitize(self.external_terms, strict=True),
             "_supercell_orb_inds": _supercell_orb_inds,
         }
         return cs_dict
 
 
 def invert_mapping(mapping):
     """Invert a mapping table from forward to backward, vice versa.
```

### Comparing `smol-0.3.1/smol/cofe/space/domain.py` & `smol-0.4.0/smol/cofe/space/domain.py`

 * *Files identical despite different names*

### Comparing `smol-0.3.1/smol/cofe/space/orbit.py` & `smol-0.4.0/smol/cofe/space/orbit.py`

 * *Files 0% similar despite different names*

```diff
@@ -10,15 +10,15 @@
 
 import numpy as np
 from monty.json import MSONable
 from pymatgen.core import Lattice
 from pymatgen.core.operations import SymmOp
 from pymatgen.util.coord import coord_list_mapping, is_coord_subset
 
-from smol.exceptions import SYMMETRY_ERROR_MESSAGE, SymmetryError
+from smol.utils.exceptions import SYMMETRY_ERROR_MESSAGE, SymmetryError
 
 from .basis import DiscreteBasis, basis_factory
 from .cluster import Cluster
 from .constants import SITE_TOL
 
 __author__ = "Luis Barroso-Luque, William Davidson Richard"
```

### Comparing `smol-0.3.1/smol/cofe/wrangling/__init__.py` & `smol-0.4.0/smol/cofe/wrangling/__init__.py`

 * *Files identical despite different names*

### Comparing `smol-0.3.1/smol/cofe/wrangling/select.py` & `smol-0.4.0/smol/cofe/wrangling/select.py`

 * *Files identical despite different names*

### Comparing `smol-0.3.1/smol/cofe/wrangling/tools.py` & `smol-0.4.0/smol/cofe/wrangling/tools.py`

 * *Files identical despite different names*

### Comparing `smol-0.3.1/smol/cofe/wrangling/wrangler.py` & `smol-0.4.0/smol/cofe/wrangling/wrangler.py`

 * *Files 2% similar despite different names*

```diff
@@ -20,15 +20,15 @@
 
 import numpy as np
 from monty.json import MSONable, jsanitize
 from pymatgen.analysis.structure_matcher import StructureMatcher
 from pymatgen.core.structure import Structure
 from pymatgen.entries.computed_entries import ComputedStructureEntry
 
-from smol.exceptions import StructureMatchError
+from smol.utils.exceptions import StructureMatchError
 
 
 class StructureWrangler(MSONable):
     """Class to create fitting data to fit a cluster expansion.
 
     A StructureWrangler handles (wrangles) input data structures and properties
     to fit in a cluster expansion. This class holds a ClusterSubspace used to
@@ -758,22 +758,22 @@
                     supercell, entry.structure
                 )
 
             fm_row = self._subspace.corr_from_structure(
                 entry.structure, scmatrix=supercell_matrix, site_mapping=site_mapping
             )
             refined_struct = self._subspace.refine_structure(
-                entry.structure, supercell_matrix
+                entry.structure, scmatrix=supercell_matrix, site_mapping=site_mapping
             )
 
         except StructureMatchError as s_match_error:
             if verbose:
                 warnings.warn(
                     f"Unable to match {entry.composition} with "
-                    f"properties {properties} to supercell_structure. "
+                    f"energy {entry.energy} to supercell_structure. "
                     f"Throwing out.\n Error Message: {str(s_match_error)}",
                     UserWarning,
                 )
             if raise_failed:
                 raise s_match_error
             return None
 
@@ -874,12 +874,12 @@
         Returns:
             MSONable dict
         """
         wrangler_dict = {
             "@module": self.__class__.__module__,
             "@class": self.__class__.__name__,
             "_subspace": self._subspace.as_dict(),
-            "_entries": [entry.as_dict() for entry in self._entries],
-            "_ind_sets": jsanitize(self._ind_sets),  # jic for int's
+            "_entries": jsanitize(self._entries, strict=True),
+            "_ind_sets": jsanitize(self._ind_sets, strict=True),  # jic for int's
             "metadata": self.metadata,
         }
         return wrangler_dict
```

### Comparing `smol-0.3.1/smol/correlations.c` & `smol-0.4.0/smol/utils/cluster/correlations.c`

 * *Files 2% similar despite different names*

```diff
@@ -1,34 +1,34 @@
-/* Generated by Cython 0.29.33 */
+/* Generated by Cython 0.29.35 */
 
 /* BEGIN: Cython Metadata
 {
     "distutils": {
         "depends": [],
         "language": "c",
-        "name": "smol.correlations",
+        "name": "smol.utils.cluster.correlations",
         "sources": [
-            "smol/correlations.pyx"
+            "smol/utils/cluster/correlations.pyx"
         ]
     },
-    "module_name": "smol.correlations"
+    "module_name": "smol.utils.cluster.correlations"
 }
 END: Cython Metadata */
 
 #ifndef PY_SSIZE_T_CLEAN
 #define PY_SSIZE_T_CLEAN
 #endif /* PY_SSIZE_T_CLEAN */
 #include "Python.h"
 #ifndef Py_PYTHON_H
     #error Python headers needed to compile C extensions, please install development version of Python.
 #elif PY_VERSION_HEX < 0x02060000 || (0x03000000 <= PY_VERSION_HEX && PY_VERSION_HEX < 0x03030000)
     #error Cython requires Python 2.6+ or Python 3.3+.
 #else
-#define CYTHON_ABI "0_29_33"
-#define CYTHON_HEX_VERSION 0x001D21F0
+#define CYTHON_ABI "0_29_35"
+#define CYTHON_HEX_VERSION 0x001D23F0
 #define CYTHON_FUTURE_DIVISION 1
 #include <stddef.h>
 #ifndef offsetof
   #define offsetof(type, member) ( (size_t) & ((type*)0) -> member )
 #endif
 #if !defined(WIN32) && !defined(MS_WINDOWS)
   #ifndef __stdcall
@@ -88,16 +88,20 @@
   #define CYTHON_ASSUME_SAFE_MACROS 0
   #undef CYTHON_UNPACK_METHODS
   #define CYTHON_UNPACK_METHODS 0
   #undef CYTHON_FAST_THREAD_STATE
   #define CYTHON_FAST_THREAD_STATE 0
   #undef CYTHON_FAST_PYCALL
   #define CYTHON_FAST_PYCALL 0
-  #undef CYTHON_PEP489_MULTI_PHASE_INIT
-  #define CYTHON_PEP489_MULTI_PHASE_INIT 0
+  #if PY_VERSION_HEX < 0x03090000
+    #undef CYTHON_PEP489_MULTI_PHASE_INIT
+    #define CYTHON_PEP489_MULTI_PHASE_INIT 0
+  #elif !defined(CYTHON_PEP489_MULTI_PHASE_INIT)
+    #define CYTHON_PEP489_MULTI_PHASE_INIT 1
+  #endif
   #undef CYTHON_USE_TP_FINALIZE
   #define CYTHON_USE_TP_FINALIZE 0
   #undef CYTHON_USE_DICT_VERSIONS
   #define CYTHON_USE_DICT_VERSIONS 0
   #undef CYTHON_USE_EXC_INFO_STACK
   #define CYTHON_USE_EXC_INFO_STACK 0
   #ifndef CYTHON_UPDATE_DESCRIPTOR_DOC
@@ -213,15 +217,15 @@
   #elif !defined(CYTHON_USE_ASYNC_SLOTS)
     #define CYTHON_USE_ASYNC_SLOTS 1
   #endif
   #if PY_VERSION_HEX < 0x02070000
     #undef CYTHON_USE_PYLONG_INTERNALS
     #define CYTHON_USE_PYLONG_INTERNALS 0
   #elif !defined(CYTHON_USE_PYLONG_INTERNALS)
-    #define CYTHON_USE_PYLONG_INTERNALS 1
+    #define CYTHON_USE_PYLONG_INTERNALS (PY_VERSION_HEX < 0x030C00A5)
   #endif
   #ifndef CYTHON_USE_PYLIST_INTERNALS
     #define CYTHON_USE_PYLIST_INTERNALS 1
   #endif
   #ifndef CYTHON_USE_UNICODE_INTERNALS
     #define CYTHON_USE_UNICODE_INTERNALS 1
   #endif
@@ -252,15 +256,15 @@
   #ifndef CYTHON_PEP489_MULTI_PHASE_INIT
     #define CYTHON_PEP489_MULTI_PHASE_INIT (PY_VERSION_HEX >= 0x03050000)
   #endif
   #ifndef CYTHON_USE_TP_FINALIZE
     #define CYTHON_USE_TP_FINALIZE (PY_VERSION_HEX >= 0x030400a1)
   #endif
   #ifndef CYTHON_USE_DICT_VERSIONS
-    #define CYTHON_USE_DICT_VERSIONS (PY_VERSION_HEX >= 0x030600B1)
+    #define CYTHON_USE_DICT_VERSIONS ((PY_VERSION_HEX >= 0x030600B1) && (PY_VERSION_HEX < 0x030C00A5))
   #endif
   #if PY_VERSION_HEX >= 0x030B00A4
     #undef CYTHON_USE_EXC_INFO_STACK
     #define CYTHON_USE_EXC_INFO_STACK 0
   #elif !defined(CYTHON_USE_EXC_INFO_STACK)
     #define CYTHON_USE_EXC_INFO_STACK (PY_VERSION_HEX >= 0x030700A3)
   #endif
@@ -748,27 +752,27 @@
   #ifdef __cplusplus
     #define __PYX_EXTERN_C extern "C"
   #else
     #define __PYX_EXTERN_C extern
   #endif
 #endif
 
-#define __PYX_HAVE__smol__correlations
-#define __PYX_HAVE_API__smol__correlations
+#define __PYX_HAVE__smol__utils__cluster__correlations
+#define __PYX_HAVE_API__smol__utils__cluster__correlations
 /* Early includes */
 #include <string.h>
 #include <stdio.h>
 #include "numpy/arrayobject.h"
 #include "numpy/ndarrayobject.h"
 #include "numpy/ndarraytypes.h"
 #include "numpy/arrayscalars.h"
 #include "numpy/ufuncobject.h"
 
     /* NumPy API declarations from "numpy/__init__.pxd" */
-
+    
 #include "pythread.h"
 #include <stdlib.h>
 #include "pystate.h"
 #ifdef _OPENMP
 #include <omp.h>
 #endif /* _OPENMP */
 
@@ -995,15 +999,15 @@
 #if CYTHON_CCOMPLEX && !defined(__cplusplus) && defined(__sun__) && defined(__GNUC__)
   #undef _Complex_I
   #define _Complex_I 1.0fj
 #endif
 
 
 static const char *__pyx_f[] = {
-  "smol/correlations.pyx",
+  "smol/utils/cluster/correlations.pyx",
   "__init__.pxd",
   "stringsource",
   "type.pxd",
 };
 /* MemviewSliceStruct.proto */
 struct __pyx_memoryview_obj;
 typedef struct {
@@ -1105,199 +1109,199 @@
   char enc_type;
   char new_packmode;
   char enc_packmode;
   char is_valid_array;
 } __Pyx_BufFmt_Context;
 
 
-/* "../../miniconda3/envs/matx_310/lib/python3.10/site-packages/numpy/__init__.pxd":689
+/* "../../../../../tmp/build-env-f9bdzduv/lib/python3.10/site-packages/numpy/__init__.pxd":689
  * # in Cython to enable them only on the right systems.
- *
+ * 
  * ctypedef npy_int8       int8_t             # <<<<<<<<<<<<<<
  * ctypedef npy_int16      int16_t
  * ctypedef npy_int32      int32_t
  */
 typedef npy_int8 __pyx_t_5numpy_int8_t;
 
-/* "../../miniconda3/envs/matx_310/lib/python3.10/site-packages/numpy/__init__.pxd":690
- *
+/* "../../../../../tmp/build-env-f9bdzduv/lib/python3.10/site-packages/numpy/__init__.pxd":690
+ * 
  * ctypedef npy_int8       int8_t
  * ctypedef npy_int16      int16_t             # <<<<<<<<<<<<<<
  * ctypedef npy_int32      int32_t
  * ctypedef npy_int64      int64_t
  */
 typedef npy_int16 __pyx_t_5numpy_int16_t;
 
-/* "../../miniconda3/envs/matx_310/lib/python3.10/site-packages/numpy/__init__.pxd":691
+/* "../../../../../tmp/build-env-f9bdzduv/lib/python3.10/site-packages/numpy/__init__.pxd":691
  * ctypedef npy_int8       int8_t
  * ctypedef npy_int16      int16_t
  * ctypedef npy_int32      int32_t             # <<<<<<<<<<<<<<
  * ctypedef npy_int64      int64_t
  * #ctypedef npy_int96      int96_t
  */
 typedef npy_int32 __pyx_t_5numpy_int32_t;
 
-/* "../../miniconda3/envs/matx_310/lib/python3.10/site-packages/numpy/__init__.pxd":692
+/* "../../../../../tmp/build-env-f9bdzduv/lib/python3.10/site-packages/numpy/__init__.pxd":692
  * ctypedef npy_int16      int16_t
  * ctypedef npy_int32      int32_t
  * ctypedef npy_int64      int64_t             # <<<<<<<<<<<<<<
  * #ctypedef npy_int96      int96_t
  * #ctypedef npy_int128     int128_t
  */
 typedef npy_int64 __pyx_t_5numpy_int64_t;
 
-/* "../../miniconda3/envs/matx_310/lib/python3.10/site-packages/numpy/__init__.pxd":696
+/* "../../../../../tmp/build-env-f9bdzduv/lib/python3.10/site-packages/numpy/__init__.pxd":696
  * #ctypedef npy_int128     int128_t
- *
+ * 
  * ctypedef npy_uint8      uint8_t             # <<<<<<<<<<<<<<
  * ctypedef npy_uint16     uint16_t
  * ctypedef npy_uint32     uint32_t
  */
 typedef npy_uint8 __pyx_t_5numpy_uint8_t;
 
-/* "../../miniconda3/envs/matx_310/lib/python3.10/site-packages/numpy/__init__.pxd":697
- *
+/* "../../../../../tmp/build-env-f9bdzduv/lib/python3.10/site-packages/numpy/__init__.pxd":697
+ * 
  * ctypedef npy_uint8      uint8_t
  * ctypedef npy_uint16     uint16_t             # <<<<<<<<<<<<<<
  * ctypedef npy_uint32     uint32_t
  * ctypedef npy_uint64     uint64_t
  */
 typedef npy_uint16 __pyx_t_5numpy_uint16_t;
 
-/* "../../miniconda3/envs/matx_310/lib/python3.10/site-packages/numpy/__init__.pxd":698
+/* "../../../../../tmp/build-env-f9bdzduv/lib/python3.10/site-packages/numpy/__init__.pxd":698
  * ctypedef npy_uint8      uint8_t
  * ctypedef npy_uint16     uint16_t
  * ctypedef npy_uint32     uint32_t             # <<<<<<<<<<<<<<
  * ctypedef npy_uint64     uint64_t
  * #ctypedef npy_uint96     uint96_t
  */
 typedef npy_uint32 __pyx_t_5numpy_uint32_t;
 
-/* "../../miniconda3/envs/matx_310/lib/python3.10/site-packages/numpy/__init__.pxd":699
+/* "../../../../../tmp/build-env-f9bdzduv/lib/python3.10/site-packages/numpy/__init__.pxd":699
  * ctypedef npy_uint16     uint16_t
  * ctypedef npy_uint32     uint32_t
  * ctypedef npy_uint64     uint64_t             # <<<<<<<<<<<<<<
  * #ctypedef npy_uint96     uint96_t
  * #ctypedef npy_uint128    uint128_t
  */
 typedef npy_uint64 __pyx_t_5numpy_uint64_t;
 
-/* "../../miniconda3/envs/matx_310/lib/python3.10/site-packages/numpy/__init__.pxd":703
+/* "../../../../../tmp/build-env-f9bdzduv/lib/python3.10/site-packages/numpy/__init__.pxd":703
  * #ctypedef npy_uint128    uint128_t
- *
+ * 
  * ctypedef npy_float32    float32_t             # <<<<<<<<<<<<<<
  * ctypedef npy_float64    float64_t
  * #ctypedef npy_float80    float80_t
  */
 typedef npy_float32 __pyx_t_5numpy_float32_t;
 
-/* "../../miniconda3/envs/matx_310/lib/python3.10/site-packages/numpy/__init__.pxd":704
- *
+/* "../../../../../tmp/build-env-f9bdzduv/lib/python3.10/site-packages/numpy/__init__.pxd":704
+ * 
  * ctypedef npy_float32    float32_t
  * ctypedef npy_float64    float64_t             # <<<<<<<<<<<<<<
  * #ctypedef npy_float80    float80_t
  * #ctypedef npy_float128   float128_t
  */
 typedef npy_float64 __pyx_t_5numpy_float64_t;
 
-/* "../../miniconda3/envs/matx_310/lib/python3.10/site-packages/numpy/__init__.pxd":713
+/* "../../../../../tmp/build-env-f9bdzduv/lib/python3.10/site-packages/numpy/__init__.pxd":713
  * # The int types are mapped a bit surprising --
  * # numpy.int corresponds to 'l' and numpy.long to 'q'
  * ctypedef npy_long       int_t             # <<<<<<<<<<<<<<
  * ctypedef npy_longlong   long_t
  * ctypedef npy_longlong   longlong_t
  */
 typedef npy_long __pyx_t_5numpy_int_t;
 
-/* "../../miniconda3/envs/matx_310/lib/python3.10/site-packages/numpy/__init__.pxd":714
+/* "../../../../../tmp/build-env-f9bdzduv/lib/python3.10/site-packages/numpy/__init__.pxd":714
  * # numpy.int corresponds to 'l' and numpy.long to 'q'
  * ctypedef npy_long       int_t
  * ctypedef npy_longlong   long_t             # <<<<<<<<<<<<<<
  * ctypedef npy_longlong   longlong_t
- *
+ * 
  */
 typedef npy_longlong __pyx_t_5numpy_long_t;
 
-/* "../../miniconda3/envs/matx_310/lib/python3.10/site-packages/numpy/__init__.pxd":715
+/* "../../../../../tmp/build-env-f9bdzduv/lib/python3.10/site-packages/numpy/__init__.pxd":715
  * ctypedef npy_long       int_t
  * ctypedef npy_longlong   long_t
  * ctypedef npy_longlong   longlong_t             # <<<<<<<<<<<<<<
- *
+ * 
  * ctypedef npy_ulong      uint_t
  */
 typedef npy_longlong __pyx_t_5numpy_longlong_t;
 
-/* "../../miniconda3/envs/matx_310/lib/python3.10/site-packages/numpy/__init__.pxd":717
+/* "../../../../../tmp/build-env-f9bdzduv/lib/python3.10/site-packages/numpy/__init__.pxd":717
  * ctypedef npy_longlong   longlong_t
- *
+ * 
  * ctypedef npy_ulong      uint_t             # <<<<<<<<<<<<<<
  * ctypedef npy_ulonglong  ulong_t
  * ctypedef npy_ulonglong  ulonglong_t
  */
 typedef npy_ulong __pyx_t_5numpy_uint_t;
 
-/* "../../miniconda3/envs/matx_310/lib/python3.10/site-packages/numpy/__init__.pxd":718
- *
+/* "../../../../../tmp/build-env-f9bdzduv/lib/python3.10/site-packages/numpy/__init__.pxd":718
+ * 
  * ctypedef npy_ulong      uint_t
  * ctypedef npy_ulonglong  ulong_t             # <<<<<<<<<<<<<<
  * ctypedef npy_ulonglong  ulonglong_t
- *
+ * 
  */
 typedef npy_ulonglong __pyx_t_5numpy_ulong_t;
 
-/* "../../miniconda3/envs/matx_310/lib/python3.10/site-packages/numpy/__init__.pxd":719
+/* "../../../../../tmp/build-env-f9bdzduv/lib/python3.10/site-packages/numpy/__init__.pxd":719
  * ctypedef npy_ulong      uint_t
  * ctypedef npy_ulonglong  ulong_t
  * ctypedef npy_ulonglong  ulonglong_t             # <<<<<<<<<<<<<<
- *
+ * 
  * ctypedef npy_intp       intp_t
  */
 typedef npy_ulonglong __pyx_t_5numpy_ulonglong_t;
 
-/* "../../miniconda3/envs/matx_310/lib/python3.10/site-packages/numpy/__init__.pxd":721
+/* "../../../../../tmp/build-env-f9bdzduv/lib/python3.10/site-packages/numpy/__init__.pxd":721
  * ctypedef npy_ulonglong  ulonglong_t
- *
+ * 
  * ctypedef npy_intp       intp_t             # <<<<<<<<<<<<<<
  * ctypedef npy_uintp      uintp_t
- *
+ * 
  */
 typedef npy_intp __pyx_t_5numpy_intp_t;
 
-/* "../../miniconda3/envs/matx_310/lib/python3.10/site-packages/numpy/__init__.pxd":722
- *
+/* "../../../../../tmp/build-env-f9bdzduv/lib/python3.10/site-packages/numpy/__init__.pxd":722
+ * 
  * ctypedef npy_intp       intp_t
  * ctypedef npy_uintp      uintp_t             # <<<<<<<<<<<<<<
- *
+ * 
  * ctypedef npy_double     float_t
  */
 typedef npy_uintp __pyx_t_5numpy_uintp_t;
 
-/* "../../miniconda3/envs/matx_310/lib/python3.10/site-packages/numpy/__init__.pxd":724
+/* "../../../../../tmp/build-env-f9bdzduv/lib/python3.10/site-packages/numpy/__init__.pxd":724
  * ctypedef npy_uintp      uintp_t
- *
+ * 
  * ctypedef npy_double     float_t             # <<<<<<<<<<<<<<
  * ctypedef npy_double     double_t
  * ctypedef npy_longdouble longdouble_t
  */
 typedef npy_double __pyx_t_5numpy_float_t;
 
-/* "../../miniconda3/envs/matx_310/lib/python3.10/site-packages/numpy/__init__.pxd":725
- *
+/* "../../../../../tmp/build-env-f9bdzduv/lib/python3.10/site-packages/numpy/__init__.pxd":725
+ * 
  * ctypedef npy_double     float_t
  * ctypedef npy_double     double_t             # <<<<<<<<<<<<<<
  * ctypedef npy_longdouble longdouble_t
- *
+ * 
  */
 typedef npy_double __pyx_t_5numpy_double_t;
 
-/* "../../miniconda3/envs/matx_310/lib/python3.10/site-packages/numpy/__init__.pxd":726
+/* "../../../../../tmp/build-env-f9bdzduv/lib/python3.10/site-packages/numpy/__init__.pxd":726
  * ctypedef npy_double     float_t
  * ctypedef npy_double     double_t
  * ctypedef npy_longdouble longdouble_t             # <<<<<<<<<<<<<<
- *
+ * 
  * ctypedef npy_cfloat      cfloat_t
  */
 typedef npy_longdouble __pyx_t_5numpy_longdouble_t;
 /* Declarations.proto */
 #if CYTHON_CCOMPLEX
   #ifdef __cplusplus
     typedef ::std::complex< float > __pyx_t_float_complex;
@@ -1324,55 +1328,55 @@
 
 /*--- Type declarations ---*/
 struct __pyx_array_obj;
 struct __pyx_MemviewEnum_obj;
 struct __pyx_memoryview_obj;
 struct __pyx_memoryviewslice_obj;
 
-/* "../../miniconda3/envs/matx_310/lib/python3.10/site-packages/numpy/__init__.pxd":728
+/* "../../../../../tmp/build-env-f9bdzduv/lib/python3.10/site-packages/numpy/__init__.pxd":728
  * ctypedef npy_longdouble longdouble_t
- *
+ * 
  * ctypedef npy_cfloat      cfloat_t             # <<<<<<<<<<<<<<
  * ctypedef npy_cdouble     cdouble_t
  * ctypedef npy_clongdouble clongdouble_t
  */
 typedef npy_cfloat __pyx_t_5numpy_cfloat_t;
 
-/* "../../miniconda3/envs/matx_310/lib/python3.10/site-packages/numpy/__init__.pxd":729
- *
+/* "../../../../../tmp/build-env-f9bdzduv/lib/python3.10/site-packages/numpy/__init__.pxd":729
+ * 
  * ctypedef npy_cfloat      cfloat_t
  * ctypedef npy_cdouble     cdouble_t             # <<<<<<<<<<<<<<
  * ctypedef npy_clongdouble clongdouble_t
- *
+ * 
  */
 typedef npy_cdouble __pyx_t_5numpy_cdouble_t;
 
-/* "../../miniconda3/envs/matx_310/lib/python3.10/site-packages/numpy/__init__.pxd":730
+/* "../../../../../tmp/build-env-f9bdzduv/lib/python3.10/site-packages/numpy/__init__.pxd":730
  * ctypedef npy_cfloat      cfloat_t
  * ctypedef npy_cdouble     cdouble_t
  * ctypedef npy_clongdouble clongdouble_t             # <<<<<<<<<<<<<<
- *
+ * 
  * ctypedef npy_cdouble     complex_t
  */
 typedef npy_clongdouble __pyx_t_5numpy_clongdouble_t;
 
-/* "../../miniconda3/envs/matx_310/lib/python3.10/site-packages/numpy/__init__.pxd":732
+/* "../../../../../tmp/build-env-f9bdzduv/lib/python3.10/site-packages/numpy/__init__.pxd":732
  * ctypedef npy_clongdouble clongdouble_t
- *
+ * 
  * ctypedef npy_cdouble     complex_t             # <<<<<<<<<<<<<<
- *
+ * 
  * cdef inline object PyArray_MultiIterNew1(a):
  */
 typedef npy_cdouble __pyx_t_5numpy_complex_t;
 
 /* "View.MemoryView":106
- *
+ * 
  * @cname("__pyx_array")
  * cdef class array:             # <<<<<<<<<<<<<<
- *
+ * 
  *     cdef:
  */
 struct __pyx_array_obj {
   PyObject_HEAD
   struct __pyx_vtabstruct_array *__pyx_vtab;
   char *data;
   Py_ssize_t len;
@@ -1386,31 +1390,31 @@
   void (*callback_free_data)(void *);
   int free_data;
   int dtype_is_object;
 };
 
 
 /* "View.MemoryView":280
- *
+ * 
  * @cname('__pyx_MemviewEnum')
  * cdef class Enum(object):             # <<<<<<<<<<<<<<
  *     cdef object name
  *     def __init__(self, name):
  */
 struct __pyx_MemviewEnum_obj {
   PyObject_HEAD
   PyObject *name;
 };
 
 
 /* "View.MemoryView":331
- *
+ * 
  * @cname('__pyx_memoryview')
  * cdef class memoryview(object):             # <<<<<<<<<<<<<<
- *
+ * 
  *     cdef object obj
  */
 struct __pyx_memoryview_obj {
   PyObject_HEAD
   struct __pyx_vtabstruct_memoryview *__pyx_vtab;
   PyObject *obj;
   PyObject *_size;
@@ -1422,49 +1426,49 @@
   int flags;
   int dtype_is_object;
   __Pyx_TypeInfo *typeinfo;
 };
 
 
 /* "View.MemoryView":967
- *
+ * 
  * @cname('__pyx_memoryviewslice')
  * cdef class _memoryviewslice(memoryview):             # <<<<<<<<<<<<<<
  *     "Internal class for passing memoryview slices to Python"
- *
+ * 
  */
 struct __pyx_memoryviewslice_obj {
   struct __pyx_memoryview_obj __pyx_base;
   __Pyx_memviewslice from_slice;
   PyObject *from_object;
   PyObject *(*to_object_func)(char *);
   int (*to_dtype_func)(char *, PyObject *);
 };
 
 
 
 /* "View.MemoryView":106
- *
+ * 
  * @cname("__pyx_array")
  * cdef class array:             # <<<<<<<<<<<<<<
- *
+ * 
  *     cdef:
  */
 
 struct __pyx_vtabstruct_array {
   PyObject *(*get_memview)(struct __pyx_array_obj *);
 };
 static struct __pyx_vtabstruct_array *__pyx_vtabptr_array;
 
 
 /* "View.MemoryView":331
- *
+ * 
  * @cname('__pyx_memoryview')
  * cdef class memoryview(object):             # <<<<<<<<<<<<<<
- *
+ * 
  *     cdef object obj
  */
 
 struct __pyx_vtabstruct_memoryview {
   char *(*get_item_pointer)(struct __pyx_memoryview_obj *, PyObject *);
   PyObject *(*is_slice)(struct __pyx_memoryview_obj *, PyObject *);
   PyObject *(*setitem_slice_assignment)(struct __pyx_memoryview_obj *, PyObject *, PyObject *);
@@ -1473,19 +1477,19 @@
   PyObject *(*convert_item_to_object)(struct __pyx_memoryview_obj *, char *);
   PyObject *(*assign_item_from_object)(struct __pyx_memoryview_obj *, char *, PyObject *);
 };
 static struct __pyx_vtabstruct_memoryview *__pyx_vtabptr_memoryview;
 
 
 /* "View.MemoryView":967
- *
+ * 
  * @cname('__pyx_memoryviewslice')
  * cdef class _memoryviewslice(memoryview):             # <<<<<<<<<<<<<<
  *     "Internal class for passing memoryview slices to Python"
- *
+ * 
  */
 
 struct __pyx_vtabstruct__memoryviewslice {
   struct __pyx_vtabstruct_memoryview __pyx_base;
 };
 static struct __pyx_vtabstruct__memoryviewslice *__pyx_vtabptr__memoryviewslice;
 
@@ -1700,17 +1704,14 @@
 #define __pyx_get_slice_count_pointer(memview) (memview->acquisition_count_aligned_p)
 #define __pyx_get_slice_count(memview) (*__pyx_get_slice_count_pointer(memview))
 #define __PYX_INC_MEMVIEW(slice, have_gil) __Pyx_INC_MEMVIEW(slice, have_gil, __LINE__)
 #define __PYX_XDEC_MEMVIEW(slice, have_gil) __Pyx_XDEC_MEMVIEW(slice, have_gil, __LINE__)
 static CYTHON_INLINE void __Pyx_INC_MEMVIEW(__Pyx_memviewslice *, int, int);
 static CYTHON_INLINE void __Pyx_XDEC_MEMVIEW(__Pyx_memviewslice *, int, int);
 
-/* ExtTypeTest.proto */
-static CYTHON_INLINE int __Pyx_TypeTest(PyObject *obj, PyTypeObject *type);
-
 /* RaiseArgTupleInvalid.proto */
 static void __Pyx_RaiseArgtupleInvalid(const char* func_name, int exact,
     Py_ssize_t num_min, Py_ssize_t num_max, Py_ssize_t num_found);
 
 /* RaiseDoubleKeywords.proto */
 static void __Pyx_RaiseDoubleKeywordsError(const char* func_name, PyObject* kw_name);
 
@@ -1872,14 +1873,17 @@
 
 /* GetAttr3.proto */
 static CYTHON_INLINE PyObject *__Pyx_GetAttr3(PyObject *, PyObject *, PyObject *);
 
 /* RaiseNoneIterError.proto */
 static CYTHON_INLINE void __Pyx_RaiseNoneNotIterableError(void);
 
+/* ExtTypeTest.proto */
+static CYTHON_INLINE int __Pyx_TypeTest(PyObject *obj, PyTypeObject *type);
+
 /* SwapException.proto */
 #if CYTHON_FAST_THREAD_STATE
 #define __Pyx_ExceptionSwap(type, value, tb)  __Pyx__ExceptionSwap(__pyx_tstate, type, value, tb)
 static CYTHON_INLINE void __Pyx__ExceptionSwap(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb);
 #else
 static CYTHON_INLINE void __Pyx_ExceptionSwap(PyObject **type, PyObject **value, PyObject **tb);
 #endif
@@ -1991,22 +1995,30 @@
 /* PyObjectGetAttrStrNoError.proto */
 static CYTHON_INLINE PyObject* __Pyx_PyObject_GetAttrStrNoError(PyObject* obj, PyObject* attr_name);
 
 /* SetupReduce.proto */
 static int __Pyx_setup_reduce(PyObject* type_obj);
 
 /* TypeImport.proto */
-#ifndef __PYX_HAVE_RT_ImportType_proto
-#define __PYX_HAVE_RT_ImportType_proto
-enum __Pyx_ImportType_CheckSize {
-   __Pyx_ImportType_CheckSize_Error = 0,
-   __Pyx_ImportType_CheckSize_Warn = 1,
-   __Pyx_ImportType_CheckSize_Ignore = 2
+#ifndef __PYX_HAVE_RT_ImportType_proto_0_29_35
+#define __PYX_HAVE_RT_ImportType_proto_0_29_35
+#if __STDC_VERSION__ >= 201112L
+#include <stdalign.h>
+#endif
+#if __STDC_VERSION__ >= 201112L || __cplusplus >= 201103L
+#define __PYX_GET_STRUCT_ALIGNMENT_0_29_35(s) alignof(s)
+#else
+#define __PYX_GET_STRUCT_ALIGNMENT_0_29_35(s) sizeof(void*)
+#endif
+enum __Pyx_ImportType_CheckSize_0_29_35 {
+   __Pyx_ImportType_CheckSize_Error_0_29_35 = 0,
+   __Pyx_ImportType_CheckSize_Warn_0_29_35 = 1,
+   __Pyx_ImportType_CheckSize_Ignore_0_29_35 = 2
 };
-static PyTypeObject *__Pyx_ImportType(PyObject* module, const char *module_name, const char *class_name, size_t size, enum __Pyx_ImportType_CheckSize check_size);
+static PyTypeObject *__Pyx_ImportType_0_29_35(PyObject* module, const char *module_name, const char *class_name, size_t size, size_t alignment, enum __Pyx_ImportType_CheckSize_0_29_35 check_size);
 #endif
 
 /* CLineInTraceback.proto */
 #ifdef CYTHON_CLINE_IN_TRACEBACK
 #define __Pyx_CLineForTraceback(tstate, c_line)  (((CYTHON_CLINE_IN_TRACEBACK)) ? c_line : 0)
 #else
 static int __Pyx_CLineForTraceback(PyThreadState *tstate, int c_line);
@@ -2093,27 +2105,30 @@
 
 /* GCCDiagnostics.proto */
 #if defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 6))
 #define __Pyx_HAS_GCC_DIAGNOSTIC
 #endif
 
 /* ObjectToMemviewSlice.proto */
+static CYTHON_INLINE __Pyx_memviewslice __Pyx_PyObject_to_MemoryviewSlice_dc_double__const__(PyObject *, int writable_flag);
+
+/* ObjectToMemviewSlice.proto */
 static CYTHON_INLINE __Pyx_memviewslice __Pyx_PyObject_to_MemoryviewSlice_d_dc_double__const__(PyObject *, int writable_flag);
 
 /* ObjectToMemviewSlice.proto */
 static CYTHON_INLINE __Pyx_memviewslice __Pyx_PyObject_to_MemoryviewSlice_d_dc_long__const__(PyObject *, int writable_flag);
 
 /* ObjectToMemviewSlice.proto */
 static CYTHON_INLINE __Pyx_memviewslice __Pyx_PyObject_to_MemoryviewSlice_ds_double(PyObject *, int writable_flag);
 
 /* ObjectToMemviewSlice.proto */
 static CYTHON_INLINE __Pyx_memviewslice __Pyx_PyObject_to_MemoryviewSlice_dc_double(PyObject *, int writable_flag);
 
 /* ObjectToMemviewSlice.proto */
-static CYTHON_INLINE __Pyx_memviewslice __Pyx_PyObject_to_MemoryviewSlice_dc_double__const__(PyObject *, int writable_flag);
+static CYTHON_INLINE __Pyx_memviewslice __Pyx_PyObject_to_MemoryviewSlice_d_dc_double(PyObject *, int writable_flag);
 
 /* RealImag.proto */
 #if CYTHON_CCOMPLEX
   #ifdef __cplusplus
     #define __Pyx_CREAL(z) ((z).real())
     #define __Pyx_CIMAG(z) ((z).imag())
   #else
@@ -2218,20 +2233,20 @@
 
 /* CIntFromPy.proto */
 static CYTHON_INLINE int __Pyx_PyInt_As_int(PyObject *);
 
 /* CIntToPy.proto */
 static CYTHON_INLINE PyObject* __Pyx_PyInt_From_int(int value);
 
-/* CIntToPy.proto */
-static CYTHON_INLINE PyObject* __Pyx_PyInt_From_long(long value);
-
 /* CIntFromPy.proto */
 static CYTHON_INLINE long __Pyx_PyInt_As_long(PyObject *);
 
+/* CIntToPy.proto */
+static CYTHON_INLINE PyObject* __Pyx_PyInt_From_long(long value);
+
 /* CIntFromPy.proto */
 static CYTHON_INLINE char __Pyx_PyInt_As_char(PyObject *);
 
 /* CheckBinaryVersion.proto */
 static int __Pyx_check_binary_version(void);
 
 /* InitStrings.proto */
@@ -2282,32 +2297,33 @@
 static PyTypeObject *__pyx_ptype_5numpy_inexact = 0;
 static PyTypeObject *__pyx_ptype_5numpy_floating = 0;
 static PyTypeObject *__pyx_ptype_5numpy_complexfloating = 0;
 static PyTypeObject *__pyx_ptype_5numpy_flexible = 0;
 static PyTypeObject *__pyx_ptype_5numpy_character = 0;
 static PyTypeObject *__pyx_ptype_5numpy_ufunc = 0;
 
-/* Module declarations from 'smol.correlations' */
+/* Module declarations from 'smol.utils.cluster.correlations' */
 static PyTypeObject *__pyx_array_type = 0;
 static PyTypeObject *__pyx_MemviewEnum_type = 0;
 static PyTypeObject *__pyx_memoryview_type = 0;
 static PyTypeObject *__pyx_memoryviewslice_type = 0;
 static PyObject *generic = 0;
 static PyObject *strided = 0;
 static PyObject *indirect = 0;
 static PyObject *contiguous = 0;
 static PyObject *indirect_contiguous = 0;
 static int __pyx_memoryview_thread_locks_used;
 static PyThread_type_lock __pyx_memoryview_thread_locks[8];
-static PyArrayObject *__pyx_f_4smol_12correlations_corr_from_occupancy(__Pyx_memviewslice, int const , PyObject *, int __pyx_skip_dispatch); /*proto*/
-static PyObject *__pyx_f_4smol_12correlations_delta_corr_single_flip(__Pyx_memviewslice, __Pyx_memviewslice, int const , PyObject *, int __pyx_skip_dispatch); /*proto*/
-static PyObject *__pyx_f_4smol_12correlations_indicator_delta_corr_single_flip(__Pyx_memviewslice, __Pyx_memviewslice, int const , PyObject *, int __pyx_skip_dispatch); /*proto*/
-static PyObject *__pyx_f_4smol_12correlations_delta_ewald_single_flip(__Pyx_memviewslice, __Pyx_memviewslice, __Pyx_memviewslice, __Pyx_memviewslice, int const , int __pyx_skip_dispatch); /*proto*/
-static PyObject *__pyx_f_4smol_12correlations_interactions_from_occupancy(__Pyx_memviewslice, int const , double const , PyObject *, int __pyx_skip_dispatch); /*proto*/
-static PyObject *__pyx_f_4smol_12correlations_delta_interactions_single_flip(__Pyx_memviewslice, __Pyx_memviewslice, int const , PyObject *, int __pyx_skip_dispatch); /*proto*/
+static PyObject *__pyx_f_4smol_5utils_7cluster_12correlations_corr_from_occupancy(__Pyx_memviewslice, int const , PyObject *, int __pyx_skip_dispatch); /*proto*/
+static PyObject *__pyx_f_4smol_5utils_7cluster_12correlations_delta_corr_single_flip(__Pyx_memviewslice, __Pyx_memviewslice, int const , PyObject *, int __pyx_skip_dispatch); /*proto*/
+static PyObject *__pyx_f_4smol_5utils_7cluster_12correlations_corr_distance_single_flip(__Pyx_memviewslice, __Pyx_memviewslice, __Pyx_memviewslice, int const , PyObject *, int __pyx_skip_dispatch); /*proto*/
+static PyObject *__pyx_f_4smol_5utils_7cluster_12correlations_interactions_from_occupancy(__Pyx_memviewslice, int const , double const , PyObject *, int __pyx_skip_dispatch); /*proto*/
+static PyObject *__pyx_f_4smol_5utils_7cluster_12correlations_delta_interactions_single_flip(__Pyx_memviewslice, __Pyx_memviewslice, int const , PyObject *, int __pyx_skip_dispatch); /*proto*/
+static PyObject *__pyx_f_4smol_5utils_7cluster_12correlations_interaction_distance_single_flip(__Pyx_memviewslice, __Pyx_memviewslice, __Pyx_memviewslice, int const , PyObject *, int __pyx_skip_dispatch); /*proto*/
+static PyObject *__pyx_f_4smol_5utils_7cluster_12correlations_delta_ewald_single_flip(__Pyx_memviewslice, __Pyx_memviewslice, __Pyx_memviewslice, __Pyx_memviewslice, int const , int __pyx_skip_dispatch); /*proto*/
 static struct __pyx_array_obj *__pyx_array_new(PyObject *, Py_ssize_t, char *, char *, char *); /*proto*/
 static void *__pyx_align_pointer(void *, size_t); /*proto*/
 static PyObject *__pyx_memoryview_new(PyObject *, int, int, __Pyx_TypeInfo *); /*proto*/
 static CYTHON_INLINE int __pyx_memoryview_check(PyObject *); /*proto*/
 static PyObject *_unellipsify(PyObject *, int); /*proto*/
 static PyObject *assert_direct_dimensions(Py_ssize_t *, int); /*proto*/
 static struct __pyx_memoryview_obj *__pyx_memview_slice(struct __pyx_memoryview_obj *, PyObject *); /*proto*/
@@ -2336,19 +2352,19 @@
 static void __pyx_memoryview_refcount_objects_in_slice(char *, Py_ssize_t *, Py_ssize_t *, int, int); /*proto*/
 static void __pyx_memoryview_slice_assign_scalar(__Pyx_memviewslice *, int, size_t, void *, int); /*proto*/
 static void __pyx_memoryview__slice_assign_scalar(char *, Py_ssize_t *, Py_ssize_t *, int, size_t, void *); /*proto*/
 static PyObject *__pyx_unpickle_Enum__set_state(struct __pyx_MemviewEnum_obj *, PyObject *); /*proto*/
 static __Pyx_TypeInfo __Pyx_TypeInfo_long__const__ = { "const long", NULL, sizeof(long const ), { 0 }, 0, IS_UNSIGNED(long const ) ? 'U' : 'I', IS_UNSIGNED(long const ), 0 };
 static __Pyx_TypeInfo __Pyx_TypeInfo_double__const__ = { "const double", NULL, sizeof(double const ), { 0 }, 0, 'R', 0, 0 };
 static __Pyx_TypeInfo __Pyx_TypeInfo_double = { "double", NULL, sizeof(double), { 0 }, 0, 'R', 0, 0 };
-#define __Pyx_MODULE_NAME "smol.correlations"
-extern int __pyx_module_is_main_smol__correlations;
-int __pyx_module_is_main_smol__correlations = 0;
+#define __Pyx_MODULE_NAME "smol.utils.cluster.correlations"
+extern int __pyx_module_is_main_smol__utils__cluster__correlations;
+int __pyx_module_is_main_smol__utils__cluster__correlations = 0;
 
-/* Implementation of 'smol.correlations' */
+/* Implementation of 'smol.utils.cluster.correlations' */
 static PyObject *__pyx_builtin_range;
 static PyObject *__pyx_builtin_ImportError;
 static PyObject *__pyx_builtin_ValueError;
 static PyObject *__pyx_builtin_MemoryError;
 static PyObject *__pyx_builtin_enumerate;
 static PyObject *__pyx_builtin_TypeError;
 static PyObject *__pyx_builtin_Ellipsis;
@@ -2420,24 +2436,26 @@
 static const char __pyx_k_ewald_indices[] = "ewald_indices";
 static const char __pyx_k_pyx_getbuffer[] = "__pyx_getbuffer";
 static const char __pyx_k_reduce_cython[] = "__reduce_cython__";
 static const char __pyx_k_View_MemoryView[] = "View.MemoryView";
 static const char __pyx_k_allocate_buffer[] = "allocate_buffer";
 static const char __pyx_k_dtype_is_object[] = "dtype_is_object";
 static const char __pyx_k_pyx_PickleError[] = "__pyx_PickleError";
+static const char __pyx_k_ref_corr_vector[] = "ref_corr_vector";
 static const char __pyx_k_setstate_cython[] = "__setstate_cython__";
 static const char __pyx_k_site_orbit_list[] = "site_orbit_list";
 static const char __pyx_k_num_interactions[] = "num_interactions";
 static const char __pyx_k_pyx_unpickle_Enum[] = "__pyx_unpickle_Enum";
 static const char __pyx_k_cline_in_traceback[] = "cline_in_traceback";
 static const char __pyx_k_num_corr_functions[] = "num_corr_functions";
 static const char __pyx_k_strided_and_direct[] = "<strided and direct>";
 static const char __pyx_k_strided_and_indirect[] = "<strided and indirect>";
 static const char __pyx_k_contiguous_and_direct[] = "<contiguous and direct>";
 static const char __pyx_k_MemoryView_of_r_object[] = "<MemoryView of %r object>";
+static const char __pyx_k_ref_interaction_vector[] = "ref_interaction_vector";
 static const char __pyx_k_MemoryView_of_r_at_0x_x[] = "<MemoryView of %r at 0x%x>";
 static const char __pyx_k_contiguous_and_indirect[] = "<contiguous and indirect>";
 static const char __pyx_k_Cannot_index_with_type_s[] = "Cannot index with type '%s'";
 static const char __pyx_k_Invalid_shape_in_axis_d_d[] = "Invalid shape in axis %d: %d.";
 static const char __pyx_k_itemsize_0_for_cython_array[] = "itemsize <= 0 for cython.array";
 static const char __pyx_k_unable_to_allocate_array_data[] = "unable to allocate array data.";
 static const char __pyx_k_strided_and_direct_or_indirect[] = "<strided and direct or indirect>";
@@ -2539,14 +2557,16 @@
 static PyObject *__pyx_n_s_pyx_type;
 static PyObject *__pyx_n_s_pyx_unpickle_Enum;
 static PyObject *__pyx_n_s_pyx_vtable;
 static PyObject *__pyx_n_s_range;
 static PyObject *__pyx_n_s_reduce;
 static PyObject *__pyx_n_s_reduce_cython;
 static PyObject *__pyx_n_s_reduce_ex;
+static PyObject *__pyx_n_s_ref_corr_vector;
+static PyObject *__pyx_n_s_ref_interaction_vector;
 static PyObject *__pyx_n_s_setstate;
 static PyObject *__pyx_n_s_setstate_cython;
 static PyObject *__pyx_n_s_shape;
 static PyObject *__pyx_n_s_site_ind;
 static PyObject *__pyx_n_s_site_orbit_list;
 static PyObject *__pyx_n_s_size;
 static PyObject *__pyx_n_s_start;
@@ -2559,20 +2579,21 @@
 static PyObject *__pyx_n_s_struct;
 static PyObject *__pyx_n_s_test;
 static PyObject *__pyx_kp_s_unable_to_allocate_array_data;
 static PyObject *__pyx_kp_s_unable_to_allocate_shape_and_str;
 static PyObject *__pyx_n_s_unpack;
 static PyObject *__pyx_n_s_update;
 static PyObject *__pyx_n_s_zeros;
-static PyObject *__pyx_pf_4smol_12correlations_corr_from_occupancy(CYTHON_UNUSED PyObject *__pyx_self, __Pyx_memviewslice __pyx_v_occu, int __pyx_v_num_corr_functions, PyObject *__pyx_v_orbit_list); /* proto */
-static PyObject *__pyx_pf_4smol_12correlations_2delta_corr_single_flip(CYTHON_UNUSED PyObject *__pyx_self, __Pyx_memviewslice __pyx_v_occu_f, __Pyx_memviewslice __pyx_v_occu_i, int __pyx_v_num_corr_functions, PyObject *__pyx_v_site_orbit_list); /* proto */
-static PyObject *__pyx_pf_4smol_12correlations_4indicator_delta_corr_single_flip(CYTHON_UNUSED PyObject *__pyx_self, __Pyx_memviewslice __pyx_v_occu_f, __Pyx_memviewslice __pyx_v_occu_i, int __pyx_v_num_corr_functions, PyObject *__pyx_v_site_orbit_list); /* proto */
-static PyObject *__pyx_pf_4smol_12correlations_6delta_ewald_single_flip(CYTHON_UNUSED PyObject *__pyx_self, __Pyx_memviewslice __pyx_v_occu_f, __Pyx_memviewslice __pyx_v_occu_i, __Pyx_memviewslice __pyx_v_ewald_matrix, __Pyx_memviewslice __pyx_v_ewald_indices, int __pyx_v_site_ind); /* proto */
-static PyObject *__pyx_pf_4smol_12correlations_8interactions_from_occupancy(CYTHON_UNUSED PyObject *__pyx_self, __Pyx_memviewslice __pyx_v_occu, int __pyx_v_num_interactions, double __pyx_v_offset, PyObject *__pyx_v_orbit_list); /* proto */
-static PyObject *__pyx_pf_4smol_12correlations_10delta_interactions_single_flip(CYTHON_UNUSED PyObject *__pyx_self, __Pyx_memviewslice __pyx_v_occu_f, __Pyx_memviewslice __pyx_v_occu_i, int __pyx_v_num_interactions, PyObject *__pyx_v_site_orbit_list); /* proto */
+static PyObject *__pyx_pf_4smol_5utils_7cluster_12correlations_corr_from_occupancy(CYTHON_UNUSED PyObject *__pyx_self, __Pyx_memviewslice __pyx_v_occu, int __pyx_v_num_corr_functions, PyObject *__pyx_v_orbit_list); /* proto */
+static PyObject *__pyx_pf_4smol_5utils_7cluster_12correlations_2delta_corr_single_flip(CYTHON_UNUSED PyObject *__pyx_self, __Pyx_memviewslice __pyx_v_occu_f, __Pyx_memviewslice __pyx_v_occu_i, int __pyx_v_num_corr_functions, PyObject *__pyx_v_site_orbit_list); /* proto */
+static PyObject *__pyx_pf_4smol_5utils_7cluster_12correlations_4corr_distance_single_flip(CYTHON_UNUSED PyObject *__pyx_self, __Pyx_memviewslice __pyx_v_occu_f, __Pyx_memviewslice __pyx_v_occu_i, __Pyx_memviewslice __pyx_v_ref_corr_vector, int __pyx_v_num_corr_functions, PyObject *__pyx_v_orbit_list); /* proto */
+static PyObject *__pyx_pf_4smol_5utils_7cluster_12correlations_6interactions_from_occupancy(CYTHON_UNUSED PyObject *__pyx_self, __Pyx_memviewslice __pyx_v_occu, int __pyx_v_num_interactions, double __pyx_v_offset, PyObject *__pyx_v_orbit_list); /* proto */
+static PyObject *__pyx_pf_4smol_5utils_7cluster_12correlations_8delta_interactions_single_flip(CYTHON_UNUSED PyObject *__pyx_self, __Pyx_memviewslice __pyx_v_occu_f, __Pyx_memviewslice __pyx_v_occu_i, int __pyx_v_num_interactions, PyObject *__pyx_v_site_orbit_list); /* proto */
+static PyObject *__pyx_pf_4smol_5utils_7cluster_12correlations_10interaction_distance_single_flip(CYTHON_UNUSED PyObject *__pyx_self, __Pyx_memviewslice __pyx_v_occu_f, __Pyx_memviewslice __pyx_v_occu_i, __Pyx_memviewslice __pyx_v_ref_interaction_vector, int __pyx_v_num_interactions, PyObject *__pyx_v_orbit_list); /* proto */
+static PyObject *__pyx_pf_4smol_5utils_7cluster_12correlations_12delta_ewald_single_flip(CYTHON_UNUSED PyObject *__pyx_self, __Pyx_memviewslice __pyx_v_occu_f, __Pyx_memviewslice __pyx_v_occu_i, __Pyx_memviewslice __pyx_v_ewald_matrix, __Pyx_memviewslice __pyx_v_ewald_indices, int __pyx_v_site_ind); /* proto */
 static int __pyx_array___pyx_pf_15View_dot_MemoryView_5array___cinit__(struct __pyx_array_obj *__pyx_v_self, PyObject *__pyx_v_shape, Py_ssize_t __pyx_v_itemsize, PyObject *__pyx_v_format, PyObject *__pyx_v_mode, int __pyx_v_allocate_buffer); /* proto */
 static int __pyx_array___pyx_pf_15View_dot_MemoryView_5array_2__getbuffer__(struct __pyx_array_obj *__pyx_v_self, Py_buffer *__pyx_v_info, int __pyx_v_flags); /* proto */
 static void __pyx_array___pyx_pf_15View_dot_MemoryView_5array_4__dealloc__(struct __pyx_array_obj *__pyx_v_self); /* proto */
 static PyObject *__pyx_pf_15View_dot_MemoryView_5array_7memview___get__(struct __pyx_array_obj *__pyx_v_self); /* proto */
 static Py_ssize_t __pyx_array___pyx_pf_15View_dot_MemoryView_5array_6__len__(struct __pyx_array_obj *__pyx_v_self); /* proto */
 static PyObject *__pyx_array___pyx_pf_15View_dot_MemoryView_5array_8__getattr__(struct __pyx_array_obj *__pyx_v_self, PyObject *__pyx_v_attr); /* proto */
 static PyObject *__pyx_array___pyx_pf_15View_dot_MemoryView_5array_10__getitem__(struct __pyx_array_obj *__pyx_v_self, PyObject *__pyx_v_item); /* proto */
@@ -2613,14 +2634,15 @@
 static PyObject *__pyx_pf_15View_dot_MemoryView___pyx_unpickle_Enum(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v___pyx_type, long __pyx_v___pyx_checksum, PyObject *__pyx_v___pyx_state); /* proto */
 static PyObject *__pyx_tp_new_array(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
 static PyObject *__pyx_tp_new_Enum(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
 static PyObject *__pyx_tp_new_memoryview(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
 static PyObject *__pyx_tp_new__memoryviewslice(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
 static PyObject *__pyx_int_0;
 static PyObject *__pyx_int_1;
+static PyObject *__pyx_int_2;
 static PyObject *__pyx_int_112105877;
 static PyObject *__pyx_int_136983863;
 static PyObject *__pyx_int_184977713;
 static PyObject *__pyx_int_neg_1;
 static PyObject *__pyx_tuple_;
 static PyObject *__pyx_tuple__2;
 static PyObject *__pyx_tuple__3;
@@ -2647,39 +2669,39 @@
 static PyObject *__pyx_tuple__24;
 static PyObject *__pyx_tuple__25;
 static PyObject *__pyx_tuple__26;
 static PyObject *__pyx_tuple__27;
 static PyObject *__pyx_codeobj__28;
 /* Late includes */
 
-/* "smol/correlations.pyx":18
- *
- *
- * cpdef np.ndarray corr_from_occupancy(const long[::1] occu,             # <<<<<<<<<<<<<<
+/* "smol/utils/cluster/correlations.pyx":18
+ * 
+ * 
+ * cpdef corr_from_occupancy(const long[::1] occu,             # <<<<<<<<<<<<<<
  *                           const int num_corr_functions,
  *                           list orbit_list):
  */
 
-static PyObject *__pyx_pw_4smol_12correlations_1corr_from_occupancy(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
-static PyArrayObject *__pyx_f_4smol_12correlations_corr_from_occupancy(__Pyx_memviewslice __pyx_v_occu, int const __pyx_v_num_corr_functions, PyObject *__pyx_v_orbit_list, CYTHON_UNUSED int __pyx_skip_dispatch) {
+static PyObject *__pyx_pw_4smol_5utils_7cluster_12correlations_1corr_from_occupancy(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static PyObject *__pyx_f_4smol_5utils_7cluster_12correlations_corr_from_occupancy(__Pyx_memviewslice __pyx_v_occu, int const __pyx_v_num_corr_functions, PyObject *__pyx_v_orbit_list, CYTHON_UNUSED int __pyx_skip_dispatch) {
   int __pyx_v_i;
   int __pyx_v_j;
   int __pyx_v_n;
   int __pyx_v_m;
   int __pyx_v_I;
   int __pyx_v_J;
   int __pyx_v_M;
   int __pyx_v_index;
   double __pyx_v_p;
   __Pyx_memviewslice __pyx_v_indices = { 0, 0, { 0 }, { 0 }, { 0 } };
   __Pyx_memviewslice __pyx_v_tensor_indices = { 0, 0, { 0 }, { 0 }, { 0 } };
   __Pyx_memviewslice __pyx_v_corr_tensors = { 0, 0, { 0 }, { 0 }, { 0 } };
   PyObject *__pyx_v_out = NULL;
   __Pyx_memviewslice __pyx_v_o_view = { 0, 0, { 0 }, { 0 }, { 0 } };
-  PyArrayObject *__pyx_r = NULL;
+  PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   PyObject *__pyx_t_2 = NULL;
   PyObject *__pyx_t_3 = NULL;
   PyObject *__pyx_t_4 = NULL;
   __Pyx_memviewslice __pyx_t_5 = { 0, 0, { 0 }, { 0 }, { 0 } };
   Py_ssize_t __pyx_t_6;
@@ -2704,15 +2726,15 @@
   Py_ssize_t __pyx_t_25;
   Py_ssize_t __pyx_t_26;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("corr_from_occupancy", 0);
 
-  /* "smol/correlations.pyx":41
+  /* "smol/utils/cluster/correlations.pyx":41
  *     cdef const long[::1] tensor_indices
  *     cdef const double[:, ::1] corr_tensors
  *     out = np.zeros(num_corr_functions)             # <<<<<<<<<<<<<<
  *     cdef double[:] o_view = out
  *     o_view[0] = 1  # empty cluster
  */
   __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_np); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 41, __pyx_L1_error)
@@ -2737,39 +2759,39 @@
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 41, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __pyx_v_out = __pyx_t_1;
   __pyx_t_1 = 0;
 
-  /* "smol/correlations.pyx":42
+  /* "smol/utils/cluster/correlations.pyx":42
  *     cdef const double[:, ::1] corr_tensors
  *     out = np.zeros(num_corr_functions)
  *     cdef double[:] o_view = out             # <<<<<<<<<<<<<<
  *     o_view[0] = 1  # empty cluster
- *
+ * 
  */
   __pyx_t_5 = __Pyx_PyObject_to_MemoryviewSlice_ds_double(__pyx_v_out, PyBUF_WRITABLE); if (unlikely(!__pyx_t_5.memview)) __PYX_ERR(0, 42, __pyx_L1_error)
   __pyx_v_o_view = __pyx_t_5;
   __pyx_t_5.memview = NULL;
   __pyx_t_5.data = NULL;
 
-  /* "smol/correlations.pyx":43
+  /* "smol/utils/cluster/correlations.pyx":43
  *     out = np.zeros(num_corr_functions)
  *     cdef double[:] o_view = out
  *     o_view[0] = 1  # empty cluster             # <<<<<<<<<<<<<<
- *
+ * 
  *     for n, tensor_indices, corr_tensors, indices in orbit_list:
  */
   __pyx_t_6 = 0;
   *((double *) ( /* dim=0 */ (__pyx_v_o_view.data + __pyx_t_6 * __pyx_v_o_view.strides[0]) )) = 1.0;
 
-  /* "smol/correlations.pyx":45
+  /* "smol/utils/cluster/correlations.pyx":45
  *     o_view[0] = 1  # empty cluster
- *
+ * 
  *     for n, tensor_indices, corr_tensors, indices in orbit_list:             # <<<<<<<<<<<<<<
  *         M = corr_tensors.shape[0]  # index of bit combos
  *         I = indices.shape[0] # cluster index
  */
   if (unlikely(__pyx_v_orbit_list == Py_None)) {
     PyErr_SetString(PyExc_TypeError, "'NoneType' object is not iterable");
     __PYX_ERR(0, 45, __pyx_L1_error)
@@ -2789,23 +2811,23 @@
       if (unlikely(size != 4)) {
         if (size > 4) __Pyx_RaiseTooManyValuesError(4);
         else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
         __PYX_ERR(0, 45, __pyx_L1_error)
       }
       #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
       if (likely(PyTuple_CheckExact(sequence))) {
-        __pyx_t_2 = PyTuple_GET_ITEM(sequence, 0);
-        __pyx_t_4 = PyTuple_GET_ITEM(sequence, 1);
-        __pyx_t_8 = PyTuple_GET_ITEM(sequence, 2);
-        __pyx_t_9 = PyTuple_GET_ITEM(sequence, 3);
+        __pyx_t_2 = PyTuple_GET_ITEM(sequence, 0); 
+        __pyx_t_4 = PyTuple_GET_ITEM(sequence, 1); 
+        __pyx_t_8 = PyTuple_GET_ITEM(sequence, 2); 
+        __pyx_t_9 = PyTuple_GET_ITEM(sequence, 3); 
       } else {
-        __pyx_t_2 = PyList_GET_ITEM(sequence, 0);
-        __pyx_t_4 = PyList_GET_ITEM(sequence, 1);
-        __pyx_t_8 = PyList_GET_ITEM(sequence, 2);
-        __pyx_t_9 = PyList_GET_ITEM(sequence, 3);
+        __pyx_t_2 = PyList_GET_ITEM(sequence, 0); 
+        __pyx_t_4 = PyList_GET_ITEM(sequence, 1); 
+        __pyx_t_8 = PyList_GET_ITEM(sequence, 2); 
+        __pyx_t_9 = PyList_GET_ITEM(sequence, 3); 
       }
       __Pyx_INCREF(__pyx_t_2);
       __Pyx_INCREF(__pyx_t_4);
       __Pyx_INCREF(__pyx_t_8);
       __Pyx_INCREF(__pyx_t_9);
       #else
       {
@@ -2860,168 +2882,167 @@
     __pyx_t_14.memview = NULL;
     __pyx_t_14.data = NULL;
     __PYX_XDEC_MEMVIEW(&__pyx_v_indices, 1);
     __pyx_v_indices = __pyx_t_15;
     __pyx_t_15.memview = NULL;
     __pyx_t_15.data = NULL;
 
-    /* "smol/correlations.pyx":46
- *
+    /* "smol/utils/cluster/correlations.pyx":46
+ * 
  *     for n, tensor_indices, corr_tensors, indices in orbit_list:
  *         M = corr_tensors.shape[0]  # index of bit combos             # <<<<<<<<<<<<<<
  *         I = indices.shape[0] # cluster index
  *         J = indices.shape[1] # index within cluster
  */
     __pyx_v_M = (__pyx_v_corr_tensors.shape[0]);
 
-    /* "smol/correlations.pyx":47
+    /* "smol/utils/cluster/correlations.pyx":47
  *     for n, tensor_indices, corr_tensors, indices in orbit_list:
  *         M = corr_tensors.shape[0]  # index of bit combos
  *         I = indices.shape[0] # cluster index             # <<<<<<<<<<<<<<
  *         J = indices.shape[1] # index within cluster
  *         for m in range(M):
  */
     __pyx_v_I = (__pyx_v_indices.shape[0]);
 
-    /* "smol/correlations.pyx":48
+    /* "smol/utils/cluster/correlations.pyx":48
  *         M = corr_tensors.shape[0]  # index of bit combos
  *         I = indices.shape[0] # cluster index
  *         J = indices.shape[1] # index within cluster             # <<<<<<<<<<<<<<
  *         for m in range(M):
  *             p = 0
  */
     __pyx_v_J = (__pyx_v_indices.shape[1]);
 
-    /* "smol/correlations.pyx":49
+    /* "smol/utils/cluster/correlations.pyx":49
  *         I = indices.shape[0] # cluster index
  *         J = indices.shape[1] # index within cluster
  *         for m in range(M):             # <<<<<<<<<<<<<<
  *             p = 0
  *             for i in range(I):
  */
     __pyx_t_12 = __pyx_v_M;
     __pyx_t_16 = __pyx_t_12;
     for (__pyx_t_17 = 0; __pyx_t_17 < __pyx_t_16; __pyx_t_17+=1) {
       __pyx_v_m = __pyx_t_17;
 
-      /* "smol/correlations.pyx":50
+      /* "smol/utils/cluster/correlations.pyx":50
  *         J = indices.shape[1] # index within cluster
  *         for m in range(M):
  *             p = 0             # <<<<<<<<<<<<<<
  *             for i in range(I):
  *                 index = 0
  */
       __pyx_v_p = 0.0;
 
-      /* "smol/correlations.pyx":51
+      /* "smol/utils/cluster/correlations.pyx":51
  *         for m in range(M):
  *             p = 0
  *             for i in range(I):             # <<<<<<<<<<<<<<
  *                 index = 0
  *                 for j in range(J):
  */
       __pyx_t_18 = __pyx_v_I;
       __pyx_t_19 = __pyx_t_18;
       for (__pyx_t_20 = 0; __pyx_t_20 < __pyx_t_19; __pyx_t_20+=1) {
         __pyx_v_i = __pyx_t_20;
 
-        /* "smol/correlations.pyx":52
+        /* "smol/utils/cluster/correlations.pyx":52
  *             p = 0
  *             for i in range(I):
  *                 index = 0             # <<<<<<<<<<<<<<
  *                 for j in range(J):
  *                     index += tensor_indices[j] * occu[indices[i, j]]
  */
         __pyx_v_index = 0;
 
-        /* "smol/correlations.pyx":53
+        /* "smol/utils/cluster/correlations.pyx":53
  *             for i in range(I):
  *                 index = 0
  *                 for j in range(J):             # <<<<<<<<<<<<<<
  *                     index += tensor_indices[j] * occu[indices[i, j]]
  *                 p += corr_tensors[m, index]
  */
         __pyx_t_21 = __pyx_v_J;
         __pyx_t_22 = __pyx_t_21;
         for (__pyx_t_23 = 0; __pyx_t_23 < __pyx_t_22; __pyx_t_23+=1) {
           __pyx_v_j = __pyx_t_23;
 
-          /* "smol/correlations.pyx":54
+          /* "smol/utils/cluster/correlations.pyx":54
  *                 index = 0
  *                 for j in range(J):
  *                     index += tensor_indices[j] * occu[indices[i, j]]             # <<<<<<<<<<<<<<
  *                 p += corr_tensors[m, index]
  *             o_view[n] = p / I
  */
           __pyx_t_6 = __pyx_v_j;
           __pyx_t_24 = __pyx_v_i;
           __pyx_t_25 = __pyx_v_j;
           __pyx_t_26 = (*((long const  *) ( /* dim=1 */ ((char *) (((long const  *) ( /* dim=0 */ (__pyx_v_indices.data + __pyx_t_24 * __pyx_v_indices.strides[0]) )) + __pyx_t_25)) )));
           __pyx_v_index = (__pyx_v_index + ((*((long const  *) ( /* dim=0 */ ((char *) (((long const  *) __pyx_v_tensor_indices.data) + __pyx_t_6)) ))) * (*((long const  *) ( /* dim=0 */ ((char *) (((long const  *) __pyx_v_occu.data) + __pyx_t_26)) )))));
         }
 
-        /* "smol/correlations.pyx":55
+        /* "smol/utils/cluster/correlations.pyx":55
  *                 for j in range(J):
  *                     index += tensor_indices[j] * occu[indices[i, j]]
  *                 p += corr_tensors[m, index]             # <<<<<<<<<<<<<<
  *             o_view[n] = p / I
  *             n += 1
  */
         __pyx_t_25 = __pyx_v_m;
         __pyx_t_24 = __pyx_v_index;
         __pyx_v_p = (__pyx_v_p + (*((double const  *) ( /* dim=1 */ ((char *) (((double const  *) ( /* dim=0 */ (__pyx_v_corr_tensors.data + __pyx_t_25 * __pyx_v_corr_tensors.strides[0]) )) + __pyx_t_24)) ))));
       }
 
-      /* "smol/correlations.pyx":56
+      /* "smol/utils/cluster/correlations.pyx":56
  *                     index += tensor_indices[j] * occu[indices[i, j]]
  *                 p += corr_tensors[m, index]
  *             o_view[n] = p / I             # <<<<<<<<<<<<<<
  *             n += 1
  *     return out
  */
       __pyx_t_24 = __pyx_v_n;
       *((double *) ( /* dim=0 */ (__pyx_v_o_view.data + __pyx_t_24 * __pyx_v_o_view.strides[0]) )) = (__pyx_v_p / ((double)__pyx_v_I));
 
-      /* "smol/correlations.pyx":57
+      /* "smol/utils/cluster/correlations.pyx":57
  *                 p += corr_tensors[m, index]
  *             o_view[n] = p / I
  *             n += 1             # <<<<<<<<<<<<<<
  *     return out
- *
+ * 
  */
       __pyx_v_n = (__pyx_v_n + 1);
     }
 
-    /* "smol/correlations.pyx":45
+    /* "smol/utils/cluster/correlations.pyx":45
  *     o_view[0] = 1  # empty cluster
- *
+ * 
  *     for n, tensor_indices, corr_tensors, indices in orbit_list:             # <<<<<<<<<<<<<<
  *         M = corr_tensors.shape[0]  # index of bit combos
  *         I = indices.shape[0] # cluster index
  */
   }
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "smol/correlations.pyx":58
+  /* "smol/utils/cluster/correlations.pyx":58
  *             o_view[n] = p / I
  *             n += 1
  *     return out             # <<<<<<<<<<<<<<
- *
- *
+ * 
+ * 
  */
-  __Pyx_XDECREF(((PyObject *)__pyx_r));
-  if (!(likely(((__pyx_v_out) == Py_None) || likely(__Pyx_TypeTest(__pyx_v_out, __pyx_ptype_5numpy_ndarray))))) __PYX_ERR(0, 58, __pyx_L1_error)
+  __Pyx_XDECREF(__pyx_r);
   __Pyx_INCREF(__pyx_v_out);
-  __pyx_r = ((PyArrayObject *)__pyx_v_out);
+  __pyx_r = __pyx_v_out;
   goto __pyx_L0;
 
-  /* "smol/correlations.pyx":18
- *
- *
- * cpdef np.ndarray corr_from_occupancy(const long[::1] occu,             # <<<<<<<<<<<<<<
+  /* "smol/utils/cluster/correlations.pyx":18
+ * 
+ * 
+ * cpdef corr_from_occupancy(const long[::1] occu,             # <<<<<<<<<<<<<<
  *                           const int num_corr_functions,
  *                           list orbit_list):
  */
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
@@ -3031,31 +3052,31 @@
   __PYX_XDEC_MEMVIEW(&__pyx_t_5, 1);
   __Pyx_XDECREF(__pyx_t_8);
   __Pyx_XDECREF(__pyx_t_9);
   __Pyx_XDECREF(__pyx_t_10);
   __PYX_XDEC_MEMVIEW(&__pyx_t_13, 1);
   __PYX_XDEC_MEMVIEW(&__pyx_t_14, 1);
   __PYX_XDEC_MEMVIEW(&__pyx_t_15, 1);
-  __Pyx_AddTraceback("smol.correlations.corr_from_occupancy", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_AddTraceback("smol.utils.cluster.correlations.corr_from_occupancy", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = 0;
   __pyx_L0:;
   __PYX_XDEC_MEMVIEW(&__pyx_v_indices, 1);
   __PYX_XDEC_MEMVIEW(&__pyx_v_tensor_indices, 1);
   __PYX_XDEC_MEMVIEW(&__pyx_v_corr_tensors, 1);
   __Pyx_XDECREF(__pyx_v_out);
   __PYX_XDEC_MEMVIEW(&__pyx_v_o_view, 1);
-  __Pyx_XGIVEREF((PyObject *)__pyx_r);
+  __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* Python wrapper */
-static PyObject *__pyx_pw_4smol_12correlations_1corr_from_occupancy(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
-static char __pyx_doc_4smol_12correlations_corr_from_occupancy[] = "Computes the correlation vector for a given encoded occupancy string.\n\n    Args:\n        occu (ndarray):\n            encoded occupancy vector\n        num_corr_functions (int):\n            total number of bit orderings in expansion.\n        orbit_list:\n            Information of all orbits.\n            (orbit id, flat tensor index array, flat correlation tensor,\n             site indices of clusters)\n\n    Returns: array\n        correlation vector for given occupancy\n    ";
-static PyObject *__pyx_pw_4smol_12correlations_1corr_from_occupancy(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
+static PyObject *__pyx_pw_4smol_5utils_7cluster_12correlations_1corr_from_occupancy(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static char __pyx_doc_4smol_5utils_7cluster_12correlations_corr_from_occupancy[] = "Computes the correlation vector for a given encoded occupancy string.\n\n    Args:\n        occu (ndarray):\n            encoded occupancy array\n        num_corr_functions (int):\n            total number of bit orderings in expansion.\n        orbit_list:\n            Information of all orbits.\n            (orbit id, flat tensor index array, flat correlation tensor,\n             site indices of clusters)\n\n    Returns: array\n        correlation vector for given occupancy\n    ";
+static PyObject *__pyx_pw_4smol_5utils_7cluster_12correlations_1corr_from_occupancy(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
   __Pyx_memviewslice __pyx_v_occu = { 0, 0, { 0 }, { 0 }, { 0 } };
   int __pyx_v_num_corr_functions;
   PyObject *__pyx_v_orbit_list = 0;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   PyObject *__pyx_r = 0;
@@ -3109,67 +3130,67 @@
     __pyx_v_num_corr_functions = __Pyx_PyInt_As_int(values[1]); if (unlikely((__pyx_v_num_corr_functions == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 19, __pyx_L3_error)
     __pyx_v_orbit_list = ((PyObject*)values[2]);
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
   __Pyx_RaiseArgtupleInvalid("corr_from_occupancy", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 18, __pyx_L3_error)
   __pyx_L3_error:;
-  __Pyx_AddTraceback("smol.correlations.corr_from_occupancy", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_AddTraceback("smol.utils.cluster.correlations.corr_from_occupancy", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
   if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_orbit_list), (&PyList_Type), 1, "orbit_list", 1))) __PYX_ERR(0, 20, __pyx_L1_error)
-  __pyx_r = __pyx_pf_4smol_12correlations_corr_from_occupancy(__pyx_self, __pyx_v_occu, __pyx_v_num_corr_functions, __pyx_v_orbit_list);
+  __pyx_r = __pyx_pf_4smol_5utils_7cluster_12correlations_corr_from_occupancy(__pyx_self, __pyx_v_occu, __pyx_v_num_corr_functions, __pyx_v_orbit_list);
 
   /* function exit code */
   goto __pyx_L0;
   __pyx_L1_error:;
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-static PyObject *__pyx_pf_4smol_12correlations_corr_from_occupancy(CYTHON_UNUSED PyObject *__pyx_self, __Pyx_memviewslice __pyx_v_occu, int __pyx_v_num_corr_functions, PyObject *__pyx_v_orbit_list) {
+static PyObject *__pyx_pf_4smol_5utils_7cluster_12correlations_corr_from_occupancy(CYTHON_UNUSED PyObject *__pyx_self, __Pyx_memviewslice __pyx_v_occu, int __pyx_v_num_corr_functions, PyObject *__pyx_v_orbit_list) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("corr_from_occupancy", 0);
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = ((PyObject *)__pyx_f_4smol_12correlations_corr_from_occupancy(__pyx_v_occu, __pyx_v_num_corr_functions, __pyx_v_orbit_list, 0)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 18, __pyx_L1_error)
+  __pyx_t_1 = __pyx_f_4smol_5utils_7cluster_12correlations_corr_from_occupancy(__pyx_v_occu, __pyx_v_num_corr_functions, __pyx_v_orbit_list, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 18, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
-  __Pyx_AddTraceback("smol.correlations.corr_from_occupancy", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_AddTraceback("smol.utils.cluster.correlations.corr_from_occupancy", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __pyx_L0:;
   __PYX_XDEC_MEMVIEW(&__pyx_v_occu, 1);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "smol/correlations.pyx":61
- *
- *
+/* "smol/utils/cluster/correlations.pyx":61
+ * 
+ * 
  * cpdef delta_corr_single_flip(const long[::1] occu_f,             # <<<<<<<<<<<<<<
  *                              const long[::1] occu_i,
  *                              const int num_corr_functions,
  */
 
-static PyObject *__pyx_pw_4smol_12correlations_3delta_corr_single_flip(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
-static PyObject *__pyx_f_4smol_12correlations_delta_corr_single_flip(__Pyx_memviewslice __pyx_v_occu_f, __Pyx_memviewslice __pyx_v_occu_i, int const __pyx_v_num_corr_functions, PyObject *__pyx_v_site_orbit_list, CYTHON_UNUSED int __pyx_skip_dispatch) {
+static PyObject *__pyx_pw_4smol_5utils_7cluster_12correlations_3delta_corr_single_flip(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static PyObject *__pyx_f_4smol_5utils_7cluster_12correlations_delta_corr_single_flip(__Pyx_memviewslice __pyx_v_occu_f, __Pyx_memviewslice __pyx_v_occu_i, int const __pyx_v_num_corr_functions, PyObject *__pyx_v_site_orbit_list, CYTHON_UNUSED int __pyx_skip_dispatch) {
   int __pyx_v_i;
   int __pyx_v_j;
   int __pyx_v_n;
   int __pyx_v_m;
   int __pyx_v_I;
   int __pyx_v_J;
   int __pyx_v_M;
@@ -3213,150 +3234,150 @@
   Py_ssize_t __pyx_t_27;
   Py_ssize_t __pyx_t_28;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("delta_corr_single_flip", 0);
 
-  /* "smol/correlations.pyx":89
+  /* "smol/utils/cluster/correlations.pyx":88
  *     cdef const long[::1] tensor_indices
  *     cdef const double[:, ::1] corr_tensors
  *     out = np.zeros(num_corr_functions)             # <<<<<<<<<<<<<<
  *     cdef double[::1] o_view = out
- *
+ * 
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_np); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 89, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_np); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 88, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_zeros); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 89, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_zeros); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 88, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_2 = __Pyx_PyInt_From_int(__pyx_v_num_corr_functions); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 89, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyInt_From_int(__pyx_v_num_corr_functions); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 88, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_t_4 = NULL;
   if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
     __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
     if (likely(__pyx_t_4)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
       __Pyx_INCREF(__pyx_t_4);
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_3, function);
     }
   }
   __pyx_t_1 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_4, __pyx_t_2) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_2);
   __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 89, __pyx_L1_error)
+  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 88, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __pyx_v_out = __pyx_t_1;
   __pyx_t_1 = 0;
 
-  /* "smol/correlations.pyx":90
+  /* "smol/utils/cluster/correlations.pyx":89
  *     cdef const double[:, ::1] corr_tensors
  *     out = np.zeros(num_corr_functions)
  *     cdef double[::1] o_view = out             # <<<<<<<<<<<<<<
- *
+ * 
  *     for n, ratio, tensor_indices, corr_tensors, indices in site_orbit_list:
  */
-  __pyx_t_5 = __Pyx_PyObject_to_MemoryviewSlice_dc_double(__pyx_v_out, PyBUF_WRITABLE); if (unlikely(!__pyx_t_5.memview)) __PYX_ERR(0, 90, __pyx_L1_error)
+  __pyx_t_5 = __Pyx_PyObject_to_MemoryviewSlice_dc_double(__pyx_v_out, PyBUF_WRITABLE); if (unlikely(!__pyx_t_5.memview)) __PYX_ERR(0, 89, __pyx_L1_error)
   __pyx_v_o_view = __pyx_t_5;
   __pyx_t_5.memview = NULL;
   __pyx_t_5.data = NULL;
 
-  /* "smol/correlations.pyx":92
+  /* "smol/utils/cluster/correlations.pyx":91
  *     cdef double[::1] o_view = out
- *
+ * 
  *     for n, ratio, tensor_indices, corr_tensors, indices in site_orbit_list:             # <<<<<<<<<<<<<<
  *         M = corr_tensors.shape[0] # index of bit combos
  *         I = indices.shape[0] # cluster index
  */
   if (unlikely(__pyx_v_site_orbit_list == Py_None)) {
     PyErr_SetString(PyExc_TypeError, "'NoneType' object is not iterable");
-    __PYX_ERR(0, 92, __pyx_L1_error)
+    __PYX_ERR(0, 91, __pyx_L1_error)
   }
   __pyx_t_1 = __pyx_v_site_orbit_list; __Pyx_INCREF(__pyx_t_1); __pyx_t_6 = 0;
   for (;;) {
     if (__pyx_t_6 >= PyList_GET_SIZE(__pyx_t_1)) break;
     #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-    __pyx_t_3 = PyList_GET_ITEM(__pyx_t_1, __pyx_t_6); __Pyx_INCREF(__pyx_t_3); __pyx_t_6++; if (unlikely(0 < 0)) __PYX_ERR(0, 92, __pyx_L1_error)
+    __pyx_t_3 = PyList_GET_ITEM(__pyx_t_1, __pyx_t_6); __Pyx_INCREF(__pyx_t_3); __pyx_t_6++; if (unlikely(0 < 0)) __PYX_ERR(0, 91, __pyx_L1_error)
     #else
-    __pyx_t_3 = PySequence_ITEM(__pyx_t_1, __pyx_t_6); __pyx_t_6++; if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 92, __pyx_L1_error)
+    __pyx_t_3 = PySequence_ITEM(__pyx_t_1, __pyx_t_6); __pyx_t_6++; if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 91, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     #endif
     if ((likely(PyTuple_CheckExact(__pyx_t_3))) || (PyList_CheckExact(__pyx_t_3))) {
       PyObject* sequence = __pyx_t_3;
       Py_ssize_t size = __Pyx_PySequence_SIZE(sequence);
       if (unlikely(size != 5)) {
         if (size > 5) __Pyx_RaiseTooManyValuesError(5);
         else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
-        __PYX_ERR(0, 92, __pyx_L1_error)
+        __PYX_ERR(0, 91, __pyx_L1_error)
       }
       #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
       if (likely(PyTuple_CheckExact(sequence))) {
-        __pyx_t_2 = PyTuple_GET_ITEM(sequence, 0);
-        __pyx_t_4 = PyTuple_GET_ITEM(sequence, 1);
-        __pyx_t_7 = PyTuple_GET_ITEM(sequence, 2);
-        __pyx_t_8 = PyTuple_GET_ITEM(sequence, 3);
-        __pyx_t_9 = PyTuple_GET_ITEM(sequence, 4);
+        __pyx_t_2 = PyTuple_GET_ITEM(sequence, 0); 
+        __pyx_t_4 = PyTuple_GET_ITEM(sequence, 1); 
+        __pyx_t_7 = PyTuple_GET_ITEM(sequence, 2); 
+        __pyx_t_8 = PyTuple_GET_ITEM(sequence, 3); 
+        __pyx_t_9 = PyTuple_GET_ITEM(sequence, 4); 
       } else {
-        __pyx_t_2 = PyList_GET_ITEM(sequence, 0);
-        __pyx_t_4 = PyList_GET_ITEM(sequence, 1);
-        __pyx_t_7 = PyList_GET_ITEM(sequence, 2);
-        __pyx_t_8 = PyList_GET_ITEM(sequence, 3);
-        __pyx_t_9 = PyList_GET_ITEM(sequence, 4);
+        __pyx_t_2 = PyList_GET_ITEM(sequence, 0); 
+        __pyx_t_4 = PyList_GET_ITEM(sequence, 1); 
+        __pyx_t_7 = PyList_GET_ITEM(sequence, 2); 
+        __pyx_t_8 = PyList_GET_ITEM(sequence, 3); 
+        __pyx_t_9 = PyList_GET_ITEM(sequence, 4); 
       }
       __Pyx_INCREF(__pyx_t_2);
       __Pyx_INCREF(__pyx_t_4);
       __Pyx_INCREF(__pyx_t_7);
       __Pyx_INCREF(__pyx_t_8);
       __Pyx_INCREF(__pyx_t_9);
       #else
       {
         Py_ssize_t i;
         PyObject** temps[5] = {&__pyx_t_2,&__pyx_t_4,&__pyx_t_7,&__pyx_t_8,&__pyx_t_9};
         for (i=0; i < 5; i++) {
-          PyObject* item = PySequence_ITEM(sequence, i); if (unlikely(!item)) __PYX_ERR(0, 92, __pyx_L1_error)
+          PyObject* item = PySequence_ITEM(sequence, i); if (unlikely(!item)) __PYX_ERR(0, 91, __pyx_L1_error)
           __Pyx_GOTREF(item);
           *(temps[i]) = item;
         }
       }
       #endif
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     } else {
       Py_ssize_t index = -1;
       PyObject** temps[5] = {&__pyx_t_2,&__pyx_t_4,&__pyx_t_7,&__pyx_t_8,&__pyx_t_9};
-      __pyx_t_10 = PyObject_GetIter(__pyx_t_3); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 92, __pyx_L1_error)
+      __pyx_t_10 = PyObject_GetIter(__pyx_t_3); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 91, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_10);
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
       __pyx_t_11 = Py_TYPE(__pyx_t_10)->tp_iternext;
       for (index=0; index < 5; index++) {
         PyObject* item = __pyx_t_11(__pyx_t_10); if (unlikely(!item)) goto __pyx_L5_unpacking_failed;
         __Pyx_GOTREF(item);
         *(temps[index]) = item;
       }
-      if (__Pyx_IternextUnpackEndCheck(__pyx_t_11(__pyx_t_10), 5) < 0) __PYX_ERR(0, 92, __pyx_L1_error)
+      if (__Pyx_IternextUnpackEndCheck(__pyx_t_11(__pyx_t_10), 5) < 0) __PYX_ERR(0, 91, __pyx_L1_error)
       __pyx_t_11 = NULL;
       __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
       goto __pyx_L6_unpacking_done;
       __pyx_L5_unpacking_failed:;
       __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
       __pyx_t_11 = NULL;
       if (__Pyx_IterFinish() == 0) __Pyx_RaiseNeedMoreValuesError(index);
-      __PYX_ERR(0, 92, __pyx_L1_error)
+      __PYX_ERR(0, 91, __pyx_L1_error)
       __pyx_L6_unpacking_done:;
     }
-    __pyx_t_12 = __Pyx_PyInt_As_int(__pyx_t_2); if (unlikely((__pyx_t_12 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 92, __pyx_L1_error)
+    __pyx_t_12 = __Pyx_PyInt_As_int(__pyx_t_2); if (unlikely((__pyx_t_12 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 91, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __pyx_t_13 = __pyx_PyFloat_AsDouble(__pyx_t_4); if (unlikely((__pyx_t_13 == (double)-1) && PyErr_Occurred())) __PYX_ERR(0, 92, __pyx_L1_error)
+    __pyx_t_13 = __pyx_PyFloat_AsDouble(__pyx_t_4); if (unlikely((__pyx_t_13 == (double)-1) && PyErr_Occurred())) __PYX_ERR(0, 91, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-    __pyx_t_14 = __Pyx_PyObject_to_MemoryviewSlice_dc_long__const__(__pyx_t_7, 0); if (unlikely(!__pyx_t_14.memview)) __PYX_ERR(0, 92, __pyx_L1_error)
+    __pyx_t_14 = __Pyx_PyObject_to_MemoryviewSlice_dc_long__const__(__pyx_t_7, 0); if (unlikely(!__pyx_t_14.memview)) __PYX_ERR(0, 91, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-    __pyx_t_15 = __Pyx_PyObject_to_MemoryviewSlice_d_dc_double__const__(__pyx_t_8, 0); if (unlikely(!__pyx_t_15.memview)) __PYX_ERR(0, 92, __pyx_L1_error)
+    __pyx_t_15 = __Pyx_PyObject_to_MemoryviewSlice_d_dc_double__const__(__pyx_t_8, 0); if (unlikely(!__pyx_t_15.memview)) __PYX_ERR(0, 91, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
-    __pyx_t_16 = __Pyx_PyObject_to_MemoryviewSlice_d_dc_long__const__(__pyx_t_9, 0); if (unlikely(!__pyx_t_16.memview)) __PYX_ERR(0, 92, __pyx_L1_error)
+    __pyx_t_16 = __Pyx_PyObject_to_MemoryviewSlice_d_dc_long__const__(__pyx_t_9, 0); if (unlikely(!__pyx_t_16.memview)) __PYX_ERR(0, 91, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
     __pyx_v_n = __pyx_t_12;
     __pyx_v_ratio = __pyx_t_13;
     __PYX_XDEC_MEMVIEW(&__pyx_v_tensor_indices, 1);
     __pyx_v_tensor_indices = __pyx_t_14;
     __pyx_t_14.memview = NULL;
     __pyx_t_14.data = NULL;
@@ -3365,184 +3386,184 @@
     __pyx_t_15.memview = NULL;
     __pyx_t_15.data = NULL;
     __PYX_XDEC_MEMVIEW(&__pyx_v_indices, 1);
     __pyx_v_indices = __pyx_t_16;
     __pyx_t_16.memview = NULL;
     __pyx_t_16.data = NULL;
 
-    /* "smol/correlations.pyx":93
- *
+    /* "smol/utils/cluster/correlations.pyx":92
+ * 
  *     for n, ratio, tensor_indices, corr_tensors, indices in site_orbit_list:
  *         M = corr_tensors.shape[0] # index of bit combos             # <<<<<<<<<<<<<<
  *         I = indices.shape[0] # cluster index
  *         J = indices.shape[1] # index within cluster
  */
     __pyx_v_M = (__pyx_v_corr_tensors.shape[0]);
 
-    /* "smol/correlations.pyx":94
+    /* "smol/utils/cluster/correlations.pyx":93
  *     for n, ratio, tensor_indices, corr_tensors, indices in site_orbit_list:
  *         M = corr_tensors.shape[0] # index of bit combos
  *         I = indices.shape[0] # cluster index             # <<<<<<<<<<<<<<
  *         J = indices.shape[1] # index within cluster
  *         for m in range(M):
  */
     __pyx_v_I = (__pyx_v_indices.shape[0]);
 
-    /* "smol/correlations.pyx":95
+    /* "smol/utils/cluster/correlations.pyx":94
  *         M = corr_tensors.shape[0] # index of bit combos
  *         I = indices.shape[0] # cluster index
  *         J = indices.shape[1] # index within cluster             # <<<<<<<<<<<<<<
  *         for m in range(M):
  *             p = 0
  */
     __pyx_v_J = (__pyx_v_indices.shape[1]);
 
-    /* "smol/correlations.pyx":96
+    /* "smol/utils/cluster/correlations.pyx":95
  *         I = indices.shape[0] # cluster index
  *         J = indices.shape[1] # index within cluster
  *         for m in range(M):             # <<<<<<<<<<<<<<
  *             p = 0
  *             for i in range(I):
  */
     __pyx_t_12 = __pyx_v_M;
     __pyx_t_17 = __pyx_t_12;
     for (__pyx_t_18 = 0; __pyx_t_18 < __pyx_t_17; __pyx_t_18+=1) {
       __pyx_v_m = __pyx_t_18;
 
-      /* "smol/correlations.pyx":97
+      /* "smol/utils/cluster/correlations.pyx":96
  *         J = indices.shape[1] # index within cluster
  *         for m in range(M):
  *             p = 0             # <<<<<<<<<<<<<<
  *             for i in range(I):
  *                 ind_i, ind_f = 0, 0
  */
       __pyx_v_p = 0.0;
 
-      /* "smol/correlations.pyx":98
+      /* "smol/utils/cluster/correlations.pyx":97
  *         for m in range(M):
  *             p = 0
  *             for i in range(I):             # <<<<<<<<<<<<<<
  *                 ind_i, ind_f = 0, 0
  *                 for j in range(J):
  */
       __pyx_t_19 = __pyx_v_I;
       __pyx_t_20 = __pyx_t_19;
       for (__pyx_t_21 = 0; __pyx_t_21 < __pyx_t_20; __pyx_t_21+=1) {
         __pyx_v_i = __pyx_t_21;
 
-        /* "smol/correlations.pyx":99
+        /* "smol/utils/cluster/correlations.pyx":98
  *             p = 0
  *             for i in range(I):
  *                 ind_i, ind_f = 0, 0             # <<<<<<<<<<<<<<
  *                 for j in range(J):
  *                     ind_i += tensor_indices[j] * occu_i[indices[i, j]]
  */
         __pyx_t_22 = 0;
         __pyx_t_23 = 0;
         __pyx_v_ind_i = __pyx_t_22;
         __pyx_v_ind_f = __pyx_t_23;
 
-        /* "smol/correlations.pyx":100
+        /* "smol/utils/cluster/correlations.pyx":99
  *             for i in range(I):
  *                 ind_i, ind_f = 0, 0
  *                 for j in range(J):             # <<<<<<<<<<<<<<
  *                     ind_i += tensor_indices[j] * occu_i[indices[i, j]]
  *                     ind_f += tensor_indices[j] * occu_f[indices[i, j]]
  */
         __pyx_t_23 = __pyx_v_J;
         __pyx_t_22 = __pyx_t_23;
         for (__pyx_t_24 = 0; __pyx_t_24 < __pyx_t_22; __pyx_t_24+=1) {
           __pyx_v_j = __pyx_t_24;
 
-          /* "smol/correlations.pyx":101
+          /* "smol/utils/cluster/correlations.pyx":100
  *                 ind_i, ind_f = 0, 0
  *                 for j in range(J):
  *                     ind_i += tensor_indices[j] * occu_i[indices[i, j]]             # <<<<<<<<<<<<<<
  *                     ind_f += tensor_indices[j] * occu_f[indices[i, j]]
  *                 p += (corr_tensors[m, ind_f] - corr_tensors[m, ind_i])
  */
           __pyx_t_25 = __pyx_v_j;
           __pyx_t_26 = __pyx_v_i;
           __pyx_t_27 = __pyx_v_j;
           __pyx_t_28 = (*((long const  *) ( /* dim=1 */ ((char *) (((long const  *) ( /* dim=0 */ (__pyx_v_indices.data + __pyx_t_26 * __pyx_v_indices.strides[0]) )) + __pyx_t_27)) )));
           __pyx_v_ind_i = (__pyx_v_ind_i + ((*((long const  *) ( /* dim=0 */ ((char *) (((long const  *) __pyx_v_tensor_indices.data) + __pyx_t_25)) ))) * (*((long const  *) ( /* dim=0 */ ((char *) (((long const  *) __pyx_v_occu_i.data) + __pyx_t_28)) )))));
 
-          /* "smol/correlations.pyx":102
+          /* "smol/utils/cluster/correlations.pyx":101
  *                 for j in range(J):
  *                     ind_i += tensor_indices[j] * occu_i[indices[i, j]]
  *                     ind_f += tensor_indices[j] * occu_f[indices[i, j]]             # <<<<<<<<<<<<<<
  *                 p += (corr_tensors[m, ind_f] - corr_tensors[m, ind_i])
  *             o_view[n] = p / ratio / I
  */
           __pyx_t_27 = __pyx_v_j;
           __pyx_t_26 = __pyx_v_i;
           __pyx_t_28 = __pyx_v_j;
           __pyx_t_25 = (*((long const  *) ( /* dim=1 */ ((char *) (((long const  *) ( /* dim=0 */ (__pyx_v_indices.data + __pyx_t_26 * __pyx_v_indices.strides[0]) )) + __pyx_t_28)) )));
           __pyx_v_ind_f = (__pyx_v_ind_f + ((*((long const  *) ( /* dim=0 */ ((char *) (((long const  *) __pyx_v_tensor_indices.data) + __pyx_t_27)) ))) * (*((long const  *) ( /* dim=0 */ ((char *) (((long const  *) __pyx_v_occu_f.data) + __pyx_t_25)) )))));
         }
 
-        /* "smol/correlations.pyx":103
+        /* "smol/utils/cluster/correlations.pyx":102
  *                     ind_i += tensor_indices[j] * occu_i[indices[i, j]]
  *                     ind_f += tensor_indices[j] * occu_f[indices[i, j]]
  *                 p += (corr_tensors[m, ind_f] - corr_tensors[m, ind_i])             # <<<<<<<<<<<<<<
  *             o_view[n] = p / ratio / I
  *             n += 1
  */
         __pyx_t_28 = __pyx_v_m;
         __pyx_t_26 = __pyx_v_ind_f;
         __pyx_t_25 = __pyx_v_m;
         __pyx_t_27 = __pyx_v_ind_i;
         __pyx_v_p = (__pyx_v_p + ((*((double const  *) ( /* dim=1 */ ((char *) (((double const  *) ( /* dim=0 */ (__pyx_v_corr_tensors.data + __pyx_t_28 * __pyx_v_corr_tensors.strides[0]) )) + __pyx_t_26)) ))) - (*((double const  *) ( /* dim=1 */ ((char *) (((double const  *) ( /* dim=0 */ (__pyx_v_corr_tensors.data + __pyx_t_25 * __pyx_v_corr_tensors.strides[0]) )) + __pyx_t_27)) )))));
       }
 
-      /* "smol/correlations.pyx":104
+      /* "smol/utils/cluster/correlations.pyx":103
  *                     ind_f += tensor_indices[j] * occu_f[indices[i, j]]
  *                 p += (corr_tensors[m, ind_f] - corr_tensors[m, ind_i])
  *             o_view[n] = p / ratio / I             # <<<<<<<<<<<<<<
  *             n += 1
  *     return out
  */
       __pyx_t_27 = __pyx_v_n;
       *((double *) ( /* dim=0 */ ((char *) (((double *) __pyx_v_o_view.data) + __pyx_t_27)) )) = ((__pyx_v_p / __pyx_v_ratio) / ((double)__pyx_v_I));
 
-      /* "smol/correlations.pyx":105
+      /* "smol/utils/cluster/correlations.pyx":104
  *                 p += (corr_tensors[m, ind_f] - corr_tensors[m, ind_i])
  *             o_view[n] = p / ratio / I
  *             n += 1             # <<<<<<<<<<<<<<
  *     return out
- *
+ * 
  */
       __pyx_v_n = (__pyx_v_n + 1);
     }
 
-    /* "smol/correlations.pyx":92
+    /* "smol/utils/cluster/correlations.pyx":91
  *     cdef double[::1] o_view = out
- *
+ * 
  *     for n, ratio, tensor_indices, corr_tensors, indices in site_orbit_list:             # <<<<<<<<<<<<<<
  *         M = corr_tensors.shape[0] # index of bit combos
  *         I = indices.shape[0] # cluster index
  */
   }
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "smol/correlations.pyx":106
+  /* "smol/utils/cluster/correlations.pyx":105
  *             o_view[n] = p / ratio / I
  *             n += 1
  *     return out             # <<<<<<<<<<<<<<
- *
- *
+ * 
+ * 
  */
   __Pyx_XDECREF(__pyx_r);
   __Pyx_INCREF(__pyx_v_out);
   __pyx_r = __pyx_v_out;
   goto __pyx_L0;
 
-  /* "smol/correlations.pyx":61
- *
- *
+  /* "smol/utils/cluster/correlations.pyx":61
+ * 
+ * 
  * cpdef delta_corr_single_flip(const long[::1] occu_f,             # <<<<<<<<<<<<<<
  *                              const long[::1] occu_i,
  *                              const int num_corr_functions,
  */
 
   /* function exit code */
   __pyx_L1_error:;
@@ -3554,31 +3575,31 @@
   __Pyx_XDECREF(__pyx_t_7);
   __Pyx_XDECREF(__pyx_t_8);
   __Pyx_XDECREF(__pyx_t_9);
   __Pyx_XDECREF(__pyx_t_10);
   __PYX_XDEC_MEMVIEW(&__pyx_t_14, 1);
   __PYX_XDEC_MEMVIEW(&__pyx_t_15, 1);
   __PYX_XDEC_MEMVIEW(&__pyx_t_16, 1);
-  __Pyx_AddTraceback("smol.correlations.delta_corr_single_flip", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_AddTraceback("smol.utils.cluster.correlations.delta_corr_single_flip", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = 0;
   __pyx_L0:;
   __PYX_XDEC_MEMVIEW(&__pyx_v_indices, 1);
   __PYX_XDEC_MEMVIEW(&__pyx_v_tensor_indices, 1);
   __PYX_XDEC_MEMVIEW(&__pyx_v_corr_tensors, 1);
   __Pyx_XDECREF(__pyx_v_out);
   __PYX_XDEC_MEMVIEW(&__pyx_v_o_view, 1);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* Python wrapper */
-static PyObject *__pyx_pw_4smol_12correlations_3delta_corr_single_flip(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
-static char __pyx_doc_4smol_12correlations_2delta_corr_single_flip[] = "Computes the correlation difference between two occupancy vectors.\n\n    Args:\n        occu_f (ndarray):\n            encoded occupancy vector with flip\n        occu_i (ndarray):\n            encoded occupancy vector without flip\n        num_corr_functions (int):\n            total number of bit orderings in expansion.\n        site_orbit_list:\n            Information of all orbits that include the flip site.\n            List of tuples each with\n            (orbit id, cluster ratio, flat tensor index array,\n             flat correlation tensor, site indices of clusters)\n\n\n    Returns:\n        ndarray: correlation vector difference\n    ";
-static PyObject *__pyx_pw_4smol_12correlations_3delta_corr_single_flip(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
+static PyObject *__pyx_pw_4smol_5utils_7cluster_12correlations_3delta_corr_single_flip(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static char __pyx_doc_4smol_5utils_7cluster_12correlations_2delta_corr_single_flip[] = "Computes the correlation difference between two occupancy arrays.\n\n    Args:\n        occu_f (ndarray):\n            encoded occupancy array with flip\n        occu_i (ndarray):\n            encoded occupancy array without flip\n        num_corr_functions (int):\n            total number of bit orderings in expansion.\n        site_orbit_list:\n            Information of all orbits that include the flip site.\n            List of tuples each with\n            (orbit id, cluster ratio, flat tensor index array,\n             flat correlation tensor, site indices of clusters)\n\n    Returns:\n        ndarray: correlation vector difference\n    ";
+static PyObject *__pyx_pw_4smol_5utils_7cluster_12correlations_3delta_corr_single_flip(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
   __Pyx_memviewslice __pyx_v_occu_f = { 0, 0, { 0 }, { 0 }, { 0 } };
   __Pyx_memviewslice __pyx_v_occu_i = { 0, 0, { 0 }, { 0 }, { 0 } };
   int __pyx_v_num_corr_functions;
   PyObject *__pyx_v_site_orbit_list = 0;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
@@ -3643,1062 +3664,557 @@
     __pyx_v_num_corr_functions = __Pyx_PyInt_As_int(values[2]); if (unlikely((__pyx_v_num_corr_functions == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 63, __pyx_L3_error)
     __pyx_v_site_orbit_list = ((PyObject*)values[3]);
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
   __Pyx_RaiseArgtupleInvalid("delta_corr_single_flip", 1, 4, 4, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 61, __pyx_L3_error)
   __pyx_L3_error:;
-  __Pyx_AddTraceback("smol.correlations.delta_corr_single_flip", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_AddTraceback("smol.utils.cluster.correlations.delta_corr_single_flip", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
   if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_site_orbit_list), (&PyList_Type), 1, "site_orbit_list", 1))) __PYX_ERR(0, 64, __pyx_L1_error)
-  __pyx_r = __pyx_pf_4smol_12correlations_2delta_corr_single_flip(__pyx_self, __pyx_v_occu_f, __pyx_v_occu_i, __pyx_v_num_corr_functions, __pyx_v_site_orbit_list);
+  __pyx_r = __pyx_pf_4smol_5utils_7cluster_12correlations_2delta_corr_single_flip(__pyx_self, __pyx_v_occu_f, __pyx_v_occu_i, __pyx_v_num_corr_functions, __pyx_v_site_orbit_list);
 
   /* function exit code */
   goto __pyx_L0;
   __pyx_L1_error:;
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-static PyObject *__pyx_pf_4smol_12correlations_2delta_corr_single_flip(CYTHON_UNUSED PyObject *__pyx_self, __Pyx_memviewslice __pyx_v_occu_f, __Pyx_memviewslice __pyx_v_occu_i, int __pyx_v_num_corr_functions, PyObject *__pyx_v_site_orbit_list) {
+static PyObject *__pyx_pf_4smol_5utils_7cluster_12correlations_2delta_corr_single_flip(CYTHON_UNUSED PyObject *__pyx_self, __Pyx_memviewslice __pyx_v_occu_f, __Pyx_memviewslice __pyx_v_occu_i, int __pyx_v_num_corr_functions, PyObject *__pyx_v_site_orbit_list) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("delta_corr_single_flip", 0);
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __pyx_f_4smol_12correlations_delta_corr_single_flip(__pyx_v_occu_f, __pyx_v_occu_i, __pyx_v_num_corr_functions, __pyx_v_site_orbit_list, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 61, __pyx_L1_error)
+  __pyx_t_1 = __pyx_f_4smol_5utils_7cluster_12correlations_delta_corr_single_flip(__pyx_v_occu_f, __pyx_v_occu_i, __pyx_v_num_corr_functions, __pyx_v_site_orbit_list, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 61, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
-  __Pyx_AddTraceback("smol.correlations.delta_corr_single_flip", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_AddTraceback("smol.utils.cluster.correlations.delta_corr_single_flip", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __pyx_L0:;
   __PYX_XDEC_MEMVIEW(&__pyx_v_occu_f, 1);
   __PYX_XDEC_MEMVIEW(&__pyx_v_occu_i, 1);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "smol/correlations.pyx":109
- *
- *
- * cpdef indicator_delta_corr_single_flip(const long[::1] occu_f,             # <<<<<<<<<<<<<<
- *                                        const long[::1] occu_i,
- *                                        const int num_corr_functions,
+/* "smol/utils/cluster/correlations.pyx":108
+ * 
+ * 
+ * cpdef corr_distance_single_flip(const long[::1] occu_f,             # <<<<<<<<<<<<<<
+ *                                 const long[::1] occu_i,
+ *                                 const double[::1] ref_corr_vector,
  */
 
-static PyObject *__pyx_pw_4smol_12correlations_5indicator_delta_corr_single_flip(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
-static PyObject *__pyx_f_4smol_12correlations_indicator_delta_corr_single_flip(__Pyx_memviewslice __pyx_v_occu_f, __Pyx_memviewslice __pyx_v_occu_i, int const __pyx_v_num_corr_functions, PyObject *__pyx_v_site_orbit_list, CYTHON_UNUSED int __pyx_skip_dispatch) {
+static PyObject *__pyx_pw_4smol_5utils_7cluster_12correlations_5corr_distance_single_flip(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static PyObject *__pyx_f_4smol_5utils_7cluster_12correlations_corr_distance_single_flip(__Pyx_memviewslice __pyx_v_occu_f, __Pyx_memviewslice __pyx_v_occu_i, __Pyx_memviewslice __pyx_v_ref_corr_vector, int const __pyx_v_num_corr_functions, PyObject *__pyx_v_orbit_list, CYTHON_UNUSED int __pyx_skip_dispatch) {
   int __pyx_v_i;
   int __pyx_v_j;
-  int __pyx_v_k;
   int __pyx_v_n;
   int __pyx_v_m;
   int __pyx_v_I;
-  int __pyx_v_K;
+  int __pyx_v_J;
   int __pyx_v_M;
-  int __pyx_v_ok;
-  __Pyx_memviewslice __pyx_v_bit_combos = { 0, 0, { 0 }, { 0 }, { 0 } };
+  int __pyx_v_ind_i;
+  int __pyx_v_ind_f;
+  double __pyx_v_p_i;
+  double __pyx_v_p_f;
   __Pyx_memviewslice __pyx_v_indices = { 0, 0, { 0 }, { 0 }, { 0 } };
-  __Pyx_memviewslice __pyx_v_bit_indices = { 0, 0, { 0 }, { 0 }, { 0 } };
+  __Pyx_memviewslice __pyx_v_tensor_indices = { 0, 0, { 0 }, { 0 }, { 0 } };
+  __Pyx_memviewslice __pyx_v_corr_tensors = { 0, 0, { 0 }, { 0 }, { 0 } };
   PyObject *__pyx_v_out = NULL;
   __Pyx_memviewslice __pyx_v_o_view = { 0, 0, { 0 }, { 0 }, { 0 } };
-  double __pyx_v_r;
-  double __pyx_v_o;
-  CYTHON_UNUSED PyObject *__pyx_v__ = NULL;
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   PyObject *__pyx_t_2 = NULL;
   PyObject *__pyx_t_3 = NULL;
   PyObject *__pyx_t_4 = NULL;
   __Pyx_memviewslice __pyx_t_5 = { 0, 0, { 0 }, { 0 }, { 0 } };
-  Py_ssize_t __pyx_t_6;
-  PyObject *__pyx_t_7 = NULL;
+  __Pyx_memviewslice __pyx_t_6 = { 0, 0, { 0 }, { 0 }, { 0 } };
+  Py_ssize_t __pyx_t_7;
   PyObject *__pyx_t_8 = NULL;
   PyObject *__pyx_t_9 = NULL;
   PyObject *__pyx_t_10 = NULL;
-  PyObject *__pyx_t_11 = NULL;
-  PyObject *(*__pyx_t_12)(PyObject *);
-  int __pyx_t_13;
-  double __pyx_t_14;
+  PyObject *(*__pyx_t_11)(PyObject *);
+  int __pyx_t_12;
+  __Pyx_memviewslice __pyx_t_13 = { 0, 0, { 0 }, { 0 }, { 0 } };
+  __Pyx_memviewslice __pyx_t_14 = { 0, 0, { 0 }, { 0 }, { 0 } };
   __Pyx_memviewslice __pyx_t_15 = { 0, 0, { 0 }, { 0 }, { 0 } };
-  __Pyx_memviewslice __pyx_t_16 = { 0, 0, { 0 }, { 0 }, { 0 } };
-  __Pyx_memviewslice __pyx_t_17 = { 0, 0, { 0 }, { 0 }, { 0 } };
-  long __pyx_t_18;
-  long __pyx_t_19;
+  int __pyx_t_16;
+  int __pyx_t_17;
+  double __pyx_t_18;
+  double __pyx_t_19;
   int __pyx_t_20;
   int __pyx_t_21;
   int __pyx_t_22;
-  Py_ssize_t __pyx_t_23;
-  long __pyx_t_24;
-  long __pyx_t_25;
-  int __pyx_t_26;
-  int __pyx_t_27;
-  int __pyx_t_28;
-  int __pyx_t_29;
-  Py_ssize_t __pyx_t_30;
-  Py_ssize_t __pyx_t_31;
-  Py_ssize_t __pyx_t_32;
-  Py_ssize_t __pyx_t_33;
-  Py_ssize_t __pyx_t_34;
-  int __pyx_t_35;
+  int __pyx_t_23;
+  int __pyx_t_24;
+  int __pyx_t_25;
+  Py_ssize_t __pyx_t_26;
+  Py_ssize_t __pyx_t_27;
+  Py_ssize_t __pyx_t_28;
+  Py_ssize_t __pyx_t_29;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("indicator_delta_corr_single_flip", 0);
-
-  /* "smol/correlations.pyx":135
- *     cdef const long[:, ::1] bit_combos, indices
- *     cdef const long[::1] bit_indices
- *     out = np.zeros(num_corr_functions)             # <<<<<<<<<<<<<<
- *     cdef double[::1] o_view = out
- *     cdef double r, o
+  __Pyx_RefNannySetupContext("corr_distance_single_flip", 0);
+
+  /* "smol/utils/cluster/correlations.pyx":141
+ *     cdef const long[::1] tensor_indices
+ *     cdef const double[:, ::1] corr_tensors
+ *     out = np.zeros((2, num_corr_functions))             # <<<<<<<<<<<<<<
+ *     cdef double[:, ::1] o_view = out
+ *     o_view[:, 0] = 0
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_np); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 135, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_np); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 141, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_zeros); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 135, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_zeros); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 141, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_2 = __Pyx_PyInt_From_int(__pyx_v_num_corr_functions); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 135, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyInt_From_int(__pyx_v_num_corr_functions); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 141, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_4 = NULL;
+  __pyx_t_4 = PyTuple_New(2); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 141, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_4);
+  __Pyx_INCREF(__pyx_int_2);
+  __Pyx_GIVEREF(__pyx_int_2);
+  PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_int_2);
+  __Pyx_GIVEREF(__pyx_t_2);
+  PyTuple_SET_ITEM(__pyx_t_4, 1, __pyx_t_2);
+  __pyx_t_2 = 0;
+  __pyx_t_2 = NULL;
   if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
-    __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
-    if (likely(__pyx_t_4)) {
+    __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_3);
+    if (likely(__pyx_t_2)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
-      __Pyx_INCREF(__pyx_t_4);
+      __Pyx_INCREF(__pyx_t_2);
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_3, function);
     }
   }
-  __pyx_t_1 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_4, __pyx_t_2) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_2);
-  __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 135, __pyx_L1_error)
+  __pyx_t_1 = (__pyx_t_2) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_2, __pyx_t_4) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4);
+  __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 141, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __pyx_v_out = __pyx_t_1;
   __pyx_t_1 = 0;
 
-  /* "smol/correlations.pyx":136
- *     cdef const long[::1] bit_indices
- *     out = np.zeros(num_corr_functions)
- *     cdef double[::1] o_view = out             # <<<<<<<<<<<<<<
- *     cdef double r, o
- *
+  /* "smol/utils/cluster/correlations.pyx":142
+ *     cdef const double[:, ::1] corr_tensors
+ *     out = np.zeros((2, num_corr_functions))
+ *     cdef double[:, ::1] o_view = out             # <<<<<<<<<<<<<<
+ *     o_view[:, 0] = 0
+ * 
  */
-  __pyx_t_5 = __Pyx_PyObject_to_MemoryviewSlice_dc_double(__pyx_v_out, PyBUF_WRITABLE); if (unlikely(!__pyx_t_5.memview)) __PYX_ERR(0, 136, __pyx_L1_error)
+  __pyx_t_5 = __Pyx_PyObject_to_MemoryviewSlice_d_dc_double(__pyx_v_out, PyBUF_WRITABLE); if (unlikely(!__pyx_t_5.memview)) __PYX_ERR(0, 142, __pyx_L1_error)
   __pyx_v_o_view = __pyx_t_5;
   __pyx_t_5.memview = NULL;
   __pyx_t_5.data = NULL;
 
-  /* "smol/correlations.pyx":139
- *     cdef double r, o
- *
- *     for n, r, bit_combos, bit_indices, _, indices in site_orbit_list:             # <<<<<<<<<<<<<<
- *         M = bit_indices.shape[0] # index of bit combos
+  /* "smol/utils/cluster/correlations.pyx":143
+ *     out = np.zeros((2, num_corr_functions))
+ *     cdef double[:, ::1] o_view = out
+ *     o_view[:, 0] = 0             # <<<<<<<<<<<<<<
+ * 
+ *     for n, tensor_indices, corr_tensors, indices in orbit_list:
+ */
+  __pyx_t_6.data = __pyx_v_o_view.data;
+  __pyx_t_6.memview = __pyx_v_o_view.memview;
+  __PYX_INC_MEMVIEW(&__pyx_t_6, 0);
+  __pyx_t_6.shape[0] = __pyx_v_o_view.shape[0];
+__pyx_t_6.strides[0] = __pyx_v_o_view.strides[0];
+    __pyx_t_6.suboffsets[0] = -1;
+
+{
+    Py_ssize_t __pyx_tmp_idx = 0;
+    Py_ssize_t __pyx_tmp_stride = __pyx_v_o_view.strides[1];
+        __pyx_t_6.data += __pyx_tmp_idx * __pyx_tmp_stride;
+}
+
+{
+      double __pyx_temp_scalar = 0.0;
+      {
+          Py_ssize_t __pyx_temp_extent_0 = __pyx_t_6.shape[0];
+          Py_ssize_t __pyx_temp_stride_0 = __pyx_t_6.strides[0];
+          char *__pyx_temp_pointer_0;
+          Py_ssize_t __pyx_temp_idx_0;
+          __pyx_temp_pointer_0 = __pyx_t_6.data;
+          for (__pyx_temp_idx_0 = 0; __pyx_temp_idx_0 < __pyx_temp_extent_0; __pyx_temp_idx_0++) {
+            *((double *) __pyx_temp_pointer_0) = __pyx_temp_scalar;
+            __pyx_temp_pointer_0 += __pyx_temp_stride_0;
+          }
+      }
+  }
+  __PYX_XDEC_MEMVIEW(&__pyx_t_6, 1);
+  __pyx_t_6.memview = NULL;
+  __pyx_t_6.data = NULL;
+
+  /* "smol/utils/cluster/correlations.pyx":145
+ *     o_view[:, 0] = 0
+ * 
+ *     for n, tensor_indices, corr_tensors, indices in orbit_list:             # <<<<<<<<<<<<<<
+ *         M = corr_tensors.shape[0]  # index of bit combos
  *         I = indices.shape[0] # cluster index
  */
-  if (unlikely(__pyx_v_site_orbit_list == Py_None)) {
+  if (unlikely(__pyx_v_orbit_list == Py_None)) {
     PyErr_SetString(PyExc_TypeError, "'NoneType' object is not iterable");
-    __PYX_ERR(0, 139, __pyx_L1_error)
+    __PYX_ERR(0, 145, __pyx_L1_error)
   }
-  __pyx_t_1 = __pyx_v_site_orbit_list; __Pyx_INCREF(__pyx_t_1); __pyx_t_6 = 0;
+  __pyx_t_1 = __pyx_v_orbit_list; __Pyx_INCREF(__pyx_t_1); __pyx_t_7 = 0;
   for (;;) {
-    if (__pyx_t_6 >= PyList_GET_SIZE(__pyx_t_1)) break;
+    if (__pyx_t_7 >= PyList_GET_SIZE(__pyx_t_1)) break;
     #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-    __pyx_t_3 = PyList_GET_ITEM(__pyx_t_1, __pyx_t_6); __Pyx_INCREF(__pyx_t_3); __pyx_t_6++; if (unlikely(0 < 0)) __PYX_ERR(0, 139, __pyx_L1_error)
+    __pyx_t_3 = PyList_GET_ITEM(__pyx_t_1, __pyx_t_7); __Pyx_INCREF(__pyx_t_3); __pyx_t_7++; if (unlikely(0 < 0)) __PYX_ERR(0, 145, __pyx_L1_error)
     #else
-    __pyx_t_3 = PySequence_ITEM(__pyx_t_1, __pyx_t_6); __pyx_t_6++; if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 139, __pyx_L1_error)
+    __pyx_t_3 = PySequence_ITEM(__pyx_t_1, __pyx_t_7); __pyx_t_7++; if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 145, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     #endif
     if ((likely(PyTuple_CheckExact(__pyx_t_3))) || (PyList_CheckExact(__pyx_t_3))) {
       PyObject* sequence = __pyx_t_3;
       Py_ssize_t size = __Pyx_PySequence_SIZE(sequence);
-      if (unlikely(size != 6)) {
-        if (size > 6) __Pyx_RaiseTooManyValuesError(6);
+      if (unlikely(size != 4)) {
+        if (size > 4) __Pyx_RaiseTooManyValuesError(4);
         else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
-        __PYX_ERR(0, 139, __pyx_L1_error)
+        __PYX_ERR(0, 145, __pyx_L1_error)
       }
       #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
       if (likely(PyTuple_CheckExact(sequence))) {
-        __pyx_t_2 = PyTuple_GET_ITEM(sequence, 0);
-        __pyx_t_4 = PyTuple_GET_ITEM(sequence, 1);
-        __pyx_t_7 = PyTuple_GET_ITEM(sequence, 2);
-        __pyx_t_8 = PyTuple_GET_ITEM(sequence, 3);
-        __pyx_t_9 = PyTuple_GET_ITEM(sequence, 4);
-        __pyx_t_10 = PyTuple_GET_ITEM(sequence, 5);
+        __pyx_t_4 = PyTuple_GET_ITEM(sequence, 0); 
+        __pyx_t_2 = PyTuple_GET_ITEM(sequence, 1); 
+        __pyx_t_8 = PyTuple_GET_ITEM(sequence, 2); 
+        __pyx_t_9 = PyTuple_GET_ITEM(sequence, 3); 
       } else {
-        __pyx_t_2 = PyList_GET_ITEM(sequence, 0);
-        __pyx_t_4 = PyList_GET_ITEM(sequence, 1);
-        __pyx_t_7 = PyList_GET_ITEM(sequence, 2);
-        __pyx_t_8 = PyList_GET_ITEM(sequence, 3);
-        __pyx_t_9 = PyList_GET_ITEM(sequence, 4);
-        __pyx_t_10 = PyList_GET_ITEM(sequence, 5);
+        __pyx_t_4 = PyList_GET_ITEM(sequence, 0); 
+        __pyx_t_2 = PyList_GET_ITEM(sequence, 1); 
+        __pyx_t_8 = PyList_GET_ITEM(sequence, 2); 
+        __pyx_t_9 = PyList_GET_ITEM(sequence, 3); 
       }
-      __Pyx_INCREF(__pyx_t_2);
       __Pyx_INCREF(__pyx_t_4);
-      __Pyx_INCREF(__pyx_t_7);
+      __Pyx_INCREF(__pyx_t_2);
       __Pyx_INCREF(__pyx_t_8);
       __Pyx_INCREF(__pyx_t_9);
-      __Pyx_INCREF(__pyx_t_10);
       #else
       {
         Py_ssize_t i;
-        PyObject** temps[6] = {&__pyx_t_2,&__pyx_t_4,&__pyx_t_7,&__pyx_t_8,&__pyx_t_9,&__pyx_t_10};
-        for (i=0; i < 6; i++) {
-          PyObject* item = PySequence_ITEM(sequence, i); if (unlikely(!item)) __PYX_ERR(0, 139, __pyx_L1_error)
+        PyObject** temps[4] = {&__pyx_t_4,&__pyx_t_2,&__pyx_t_8,&__pyx_t_9};
+        for (i=0; i < 4; i++) {
+          PyObject* item = PySequence_ITEM(sequence, i); if (unlikely(!item)) __PYX_ERR(0, 145, __pyx_L1_error)
           __Pyx_GOTREF(item);
           *(temps[i]) = item;
         }
       }
       #endif
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     } else {
       Py_ssize_t index = -1;
-      PyObject** temps[6] = {&__pyx_t_2,&__pyx_t_4,&__pyx_t_7,&__pyx_t_8,&__pyx_t_9,&__pyx_t_10};
-      __pyx_t_11 = PyObject_GetIter(__pyx_t_3); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 139, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_11);
+      PyObject** temps[4] = {&__pyx_t_4,&__pyx_t_2,&__pyx_t_8,&__pyx_t_9};
+      __pyx_t_10 = PyObject_GetIter(__pyx_t_3); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 145, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_10);
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-      __pyx_t_12 = Py_TYPE(__pyx_t_11)->tp_iternext;
-      for (index=0; index < 6; index++) {
-        PyObject* item = __pyx_t_12(__pyx_t_11); if (unlikely(!item)) goto __pyx_L5_unpacking_failed;
+      __pyx_t_11 = Py_TYPE(__pyx_t_10)->tp_iternext;
+      for (index=0; index < 4; index++) {
+        PyObject* item = __pyx_t_11(__pyx_t_10); if (unlikely(!item)) goto __pyx_L5_unpacking_failed;
         __Pyx_GOTREF(item);
         *(temps[index]) = item;
       }
-      if (__Pyx_IternextUnpackEndCheck(__pyx_t_12(__pyx_t_11), 6) < 0) __PYX_ERR(0, 139, __pyx_L1_error)
-      __pyx_t_12 = NULL;
-      __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
+      if (__Pyx_IternextUnpackEndCheck(__pyx_t_11(__pyx_t_10), 4) < 0) __PYX_ERR(0, 145, __pyx_L1_error)
+      __pyx_t_11 = NULL;
+      __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
       goto __pyx_L6_unpacking_done;
       __pyx_L5_unpacking_failed:;
-      __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
-      __pyx_t_12 = NULL;
+      __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
+      __pyx_t_11 = NULL;
       if (__Pyx_IterFinish() == 0) __Pyx_RaiseNeedMoreValuesError(index);
-      __PYX_ERR(0, 139, __pyx_L1_error)
+      __PYX_ERR(0, 145, __pyx_L1_error)
       __pyx_L6_unpacking_done:;
     }
-    __pyx_t_13 = __Pyx_PyInt_As_int(__pyx_t_2); if (unlikely((__pyx_t_13 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 139, __pyx_L1_error)
-    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __pyx_t_14 = __pyx_PyFloat_AsDouble(__pyx_t_4); if (unlikely((__pyx_t_14 == (double)-1) && PyErr_Occurred())) __PYX_ERR(0, 139, __pyx_L1_error)
+    __pyx_t_12 = __Pyx_PyInt_As_int(__pyx_t_4); if (unlikely((__pyx_t_12 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 145, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-    __pyx_t_15 = __Pyx_PyObject_to_MemoryviewSlice_d_dc_long__const__(__pyx_t_7, 0); if (unlikely(!__pyx_t_15.memview)) __PYX_ERR(0, 139, __pyx_L1_error)
-    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-    __pyx_t_16 = __Pyx_PyObject_to_MemoryviewSlice_dc_long__const__(__pyx_t_8, 0); if (unlikely(!__pyx_t_16.memview)) __PYX_ERR(0, 139, __pyx_L1_error)
+    __pyx_t_13 = __Pyx_PyObject_to_MemoryviewSlice_dc_long__const__(__pyx_t_2, 0); if (unlikely(!__pyx_t_13.memview)) __PYX_ERR(0, 145, __pyx_L1_error)
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __pyx_t_14 = __Pyx_PyObject_to_MemoryviewSlice_d_dc_double__const__(__pyx_t_8, 0); if (unlikely(!__pyx_t_14.memview)) __PYX_ERR(0, 145, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
-    __pyx_t_17 = __Pyx_PyObject_to_MemoryviewSlice_d_dc_long__const__(__pyx_t_10, 0); if (unlikely(!__pyx_t_17.memview)) __PYX_ERR(0, 139, __pyx_L1_error)
-    __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
-    __pyx_v_n = __pyx_t_13;
-    __pyx_v_r = __pyx_t_14;
-    __PYX_XDEC_MEMVIEW(&__pyx_v_bit_combos, 1);
-    __pyx_v_bit_combos = __pyx_t_15;
+    __pyx_t_15 = __Pyx_PyObject_to_MemoryviewSlice_d_dc_long__const__(__pyx_t_9, 0); if (unlikely(!__pyx_t_15.memview)) __PYX_ERR(0, 145, __pyx_L1_error)
+    __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
+    __pyx_v_n = __pyx_t_12;
+    __PYX_XDEC_MEMVIEW(&__pyx_v_tensor_indices, 1);
+    __pyx_v_tensor_indices = __pyx_t_13;
+    __pyx_t_13.memview = NULL;
+    __pyx_t_13.data = NULL;
+    __PYX_XDEC_MEMVIEW(&__pyx_v_corr_tensors, 1);
+    __pyx_v_corr_tensors = __pyx_t_14;
+    __pyx_t_14.memview = NULL;
+    __pyx_t_14.data = NULL;
+    __PYX_XDEC_MEMVIEW(&__pyx_v_indices, 1);
+    __pyx_v_indices = __pyx_t_15;
     __pyx_t_15.memview = NULL;
     __pyx_t_15.data = NULL;
-    __PYX_XDEC_MEMVIEW(&__pyx_v_bit_indices, 1);
-    __pyx_v_bit_indices = __pyx_t_16;
-    __pyx_t_16.memview = NULL;
-    __pyx_t_16.data = NULL;
-    __Pyx_XDECREF_SET(__pyx_v__, __pyx_t_9);
-    __pyx_t_9 = 0;
-    __PYX_XDEC_MEMVIEW(&__pyx_v_indices, 1);
-    __pyx_v_indices = __pyx_t_17;
-    __pyx_t_17.memview = NULL;
-    __pyx_t_17.data = NULL;
-
-    /* "smol/correlations.pyx":140
- *
- *     for n, r, bit_combos, bit_indices, _, indices in site_orbit_list:
- *         M = bit_indices.shape[0] # index of bit combos             # <<<<<<<<<<<<<<
+
+    /* "smol/utils/cluster/correlations.pyx":146
+ * 
+ *     for n, tensor_indices, corr_tensors, indices in orbit_list:
+ *         M = corr_tensors.shape[0]  # index of bit combos             # <<<<<<<<<<<<<<
  *         I = indices.shape[0] # cluster index
- *         K = indices.shape[1] # index within cluster
+ *         J = indices.shape[1] # index within cluster
  */
-    __pyx_v_M = (__pyx_v_bit_indices.shape[0]);
+    __pyx_v_M = (__pyx_v_corr_tensors.shape[0]);
 
-    /* "smol/correlations.pyx":141
- *     for n, r, bit_combos, bit_indices, _, indices in site_orbit_list:
- *         M = bit_indices.shape[0] # index of bit combos
+    /* "smol/utils/cluster/correlations.pyx":147
+ *     for n, tensor_indices, corr_tensors, indices in orbit_list:
+ *         M = corr_tensors.shape[0]  # index of bit combos
  *         I = indices.shape[0] # cluster index             # <<<<<<<<<<<<<<
- *         K = indices.shape[1] # index within cluster
- *         for m in range(M - 1):
+ *         J = indices.shape[1] # index within cluster
+ *         for m in range(M):
  */
     __pyx_v_I = (__pyx_v_indices.shape[0]);
 
-    /* "smol/correlations.pyx":142
- *         M = bit_indices.shape[0] # index of bit combos
+    /* "smol/utils/cluster/correlations.pyx":148
+ *         M = corr_tensors.shape[0]  # index of bit combos
  *         I = indices.shape[0] # cluster index
- *         K = indices.shape[1] # index within cluster             # <<<<<<<<<<<<<<
- *         for m in range(M - 1):
- *             o = 0
+ *         J = indices.shape[1] # index within cluster             # <<<<<<<<<<<<<<
+ *         for m in range(M):
+ *             p_f, p_i = 0, 0
  */
-    __pyx_v_K = (__pyx_v_indices.shape[1]);
+    __pyx_v_J = (__pyx_v_indices.shape[1]);
 
-    /* "smol/correlations.pyx":143
+    /* "smol/utils/cluster/correlations.pyx":149
  *         I = indices.shape[0] # cluster index
- *         K = indices.shape[1] # index within cluster
- *         for m in range(M - 1):             # <<<<<<<<<<<<<<
- *             o = 0
+ *         J = indices.shape[1] # index within cluster
+ *         for m in range(M):             # <<<<<<<<<<<<<<
+ *             p_f, p_i = 0, 0
  *             for i in range(I):
  */
-    __pyx_t_18 = (__pyx_v_M - 1);
-    __pyx_t_19 = __pyx_t_18;
-    for (__pyx_t_13 = 0; __pyx_t_13 < __pyx_t_19; __pyx_t_13+=1) {
-      __pyx_v_m = __pyx_t_13;
-
-      /* "smol/correlations.pyx":144
- *         K = indices.shape[1] # index within cluster
- *         for m in range(M - 1):
- *             o = 0             # <<<<<<<<<<<<<<
+    __pyx_t_12 = __pyx_v_M;
+    __pyx_t_16 = __pyx_t_12;
+    for (__pyx_t_17 = 0; __pyx_t_17 < __pyx_t_16; __pyx_t_17+=1) {
+      __pyx_v_m = __pyx_t_17;
+
+      /* "smol/utils/cluster/correlations.pyx":150
+ *         J = indices.shape[1] # index within cluster
+ *         for m in range(M):
+ *             p_f, p_i = 0, 0             # <<<<<<<<<<<<<<
  *             for i in range(I):
- *                 for j in range(bit_indices[m], bit_indices[m + 1]):
+ *                 ind_f, ind_i = 0, 0
  */
-      __pyx_v_o = 0.0;
+      __pyx_t_18 = 0.0;
+      __pyx_t_19 = 0.0;
+      __pyx_v_p_f = __pyx_t_18;
+      __pyx_v_p_i = __pyx_t_19;
 
-      /* "smol/correlations.pyx":145
- *         for m in range(M - 1):
- *             o = 0
+      /* "smol/utils/cluster/correlations.pyx":151
+ *         for m in range(M):
+ *             p_f, p_i = 0, 0
  *             for i in range(I):             # <<<<<<<<<<<<<<
- *                 for j in range(bit_indices[m], bit_indices[m + 1]):
- *                     ok = True
+ *                 ind_f, ind_i = 0, 0
+ *                 for j in range(J):
  */
       __pyx_t_20 = __pyx_v_I;
       __pyx_t_21 = __pyx_t_20;
       for (__pyx_t_22 = 0; __pyx_t_22 < __pyx_t_21; __pyx_t_22+=1) {
         __pyx_v_i = __pyx_t_22;
 
-        /* "smol/correlations.pyx":146
- *             o = 0
+        /* "smol/utils/cluster/correlations.pyx":152
+ *             p_f, p_i = 0, 0
  *             for i in range(I):
- *                 for j in range(bit_indices[m], bit_indices[m + 1]):             # <<<<<<<<<<<<<<
- *                     ok = True
- *                     for k in range(K):
- */
-        __pyx_t_23 = (__pyx_v_m + 1);
-        __pyx_t_24 = (*((long const  *) ( /* dim=0 */ ((char *) (((long const  *) __pyx_v_bit_indices.data) + __pyx_t_23)) )));
-        __pyx_t_23 = __pyx_v_m;
-        __pyx_t_25 = __pyx_t_24;
-        for (__pyx_t_26 = (*((long const  *) ( /* dim=0 */ ((char *) (((long const  *) __pyx_v_bit_indices.data) + __pyx_t_23)) ))); __pyx_t_26 < __pyx_t_25; __pyx_t_26+=1) {
-          __pyx_v_j = __pyx_t_26;
-
-          /* "smol/correlations.pyx":147
- *             for i in range(I):
- *                 for j in range(bit_indices[m], bit_indices[m + 1]):
- *                     ok = True             # <<<<<<<<<<<<<<
- *                     for k in range(K):
- *                         if occu_f[indices[i, k]] != bit_combos[j, k]:
- */
-          __pyx_v_ok = 1;
-
-          /* "smol/correlations.pyx":148
- *                 for j in range(bit_indices[m], bit_indices[m + 1]):
- *                     ok = True
- *                     for k in range(K):             # <<<<<<<<<<<<<<
- *                         if occu_f[indices[i, k]] != bit_combos[j, k]:
- *                             ok = False
- */
-          __pyx_t_27 = __pyx_v_K;
-          __pyx_t_28 = __pyx_t_27;
-          for (__pyx_t_29 = 0; __pyx_t_29 < __pyx_t_28; __pyx_t_29+=1) {
-            __pyx_v_k = __pyx_t_29;
-
-            /* "smol/correlations.pyx":149
- *                     ok = True
- *                     for k in range(K):
- *                         if occu_f[indices[i, k]] != bit_combos[j, k]:             # <<<<<<<<<<<<<<
- *                             ok = False
- *                             break
- */
-            __pyx_t_30 = __pyx_v_i;
-            __pyx_t_31 = __pyx_v_k;
-            __pyx_t_32 = (*((long const  *) ( /* dim=1 */ ((char *) (((long const  *) ( /* dim=0 */ (__pyx_v_indices.data + __pyx_t_30 * __pyx_v_indices.strides[0]) )) + __pyx_t_31)) )));
-            __pyx_t_33 = __pyx_v_j;
-            __pyx_t_34 = __pyx_v_k;
-            __pyx_t_35 = (((*((long const  *) ( /* dim=0 */ ((char *) (((long const  *) __pyx_v_occu_f.data) + __pyx_t_32)) ))) != (*((long const  *) ( /* dim=1 */ ((char *) (((long const  *) ( /* dim=0 */ (__pyx_v_bit_combos.data + __pyx_t_33 * __pyx_v_bit_combos.strides[0]) )) + __pyx_t_34)) )))) != 0);
-            if (__pyx_t_35) {
-
-              /* "smol/correlations.pyx":150
- *                     for k in range(K):
- *                         if occu_f[indices[i, k]] != bit_combos[j, k]:
- *                             ok = False             # <<<<<<<<<<<<<<
- *                             break
- *                     if ok:
- */
-              __pyx_v_ok = 0;
-
-              /* "smol/correlations.pyx":151
- *                         if occu_f[indices[i, k]] != bit_combos[j, k]:
- *                             ok = False
- *                             break             # <<<<<<<<<<<<<<
- *                     if ok:
- *                         o += 1
- */
-              goto __pyx_L14_break;
-
-              /* "smol/correlations.pyx":149
- *                     ok = True
- *                     for k in range(K):
- *                         if occu_f[indices[i, k]] != bit_combos[j, k]:             # <<<<<<<<<<<<<<
- *                             ok = False
- *                             break
+ *                 ind_f, ind_i = 0, 0             # <<<<<<<<<<<<<<
+ *                 for j in range(J):
+ *                     ind_f += tensor_indices[j] * occu_f[indices[i, j]]
  */
-            }
-          }
-          __pyx_L14_break:;
+        __pyx_t_23 = 0;
+        __pyx_t_24 = 0;
+        __pyx_v_ind_f = __pyx_t_23;
+        __pyx_v_ind_i = __pyx_t_24;
 
-          /* "smol/correlations.pyx":152
- *                             ok = False
- *                             break
- *                     if ok:             # <<<<<<<<<<<<<<
- *                         o += 1
- *
- */
-          __pyx_t_35 = (__pyx_v_ok != 0);
-          if (__pyx_t_35) {
-
-            /* "smol/correlations.pyx":153
- *                             break
- *                     if ok:
- *                         o += 1             # <<<<<<<<<<<<<<
- *
- *                     ok = True
- */
-            __pyx_v_o = (__pyx_v_o + 1.0);
-
-            /* "smol/correlations.pyx":152
- *                             ok = False
- *                             break
- *                     if ok:             # <<<<<<<<<<<<<<
- *                         o += 1
- *
+        /* "smol/utils/cluster/correlations.pyx":153
+ *             for i in range(I):
+ *                 ind_f, ind_i = 0, 0
+ *                 for j in range(J):             # <<<<<<<<<<<<<<
+ *                     ind_f += tensor_indices[j] * occu_f[indices[i, j]]
+ *                     ind_i += tensor_indices[j] * occu_i[indices[i, j]]
  */
-          }
+        __pyx_t_24 = __pyx_v_J;
+        __pyx_t_23 = __pyx_t_24;
+        for (__pyx_t_25 = 0; __pyx_t_25 < __pyx_t_23; __pyx_t_25+=1) {
+          __pyx_v_j = __pyx_t_25;
 
-          /* "smol/correlations.pyx":155
- *                         o += 1
- *
- *                     ok = True             # <<<<<<<<<<<<<<
- *                     for k in range(K):
- *                         if occu_i[indices[i, k]] != bit_combos[j, k]:
- */
-          __pyx_v_ok = 1;
-
-          /* "smol/correlations.pyx":156
- *
- *                     ok = True
- *                     for k in range(K):             # <<<<<<<<<<<<<<
- *                         if occu_i[indices[i, k]] != bit_combos[j, k]:
- *                             ok = False
- */
-          __pyx_t_27 = __pyx_v_K;
-          __pyx_t_28 = __pyx_t_27;
-          for (__pyx_t_29 = 0; __pyx_t_29 < __pyx_t_28; __pyx_t_29+=1) {
-            __pyx_v_k = __pyx_t_29;
-
-            /* "smol/correlations.pyx":157
- *                     ok = True
- *                     for k in range(K):
- *                         if occu_i[indices[i, k]] != bit_combos[j, k]:             # <<<<<<<<<<<<<<
- *                             ok = False
- *                             break
- */
-            __pyx_t_34 = __pyx_v_i;
-            __pyx_t_33 = __pyx_v_k;
-            __pyx_t_31 = (*((long const  *) ( /* dim=1 */ ((char *) (((long const  *) ( /* dim=0 */ (__pyx_v_indices.data + __pyx_t_34 * __pyx_v_indices.strides[0]) )) + __pyx_t_33)) )));
-            __pyx_t_30 = __pyx_v_j;
-            __pyx_t_32 = __pyx_v_k;
-            __pyx_t_35 = (((*((long const  *) ( /* dim=0 */ ((char *) (((long const  *) __pyx_v_occu_i.data) + __pyx_t_31)) ))) != (*((long const  *) ( /* dim=1 */ ((char *) (((long const  *) ( /* dim=0 */ (__pyx_v_bit_combos.data + __pyx_t_30 * __pyx_v_bit_combos.strides[0]) )) + __pyx_t_32)) )))) != 0);
-            if (__pyx_t_35) {
-
-              /* "smol/correlations.pyx":158
- *                     for k in range(K):
- *                         if occu_i[indices[i, k]] != bit_combos[j, k]:
- *                             ok = False             # <<<<<<<<<<<<<<
- *                             break
- *                     if ok:
- */
-              __pyx_v_ok = 0;
-
-              /* "smol/correlations.pyx":159
- *                         if occu_i[indices[i, k]] != bit_combos[j, k]:
- *                             ok = False
- *                             break             # <<<<<<<<<<<<<<
- *                     if ok:
- *                         o -= 1
- */
-              goto __pyx_L18_break;
-
-              /* "smol/correlations.pyx":157
- *                     ok = True
- *                     for k in range(K):
- *                         if occu_i[indices[i, k]] != bit_combos[j, k]:             # <<<<<<<<<<<<<<
- *                             ok = False
- *                             break
+          /* "smol/utils/cluster/correlations.pyx":154
+ *                 ind_f, ind_i = 0, 0
+ *                 for j in range(J):
+ *                     ind_f += tensor_indices[j] * occu_f[indices[i, j]]             # <<<<<<<<<<<<<<
+ *                     ind_i += tensor_indices[j] * occu_i[indices[i, j]]
+ *                 p_f += corr_tensors[m, ind_f]
  */
-            }
-          }
-          __pyx_L18_break:;
+          __pyx_t_26 = __pyx_v_j;
+          __pyx_t_27 = __pyx_v_i;
+          __pyx_t_28 = __pyx_v_j;
+          __pyx_t_29 = (*((long const  *) ( /* dim=1 */ ((char *) (((long const  *) ( /* dim=0 */ (__pyx_v_indices.data + __pyx_t_27 * __pyx_v_indices.strides[0]) )) + __pyx_t_28)) )));
+          __pyx_v_ind_f = (__pyx_v_ind_f + ((*((long const  *) ( /* dim=0 */ ((char *) (((long const  *) __pyx_v_tensor_indices.data) + __pyx_t_26)) ))) * (*((long const  *) ( /* dim=0 */ ((char *) (((long const  *) __pyx_v_occu_f.data) + __pyx_t_29)) )))));
 
-          /* "smol/correlations.pyx":160
- *                             ok = False
- *                             break
- *                     if ok:             # <<<<<<<<<<<<<<
- *                         o -= 1
- *
- */
-          __pyx_t_35 = (__pyx_v_ok != 0);
-          if (__pyx_t_35) {
-
-            /* "smol/correlations.pyx":161
- *                             break
- *                     if ok:
- *                         o -= 1             # <<<<<<<<<<<<<<
- *
- *             o_view[n] = o / r / (I * (bit_indices[m + 1] - bit_indices[m]))
- */
-            __pyx_v_o = (__pyx_v_o - 1.0);
-
-            /* "smol/correlations.pyx":160
- *                             ok = False
- *                             break
- *                     if ok:             # <<<<<<<<<<<<<<
- *                         o -= 1
- *
+          /* "smol/utils/cluster/correlations.pyx":155
+ *                 for j in range(J):
+ *                     ind_f += tensor_indices[j] * occu_f[indices[i, j]]
+ *                     ind_i += tensor_indices[j] * occu_i[indices[i, j]]             # <<<<<<<<<<<<<<
+ *                 p_f += corr_tensors[m, ind_f]
+ *                 p_i += corr_tensors[m, ind_i]
  */
-          }
+          __pyx_t_28 = __pyx_v_j;
+          __pyx_t_27 = __pyx_v_i;
+          __pyx_t_29 = __pyx_v_j;
+          __pyx_t_26 = (*((long const  *) ( /* dim=1 */ ((char *) (((long const  *) ( /* dim=0 */ (__pyx_v_indices.data + __pyx_t_27 * __pyx_v_indices.strides[0]) )) + __pyx_t_29)) )));
+          __pyx_v_ind_i = (__pyx_v_ind_i + ((*((long const  *) ( /* dim=0 */ ((char *) (((long const  *) __pyx_v_tensor_indices.data) + __pyx_t_28)) ))) * (*((long const  *) ( /* dim=0 */ ((char *) (((long const  *) __pyx_v_occu_i.data) + __pyx_t_26)) )))));
         }
+
+        /* "smol/utils/cluster/correlations.pyx":156
+ *                     ind_f += tensor_indices[j] * occu_f[indices[i, j]]
+ *                     ind_i += tensor_indices[j] * occu_i[indices[i, j]]
+ *                 p_f += corr_tensors[m, ind_f]             # <<<<<<<<<<<<<<
+ *                 p_i += corr_tensors[m, ind_i]
+ *             o_view[1, n] = abs(p_f / I - ref_corr_vector[n])
+ */
+        __pyx_t_29 = __pyx_v_m;
+        __pyx_t_27 = __pyx_v_ind_f;
+        __pyx_v_p_f = (__pyx_v_p_f + (*((double const  *) ( /* dim=1 */ ((char *) (((double const  *) ( /* dim=0 */ (__pyx_v_corr_tensors.data + __pyx_t_29 * __pyx_v_corr_tensors.strides[0]) )) + __pyx_t_27)) ))));
+
+        /* "smol/utils/cluster/correlations.pyx":157
+ *                     ind_i += tensor_indices[j] * occu_i[indices[i, j]]
+ *                 p_f += corr_tensors[m, ind_f]
+ *                 p_i += corr_tensors[m, ind_i]             # <<<<<<<<<<<<<<
+ *             o_view[1, n] = abs(p_f / I - ref_corr_vector[n])
+ *             o_view[0, n] = abs(p_i / I - ref_corr_vector[n])
+ */
+        __pyx_t_27 = __pyx_v_m;
+        __pyx_t_29 = __pyx_v_ind_i;
+        __pyx_v_p_i = (__pyx_v_p_i + (*((double const  *) ( /* dim=1 */ ((char *) (((double const  *) ( /* dim=0 */ (__pyx_v_corr_tensors.data + __pyx_t_27 * __pyx_v_corr_tensors.strides[0]) )) + __pyx_t_29)) ))));
       }
 
-      /* "smol/correlations.pyx":163
- *                         o -= 1
- *
- *             o_view[n] = o / r / (I * (bit_indices[m + 1] - bit_indices[m]))             # <<<<<<<<<<<<<<
+      /* "smol/utils/cluster/correlations.pyx":158
+ *                 p_f += corr_tensors[m, ind_f]
+ *                 p_i += corr_tensors[m, ind_i]
+ *             o_view[1, n] = abs(p_f / I - ref_corr_vector[n])             # <<<<<<<<<<<<<<
+ *             o_view[0, n] = abs(p_i / I - ref_corr_vector[n])
+ *             n += 1
+ */
+      __pyx_t_29 = __pyx_v_n;
+      __pyx_t_27 = 1;
+      __pyx_t_26 = __pyx_v_n;
+      *((double *) ( /* dim=1 */ ((char *) (((double *) ( /* dim=0 */ (__pyx_v_o_view.data + __pyx_t_27 * __pyx_v_o_view.strides[0]) )) + __pyx_t_26)) )) = fabs(((__pyx_v_p_f / ((double)__pyx_v_I)) - (*((double const  *) ( /* dim=0 */ ((char *) (((double const  *) __pyx_v_ref_corr_vector.data) + __pyx_t_29)) )))));
+
+      /* "smol/utils/cluster/correlations.pyx":159
+ *                 p_i += corr_tensors[m, ind_i]
+ *             o_view[1, n] = abs(p_f / I - ref_corr_vector[n])
+ *             o_view[0, n] = abs(p_i / I - ref_corr_vector[n])             # <<<<<<<<<<<<<<
  *             n += 1
  *     return out
  */
-      __pyx_t_23 = (__pyx_v_m + 1);
-      __pyx_t_32 = __pyx_v_m;
-      __pyx_t_30 = __pyx_v_n;
-      *((double *) ( /* dim=0 */ ((char *) (((double *) __pyx_v_o_view.data) + __pyx_t_30)) )) = ((__pyx_v_o / __pyx_v_r) / ((double)(__pyx_v_I * ((*((long const  *) ( /* dim=0 */ ((char *) (((long const  *) __pyx_v_bit_indices.data) + __pyx_t_23)) ))) - (*((long const  *) ( /* dim=0 */ ((char *) (((long const  *) __pyx_v_bit_indices.data) + __pyx_t_32)) )))))));
-
-      /* "smol/correlations.pyx":164
- *
- *             o_view[n] = o / r / (I * (bit_indices[m + 1] - bit_indices[m]))
+      __pyx_t_29 = __pyx_v_n;
+      __pyx_t_26 = 0;
+      __pyx_t_27 = __pyx_v_n;
+      *((double *) ( /* dim=1 */ ((char *) (((double *) ( /* dim=0 */ (__pyx_v_o_view.data + __pyx_t_26 * __pyx_v_o_view.strides[0]) )) + __pyx_t_27)) )) = fabs(((__pyx_v_p_i / ((double)__pyx_v_I)) - (*((double const  *) ( /* dim=0 */ ((char *) (((double const  *) __pyx_v_ref_corr_vector.data) + __pyx_t_29)) )))));
+
+      /* "smol/utils/cluster/correlations.pyx":160
+ *             o_view[1, n] = abs(p_f / I - ref_corr_vector[n])
+ *             o_view[0, n] = abs(p_i / I - ref_corr_vector[n])
  *             n += 1             # <<<<<<<<<<<<<<
  *     return out
- *
+ * 
  */
       __pyx_v_n = (__pyx_v_n + 1);
     }
 
-    /* "smol/correlations.pyx":139
- *     cdef double r, o
- *
- *     for n, r, bit_combos, bit_indices, _, indices in site_orbit_list:             # <<<<<<<<<<<<<<
- *         M = bit_indices.shape[0] # index of bit combos
+    /* "smol/utils/cluster/correlations.pyx":145
+ *     o_view[:, 0] = 0
+ * 
+ *     for n, tensor_indices, corr_tensors, indices in orbit_list:             # <<<<<<<<<<<<<<
+ *         M = corr_tensors.shape[0]  # index of bit combos
  *         I = indices.shape[0] # cluster index
  */
   }
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "smol/correlations.pyx":165
- *             o_view[n] = o / r / (I * (bit_indices[m + 1] - bit_indices[m]))
+  /* "smol/utils/cluster/correlations.pyx":161
+ *             o_view[0, n] = abs(p_i / I - ref_corr_vector[n])
  *             n += 1
  *     return out             # <<<<<<<<<<<<<<
- *
- *
+ * 
+ * 
  */
   __Pyx_XDECREF(__pyx_r);
   __Pyx_INCREF(__pyx_v_out);
   __pyx_r = __pyx_v_out;
   goto __pyx_L0;
 
-  /* "smol/correlations.pyx":109
- *
- *
- * cpdef indicator_delta_corr_single_flip(const long[::1] occu_f,             # <<<<<<<<<<<<<<
- *                                        const long[::1] occu_i,
- *                                        const int num_corr_functions,
+  /* "smol/utils/cluster/correlations.pyx":108
+ * 
+ * 
+ * cpdef corr_distance_single_flip(const long[::1] occu_f,             # <<<<<<<<<<<<<<
+ *                                 const long[::1] occu_i,
+ *                                 const double[::1] ref_corr_vector,
  */
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_XDECREF(__pyx_t_2);
   __Pyx_XDECREF(__pyx_t_3);
   __Pyx_XDECREF(__pyx_t_4);
   __PYX_XDEC_MEMVIEW(&__pyx_t_5, 1);
-  __Pyx_XDECREF(__pyx_t_7);
+  __PYX_XDEC_MEMVIEW(&__pyx_t_6, 1);
   __Pyx_XDECREF(__pyx_t_8);
   __Pyx_XDECREF(__pyx_t_9);
   __Pyx_XDECREF(__pyx_t_10);
-  __Pyx_XDECREF(__pyx_t_11);
+  __PYX_XDEC_MEMVIEW(&__pyx_t_13, 1);
+  __PYX_XDEC_MEMVIEW(&__pyx_t_14, 1);
   __PYX_XDEC_MEMVIEW(&__pyx_t_15, 1);
-  __PYX_XDEC_MEMVIEW(&__pyx_t_16, 1);
-  __PYX_XDEC_MEMVIEW(&__pyx_t_17, 1);
-  __Pyx_AddTraceback("smol.correlations.indicator_delta_corr_single_flip", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_AddTraceback("smol.utils.cluster.correlations.corr_distance_single_flip", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = 0;
   __pyx_L0:;
-  __PYX_XDEC_MEMVIEW(&__pyx_v_bit_combos, 1);
   __PYX_XDEC_MEMVIEW(&__pyx_v_indices, 1);
-  __PYX_XDEC_MEMVIEW(&__pyx_v_bit_indices, 1);
+  __PYX_XDEC_MEMVIEW(&__pyx_v_tensor_indices, 1);
+  __PYX_XDEC_MEMVIEW(&__pyx_v_corr_tensors, 1);
   __Pyx_XDECREF(__pyx_v_out);
   __PYX_XDEC_MEMVIEW(&__pyx_v_o_view, 1);
-  __Pyx_XDECREF(__pyx_v__);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* Python wrapper */
-static PyObject *__pyx_pw_4smol_12correlations_5indicator_delta_corr_single_flip(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
-static char __pyx_doc_4smol_12correlations_4indicator_delta_corr_single_flip[] = "Local change in indicator basis correlation vector from single flip.\n\n    Args:\n        occu_f (ndarray):\n            encoded occupancy vector with flip\n        occu_i (ndarray):\n            encoded occupancy vector without flip\n        num_corr_functions (int):\n            total number of bit orderings in expansion.\n        site_orbit_list:\n            Information of all orbits that include the flip site.\n            List of tuples each with\n            (orbit id, cluster ratio, bit_combos,\n             bit_combo_indices site indices, bases array)\n\n    Returns:\n        ndarray: correlation vector difference\n    ";
-static PyObject *__pyx_pw_4smol_12correlations_5indicator_delta_corr_single_flip(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
+static PyObject *__pyx_pw_4smol_5utils_7cluster_12correlations_5corr_distance_single_flip(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static char __pyx_doc_4smol_5utils_7cluster_12correlations_4corr_distance_single_flip[] = "Computes the absolute distance of two correlation vectors separated by a single\n    flip and a given correlation vector.\n\n    Unfortunately this scales just as bad as computing the full correlation vector.\n\n    Args:\n        occu_f (ndarray):\n            encoded occupancy array with flip\n        occu_i (ndarray):\n            encoded occupancy array without flip\n        ref_corr_vector (ndarray):\n            reference correlation vector\n        num_corr_functions (int):\n            total number of bit orderings in expansion.\n        orbit_list:\n            Information of all orbits.\n            (orbit id, flat tensor index array, flat correlation tensor,\n             site indices of clusters)\n\n    Returns:\n        ndarray: 2D with correlation vector distances from reference for each of occu_i\n        and occu_f\n    ";
+static PyObject *__pyx_pw_4smol_5utils_7cluster_12correlations_5corr_distance_single_flip(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
   __Pyx_memviewslice __pyx_v_occu_f = { 0, 0, { 0 }, { 0 }, { 0 } };
   __Pyx_memviewslice __pyx_v_occu_i = { 0, 0, { 0 }, { 0 }, { 0 } };
+  __Pyx_memviewslice __pyx_v_ref_corr_vector = { 0, 0, { 0 }, { 0 }, { 0 } };
   int __pyx_v_num_corr_functions;
-  PyObject *__pyx_v_site_orbit_list = 0;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  PyObject *__pyx_r = 0;
-  __Pyx_RefNannyDeclarations
-  __Pyx_RefNannySetupContext("indicator_delta_corr_single_flip (wrapper)", 0);
-  {
-    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_occu_f,&__pyx_n_s_occu_i,&__pyx_n_s_num_corr_functions,&__pyx_n_s_site_orbit_list,0};
-    PyObject* values[4] = {0,0,0,0};
-    if (unlikely(__pyx_kwds)) {
-      Py_ssize_t kw_args;
-      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
-      switch (pos_args) {
-        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
-        CYTHON_FALLTHROUGH;
-        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
-        CYTHON_FALLTHROUGH;
-        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
-        CYTHON_FALLTHROUGH;
-        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
-        CYTHON_FALLTHROUGH;
-        case  0: break;
-        default: goto __pyx_L5_argtuple_error;
-      }
-      kw_args = PyDict_Size(__pyx_kwds);
-      switch (pos_args) {
-        case  0:
-        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_occu_f)) != 0)) kw_args--;
-        else goto __pyx_L5_argtuple_error;
-        CYTHON_FALLTHROUGH;
-        case  1:
-        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_occu_i)) != 0)) kw_args--;
-        else {
-          __Pyx_RaiseArgtupleInvalid("indicator_delta_corr_single_flip", 1, 4, 4, 1); __PYX_ERR(0, 109, __pyx_L3_error)
-        }
-        CYTHON_FALLTHROUGH;
-        case  2:
-        if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_num_corr_functions)) != 0)) kw_args--;
-        else {
-          __Pyx_RaiseArgtupleInvalid("indicator_delta_corr_single_flip", 1, 4, 4, 2); __PYX_ERR(0, 109, __pyx_L3_error)
-        }
-        CYTHON_FALLTHROUGH;
-        case  3:
-        if (likely((values[3] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_site_orbit_list)) != 0)) kw_args--;
-        else {
-          __Pyx_RaiseArgtupleInvalid("indicator_delta_corr_single_flip", 1, 4, 4, 3); __PYX_ERR(0, 109, __pyx_L3_error)
-        }
-      }
-      if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "indicator_delta_corr_single_flip") < 0)) __PYX_ERR(0, 109, __pyx_L3_error)
-      }
-    } else if (PyTuple_GET_SIZE(__pyx_args) != 4) {
-      goto __pyx_L5_argtuple_error;
-    } else {
-      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
-      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
-      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
-      values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
-    }
-    __pyx_v_occu_f = __Pyx_PyObject_to_MemoryviewSlice_dc_long__const__(values[0], 0); if (unlikely(!__pyx_v_occu_f.memview)) __PYX_ERR(0, 109, __pyx_L3_error)
-    __pyx_v_occu_i = __Pyx_PyObject_to_MemoryviewSlice_dc_long__const__(values[1], 0); if (unlikely(!__pyx_v_occu_i.memview)) __PYX_ERR(0, 110, __pyx_L3_error)
-    __pyx_v_num_corr_functions = __Pyx_PyInt_As_int(values[2]); if (unlikely((__pyx_v_num_corr_functions == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 111, __pyx_L3_error)
-    __pyx_v_site_orbit_list = ((PyObject*)values[3]);
-  }
-  goto __pyx_L4_argument_unpacking_done;
-  __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("indicator_delta_corr_single_flip", 1, 4, 4, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 109, __pyx_L3_error)
-  __pyx_L3_error:;
-  __Pyx_AddTraceback("smol.correlations.indicator_delta_corr_single_flip", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __Pyx_RefNannyFinishContext();
-  return NULL;
-  __pyx_L4_argument_unpacking_done:;
-  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_site_orbit_list), (&PyList_Type), 1, "site_orbit_list", 1))) __PYX_ERR(0, 112, __pyx_L1_error)
-  __pyx_r = __pyx_pf_4smol_12correlations_4indicator_delta_corr_single_flip(__pyx_self, __pyx_v_occu_f, __pyx_v_occu_i, __pyx_v_num_corr_functions, __pyx_v_site_orbit_list);
-
-  /* function exit code */
-  goto __pyx_L0;
-  __pyx_L1_error:;
-  __pyx_r = NULL;
-  __pyx_L0:;
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-static PyObject *__pyx_pf_4smol_12correlations_4indicator_delta_corr_single_flip(CYTHON_UNUSED PyObject *__pyx_self, __Pyx_memviewslice __pyx_v_occu_f, __Pyx_memviewslice __pyx_v_occu_i, int __pyx_v_num_corr_functions, PyObject *__pyx_v_site_orbit_list) {
-  PyObject *__pyx_r = NULL;
-  __Pyx_RefNannyDeclarations
-  PyObject *__pyx_t_1 = NULL;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("indicator_delta_corr_single_flip", 0);
-  __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __pyx_f_4smol_12correlations_indicator_delta_corr_single_flip(__pyx_v_occu_f, __pyx_v_occu_i, __pyx_v_num_corr_functions, __pyx_v_site_orbit_list, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 109, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_r = __pyx_t_1;
-  __pyx_t_1 = 0;
-  goto __pyx_L0;
-
-  /* function exit code */
-  __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_1);
-  __Pyx_AddTraceback("smol.correlations.indicator_delta_corr_single_flip", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __pyx_r = NULL;
-  __pyx_L0:;
-  __PYX_XDEC_MEMVIEW(&__pyx_v_occu_f, 1);
-  __PYX_XDEC_MEMVIEW(&__pyx_v_occu_i, 1);
-  __Pyx_XGIVEREF(__pyx_r);
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-/* "smol/correlations.pyx":168
- *
- *
- * cpdef delta_ewald_single_flip(const long[::1] occu_f,             # <<<<<<<<<<<<<<
- *                               const long[::1] occu_i,
- *                               const double[:, ::1] ewald_matrix,
- */
-
-static PyObject *__pyx_pw_4smol_12correlations_7delta_ewald_single_flip(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
-static PyObject *__pyx_f_4smol_12correlations_delta_ewald_single_flip(__Pyx_memviewslice __pyx_v_occu_f, __Pyx_memviewslice __pyx_v_occu_i, __Pyx_memviewslice __pyx_v_ewald_matrix, __Pyx_memviewslice __pyx_v_ewald_indices, int const __pyx_v_site_ind, CYTHON_UNUSED int __pyx_skip_dispatch) {
-  int __pyx_v_i;
-  int __pyx_v_j;
-  int __pyx_v_k;
-  int __pyx_v_add;
-  int __pyx_v_sub;
-  double __pyx_v_out;
-  double __pyx_v_out_k;
-  PyObject *__pyx_r = NULL;
-  __Pyx_RefNannyDeclarations
-  Py_ssize_t __pyx_t_1;
-  Py_ssize_t __pyx_t_2;
-  Py_ssize_t __pyx_t_3;
-  Py_ssize_t __pyx_t_4;
-  Py_ssize_t __pyx_t_5;
-  int __pyx_t_6;
-  int __pyx_t_7;
-  int __pyx_t_8;
-  PyObject *__pyx_t_9 = NULL;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("delta_ewald_single_flip", 0);
-
-  /* "smol/correlations.pyx":193
- *     cdef int i, j, k, add, sub
- *     cdef bint ok
- *     cdef double out = 0             # <<<<<<<<<<<<<<
- *     cdef double out_k
- *
- */
-  __pyx_v_out = 0.0;
-
-  /* "smol/correlations.pyx":197
- *
- *     # values of -1 are vacancies and hence don't have ewald indices
- *     add = ewald_indices[site_ind, occu_f[site_ind]]             # <<<<<<<<<<<<<<
- *     sub = ewald_indices[site_ind, occu_i[site_ind]]
- *
- */
-  __pyx_t_1 = __pyx_v_site_ind;
-  __pyx_t_2 = __pyx_v_site_ind;
-  __pyx_t_3 = (*((long const  *) ( /* dim=0 */ ((char *) (((long const  *) __pyx_v_occu_f.data) + __pyx_t_1)) )));
-  __pyx_v_add = (*((long const  *) ( /* dim=1 */ ((char *) (((long const  *) ( /* dim=0 */ (__pyx_v_ewald_indices.data + __pyx_t_2 * __pyx_v_ewald_indices.strides[0]) )) + __pyx_t_3)) )));
-
-  /* "smol/correlations.pyx":198
- *     # values of -1 are vacancies and hence don't have ewald indices
- *     add = ewald_indices[site_ind, occu_f[site_ind]]
- *     sub = ewald_indices[site_ind, occu_i[site_ind]]             # <<<<<<<<<<<<<<
- *
- *     for k in range(occu_f.shape[0]):
- */
-  __pyx_t_1 = __pyx_v_site_ind;
-  __pyx_t_3 = __pyx_v_site_ind;
-  __pyx_t_2 = (*((long const  *) ( /* dim=0 */ ((char *) (((long const  *) __pyx_v_occu_i.data) + __pyx_t_1)) )));
-  __pyx_v_sub = (*((long const  *) ( /* dim=1 */ ((char *) (((long const  *) ( /* dim=0 */ (__pyx_v_ewald_indices.data + __pyx_t_3 * __pyx_v_ewald_indices.strides[0]) )) + __pyx_t_2)) )));
-
-  /* "smol/correlations.pyx":200
- *     sub = ewald_indices[site_ind, occu_i[site_ind]]
- *
- *     for k in range(occu_f.shape[0]):             # <<<<<<<<<<<<<<
- *         i = ewald_indices[k, occu_f[k]]
- *         out_k = 0
- */
-  __pyx_t_4 = (__pyx_v_occu_f.shape[0]);
-  __pyx_t_5 = __pyx_t_4;
-  for (__pyx_t_6 = 0; __pyx_t_6 < __pyx_t_5; __pyx_t_6+=1) {
-    __pyx_v_k = __pyx_t_6;
-
-    /* "smol/correlations.pyx":201
- *
- *     for k in range(occu_f.shape[0]):
- *         i = ewald_indices[k, occu_f[k]]             # <<<<<<<<<<<<<<
- *         out_k = 0
- *         if i != -1 and add != -1:
- */
-    __pyx_t_1 = __pyx_v_k;
-    __pyx_t_2 = __pyx_v_k;
-    __pyx_t_3 = (*((long const  *) ( /* dim=0 */ ((char *) (((long const  *) __pyx_v_occu_f.data) + __pyx_t_1)) )));
-    __pyx_v_i = (*((long const  *) ( /* dim=1 */ ((char *) (((long const  *) ( /* dim=0 */ (__pyx_v_ewald_indices.data + __pyx_t_2 * __pyx_v_ewald_indices.strides[0]) )) + __pyx_t_3)) )));
-
-    /* "smol/correlations.pyx":202
- *     for k in range(occu_f.shape[0]):
- *         i = ewald_indices[k, occu_f[k]]
- *         out_k = 0             # <<<<<<<<<<<<<<
- *         if i != -1 and add != -1:
- *             if i != add:
- */
-    __pyx_v_out_k = 0.0;
-
-    /* "smol/correlations.pyx":203
- *         i = ewald_indices[k, occu_f[k]]
- *         out_k = 0
- *         if i != -1 and add != -1:             # <<<<<<<<<<<<<<
- *             if i != add:
- *                 out_k = out_k + 2 * ewald_matrix[i, add]
- */
-    __pyx_t_8 = ((__pyx_v_i != -1L) != 0);
-    if (__pyx_t_8) {
-    } else {
-      __pyx_t_7 = __pyx_t_8;
-      goto __pyx_L6_bool_binop_done;
-    }
-    __pyx_t_8 = ((__pyx_v_add != -1L) != 0);
-    __pyx_t_7 = __pyx_t_8;
-    __pyx_L6_bool_binop_done:;
-    if (__pyx_t_7) {
-
-      /* "smol/correlations.pyx":204
- *         out_k = 0
- *         if i != -1 and add != -1:
- *             if i != add:             # <<<<<<<<<<<<<<
- *                 out_k = out_k + 2 * ewald_matrix[i, add]
- *             else:
- */
-      __pyx_t_7 = ((__pyx_v_i != __pyx_v_add) != 0);
-      if (__pyx_t_7) {
-
-        /* "smol/correlations.pyx":205
- *         if i != -1 and add != -1:
- *             if i != add:
- *                 out_k = out_k + 2 * ewald_matrix[i, add]             # <<<<<<<<<<<<<<
- *             else:
- *                 out_k = out_k + ewald_matrix[i, add]
- */
-        __pyx_t_1 = __pyx_v_i;
-        __pyx_t_3 = __pyx_v_add;
-        __pyx_v_out_k = (__pyx_v_out_k + (2.0 * (*((double const  *) ( /* dim=1 */ ((char *) (((double const  *) ( /* dim=0 */ (__pyx_v_ewald_matrix.data + __pyx_t_1 * __pyx_v_ewald_matrix.strides[0]) )) + __pyx_t_3)) )))));
-
-        /* "smol/correlations.pyx":204
- *         out_k = 0
- *         if i != -1 and add != -1:
- *             if i != add:             # <<<<<<<<<<<<<<
- *                 out_k = out_k + 2 * ewald_matrix[i, add]
- *             else:
- */
-        goto __pyx_L8;
-      }
-
-      /* "smol/correlations.pyx":207
- *                 out_k = out_k + 2 * ewald_matrix[i, add]
- *             else:
- *                 out_k = out_k + ewald_matrix[i, add]             # <<<<<<<<<<<<<<
- *
- *         j = ewald_indices[k, occu_i[k]]
- */
-      /*else*/ {
-        __pyx_t_3 = __pyx_v_i;
-        __pyx_t_1 = __pyx_v_add;
-        __pyx_v_out_k = (__pyx_v_out_k + (*((double const  *) ( /* dim=1 */ ((char *) (((double const  *) ( /* dim=0 */ (__pyx_v_ewald_matrix.data + __pyx_t_3 * __pyx_v_ewald_matrix.strides[0]) )) + __pyx_t_1)) ))));
-      }
-      __pyx_L8:;
-
-      /* "smol/correlations.pyx":203
- *         i = ewald_indices[k, occu_f[k]]
- *         out_k = 0
- *         if i != -1 and add != -1:             # <<<<<<<<<<<<<<
- *             if i != add:
- *                 out_k = out_k + 2 * ewald_matrix[i, add]
- */
-    }
-
-    /* "smol/correlations.pyx":209
- *                 out_k = out_k + ewald_matrix[i, add]
- *
- *         j = ewald_indices[k, occu_i[k]]             # <<<<<<<<<<<<<<
- *         if j != -1 and sub != -1:
- *             if j != sub:
- */
-    __pyx_t_1 = __pyx_v_k;
-    __pyx_t_3 = __pyx_v_k;
-    __pyx_t_2 = (*((long const  *) ( /* dim=0 */ ((char *) (((long const  *) __pyx_v_occu_i.data) + __pyx_t_1)) )));
-    __pyx_v_j = (*((long const  *) ( /* dim=1 */ ((char *) (((long const  *) ( /* dim=0 */ (__pyx_v_ewald_indices.data + __pyx_t_3 * __pyx_v_ewald_indices.strides[0]) )) + __pyx_t_2)) )));
-
-    /* "smol/correlations.pyx":210
- *
- *         j = ewald_indices[k, occu_i[k]]
- *         if j != -1 and sub != -1:             # <<<<<<<<<<<<<<
- *             if j != sub:
- *                 out_k = out_k - 2 * ewald_matrix[j, sub]
- */
-    __pyx_t_8 = ((__pyx_v_j != -1L) != 0);
-    if (__pyx_t_8) {
-    } else {
-      __pyx_t_7 = __pyx_t_8;
-      goto __pyx_L10_bool_binop_done;
-    }
-    __pyx_t_8 = ((__pyx_v_sub != -1L) != 0);
-    __pyx_t_7 = __pyx_t_8;
-    __pyx_L10_bool_binop_done:;
-    if (__pyx_t_7) {
-
-      /* "smol/correlations.pyx":211
- *         j = ewald_indices[k, occu_i[k]]
- *         if j != -1 and sub != -1:
- *             if j != sub:             # <<<<<<<<<<<<<<
- *                 out_k = out_k - 2 * ewald_matrix[j, sub]
- *             else:
- */
-      __pyx_t_7 = ((__pyx_v_j != __pyx_v_sub) != 0);
-      if (__pyx_t_7) {
-
-        /* "smol/correlations.pyx":212
- *         if j != -1 and sub != -1:
- *             if j != sub:
- *                 out_k = out_k - 2 * ewald_matrix[j, sub]             # <<<<<<<<<<<<<<
- *             else:
- *                 out_k = out_k - ewald_matrix[j, sub]
- */
-        __pyx_t_1 = __pyx_v_j;
-        __pyx_t_2 = __pyx_v_sub;
-        __pyx_v_out_k = (__pyx_v_out_k - (2.0 * (*((double const  *) ( /* dim=1 */ ((char *) (((double const  *) ( /* dim=0 */ (__pyx_v_ewald_matrix.data + __pyx_t_1 * __pyx_v_ewald_matrix.strides[0]) )) + __pyx_t_2)) )))));
-
-        /* "smol/correlations.pyx":211
- *         j = ewald_indices[k, occu_i[k]]
- *         if j != -1 and sub != -1:
- *             if j != sub:             # <<<<<<<<<<<<<<
- *                 out_k = out_k - 2 * ewald_matrix[j, sub]
- *             else:
- */
-        goto __pyx_L12;
-      }
-
-      /* "smol/correlations.pyx":214
- *                 out_k = out_k - 2 * ewald_matrix[j, sub]
- *             else:
- *                 out_k = out_k - ewald_matrix[j, sub]             # <<<<<<<<<<<<<<
- *         out += out_k
- *     return out
- */
-      /*else*/ {
-        __pyx_t_2 = __pyx_v_j;
-        __pyx_t_1 = __pyx_v_sub;
-        __pyx_v_out_k = (__pyx_v_out_k - (*((double const  *) ( /* dim=1 */ ((char *) (((double const  *) ( /* dim=0 */ (__pyx_v_ewald_matrix.data + __pyx_t_2 * __pyx_v_ewald_matrix.strides[0]) )) + __pyx_t_1)) ))));
-      }
-      __pyx_L12:;
-
-      /* "smol/correlations.pyx":210
- *
- *         j = ewald_indices[k, occu_i[k]]
- *         if j != -1 and sub != -1:             # <<<<<<<<<<<<<<
- *             if j != sub:
- *                 out_k = out_k - 2 * ewald_matrix[j, sub]
- */
-    }
-
-    /* "smol/correlations.pyx":215
- *             else:
- *                 out_k = out_k - ewald_matrix[j, sub]
- *         out += out_k             # <<<<<<<<<<<<<<
- *     return out
- *
- */
-    __pyx_v_out = (__pyx_v_out + __pyx_v_out_k);
-  }
-
-  /* "smol/correlations.pyx":216
- *                 out_k = out_k - ewald_matrix[j, sub]
- *         out += out_k
- *     return out             # <<<<<<<<<<<<<<
- *
- *
- */
-  __Pyx_XDECREF(__pyx_r);
-  __pyx_t_9 = PyFloat_FromDouble(__pyx_v_out); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 216, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_9);
-  __pyx_r = __pyx_t_9;
-  __pyx_t_9 = 0;
-  goto __pyx_L0;
-
-  /* "smol/correlations.pyx":168
- *
- *
- * cpdef delta_ewald_single_flip(const long[::1] occu_f,             # <<<<<<<<<<<<<<
- *                               const long[::1] occu_i,
- *                               const double[:, ::1] ewald_matrix,
- */
-
-  /* function exit code */
-  __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_9);
-  __Pyx_AddTraceback("smol.correlations.delta_ewald_single_flip", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __pyx_r = 0;
-  __pyx_L0:;
-  __Pyx_XGIVEREF(__pyx_r);
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-/* Python wrapper */
-static PyObject *__pyx_pw_4smol_12correlations_7delta_ewald_single_flip(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
-static char __pyx_doc_4smol_12correlations_6delta_ewald_single_flip[] = "Compute the change in electrostatic interaction energy from a flip.\n\n    Args:\n        occu_f (ndarray):\n            encoded occupancy vector with flip\n        occu_i (ndarray):\n            encoded occupancy vector without flip\n        ewald_matrix (ndarray):\n            Ewald matrix for electrostatic interactions\n        ewald_indices (ndarray):\n            2D array of indices corresponding to a specific site occupation\n            in the ewald matrix\n        site_ind (int):\n            site index for site being flipped\n\n    Returns:\n        float: electrostatic interaction energy difference\n    ";
-static PyObject *__pyx_pw_4smol_12correlations_7delta_ewald_single_flip(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
-  __Pyx_memviewslice __pyx_v_occu_f = { 0, 0, { 0 }, { 0 }, { 0 } };
-  __Pyx_memviewslice __pyx_v_occu_i = { 0, 0, { 0 }, { 0 }, { 0 } };
-  __Pyx_memviewslice __pyx_v_ewald_matrix = { 0, 0, { 0 }, { 0 }, { 0 } };
-  __Pyx_memviewslice __pyx_v_ewald_indices = { 0, 0, { 0 }, { 0 }, { 0 } };
-  int __pyx_v_site_ind;
+  PyObject *__pyx_v_orbit_list = 0;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
-  __Pyx_RefNannySetupContext("delta_ewald_single_flip (wrapper)", 0);
+  __Pyx_RefNannySetupContext("corr_distance_single_flip (wrapper)", 0);
   {
-    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_occu_f,&__pyx_n_s_occu_i,&__pyx_n_s_ewald_matrix,&__pyx_n_s_ewald_indices,&__pyx_n_s_site_ind,0};
+    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_occu_f,&__pyx_n_s_occu_i,&__pyx_n_s_ref_corr_vector,&__pyx_n_s_num_corr_functions,&__pyx_n_s_orbit_list,0};
     PyObject* values[5] = {0,0,0,0,0};
     if (unlikely(__pyx_kwds)) {
       Py_ssize_t kw_args;
       const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
       switch (pos_args) {
         case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
         CYTHON_FALLTHROUGH;
@@ -4718,118 +4234,122 @@
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_occu_f)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_occu_i)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("delta_ewald_single_flip", 1, 5, 5, 1); __PYX_ERR(0, 168, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("corr_distance_single_flip", 1, 5, 5, 1); __PYX_ERR(0, 108, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  2:
-        if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_ewald_matrix)) != 0)) kw_args--;
+        if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_ref_corr_vector)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("delta_ewald_single_flip", 1, 5, 5, 2); __PYX_ERR(0, 168, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("corr_distance_single_flip", 1, 5, 5, 2); __PYX_ERR(0, 108, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  3:
-        if (likely((values[3] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_ewald_indices)) != 0)) kw_args--;
+        if (likely((values[3] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_num_corr_functions)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("delta_ewald_single_flip", 1, 5, 5, 3); __PYX_ERR(0, 168, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("corr_distance_single_flip", 1, 5, 5, 3); __PYX_ERR(0, 108, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  4:
-        if (likely((values[4] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_site_ind)) != 0)) kw_args--;
+        if (likely((values[4] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_orbit_list)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("delta_ewald_single_flip", 1, 5, 5, 4); __PYX_ERR(0, 168, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("corr_distance_single_flip", 1, 5, 5, 4); __PYX_ERR(0, 108, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "delta_ewald_single_flip") < 0)) __PYX_ERR(0, 168, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "corr_distance_single_flip") < 0)) __PYX_ERR(0, 108, __pyx_L3_error)
       }
     } else if (PyTuple_GET_SIZE(__pyx_args) != 5) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
       values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
       values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
       values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
       values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
     }
-    __pyx_v_occu_f = __Pyx_PyObject_to_MemoryviewSlice_dc_long__const__(values[0], 0); if (unlikely(!__pyx_v_occu_f.memview)) __PYX_ERR(0, 168, __pyx_L3_error)
-    __pyx_v_occu_i = __Pyx_PyObject_to_MemoryviewSlice_dc_long__const__(values[1], 0); if (unlikely(!__pyx_v_occu_i.memview)) __PYX_ERR(0, 169, __pyx_L3_error)
-    __pyx_v_ewald_matrix = __Pyx_PyObject_to_MemoryviewSlice_d_dc_double__const__(values[2], 0); if (unlikely(!__pyx_v_ewald_matrix.memview)) __PYX_ERR(0, 170, __pyx_L3_error)
-    __pyx_v_ewald_indices = __Pyx_PyObject_to_MemoryviewSlice_d_dc_long__const__(values[3], 0); if (unlikely(!__pyx_v_ewald_indices.memview)) __PYX_ERR(0, 171, __pyx_L3_error)
-    __pyx_v_site_ind = __Pyx_PyInt_As_int(values[4]); if (unlikely((__pyx_v_site_ind == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 172, __pyx_L3_error)
+    __pyx_v_occu_f = __Pyx_PyObject_to_MemoryviewSlice_dc_long__const__(values[0], 0); if (unlikely(!__pyx_v_occu_f.memview)) __PYX_ERR(0, 108, __pyx_L3_error)
+    __pyx_v_occu_i = __Pyx_PyObject_to_MemoryviewSlice_dc_long__const__(values[1], 0); if (unlikely(!__pyx_v_occu_i.memview)) __PYX_ERR(0, 109, __pyx_L3_error)
+    __pyx_v_ref_corr_vector = __Pyx_PyObject_to_MemoryviewSlice_dc_double__const__(values[2], 0); if (unlikely(!__pyx_v_ref_corr_vector.memview)) __PYX_ERR(0, 110, __pyx_L3_error)
+    __pyx_v_num_corr_functions = __Pyx_PyInt_As_int(values[3]); if (unlikely((__pyx_v_num_corr_functions == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 111, __pyx_L3_error)
+    __pyx_v_orbit_list = ((PyObject*)values[4]);
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("delta_ewald_single_flip", 1, 5, 5, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 168, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("corr_distance_single_flip", 1, 5, 5, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 108, __pyx_L3_error)
   __pyx_L3_error:;
-  __Pyx_AddTraceback("smol.correlations.delta_ewald_single_flip", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_AddTraceback("smol.utils.cluster.correlations.corr_distance_single_flip", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
-  __pyx_r = __pyx_pf_4smol_12correlations_6delta_ewald_single_flip(__pyx_self, __pyx_v_occu_f, __pyx_v_occu_i, __pyx_v_ewald_matrix, __pyx_v_ewald_indices, __pyx_v_site_ind);
+  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_orbit_list), (&PyList_Type), 1, "orbit_list", 1))) __PYX_ERR(0, 112, __pyx_L1_error)
+  __pyx_r = __pyx_pf_4smol_5utils_7cluster_12correlations_4corr_distance_single_flip(__pyx_self, __pyx_v_occu_f, __pyx_v_occu_i, __pyx_v_ref_corr_vector, __pyx_v_num_corr_functions, __pyx_v_orbit_list);
 
   /* function exit code */
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __pyx_r = NULL;
+  __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-static PyObject *__pyx_pf_4smol_12correlations_6delta_ewald_single_flip(CYTHON_UNUSED PyObject *__pyx_self, __Pyx_memviewslice __pyx_v_occu_f, __Pyx_memviewslice __pyx_v_occu_i, __Pyx_memviewslice __pyx_v_ewald_matrix, __Pyx_memviewslice __pyx_v_ewald_indices, int __pyx_v_site_ind) {
+static PyObject *__pyx_pf_4smol_5utils_7cluster_12correlations_4corr_distance_single_flip(CYTHON_UNUSED PyObject *__pyx_self, __Pyx_memviewslice __pyx_v_occu_f, __Pyx_memviewslice __pyx_v_occu_i, __Pyx_memviewslice __pyx_v_ref_corr_vector, int __pyx_v_num_corr_functions, PyObject *__pyx_v_orbit_list) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("delta_ewald_single_flip", 0);
+  __Pyx_RefNannySetupContext("corr_distance_single_flip", 0);
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __pyx_f_4smol_12correlations_delta_ewald_single_flip(__pyx_v_occu_f, __pyx_v_occu_i, __pyx_v_ewald_matrix, __pyx_v_ewald_indices, __pyx_v_site_ind, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 168, __pyx_L1_error)
+  __pyx_t_1 = __pyx_f_4smol_5utils_7cluster_12correlations_corr_distance_single_flip(__pyx_v_occu_f, __pyx_v_occu_i, __pyx_v_ref_corr_vector, __pyx_v_num_corr_functions, __pyx_v_orbit_list, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 108, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
-  __Pyx_AddTraceback("smol.correlations.delta_ewald_single_flip", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_AddTraceback("smol.utils.cluster.correlations.corr_distance_single_flip", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __pyx_L0:;
   __PYX_XDEC_MEMVIEW(&__pyx_v_occu_f, 1);
   __PYX_XDEC_MEMVIEW(&__pyx_v_occu_i, 1);
-  __PYX_XDEC_MEMVIEW(&__pyx_v_ewald_matrix, 1);
-  __PYX_XDEC_MEMVIEW(&__pyx_v_ewald_indices, 1);
+  __PYX_XDEC_MEMVIEW(&__pyx_v_ref_corr_vector, 1);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "smol/correlations.pyx":219
- *
- *
+/* "smol/utils/cluster/correlations.pyx":164
+ * 
+ * 
  * cpdef interactions_from_occupancy(const long[::1] occu,             # <<<<<<<<<<<<<<
  *                                   const int num_interactions,
  *                                   const double offset,
  */
 
-static PyObject *__pyx_pw_4smol_12correlations_9interactions_from_occupancy(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
-static PyObject *__pyx_f_4smol_12correlations_interactions_from_occupancy(__Pyx_memviewslice __pyx_v_occu, int const __pyx_v_num_interactions, double const __pyx_v_offset, PyObject *__pyx_v_orbit_list, CYTHON_UNUSED int __pyx_skip_dispatch) {
+static PyObject *__pyx_pw_4smol_5utils_7cluster_12correlations_7interactions_from_occupancy(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static PyObject *__pyx_f_4smol_5utils_7cluster_12correlations_interactions_from_occupancy(__Pyx_memviewslice __pyx_v_occu, int const __pyx_v_num_interactions, double const __pyx_v_offset, PyObject *__pyx_v_orbit_list, CYTHON_UNUSED int __pyx_skip_dispatch) {
   int __pyx_v_n;
   int __pyx_v_i;
   int __pyx_v_j;
   int __pyx_v_I;
   int __pyx_v_J;
   int __pyx_v_index;
   double __pyx_v_p;
   __Pyx_memviewslice __pyx_v_indices = { 0, 0, { 0 }, { 0 }, { 0 } };
   __Pyx_memviewslice __pyx_v_tensor_indices = { 0, 0, { 0 }, { 0 }, { 0 } };
-  __Pyx_memviewslice __pyx_v_interaction_tensors = { 0, 0, { 0 }, { 0 }, { 0 } };
+  __Pyx_memviewslice __pyx_v_interaction_tensor = { 0, 0, { 0 }, { 0 }, { 0 } };
   PyObject *__pyx_v_out = NULL;
   __Pyx_memviewslice __pyx_v_o_view = { 0, 0, { 0 }, { 0 }, { 0 } };
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   PyObject *__pyx_t_2 = NULL;
   PyObject *__pyx_t_3 = NULL;
@@ -4853,299 +4373,299 @@
   Py_ssize_t __pyx_t_21;
   Py_ssize_t __pyx_t_22;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("interactions_from_occupancy", 0);
 
-  /* "smol/correlations.pyx":243
+  /* "smol/utils/cluster/correlations.pyx":189
  *     cdef const long[::1] tensor_indices
- *     cdef const double[::1] interaction_tensors
+ *     cdef const double[::1] interaction_tensor
  *     out = np.zeros(num_interactions)             # <<<<<<<<<<<<<<
  *     cdef double[:] o_view = out
  *     o_view[0] = offset  # empty cluster
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_np); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 243, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_np); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 189, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_zeros); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 243, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_zeros); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 189, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_2 = __Pyx_PyInt_From_int(__pyx_v_num_interactions); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 243, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyInt_From_int(__pyx_v_num_interactions); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 189, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_t_4 = NULL;
   if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
     __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
     if (likely(__pyx_t_4)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
       __Pyx_INCREF(__pyx_t_4);
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_3, function);
     }
   }
   __pyx_t_1 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_4, __pyx_t_2) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_2);
   __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 243, __pyx_L1_error)
+  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 189, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __pyx_v_out = __pyx_t_1;
   __pyx_t_1 = 0;
 
-  /* "smol/correlations.pyx":244
- *     cdef const double[::1] interaction_tensors
+  /* "smol/utils/cluster/correlations.pyx":190
+ *     cdef const double[::1] interaction_tensor
  *     out = np.zeros(num_interactions)
  *     cdef double[:] o_view = out             # <<<<<<<<<<<<<<
  *     o_view[0] = offset  # empty cluster
- *
+ * 
  */
-  __pyx_t_5 = __Pyx_PyObject_to_MemoryviewSlice_ds_double(__pyx_v_out, PyBUF_WRITABLE); if (unlikely(!__pyx_t_5.memview)) __PYX_ERR(0, 244, __pyx_L1_error)
+  __pyx_t_5 = __Pyx_PyObject_to_MemoryviewSlice_ds_double(__pyx_v_out, PyBUF_WRITABLE); if (unlikely(!__pyx_t_5.memview)) __PYX_ERR(0, 190, __pyx_L1_error)
   __pyx_v_o_view = __pyx_t_5;
   __pyx_t_5.memview = NULL;
   __pyx_t_5.data = NULL;
 
-  /* "smol/correlations.pyx":245
+  /* "smol/utils/cluster/correlations.pyx":191
  *     out = np.zeros(num_interactions)
  *     cdef double[:] o_view = out
  *     o_view[0] = offset  # empty cluster             # <<<<<<<<<<<<<<
- *
+ * 
  *     n = 1
  */
   __pyx_t_6 = 0;
   *((double *) ( /* dim=0 */ (__pyx_v_o_view.data + __pyx_t_6 * __pyx_v_o_view.strides[0]) )) = __pyx_v_offset;
 
-  /* "smol/correlations.pyx":247
+  /* "smol/utils/cluster/correlations.pyx":193
  *     o_view[0] = offset  # empty cluster
- *
+ * 
  *     n = 1             # <<<<<<<<<<<<<<
- *     for tensor_indices, interaction_tensors, indices in orbit_list:
+ *     for tensor_indices, interaction_tensor, indices in orbit_list:
  *         I = indices.shape[0] # cluster index
  */
   __pyx_v_n = 1;
 
-  /* "smol/correlations.pyx":248
- *
+  /* "smol/utils/cluster/correlations.pyx":194
+ * 
  *     n = 1
- *     for tensor_indices, interaction_tensors, indices in orbit_list:             # <<<<<<<<<<<<<<
+ *     for tensor_indices, interaction_tensor, indices in orbit_list:             # <<<<<<<<<<<<<<
  *         I = indices.shape[0] # cluster index
  *         J = indices.shape[1] # index within cluster
  */
   if (unlikely(__pyx_v_orbit_list == Py_None)) {
     PyErr_SetString(PyExc_TypeError, "'NoneType' object is not iterable");
-    __PYX_ERR(0, 248, __pyx_L1_error)
+    __PYX_ERR(0, 194, __pyx_L1_error)
   }
   __pyx_t_1 = __pyx_v_orbit_list; __Pyx_INCREF(__pyx_t_1); __pyx_t_7 = 0;
   for (;;) {
     if (__pyx_t_7 >= PyList_GET_SIZE(__pyx_t_1)) break;
     #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-    __pyx_t_3 = PyList_GET_ITEM(__pyx_t_1, __pyx_t_7); __Pyx_INCREF(__pyx_t_3); __pyx_t_7++; if (unlikely(0 < 0)) __PYX_ERR(0, 248, __pyx_L1_error)
+    __pyx_t_3 = PyList_GET_ITEM(__pyx_t_1, __pyx_t_7); __Pyx_INCREF(__pyx_t_3); __pyx_t_7++; if (unlikely(0 < 0)) __PYX_ERR(0, 194, __pyx_L1_error)
     #else
-    __pyx_t_3 = PySequence_ITEM(__pyx_t_1, __pyx_t_7); __pyx_t_7++; if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 248, __pyx_L1_error)
+    __pyx_t_3 = PySequence_ITEM(__pyx_t_1, __pyx_t_7); __pyx_t_7++; if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 194, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     #endif
     if ((likely(PyTuple_CheckExact(__pyx_t_3))) || (PyList_CheckExact(__pyx_t_3))) {
       PyObject* sequence = __pyx_t_3;
       Py_ssize_t size = __Pyx_PySequence_SIZE(sequence);
       if (unlikely(size != 3)) {
         if (size > 3) __Pyx_RaiseTooManyValuesError(3);
         else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
-        __PYX_ERR(0, 248, __pyx_L1_error)
+        __PYX_ERR(0, 194, __pyx_L1_error)
       }
       #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
       if (likely(PyTuple_CheckExact(sequence))) {
-        __pyx_t_2 = PyTuple_GET_ITEM(sequence, 0);
-        __pyx_t_4 = PyTuple_GET_ITEM(sequence, 1);
-        __pyx_t_8 = PyTuple_GET_ITEM(sequence, 2);
+        __pyx_t_2 = PyTuple_GET_ITEM(sequence, 0); 
+        __pyx_t_4 = PyTuple_GET_ITEM(sequence, 1); 
+        __pyx_t_8 = PyTuple_GET_ITEM(sequence, 2); 
       } else {
-        __pyx_t_2 = PyList_GET_ITEM(sequence, 0);
-        __pyx_t_4 = PyList_GET_ITEM(sequence, 1);
-        __pyx_t_8 = PyList_GET_ITEM(sequence, 2);
+        __pyx_t_2 = PyList_GET_ITEM(sequence, 0); 
+        __pyx_t_4 = PyList_GET_ITEM(sequence, 1); 
+        __pyx_t_8 = PyList_GET_ITEM(sequence, 2); 
       }
       __Pyx_INCREF(__pyx_t_2);
       __Pyx_INCREF(__pyx_t_4);
       __Pyx_INCREF(__pyx_t_8);
       #else
-      __pyx_t_2 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 248, __pyx_L1_error)
+      __pyx_t_2 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 194, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_2);
-      __pyx_t_4 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 248, __pyx_L1_error)
+      __pyx_t_4 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 194, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_4);
-      __pyx_t_8 = PySequence_ITEM(sequence, 2); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 248, __pyx_L1_error)
+      __pyx_t_8 = PySequence_ITEM(sequence, 2); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 194, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_8);
       #endif
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     } else {
       Py_ssize_t index = -1;
-      __pyx_t_9 = PyObject_GetIter(__pyx_t_3); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 248, __pyx_L1_error)
+      __pyx_t_9 = PyObject_GetIter(__pyx_t_3); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 194, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_9);
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
       __pyx_t_10 = Py_TYPE(__pyx_t_9)->tp_iternext;
       index = 0; __pyx_t_2 = __pyx_t_10(__pyx_t_9); if (unlikely(!__pyx_t_2)) goto __pyx_L5_unpacking_failed;
       __Pyx_GOTREF(__pyx_t_2);
       index = 1; __pyx_t_4 = __pyx_t_10(__pyx_t_9); if (unlikely(!__pyx_t_4)) goto __pyx_L5_unpacking_failed;
       __Pyx_GOTREF(__pyx_t_4);
       index = 2; __pyx_t_8 = __pyx_t_10(__pyx_t_9); if (unlikely(!__pyx_t_8)) goto __pyx_L5_unpacking_failed;
       __Pyx_GOTREF(__pyx_t_8);
-      if (__Pyx_IternextUnpackEndCheck(__pyx_t_10(__pyx_t_9), 3) < 0) __PYX_ERR(0, 248, __pyx_L1_error)
+      if (__Pyx_IternextUnpackEndCheck(__pyx_t_10(__pyx_t_9), 3) < 0) __PYX_ERR(0, 194, __pyx_L1_error)
       __pyx_t_10 = NULL;
       __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
       goto __pyx_L6_unpacking_done;
       __pyx_L5_unpacking_failed:;
       __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
       __pyx_t_10 = NULL;
       if (__Pyx_IterFinish() == 0) __Pyx_RaiseNeedMoreValuesError(index);
-      __PYX_ERR(0, 248, __pyx_L1_error)
+      __PYX_ERR(0, 194, __pyx_L1_error)
       __pyx_L6_unpacking_done:;
     }
-    __pyx_t_11 = __Pyx_PyObject_to_MemoryviewSlice_dc_long__const__(__pyx_t_2, 0); if (unlikely(!__pyx_t_11.memview)) __PYX_ERR(0, 248, __pyx_L1_error)
+    __pyx_t_11 = __Pyx_PyObject_to_MemoryviewSlice_dc_long__const__(__pyx_t_2, 0); if (unlikely(!__pyx_t_11.memview)) __PYX_ERR(0, 194, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __pyx_t_12 = __Pyx_PyObject_to_MemoryviewSlice_dc_double__const__(__pyx_t_4, 0); if (unlikely(!__pyx_t_12.memview)) __PYX_ERR(0, 248, __pyx_L1_error)
+    __pyx_t_12 = __Pyx_PyObject_to_MemoryviewSlice_dc_double__const__(__pyx_t_4, 0); if (unlikely(!__pyx_t_12.memview)) __PYX_ERR(0, 194, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-    __pyx_t_13 = __Pyx_PyObject_to_MemoryviewSlice_d_dc_long__const__(__pyx_t_8, 0); if (unlikely(!__pyx_t_13.memview)) __PYX_ERR(0, 248, __pyx_L1_error)
+    __pyx_t_13 = __Pyx_PyObject_to_MemoryviewSlice_d_dc_long__const__(__pyx_t_8, 0); if (unlikely(!__pyx_t_13.memview)) __PYX_ERR(0, 194, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
     __PYX_XDEC_MEMVIEW(&__pyx_v_tensor_indices, 1);
     __pyx_v_tensor_indices = __pyx_t_11;
     __pyx_t_11.memview = NULL;
     __pyx_t_11.data = NULL;
-    __PYX_XDEC_MEMVIEW(&__pyx_v_interaction_tensors, 1);
-    __pyx_v_interaction_tensors = __pyx_t_12;
+    __PYX_XDEC_MEMVIEW(&__pyx_v_interaction_tensor, 1);
+    __pyx_v_interaction_tensor = __pyx_t_12;
     __pyx_t_12.memview = NULL;
     __pyx_t_12.data = NULL;
     __PYX_XDEC_MEMVIEW(&__pyx_v_indices, 1);
     __pyx_v_indices = __pyx_t_13;
     __pyx_t_13.memview = NULL;
     __pyx_t_13.data = NULL;
 
-    /* "smol/correlations.pyx":249
+    /* "smol/utils/cluster/correlations.pyx":195
  *     n = 1
- *     for tensor_indices, interaction_tensors, indices in orbit_list:
+ *     for tensor_indices, interaction_tensor, indices in orbit_list:
  *         I = indices.shape[0] # cluster index             # <<<<<<<<<<<<<<
  *         J = indices.shape[1] # index within cluster
  *         p = 0
  */
     __pyx_v_I = (__pyx_v_indices.shape[0]);
 
-    /* "smol/correlations.pyx":250
- *     for tensor_indices, interaction_tensors, indices in orbit_list:
+    /* "smol/utils/cluster/correlations.pyx":196
+ *     for tensor_indices, interaction_tensor, indices in orbit_list:
  *         I = indices.shape[0] # cluster index
  *         J = indices.shape[1] # index within cluster             # <<<<<<<<<<<<<<
  *         p = 0
  *         for i in range(I):
  */
     __pyx_v_J = (__pyx_v_indices.shape[1]);
 
-    /* "smol/correlations.pyx":251
+    /* "smol/utils/cluster/correlations.pyx":197
  *         I = indices.shape[0] # cluster index
  *         J = indices.shape[1] # index within cluster
  *         p = 0             # <<<<<<<<<<<<<<
  *         for i in range(I):
  *             index = 0
  */
     __pyx_v_p = 0.0;
 
-    /* "smol/correlations.pyx":252
+    /* "smol/utils/cluster/correlations.pyx":198
  *         J = indices.shape[1] # index within cluster
  *         p = 0
  *         for i in range(I):             # <<<<<<<<<<<<<<
  *             index = 0
  *             for j in range(J):
  */
     __pyx_t_14 = __pyx_v_I;
     __pyx_t_15 = __pyx_t_14;
     for (__pyx_t_16 = 0; __pyx_t_16 < __pyx_t_15; __pyx_t_16+=1) {
       __pyx_v_i = __pyx_t_16;
 
-      /* "smol/correlations.pyx":253
+      /* "smol/utils/cluster/correlations.pyx":199
  *         p = 0
  *         for i in range(I):
  *             index = 0             # <<<<<<<<<<<<<<
  *             for j in range(J):
  *                 index += tensor_indices[j] * occu[indices[i, j]]
  */
       __pyx_v_index = 0;
 
-      /* "smol/correlations.pyx":254
+      /* "smol/utils/cluster/correlations.pyx":200
  *         for i in range(I):
  *             index = 0
  *             for j in range(J):             # <<<<<<<<<<<<<<
  *                 index += tensor_indices[j] * occu[indices[i, j]]
- *             p += interaction_tensors[index]
+ *             p += interaction_tensor[index]
  */
       __pyx_t_17 = __pyx_v_J;
       __pyx_t_18 = __pyx_t_17;
       for (__pyx_t_19 = 0; __pyx_t_19 < __pyx_t_18; __pyx_t_19+=1) {
         __pyx_v_j = __pyx_t_19;
 
-        /* "smol/correlations.pyx":255
+        /* "smol/utils/cluster/correlations.pyx":201
  *             index = 0
  *             for j in range(J):
  *                 index += tensor_indices[j] * occu[indices[i, j]]             # <<<<<<<<<<<<<<
- *             p += interaction_tensors[index]
+ *             p += interaction_tensor[index]
  *         o_view[n] = p / I
  */
         __pyx_t_6 = __pyx_v_j;
         __pyx_t_20 = __pyx_v_i;
         __pyx_t_21 = __pyx_v_j;
         __pyx_t_22 = (*((long const  *) ( /* dim=1 */ ((char *) (((long const  *) ( /* dim=0 */ (__pyx_v_indices.data + __pyx_t_20 * __pyx_v_indices.strides[0]) )) + __pyx_t_21)) )));
         __pyx_v_index = (__pyx_v_index + ((*((long const  *) ( /* dim=0 */ ((char *) (((long const  *) __pyx_v_tensor_indices.data) + __pyx_t_6)) ))) * (*((long const  *) ( /* dim=0 */ ((char *) (((long const  *) __pyx_v_occu.data) + __pyx_t_22)) )))));
       }
 
-      /* "smol/correlations.pyx":256
+      /* "smol/utils/cluster/correlations.pyx":202
  *             for j in range(J):
  *                 index += tensor_indices[j] * occu[indices[i, j]]
- *             p += interaction_tensors[index]             # <<<<<<<<<<<<<<
+ *             p += interaction_tensor[index]             # <<<<<<<<<<<<<<
  *         o_view[n] = p / I
  *         n += 1
  */
       __pyx_t_21 = __pyx_v_index;
-      __pyx_v_p = (__pyx_v_p + (*((double const  *) ( /* dim=0 */ ((char *) (((double const  *) __pyx_v_interaction_tensors.data) + __pyx_t_21)) ))));
+      __pyx_v_p = (__pyx_v_p + (*((double const  *) ( /* dim=0 */ ((char *) (((double const  *) __pyx_v_interaction_tensor.data) + __pyx_t_21)) ))));
     }
 
-    /* "smol/correlations.pyx":257
+    /* "smol/utils/cluster/correlations.pyx":203
  *                 index += tensor_indices[j] * occu[indices[i, j]]
- *             p += interaction_tensors[index]
+ *             p += interaction_tensor[index]
  *         o_view[n] = p / I             # <<<<<<<<<<<<<<
  *         n += 1
- *
+ * 
  */
     __pyx_t_21 = __pyx_v_n;
     *((double *) ( /* dim=0 */ (__pyx_v_o_view.data + __pyx_t_21 * __pyx_v_o_view.strides[0]) )) = (__pyx_v_p / ((double)__pyx_v_I));
 
-    /* "smol/correlations.pyx":258
- *             p += interaction_tensors[index]
+    /* "smol/utils/cluster/correlations.pyx":204
+ *             p += interaction_tensor[index]
  *         o_view[n] = p / I
  *         n += 1             # <<<<<<<<<<<<<<
- *
+ * 
  *     return out
  */
     __pyx_v_n = (__pyx_v_n + 1);
 
-    /* "smol/correlations.pyx":248
- *
+    /* "smol/utils/cluster/correlations.pyx":194
+ * 
  *     n = 1
- *     for tensor_indices, interaction_tensors, indices in orbit_list:             # <<<<<<<<<<<<<<
+ *     for tensor_indices, interaction_tensor, indices in orbit_list:             # <<<<<<<<<<<<<<
  *         I = indices.shape[0] # cluster index
  *         J = indices.shape[1] # index within cluster
  */
   }
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "smol/correlations.pyx":260
+  /* "smol/utils/cluster/correlations.pyx":206
  *         n += 1
- *
+ * 
  *     return out             # <<<<<<<<<<<<<<
- *
- *
+ * 
+ * 
  */
   __Pyx_XDECREF(__pyx_r);
   __Pyx_INCREF(__pyx_v_out);
   __pyx_r = __pyx_v_out;
   goto __pyx_L0;
 
-  /* "smol/correlations.pyx":219
- *
- *
+  /* "smol/utils/cluster/correlations.pyx":164
+ * 
+ * 
  * cpdef interactions_from_occupancy(const long[::1] occu,             # <<<<<<<<<<<<<<
  *                                   const int num_interactions,
  *                                   const double offset,
  */
 
   /* function exit code */
   __pyx_L1_error:;
@@ -5155,31 +4675,31 @@
   __Pyx_XDECREF(__pyx_t_4);
   __PYX_XDEC_MEMVIEW(&__pyx_t_5, 1);
   __Pyx_XDECREF(__pyx_t_8);
   __Pyx_XDECREF(__pyx_t_9);
   __PYX_XDEC_MEMVIEW(&__pyx_t_11, 1);
   __PYX_XDEC_MEMVIEW(&__pyx_t_12, 1);
   __PYX_XDEC_MEMVIEW(&__pyx_t_13, 1);
-  __Pyx_AddTraceback("smol.correlations.interactions_from_occupancy", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_AddTraceback("smol.utils.cluster.correlations.interactions_from_occupancy", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = 0;
   __pyx_L0:;
   __PYX_XDEC_MEMVIEW(&__pyx_v_indices, 1);
   __PYX_XDEC_MEMVIEW(&__pyx_v_tensor_indices, 1);
-  __PYX_XDEC_MEMVIEW(&__pyx_v_interaction_tensors, 1);
+  __PYX_XDEC_MEMVIEW(&__pyx_v_interaction_tensor, 1);
   __Pyx_XDECREF(__pyx_v_out);
   __PYX_XDEC_MEMVIEW(&__pyx_v_o_view, 1);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* Python wrapper */
-static PyObject *__pyx_pw_4smol_12correlations_9interactions_from_occupancy(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
-static char __pyx_doc_4smol_12correlations_8interactions_from_occupancy[] = "Computes the cluster interaction vector for a given encoded occupancy string.\n    Args:\n        occu (ndarray):\n            encoded occupancy vector\n        num_interactions (int):\n            total number of cluster interactions (orbits in cluster subspace).\n        offset (float):\n            eci value for the constant term.\n        orbit_list:\n            Information of all orbits.\n            (flat tensor index array, flat cluster interaction tensor,\n             site indices of clusters)\n    Returns: array\n        cluster interaction vector for given occupancy\n    ";
-static PyObject *__pyx_pw_4smol_12correlations_9interactions_from_occupancy(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
+static PyObject *__pyx_pw_4smol_5utils_7cluster_12correlations_7interactions_from_occupancy(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static char __pyx_doc_4smol_5utils_7cluster_12correlations_6interactions_from_occupancy[] = "Computes the cluster interaction vector for a given encoded occupancy string.\n\n    Args:\n        occu (ndarray):\n            encoded occupancy vector\n        num_interactions (int):\n            total number of cluster interactions (orbits in cluster subspace).\n        offset (float):\n            eci value for the constant term.\n        orbit_list:\n            Information of all orbits.\n            (flat tensor index array, flat cluster interaction tensor,\n             site indices of clusters)\n    Returns: array\n        cluster interaction vector for given occupancy\n    ";
+static PyObject *__pyx_pw_4smol_5utils_7cluster_12correlations_7interactions_from_occupancy(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
   __Pyx_memviewslice __pyx_v_occu = { 0, 0, { 0 }, { 0 }, { 0 } };
   int __pyx_v_num_interactions;
   double __pyx_v_offset;
   PyObject *__pyx_v_orbit_list = 0;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
@@ -5209,102 +4729,102 @@
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_occu)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_num_interactions)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("interactions_from_occupancy", 1, 4, 4, 1); __PYX_ERR(0, 219, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("interactions_from_occupancy", 1, 4, 4, 1); __PYX_ERR(0, 164, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  2:
         if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_offset)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("interactions_from_occupancy", 1, 4, 4, 2); __PYX_ERR(0, 219, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("interactions_from_occupancy", 1, 4, 4, 2); __PYX_ERR(0, 164, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  3:
         if (likely((values[3] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_orbit_list)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("interactions_from_occupancy", 1, 4, 4, 3); __PYX_ERR(0, 219, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("interactions_from_occupancy", 1, 4, 4, 3); __PYX_ERR(0, 164, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "interactions_from_occupancy") < 0)) __PYX_ERR(0, 219, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "interactions_from_occupancy") < 0)) __PYX_ERR(0, 164, __pyx_L3_error)
       }
     } else if (PyTuple_GET_SIZE(__pyx_args) != 4) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
       values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
       values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
       values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
     }
-    __pyx_v_occu = __Pyx_PyObject_to_MemoryviewSlice_dc_long__const__(values[0], 0); if (unlikely(!__pyx_v_occu.memview)) __PYX_ERR(0, 219, __pyx_L3_error)
-    __pyx_v_num_interactions = __Pyx_PyInt_As_int(values[1]); if (unlikely((__pyx_v_num_interactions == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 220, __pyx_L3_error)
-    __pyx_v_offset = __pyx_PyFloat_AsDouble(values[2]); if (unlikely((__pyx_v_offset == (double)-1) && PyErr_Occurred())) __PYX_ERR(0, 221, __pyx_L3_error)
+    __pyx_v_occu = __Pyx_PyObject_to_MemoryviewSlice_dc_long__const__(values[0], 0); if (unlikely(!__pyx_v_occu.memview)) __PYX_ERR(0, 164, __pyx_L3_error)
+    __pyx_v_num_interactions = __Pyx_PyInt_As_int(values[1]); if (unlikely((__pyx_v_num_interactions == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 165, __pyx_L3_error)
+    __pyx_v_offset = __pyx_PyFloat_AsDouble(values[2]); if (unlikely((__pyx_v_offset == (double)-1) && PyErr_Occurred())) __PYX_ERR(0, 166, __pyx_L3_error)
     __pyx_v_orbit_list = ((PyObject*)values[3]);
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("interactions_from_occupancy", 1, 4, 4, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 219, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("interactions_from_occupancy", 1, 4, 4, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 164, __pyx_L3_error)
   __pyx_L3_error:;
-  __Pyx_AddTraceback("smol.correlations.interactions_from_occupancy", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_AddTraceback("smol.utils.cluster.correlations.interactions_from_occupancy", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
-  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_orbit_list), (&PyList_Type), 1, "orbit_list", 1))) __PYX_ERR(0, 222, __pyx_L1_error)
-  __pyx_r = __pyx_pf_4smol_12correlations_8interactions_from_occupancy(__pyx_self, __pyx_v_occu, __pyx_v_num_interactions, __pyx_v_offset, __pyx_v_orbit_list);
+  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_orbit_list), (&PyList_Type), 1, "orbit_list", 1))) __PYX_ERR(0, 167, __pyx_L1_error)
+  __pyx_r = __pyx_pf_4smol_5utils_7cluster_12correlations_6interactions_from_occupancy(__pyx_self, __pyx_v_occu, __pyx_v_num_interactions, __pyx_v_offset, __pyx_v_orbit_list);
 
   /* function exit code */
   goto __pyx_L0;
   __pyx_L1_error:;
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-static PyObject *__pyx_pf_4smol_12correlations_8interactions_from_occupancy(CYTHON_UNUSED PyObject *__pyx_self, __Pyx_memviewslice __pyx_v_occu, int __pyx_v_num_interactions, double __pyx_v_offset, PyObject *__pyx_v_orbit_list) {
+static PyObject *__pyx_pf_4smol_5utils_7cluster_12correlations_6interactions_from_occupancy(CYTHON_UNUSED PyObject *__pyx_self, __Pyx_memviewslice __pyx_v_occu, int __pyx_v_num_interactions, double __pyx_v_offset, PyObject *__pyx_v_orbit_list) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("interactions_from_occupancy", 0);
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __pyx_f_4smol_12correlations_interactions_from_occupancy(__pyx_v_occu, __pyx_v_num_interactions, __pyx_v_offset, __pyx_v_orbit_list, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 219, __pyx_L1_error)
+  __pyx_t_1 = __pyx_f_4smol_5utils_7cluster_12correlations_interactions_from_occupancy(__pyx_v_occu, __pyx_v_num_interactions, __pyx_v_offset, __pyx_v_orbit_list, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 164, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
-  __Pyx_AddTraceback("smol.correlations.interactions_from_occupancy", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_AddTraceback("smol.utils.cluster.correlations.interactions_from_occupancy", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __pyx_L0:;
   __PYX_XDEC_MEMVIEW(&__pyx_v_occu, 1);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "smol/correlations.pyx":263
- *
- *
+/* "smol/utils/cluster/correlations.pyx":209
+ * 
+ * 
  * cpdef delta_interactions_single_flip(const long[::1] occu_f,             # <<<<<<<<<<<<<<
  *                                      const long[::1] occu_i,
  *                                      const int num_interactions,
  */
 
-static PyObject *__pyx_pw_4smol_12correlations_11delta_interactions_single_flip(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
-static PyObject *__pyx_f_4smol_12correlations_delta_interactions_single_flip(__Pyx_memviewslice __pyx_v_occu_f, __Pyx_memviewslice __pyx_v_occu_i, int const __pyx_v_num_interactions, PyObject *__pyx_v_site_orbit_list, CYTHON_UNUSED int __pyx_skip_dispatch) {
+static PyObject *__pyx_pw_4smol_5utils_7cluster_12correlations_9delta_interactions_single_flip(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static PyObject *__pyx_f_4smol_5utils_7cluster_12correlations_delta_interactions_single_flip(__Pyx_memviewslice __pyx_v_occu_f, __Pyx_memviewslice __pyx_v_occu_i, int const __pyx_v_num_interactions, PyObject *__pyx_v_site_orbit_list, CYTHON_UNUSED int __pyx_skip_dispatch) {
   int __pyx_v_i;
   int __pyx_v_j;
   int __pyx_v_n;
   int __pyx_v_I;
   int __pyx_v_J;
   int __pyx_v_ind_i;
   int __pyx_v_ind_f;
@@ -5343,150 +4863,150 @@
   Py_ssize_t __pyx_t_24;
   Py_ssize_t __pyx_t_25;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("delta_interactions_single_flip", 0);
 
-  /* "smol/correlations.pyx":289
+  /* "smol/utils/cluster/correlations.pyx":235
  *     cdef const long[::1] tensor_indices
  *     cdef const double[::1] interaction_tensor
  *     out = np.zeros(num_interactions)             # <<<<<<<<<<<<<<
  *     cdef double[::1] o_view = out
- *
+ * 
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_np); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 289, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_np); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 235, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_zeros); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 289, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_zeros); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 235, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_2 = __Pyx_PyInt_From_int(__pyx_v_num_interactions); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 289, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyInt_From_int(__pyx_v_num_interactions); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 235, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_t_4 = NULL;
   if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
     __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
     if (likely(__pyx_t_4)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
       __Pyx_INCREF(__pyx_t_4);
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_3, function);
     }
   }
   __pyx_t_1 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_4, __pyx_t_2) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_2);
   __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 289, __pyx_L1_error)
+  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 235, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __pyx_v_out = __pyx_t_1;
   __pyx_t_1 = 0;
 
-  /* "smol/correlations.pyx":290
+  /* "smol/utils/cluster/correlations.pyx":236
  *     cdef const double[::1] interaction_tensor
  *     out = np.zeros(num_interactions)
  *     cdef double[::1] o_view = out             # <<<<<<<<<<<<<<
- *
+ * 
  *     for n, ratio, tensor_indices, interaction_tensor, indices in site_orbit_list:
  */
-  __pyx_t_5 = __Pyx_PyObject_to_MemoryviewSlice_dc_double(__pyx_v_out, PyBUF_WRITABLE); if (unlikely(!__pyx_t_5.memview)) __PYX_ERR(0, 290, __pyx_L1_error)
+  __pyx_t_5 = __Pyx_PyObject_to_MemoryviewSlice_dc_double(__pyx_v_out, PyBUF_WRITABLE); if (unlikely(!__pyx_t_5.memview)) __PYX_ERR(0, 236, __pyx_L1_error)
   __pyx_v_o_view = __pyx_t_5;
   __pyx_t_5.memview = NULL;
   __pyx_t_5.data = NULL;
 
-  /* "smol/correlations.pyx":292
+  /* "smol/utils/cluster/correlations.pyx":238
  *     cdef double[::1] o_view = out
- *
+ * 
  *     for n, ratio, tensor_indices, interaction_tensor, indices in site_orbit_list:             # <<<<<<<<<<<<<<
  *         I = indices.shape[0] # cluster index
  *         J = indices.shape[1] # index within cluster
  */
   if (unlikely(__pyx_v_site_orbit_list == Py_None)) {
     PyErr_SetString(PyExc_TypeError, "'NoneType' object is not iterable");
-    __PYX_ERR(0, 292, __pyx_L1_error)
+    __PYX_ERR(0, 238, __pyx_L1_error)
   }
   __pyx_t_1 = __pyx_v_site_orbit_list; __Pyx_INCREF(__pyx_t_1); __pyx_t_6 = 0;
   for (;;) {
     if (__pyx_t_6 >= PyList_GET_SIZE(__pyx_t_1)) break;
     #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-    __pyx_t_3 = PyList_GET_ITEM(__pyx_t_1, __pyx_t_6); __Pyx_INCREF(__pyx_t_3); __pyx_t_6++; if (unlikely(0 < 0)) __PYX_ERR(0, 292, __pyx_L1_error)
+    __pyx_t_3 = PyList_GET_ITEM(__pyx_t_1, __pyx_t_6); __Pyx_INCREF(__pyx_t_3); __pyx_t_6++; if (unlikely(0 < 0)) __PYX_ERR(0, 238, __pyx_L1_error)
     #else
-    __pyx_t_3 = PySequence_ITEM(__pyx_t_1, __pyx_t_6); __pyx_t_6++; if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 292, __pyx_L1_error)
+    __pyx_t_3 = PySequence_ITEM(__pyx_t_1, __pyx_t_6); __pyx_t_6++; if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 238, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     #endif
     if ((likely(PyTuple_CheckExact(__pyx_t_3))) || (PyList_CheckExact(__pyx_t_3))) {
       PyObject* sequence = __pyx_t_3;
       Py_ssize_t size = __Pyx_PySequence_SIZE(sequence);
       if (unlikely(size != 5)) {
         if (size > 5) __Pyx_RaiseTooManyValuesError(5);
         else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
-        __PYX_ERR(0, 292, __pyx_L1_error)
+        __PYX_ERR(0, 238, __pyx_L1_error)
       }
       #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
       if (likely(PyTuple_CheckExact(sequence))) {
-        __pyx_t_2 = PyTuple_GET_ITEM(sequence, 0);
-        __pyx_t_4 = PyTuple_GET_ITEM(sequence, 1);
-        __pyx_t_7 = PyTuple_GET_ITEM(sequence, 2);
-        __pyx_t_8 = PyTuple_GET_ITEM(sequence, 3);
-        __pyx_t_9 = PyTuple_GET_ITEM(sequence, 4);
+        __pyx_t_2 = PyTuple_GET_ITEM(sequence, 0); 
+        __pyx_t_4 = PyTuple_GET_ITEM(sequence, 1); 
+        __pyx_t_7 = PyTuple_GET_ITEM(sequence, 2); 
+        __pyx_t_8 = PyTuple_GET_ITEM(sequence, 3); 
+        __pyx_t_9 = PyTuple_GET_ITEM(sequence, 4); 
       } else {
-        __pyx_t_2 = PyList_GET_ITEM(sequence, 0);
-        __pyx_t_4 = PyList_GET_ITEM(sequence, 1);
-        __pyx_t_7 = PyList_GET_ITEM(sequence, 2);
-        __pyx_t_8 = PyList_GET_ITEM(sequence, 3);
-        __pyx_t_9 = PyList_GET_ITEM(sequence, 4);
+        __pyx_t_2 = PyList_GET_ITEM(sequence, 0); 
+        __pyx_t_4 = PyList_GET_ITEM(sequence, 1); 
+        __pyx_t_7 = PyList_GET_ITEM(sequence, 2); 
+        __pyx_t_8 = PyList_GET_ITEM(sequence, 3); 
+        __pyx_t_9 = PyList_GET_ITEM(sequence, 4); 
       }
       __Pyx_INCREF(__pyx_t_2);
       __Pyx_INCREF(__pyx_t_4);
       __Pyx_INCREF(__pyx_t_7);
       __Pyx_INCREF(__pyx_t_8);
       __Pyx_INCREF(__pyx_t_9);
       #else
       {
         Py_ssize_t i;
         PyObject** temps[5] = {&__pyx_t_2,&__pyx_t_4,&__pyx_t_7,&__pyx_t_8,&__pyx_t_9};
         for (i=0; i < 5; i++) {
-          PyObject* item = PySequence_ITEM(sequence, i); if (unlikely(!item)) __PYX_ERR(0, 292, __pyx_L1_error)
+          PyObject* item = PySequence_ITEM(sequence, i); if (unlikely(!item)) __PYX_ERR(0, 238, __pyx_L1_error)
           __Pyx_GOTREF(item);
           *(temps[i]) = item;
         }
       }
       #endif
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     } else {
       Py_ssize_t index = -1;
       PyObject** temps[5] = {&__pyx_t_2,&__pyx_t_4,&__pyx_t_7,&__pyx_t_8,&__pyx_t_9};
-      __pyx_t_10 = PyObject_GetIter(__pyx_t_3); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 292, __pyx_L1_error)
+      __pyx_t_10 = PyObject_GetIter(__pyx_t_3); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 238, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_10);
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
       __pyx_t_11 = Py_TYPE(__pyx_t_10)->tp_iternext;
       for (index=0; index < 5; index++) {
         PyObject* item = __pyx_t_11(__pyx_t_10); if (unlikely(!item)) goto __pyx_L5_unpacking_failed;
         __Pyx_GOTREF(item);
         *(temps[index]) = item;
       }
-      if (__Pyx_IternextUnpackEndCheck(__pyx_t_11(__pyx_t_10), 5) < 0) __PYX_ERR(0, 292, __pyx_L1_error)
+      if (__Pyx_IternextUnpackEndCheck(__pyx_t_11(__pyx_t_10), 5) < 0) __PYX_ERR(0, 238, __pyx_L1_error)
       __pyx_t_11 = NULL;
       __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
       goto __pyx_L6_unpacking_done;
       __pyx_L5_unpacking_failed:;
       __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
       __pyx_t_11 = NULL;
       if (__Pyx_IterFinish() == 0) __Pyx_RaiseNeedMoreValuesError(index);
-      __PYX_ERR(0, 292, __pyx_L1_error)
+      __PYX_ERR(0, 238, __pyx_L1_error)
       __pyx_L6_unpacking_done:;
     }
-    __pyx_t_12 = __Pyx_PyInt_As_int(__pyx_t_2); if (unlikely((__pyx_t_12 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 292, __pyx_L1_error)
+    __pyx_t_12 = __Pyx_PyInt_As_int(__pyx_t_2); if (unlikely((__pyx_t_12 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 238, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __pyx_t_13 = __pyx_PyFloat_AsDouble(__pyx_t_4); if (unlikely((__pyx_t_13 == (double)-1) && PyErr_Occurred())) __PYX_ERR(0, 292, __pyx_L1_error)
+    __pyx_t_13 = __pyx_PyFloat_AsDouble(__pyx_t_4); if (unlikely((__pyx_t_13 == (double)-1) && PyErr_Occurred())) __PYX_ERR(0, 238, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-    __pyx_t_14 = __Pyx_PyObject_to_MemoryviewSlice_dc_long__const__(__pyx_t_7, 0); if (unlikely(!__pyx_t_14.memview)) __PYX_ERR(0, 292, __pyx_L1_error)
+    __pyx_t_14 = __Pyx_PyObject_to_MemoryviewSlice_dc_long__const__(__pyx_t_7, 0); if (unlikely(!__pyx_t_14.memview)) __PYX_ERR(0, 238, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-    __pyx_t_15 = __Pyx_PyObject_to_MemoryviewSlice_dc_double__const__(__pyx_t_8, 0); if (unlikely(!__pyx_t_15.memview)) __PYX_ERR(0, 292, __pyx_L1_error)
+    __pyx_t_15 = __Pyx_PyObject_to_MemoryviewSlice_dc_double__const__(__pyx_t_8, 0); if (unlikely(!__pyx_t_15.memview)) __PYX_ERR(0, 238, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
-    __pyx_t_16 = __Pyx_PyObject_to_MemoryviewSlice_d_dc_long__const__(__pyx_t_9, 0); if (unlikely(!__pyx_t_16.memview)) __PYX_ERR(0, 292, __pyx_L1_error)
+    __pyx_t_16 = __Pyx_PyObject_to_MemoryviewSlice_d_dc_long__const__(__pyx_t_9, 0); if (unlikely(!__pyx_t_16.memview)) __PYX_ERR(0, 238, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
     __pyx_v_n = __pyx_t_12;
     __pyx_v_ratio = __pyx_t_13;
     __PYX_XDEC_MEMVIEW(&__pyx_v_tensor_indices, 1);
     __pyx_v_tensor_indices = __pyx_t_14;
     __pyx_t_14.memview = NULL;
     __pyx_t_14.data = NULL;
@@ -5495,148 +5015,151 @@
     __pyx_t_15.memview = NULL;
     __pyx_t_15.data = NULL;
     __PYX_XDEC_MEMVIEW(&__pyx_v_indices, 1);
     __pyx_v_indices = __pyx_t_16;
     __pyx_t_16.memview = NULL;
     __pyx_t_16.data = NULL;
 
-    /* "smol/correlations.pyx":293
- *
+    /* "smol/utils/cluster/correlations.pyx":239
+ * 
  *     for n, ratio, tensor_indices, interaction_tensor, indices in site_orbit_list:
  *         I = indices.shape[0] # cluster index             # <<<<<<<<<<<<<<
  *         J = indices.shape[1] # index within cluster
  *         p = 0
  */
     __pyx_v_I = (__pyx_v_indices.shape[0]);
 
-    /* "smol/correlations.pyx":294
+    /* "smol/utils/cluster/correlations.pyx":240
  *     for n, ratio, tensor_indices, interaction_tensor, indices in site_orbit_list:
  *         I = indices.shape[0] # cluster index
  *         J = indices.shape[1] # index within cluster             # <<<<<<<<<<<<<<
  *         p = 0
  *         for i in range(I):
  */
     __pyx_v_J = (__pyx_v_indices.shape[1]);
 
-    /* "smol/correlations.pyx":295
+    /* "smol/utils/cluster/correlations.pyx":241
  *         I = indices.shape[0] # cluster index
  *         J = indices.shape[1] # index within cluster
  *         p = 0             # <<<<<<<<<<<<<<
  *         for i in range(I):
  *             ind_i, ind_f = 0, 0
  */
     __pyx_v_p = 0.0;
 
-    /* "smol/correlations.pyx":296
+    /* "smol/utils/cluster/correlations.pyx":242
  *         J = indices.shape[1] # index within cluster
  *         p = 0
  *         for i in range(I):             # <<<<<<<<<<<<<<
  *             ind_i, ind_f = 0, 0
  *             for j in range(J):
  */
     __pyx_t_12 = __pyx_v_I;
     __pyx_t_17 = __pyx_t_12;
     for (__pyx_t_18 = 0; __pyx_t_18 < __pyx_t_17; __pyx_t_18+=1) {
       __pyx_v_i = __pyx_t_18;
 
-      /* "smol/correlations.pyx":297
+      /* "smol/utils/cluster/correlations.pyx":243
  *         p = 0
  *         for i in range(I):
  *             ind_i, ind_f = 0, 0             # <<<<<<<<<<<<<<
  *             for j in range(J):
  *                 ind_i += tensor_indices[j] * occu_i[indices[i, j]]
  */
       __pyx_t_19 = 0;
       __pyx_t_20 = 0;
       __pyx_v_ind_i = __pyx_t_19;
       __pyx_v_ind_f = __pyx_t_20;
 
-      /* "smol/correlations.pyx":298
+      /* "smol/utils/cluster/correlations.pyx":244
  *         for i in range(I):
  *             ind_i, ind_f = 0, 0
  *             for j in range(J):             # <<<<<<<<<<<<<<
  *                 ind_i += tensor_indices[j] * occu_i[indices[i, j]]
  *                 ind_f += tensor_indices[j] * occu_f[indices[i, j]]
  */
       __pyx_t_20 = __pyx_v_J;
       __pyx_t_19 = __pyx_t_20;
       for (__pyx_t_21 = 0; __pyx_t_21 < __pyx_t_19; __pyx_t_21+=1) {
         __pyx_v_j = __pyx_t_21;
 
-        /* "smol/correlations.pyx":299
+        /* "smol/utils/cluster/correlations.pyx":245
  *             ind_i, ind_f = 0, 0
  *             for j in range(J):
  *                 ind_i += tensor_indices[j] * occu_i[indices[i, j]]             # <<<<<<<<<<<<<<
  *                 ind_f += tensor_indices[j] * occu_f[indices[i, j]]
  *             p += (interaction_tensor[ind_f] - interaction_tensor[ind_i])
  */
         __pyx_t_22 = __pyx_v_j;
         __pyx_t_23 = __pyx_v_i;
         __pyx_t_24 = __pyx_v_j;
         __pyx_t_25 = (*((long const  *) ( /* dim=1 */ ((char *) (((long const  *) ( /* dim=0 */ (__pyx_v_indices.data + __pyx_t_23 * __pyx_v_indices.strides[0]) )) + __pyx_t_24)) )));
         __pyx_v_ind_i = (__pyx_v_ind_i + ((*((long const  *) ( /* dim=0 */ ((char *) (((long const  *) __pyx_v_tensor_indices.data) + __pyx_t_22)) ))) * (*((long const  *) ( /* dim=0 */ ((char *) (((long const  *) __pyx_v_occu_i.data) + __pyx_t_25)) )))));
 
-        /* "smol/correlations.pyx":300
+        /* "smol/utils/cluster/correlations.pyx":246
  *             for j in range(J):
  *                 ind_i += tensor_indices[j] * occu_i[indices[i, j]]
  *                 ind_f += tensor_indices[j] * occu_f[indices[i, j]]             # <<<<<<<<<<<<<<
  *             p += (interaction_tensor[ind_f] - interaction_tensor[ind_i])
  *         o_view[n] = p / ratio / I
  */
         __pyx_t_24 = __pyx_v_j;
         __pyx_t_23 = __pyx_v_i;
         __pyx_t_25 = __pyx_v_j;
         __pyx_t_22 = (*((long const  *) ( /* dim=1 */ ((char *) (((long const  *) ( /* dim=0 */ (__pyx_v_indices.data + __pyx_t_23 * __pyx_v_indices.strides[0]) )) + __pyx_t_25)) )));
         __pyx_v_ind_f = (__pyx_v_ind_f + ((*((long const  *) ( /* dim=0 */ ((char *) (((long const  *) __pyx_v_tensor_indices.data) + __pyx_t_24)) ))) * (*((long const  *) ( /* dim=0 */ ((char *) (((long const  *) __pyx_v_occu_f.data) + __pyx_t_22)) )))));
       }
 
-      /* "smol/correlations.pyx":301
+      /* "smol/utils/cluster/correlations.pyx":247
  *                 ind_i += tensor_indices[j] * occu_i[indices[i, j]]
  *                 ind_f += tensor_indices[j] * occu_f[indices[i, j]]
  *             p += (interaction_tensor[ind_f] - interaction_tensor[ind_i])             # <<<<<<<<<<<<<<
  *         o_view[n] = p / ratio / I
  *     return out
  */
       __pyx_t_25 = __pyx_v_ind_f;
       __pyx_t_23 = __pyx_v_ind_i;
       __pyx_v_p = (__pyx_v_p + ((*((double const  *) ( /* dim=0 */ ((char *) (((double const  *) __pyx_v_interaction_tensor.data) + __pyx_t_25)) ))) - (*((double const  *) ( /* dim=0 */ ((char *) (((double const  *) __pyx_v_interaction_tensor.data) + __pyx_t_23)) )))));
     }
 
-    /* "smol/correlations.pyx":302
+    /* "smol/utils/cluster/correlations.pyx":248
  *                 ind_f += tensor_indices[j] * occu_f[indices[i, j]]
  *             p += (interaction_tensor[ind_f] - interaction_tensor[ind_i])
  *         o_view[n] = p / ratio / I             # <<<<<<<<<<<<<<
  *     return out
+ * 
  */
     __pyx_t_23 = __pyx_v_n;
     *((double *) ( /* dim=0 */ ((char *) (((double *) __pyx_v_o_view.data) + __pyx_t_23)) )) = ((__pyx_v_p / __pyx_v_ratio) / ((double)__pyx_v_I));
 
-    /* "smol/correlations.pyx":292
+    /* "smol/utils/cluster/correlations.pyx":238
  *     cdef double[::1] o_view = out
- *
+ * 
  *     for n, ratio, tensor_indices, interaction_tensor, indices in site_orbit_list:             # <<<<<<<<<<<<<<
  *         I = indices.shape[0] # cluster index
  *         J = indices.shape[1] # index within cluster
  */
   }
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "smol/correlations.pyx":303
+  /* "smol/utils/cluster/correlations.pyx":249
  *             p += (interaction_tensor[ind_f] - interaction_tensor[ind_i])
  *         o_view[n] = p / ratio / I
  *     return out             # <<<<<<<<<<<<<<
+ * 
+ * 
  */
   __Pyx_XDECREF(__pyx_r);
   __Pyx_INCREF(__pyx_v_out);
   __pyx_r = __pyx_v_out;
   goto __pyx_L0;
 
-  /* "smol/correlations.pyx":263
- *
- *
+  /* "smol/utils/cluster/correlations.pyx":209
+ * 
+ * 
  * cpdef delta_interactions_single_flip(const long[::1] occu_f,             # <<<<<<<<<<<<<<
  *                                      const long[::1] occu_i,
  *                                      const int num_interactions,
  */
 
   /* function exit code */
   __pyx_L1_error:;
@@ -5648,31 +5171,31 @@
   __Pyx_XDECREF(__pyx_t_7);
   __Pyx_XDECREF(__pyx_t_8);
   __Pyx_XDECREF(__pyx_t_9);
   __Pyx_XDECREF(__pyx_t_10);
   __PYX_XDEC_MEMVIEW(&__pyx_t_14, 1);
   __PYX_XDEC_MEMVIEW(&__pyx_t_15, 1);
   __PYX_XDEC_MEMVIEW(&__pyx_t_16, 1);
-  __Pyx_AddTraceback("smol.correlations.delta_interactions_single_flip", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_AddTraceback("smol.utils.cluster.correlations.delta_interactions_single_flip", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = 0;
   __pyx_L0:;
   __PYX_XDEC_MEMVIEW(&__pyx_v_indices, 1);
   __PYX_XDEC_MEMVIEW(&__pyx_v_tensor_indices, 1);
   __PYX_XDEC_MEMVIEW(&__pyx_v_interaction_tensor, 1);
   __Pyx_XDECREF(__pyx_v_out);
   __PYX_XDEC_MEMVIEW(&__pyx_v_o_view, 1);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* Python wrapper */
-static PyObject *__pyx_pw_4smol_12correlations_11delta_interactions_single_flip(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
-static char __pyx_doc_4smol_12correlations_10delta_interactions_single_flip[] = "Computes the cluster interaction vector difference between two occupancy\n    strings.\n    Args:\n        occu_f (ndarray):\n            encoded occupancy vector with flip\n        occu_i (ndarray):\n            encoded occupancy vector without flip\n        num_interactions (int):\n            total number of cluster interactions (orbits in cluster subspace).\n        site_orbit_list:\n            Information of all orbits that include the flip site.\n            List of tuples each with\n            (cluster ratio, flat tensor index array, flat cluster interaction tensor,\n             site indices of clusters)\n    Returns:\n        ndarray: cluster interaction vector difference\n    ";
-static PyObject *__pyx_pw_4smol_12correlations_11delta_interactions_single_flip(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
+static PyObject *__pyx_pw_4smol_5utils_7cluster_12correlations_9delta_interactions_single_flip(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static char __pyx_doc_4smol_5utils_7cluster_12correlations_8delta_interactions_single_flip[] = "Computes the cluster interaction vector difference between two occupancy\n    strings.\n    Args:\n        occu_f (ndarray):\n            encoded occupancy vector with flip\n        occu_i (ndarray):\n            encoded occupancy vector without flip\n        num_interactions (int):\n            total number of cluster interactions (orbits in cluster subspace).\n        site_orbit_list:\n            Information of all orbits that include the flip site.\n            List of tuples each with\n            (cluster ratio, flat tensor index array, flat cluster interaction tensor,\n             site indices of clusters)\n    Returns:\n        ndarray: cluster interaction vector difference\n    ";
+static PyObject *__pyx_pw_4smol_5utils_7cluster_12correlations_9delta_interactions_single_flip(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
   __Pyx_memviewslice __pyx_v_occu_f = { 0, 0, { 0 }, { 0 }, { 0 } };
   __Pyx_memviewslice __pyx_v_occu_i = { 0, 0, { 0 }, { 0 }, { 0 } };
   int __pyx_v_num_interactions;
   PyObject *__pyx_v_site_orbit_list = 0;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
@@ -5702,541 +5225,1547 @@
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_occu_f)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_occu_i)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("delta_interactions_single_flip", 1, 4, 4, 1); __PYX_ERR(0, 263, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("delta_interactions_single_flip", 1, 4, 4, 1); __PYX_ERR(0, 209, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  2:
         if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_num_interactions)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("delta_interactions_single_flip", 1, 4, 4, 2); __PYX_ERR(0, 263, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("delta_interactions_single_flip", 1, 4, 4, 2); __PYX_ERR(0, 209, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  3:
         if (likely((values[3] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_site_orbit_list)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("delta_interactions_single_flip", 1, 4, 4, 3); __PYX_ERR(0, 263, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("delta_interactions_single_flip", 1, 4, 4, 3); __PYX_ERR(0, 209, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "delta_interactions_single_flip") < 0)) __PYX_ERR(0, 263, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "delta_interactions_single_flip") < 0)) __PYX_ERR(0, 209, __pyx_L3_error)
       }
     } else if (PyTuple_GET_SIZE(__pyx_args) != 4) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
       values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
       values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
       values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
     }
-    __pyx_v_occu_f = __Pyx_PyObject_to_MemoryviewSlice_dc_long__const__(values[0], 0); if (unlikely(!__pyx_v_occu_f.memview)) __PYX_ERR(0, 263, __pyx_L3_error)
-    __pyx_v_occu_i = __Pyx_PyObject_to_MemoryviewSlice_dc_long__const__(values[1], 0); if (unlikely(!__pyx_v_occu_i.memview)) __PYX_ERR(0, 264, __pyx_L3_error)
-    __pyx_v_num_interactions = __Pyx_PyInt_As_int(values[2]); if (unlikely((__pyx_v_num_interactions == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 265, __pyx_L3_error)
+    __pyx_v_occu_f = __Pyx_PyObject_to_MemoryviewSlice_dc_long__const__(values[0], 0); if (unlikely(!__pyx_v_occu_f.memview)) __PYX_ERR(0, 209, __pyx_L3_error)
+    __pyx_v_occu_i = __Pyx_PyObject_to_MemoryviewSlice_dc_long__const__(values[1], 0); if (unlikely(!__pyx_v_occu_i.memview)) __PYX_ERR(0, 210, __pyx_L3_error)
+    __pyx_v_num_interactions = __Pyx_PyInt_As_int(values[2]); if (unlikely((__pyx_v_num_interactions == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 211, __pyx_L3_error)
     __pyx_v_site_orbit_list = ((PyObject*)values[3]);
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("delta_interactions_single_flip", 1, 4, 4, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 263, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("delta_interactions_single_flip", 1, 4, 4, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 209, __pyx_L3_error)
   __pyx_L3_error:;
-  __Pyx_AddTraceback("smol.correlations.delta_interactions_single_flip", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_AddTraceback("smol.utils.cluster.correlations.delta_interactions_single_flip", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
-  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_site_orbit_list), (&PyList_Type), 1, "site_orbit_list", 1))) __PYX_ERR(0, 266, __pyx_L1_error)
-  __pyx_r = __pyx_pf_4smol_12correlations_10delta_interactions_single_flip(__pyx_self, __pyx_v_occu_f, __pyx_v_occu_i, __pyx_v_num_interactions, __pyx_v_site_orbit_list);
+  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_site_orbit_list), (&PyList_Type), 1, "site_orbit_list", 1))) __PYX_ERR(0, 212, __pyx_L1_error)
+  __pyx_r = __pyx_pf_4smol_5utils_7cluster_12correlations_8delta_interactions_single_flip(__pyx_self, __pyx_v_occu_f, __pyx_v_occu_i, __pyx_v_num_interactions, __pyx_v_site_orbit_list);
 
   /* function exit code */
   goto __pyx_L0;
   __pyx_L1_error:;
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-static PyObject *__pyx_pf_4smol_12correlations_10delta_interactions_single_flip(CYTHON_UNUSED PyObject *__pyx_self, __Pyx_memviewslice __pyx_v_occu_f, __Pyx_memviewslice __pyx_v_occu_i, int __pyx_v_num_interactions, PyObject *__pyx_v_site_orbit_list) {
+static PyObject *__pyx_pf_4smol_5utils_7cluster_12correlations_8delta_interactions_single_flip(CYTHON_UNUSED PyObject *__pyx_self, __Pyx_memviewslice __pyx_v_occu_f, __Pyx_memviewslice __pyx_v_occu_i, int __pyx_v_num_interactions, PyObject *__pyx_v_site_orbit_list) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("delta_interactions_single_flip", 0);
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __pyx_f_4smol_12correlations_delta_interactions_single_flip(__pyx_v_occu_f, __pyx_v_occu_i, __pyx_v_num_interactions, __pyx_v_site_orbit_list, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 263, __pyx_L1_error)
+  __pyx_t_1 = __pyx_f_4smol_5utils_7cluster_12correlations_delta_interactions_single_flip(__pyx_v_occu_f, __pyx_v_occu_i, __pyx_v_num_interactions, __pyx_v_site_orbit_list, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 209, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
-  __Pyx_AddTraceback("smol.correlations.delta_interactions_single_flip", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_AddTraceback("smol.utils.cluster.correlations.delta_interactions_single_flip", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __pyx_L0:;
   __PYX_XDEC_MEMVIEW(&__pyx_v_occu_f, 1);
   __PYX_XDEC_MEMVIEW(&__pyx_v_occu_i, 1);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "../../miniconda3/envs/matx_310/lib/python3.10/site-packages/numpy/__init__.pxd":734
+/* "smol/utils/cluster/correlations.pyx":252
+ * 
+ * 
+ * cpdef interaction_distance_single_flip(const long[::1] occu_f,             # <<<<<<<<<<<<<<
+ *                                        const long[::1] occu_i,
+ *                                        const double[::1] ref_interaction_vector,
+ */
+
+static PyObject *__pyx_pw_4smol_5utils_7cluster_12correlations_11interaction_distance_single_flip(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static PyObject *__pyx_f_4smol_5utils_7cluster_12correlations_interaction_distance_single_flip(__Pyx_memviewslice __pyx_v_occu_f, __Pyx_memviewslice __pyx_v_occu_i, __Pyx_memviewslice __pyx_v_ref_interaction_vector, int const __pyx_v_num_interactions, PyObject *__pyx_v_orbit_list, CYTHON_UNUSED int __pyx_skip_dispatch) {
+  int __pyx_v_n;
+  int __pyx_v_i;
+  int __pyx_v_j;
+  int __pyx_v_I;
+  int __pyx_v_J;
+  int __pyx_v_ind_i;
+  int __pyx_v_ind_f;
+  double __pyx_v_p_i;
+  double __pyx_v_p_f;
+  __Pyx_memviewslice __pyx_v_indices = { 0, 0, { 0 }, { 0 }, { 0 } };
+  __Pyx_memviewslice __pyx_v_tensor_indices = { 0, 0, { 0 }, { 0 }, { 0 } };
+  __Pyx_memviewslice __pyx_v_interaction_tensor = { 0, 0, { 0 }, { 0 }, { 0 } };
+  PyObject *__pyx_v_out = NULL;
+  __Pyx_memviewslice __pyx_v_o_view = { 0, 0, { 0 }, { 0 }, { 0 } };
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  PyObject *__pyx_t_2 = NULL;
+  PyObject *__pyx_t_3 = NULL;
+  PyObject *__pyx_t_4 = NULL;
+  __Pyx_memviewslice __pyx_t_5 = { 0, 0, { 0 }, { 0 }, { 0 } };
+  __Pyx_memviewslice __pyx_t_6 = { 0, 0, { 0 }, { 0 }, { 0 } };
+  Py_ssize_t __pyx_t_7;
+  PyObject *__pyx_t_8 = NULL;
+  PyObject *__pyx_t_9 = NULL;
+  PyObject *(*__pyx_t_10)(PyObject *);
+  __Pyx_memviewslice __pyx_t_11 = { 0, 0, { 0 }, { 0 }, { 0 } };
+  __Pyx_memviewslice __pyx_t_12 = { 0, 0, { 0 }, { 0 }, { 0 } };
+  __Pyx_memviewslice __pyx_t_13 = { 0, 0, { 0 }, { 0 }, { 0 } };
+  double __pyx_t_14;
+  double __pyx_t_15;
+  int __pyx_t_16;
+  int __pyx_t_17;
+  int __pyx_t_18;
+  int __pyx_t_19;
+  int __pyx_t_20;
+  int __pyx_t_21;
+  Py_ssize_t __pyx_t_22;
+  Py_ssize_t __pyx_t_23;
+  Py_ssize_t __pyx_t_24;
+  Py_ssize_t __pyx_t_25;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("interaction_distance_single_flip", 0);
+
+  /* "smol/utils/cluster/correlations.pyx":286
+ *     cdef const long[::1] tensor_indices
+ *     cdef const double[::1] interaction_tensor
+ *     out = np.zeros((2, num_interactions))             # <<<<<<<<<<<<<<
+ *     cdef double[:, ::1] o_view = out
+ *     o_view[:, 0] = 0
+ */
+  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_np); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 286, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_zeros); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 286, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_3);
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __pyx_t_2 = __Pyx_PyInt_From_int(__pyx_v_num_interactions); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 286, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_4 = PyTuple_New(2); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 286, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_4);
+  __Pyx_INCREF(__pyx_int_2);
+  __Pyx_GIVEREF(__pyx_int_2);
+  PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_int_2);
+  __Pyx_GIVEREF(__pyx_t_2);
+  PyTuple_SET_ITEM(__pyx_t_4, 1, __pyx_t_2);
+  __pyx_t_2 = 0;
+  __pyx_t_2 = NULL;
+  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
+    __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_3);
+    if (likely(__pyx_t_2)) {
+      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
+      __Pyx_INCREF(__pyx_t_2);
+      __Pyx_INCREF(function);
+      __Pyx_DECREF_SET(__pyx_t_3, function);
+    }
+  }
+  __pyx_t_1 = (__pyx_t_2) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_2, __pyx_t_4) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4);
+  __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 286, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_v_out = __pyx_t_1;
+  __pyx_t_1 = 0;
+
+  /* "smol/utils/cluster/correlations.pyx":287
+ *     cdef const double[::1] interaction_tensor
+ *     out = np.zeros((2, num_interactions))
+ *     cdef double[:, ::1] o_view = out             # <<<<<<<<<<<<<<
+ *     o_view[:, 0] = 0
+ * 
+ */
+  __pyx_t_5 = __Pyx_PyObject_to_MemoryviewSlice_d_dc_double(__pyx_v_out, PyBUF_WRITABLE); if (unlikely(!__pyx_t_5.memview)) __PYX_ERR(0, 287, __pyx_L1_error)
+  __pyx_v_o_view = __pyx_t_5;
+  __pyx_t_5.memview = NULL;
+  __pyx_t_5.data = NULL;
+
+  /* "smol/utils/cluster/correlations.pyx":288
+ *     out = np.zeros((2, num_interactions))
+ *     cdef double[:, ::1] o_view = out
+ *     o_view[:, 0] = 0             # <<<<<<<<<<<<<<
+ * 
+ *     n = 1
+ */
+  __pyx_t_6.data = __pyx_v_o_view.data;
+  __pyx_t_6.memview = __pyx_v_o_view.memview;
+  __PYX_INC_MEMVIEW(&__pyx_t_6, 0);
+  __pyx_t_6.shape[0] = __pyx_v_o_view.shape[0];
+__pyx_t_6.strides[0] = __pyx_v_o_view.strides[0];
+    __pyx_t_6.suboffsets[0] = -1;
+
+{
+    Py_ssize_t __pyx_tmp_idx = 0;
+    Py_ssize_t __pyx_tmp_stride = __pyx_v_o_view.strides[1];
+        __pyx_t_6.data += __pyx_tmp_idx * __pyx_tmp_stride;
+}
+
+{
+      double __pyx_temp_scalar = 0.0;
+      {
+          Py_ssize_t __pyx_temp_extent_0 = __pyx_t_6.shape[0];
+          Py_ssize_t __pyx_temp_stride_0 = __pyx_t_6.strides[0];
+          char *__pyx_temp_pointer_0;
+          Py_ssize_t __pyx_temp_idx_0;
+          __pyx_temp_pointer_0 = __pyx_t_6.data;
+          for (__pyx_temp_idx_0 = 0; __pyx_temp_idx_0 < __pyx_temp_extent_0; __pyx_temp_idx_0++) {
+            *((double *) __pyx_temp_pointer_0) = __pyx_temp_scalar;
+            __pyx_temp_pointer_0 += __pyx_temp_stride_0;
+          }
+      }
+  }
+  __PYX_XDEC_MEMVIEW(&__pyx_t_6, 1);
+  __pyx_t_6.memview = NULL;
+  __pyx_t_6.data = NULL;
+
+  /* "smol/utils/cluster/correlations.pyx":290
+ *     o_view[:, 0] = 0
+ * 
+ *     n = 1             # <<<<<<<<<<<<<<
+ *     for tensor_indices, interaction_tensor, indices in orbit_list:
+ *         I = indices.shape[0] # cluster index
+ */
+  __pyx_v_n = 1;
+
+  /* "smol/utils/cluster/correlations.pyx":291
+ * 
+ *     n = 1
+ *     for tensor_indices, interaction_tensor, indices in orbit_list:             # <<<<<<<<<<<<<<
+ *         I = indices.shape[0] # cluster index
+ *         J = indices.shape[1] # index within cluster
+ */
+  if (unlikely(__pyx_v_orbit_list == Py_None)) {
+    PyErr_SetString(PyExc_TypeError, "'NoneType' object is not iterable");
+    __PYX_ERR(0, 291, __pyx_L1_error)
+  }
+  __pyx_t_1 = __pyx_v_orbit_list; __Pyx_INCREF(__pyx_t_1); __pyx_t_7 = 0;
+  for (;;) {
+    if (__pyx_t_7 >= PyList_GET_SIZE(__pyx_t_1)) break;
+    #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
+    __pyx_t_3 = PyList_GET_ITEM(__pyx_t_1, __pyx_t_7); __Pyx_INCREF(__pyx_t_3); __pyx_t_7++; if (unlikely(0 < 0)) __PYX_ERR(0, 291, __pyx_L1_error)
+    #else
+    __pyx_t_3 = PySequence_ITEM(__pyx_t_1, __pyx_t_7); __pyx_t_7++; if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 291, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_3);
+    #endif
+    if ((likely(PyTuple_CheckExact(__pyx_t_3))) || (PyList_CheckExact(__pyx_t_3))) {
+      PyObject* sequence = __pyx_t_3;
+      Py_ssize_t size = __Pyx_PySequence_SIZE(sequence);
+      if (unlikely(size != 3)) {
+        if (size > 3) __Pyx_RaiseTooManyValuesError(3);
+        else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
+        __PYX_ERR(0, 291, __pyx_L1_error)
+      }
+      #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
+      if (likely(PyTuple_CheckExact(sequence))) {
+        __pyx_t_4 = PyTuple_GET_ITEM(sequence, 0); 
+        __pyx_t_2 = PyTuple_GET_ITEM(sequence, 1); 
+        __pyx_t_8 = PyTuple_GET_ITEM(sequence, 2); 
+      } else {
+        __pyx_t_4 = PyList_GET_ITEM(sequence, 0); 
+        __pyx_t_2 = PyList_GET_ITEM(sequence, 1); 
+        __pyx_t_8 = PyList_GET_ITEM(sequence, 2); 
+      }
+      __Pyx_INCREF(__pyx_t_4);
+      __Pyx_INCREF(__pyx_t_2);
+      __Pyx_INCREF(__pyx_t_8);
+      #else
+      __pyx_t_4 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 291, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_4);
+      __pyx_t_2 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 291, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_2);
+      __pyx_t_8 = PySequence_ITEM(sequence, 2); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 291, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_8);
+      #endif
+      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    } else {
+      Py_ssize_t index = -1;
+      __pyx_t_9 = PyObject_GetIter(__pyx_t_3); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 291, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_9);
+      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+      __pyx_t_10 = Py_TYPE(__pyx_t_9)->tp_iternext;
+      index = 0; __pyx_t_4 = __pyx_t_10(__pyx_t_9); if (unlikely(!__pyx_t_4)) goto __pyx_L5_unpacking_failed;
+      __Pyx_GOTREF(__pyx_t_4);
+      index = 1; __pyx_t_2 = __pyx_t_10(__pyx_t_9); if (unlikely(!__pyx_t_2)) goto __pyx_L5_unpacking_failed;
+      __Pyx_GOTREF(__pyx_t_2);
+      index = 2; __pyx_t_8 = __pyx_t_10(__pyx_t_9); if (unlikely(!__pyx_t_8)) goto __pyx_L5_unpacking_failed;
+      __Pyx_GOTREF(__pyx_t_8);
+      if (__Pyx_IternextUnpackEndCheck(__pyx_t_10(__pyx_t_9), 3) < 0) __PYX_ERR(0, 291, __pyx_L1_error)
+      __pyx_t_10 = NULL;
+      __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
+      goto __pyx_L6_unpacking_done;
+      __pyx_L5_unpacking_failed:;
+      __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
+      __pyx_t_10 = NULL;
+      if (__Pyx_IterFinish() == 0) __Pyx_RaiseNeedMoreValuesError(index);
+      __PYX_ERR(0, 291, __pyx_L1_error)
+      __pyx_L6_unpacking_done:;
+    }
+    __pyx_t_11 = __Pyx_PyObject_to_MemoryviewSlice_dc_long__const__(__pyx_t_4, 0); if (unlikely(!__pyx_t_11.memview)) __PYX_ERR(0, 291, __pyx_L1_error)
+    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+    __pyx_t_12 = __Pyx_PyObject_to_MemoryviewSlice_dc_double__const__(__pyx_t_2, 0); if (unlikely(!__pyx_t_12.memview)) __PYX_ERR(0, 291, __pyx_L1_error)
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __pyx_t_13 = __Pyx_PyObject_to_MemoryviewSlice_d_dc_long__const__(__pyx_t_8, 0); if (unlikely(!__pyx_t_13.memview)) __PYX_ERR(0, 291, __pyx_L1_error)
+    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
+    __PYX_XDEC_MEMVIEW(&__pyx_v_tensor_indices, 1);
+    __pyx_v_tensor_indices = __pyx_t_11;
+    __pyx_t_11.memview = NULL;
+    __pyx_t_11.data = NULL;
+    __PYX_XDEC_MEMVIEW(&__pyx_v_interaction_tensor, 1);
+    __pyx_v_interaction_tensor = __pyx_t_12;
+    __pyx_t_12.memview = NULL;
+    __pyx_t_12.data = NULL;
+    __PYX_XDEC_MEMVIEW(&__pyx_v_indices, 1);
+    __pyx_v_indices = __pyx_t_13;
+    __pyx_t_13.memview = NULL;
+    __pyx_t_13.data = NULL;
+
+    /* "smol/utils/cluster/correlations.pyx":292
+ *     n = 1
+ *     for tensor_indices, interaction_tensor, indices in orbit_list:
+ *         I = indices.shape[0] # cluster index             # <<<<<<<<<<<<<<
+ *         J = indices.shape[1] # index within cluster
+ *         p_f, p_i = 0, 0
+ */
+    __pyx_v_I = (__pyx_v_indices.shape[0]);
+
+    /* "smol/utils/cluster/correlations.pyx":293
+ *     for tensor_indices, interaction_tensor, indices in orbit_list:
+ *         I = indices.shape[0] # cluster index
+ *         J = indices.shape[1] # index within cluster             # <<<<<<<<<<<<<<
+ *         p_f, p_i = 0, 0
+ *         for i in range(I):
+ */
+    __pyx_v_J = (__pyx_v_indices.shape[1]);
+
+    /* "smol/utils/cluster/correlations.pyx":294
+ *         I = indices.shape[0] # cluster index
+ *         J = indices.shape[1] # index within cluster
+ *         p_f, p_i = 0, 0             # <<<<<<<<<<<<<<
+ *         for i in range(I):
+ *             ind_f, ind_i = 0, 0
+ */
+    __pyx_t_14 = 0.0;
+    __pyx_t_15 = 0.0;
+    __pyx_v_p_f = __pyx_t_14;
+    __pyx_v_p_i = __pyx_t_15;
+
+    /* "smol/utils/cluster/correlations.pyx":295
+ *         J = indices.shape[1] # index within cluster
+ *         p_f, p_i = 0, 0
+ *         for i in range(I):             # <<<<<<<<<<<<<<
+ *             ind_f, ind_i = 0, 0
+ *             for j in range(J):
+ */
+    __pyx_t_16 = __pyx_v_I;
+    __pyx_t_17 = __pyx_t_16;
+    for (__pyx_t_18 = 0; __pyx_t_18 < __pyx_t_17; __pyx_t_18+=1) {
+      __pyx_v_i = __pyx_t_18;
+
+      /* "smol/utils/cluster/correlations.pyx":296
+ *         p_f, p_i = 0, 0
+ *         for i in range(I):
+ *             ind_f, ind_i = 0, 0             # <<<<<<<<<<<<<<
+ *             for j in range(J):
+ *                 ind_f += tensor_indices[j] * occu_f[indices[i, j]]
+ */
+      __pyx_t_19 = 0;
+      __pyx_t_20 = 0;
+      __pyx_v_ind_f = __pyx_t_19;
+      __pyx_v_ind_i = __pyx_t_20;
+
+      /* "smol/utils/cluster/correlations.pyx":297
+ *         for i in range(I):
+ *             ind_f, ind_i = 0, 0
+ *             for j in range(J):             # <<<<<<<<<<<<<<
+ *                 ind_f += tensor_indices[j] * occu_f[indices[i, j]]
+ *                 ind_i += tensor_indices[j] * occu_i[indices[i, j]]
+ */
+      __pyx_t_20 = __pyx_v_J;
+      __pyx_t_19 = __pyx_t_20;
+      for (__pyx_t_21 = 0; __pyx_t_21 < __pyx_t_19; __pyx_t_21+=1) {
+        __pyx_v_j = __pyx_t_21;
+
+        /* "smol/utils/cluster/correlations.pyx":298
+ *             ind_f, ind_i = 0, 0
+ *             for j in range(J):
+ *                 ind_f += tensor_indices[j] * occu_f[indices[i, j]]             # <<<<<<<<<<<<<<
+ *                 ind_i += tensor_indices[j] * occu_i[indices[i, j]]
+ *             p_f += interaction_tensor[ind_f]
+ */
+        __pyx_t_22 = __pyx_v_j;
+        __pyx_t_23 = __pyx_v_i;
+        __pyx_t_24 = __pyx_v_j;
+        __pyx_t_25 = (*((long const  *) ( /* dim=1 */ ((char *) (((long const  *) ( /* dim=0 */ (__pyx_v_indices.data + __pyx_t_23 * __pyx_v_indices.strides[0]) )) + __pyx_t_24)) )));
+        __pyx_v_ind_f = (__pyx_v_ind_f + ((*((long const  *) ( /* dim=0 */ ((char *) (((long const  *) __pyx_v_tensor_indices.data) + __pyx_t_22)) ))) * (*((long const  *) ( /* dim=0 */ ((char *) (((long const  *) __pyx_v_occu_f.data) + __pyx_t_25)) )))));
+
+        /* "smol/utils/cluster/correlations.pyx":299
+ *             for j in range(J):
+ *                 ind_f += tensor_indices[j] * occu_f[indices[i, j]]
+ *                 ind_i += tensor_indices[j] * occu_i[indices[i, j]]             # <<<<<<<<<<<<<<
+ *             p_f += interaction_tensor[ind_f]
+ *             p_i += interaction_tensor[ind_i]
+ */
+        __pyx_t_24 = __pyx_v_j;
+        __pyx_t_23 = __pyx_v_i;
+        __pyx_t_25 = __pyx_v_j;
+        __pyx_t_22 = (*((long const  *) ( /* dim=1 */ ((char *) (((long const  *) ( /* dim=0 */ (__pyx_v_indices.data + __pyx_t_23 * __pyx_v_indices.strides[0]) )) + __pyx_t_25)) )));
+        __pyx_v_ind_i = (__pyx_v_ind_i + ((*((long const  *) ( /* dim=0 */ ((char *) (((long const  *) __pyx_v_tensor_indices.data) + __pyx_t_24)) ))) * (*((long const  *) ( /* dim=0 */ ((char *) (((long const  *) __pyx_v_occu_i.data) + __pyx_t_22)) )))));
+      }
+
+      /* "smol/utils/cluster/correlations.pyx":300
+ *                 ind_f += tensor_indices[j] * occu_f[indices[i, j]]
+ *                 ind_i += tensor_indices[j] * occu_i[indices[i, j]]
+ *             p_f += interaction_tensor[ind_f]             # <<<<<<<<<<<<<<
+ *             p_i += interaction_tensor[ind_i]
+ *         o_view[1, n] = abs(p_f / I - ref_interaction_vector[n])
+ */
+      __pyx_t_25 = __pyx_v_ind_f;
+      __pyx_v_p_f = (__pyx_v_p_f + (*((double const  *) ( /* dim=0 */ ((char *) (((double const  *) __pyx_v_interaction_tensor.data) + __pyx_t_25)) ))));
+
+      /* "smol/utils/cluster/correlations.pyx":301
+ *                 ind_i += tensor_indices[j] * occu_i[indices[i, j]]
+ *             p_f += interaction_tensor[ind_f]
+ *             p_i += interaction_tensor[ind_i]             # <<<<<<<<<<<<<<
+ *         o_view[1, n] = abs(p_f / I - ref_interaction_vector[n])
+ *         o_view[0, n] = abs(p_i / I - ref_interaction_vector[n])
+ */
+      __pyx_t_25 = __pyx_v_ind_i;
+      __pyx_v_p_i = (__pyx_v_p_i + (*((double const  *) ( /* dim=0 */ ((char *) (((double const  *) __pyx_v_interaction_tensor.data) + __pyx_t_25)) ))));
+    }
+
+    /* "smol/utils/cluster/correlations.pyx":302
+ *             p_f += interaction_tensor[ind_f]
+ *             p_i += interaction_tensor[ind_i]
+ *         o_view[1, n] = abs(p_f / I - ref_interaction_vector[n])             # <<<<<<<<<<<<<<
+ *         o_view[0, n] = abs(p_i / I - ref_interaction_vector[n])
+ *         n += 1
+ */
+    __pyx_t_25 = __pyx_v_n;
+    __pyx_t_23 = 1;
+    __pyx_t_22 = __pyx_v_n;
+    *((double *) ( /* dim=1 */ ((char *) (((double *) ( /* dim=0 */ (__pyx_v_o_view.data + __pyx_t_23 * __pyx_v_o_view.strides[0]) )) + __pyx_t_22)) )) = fabs(((__pyx_v_p_f / ((double)__pyx_v_I)) - (*((double const  *) ( /* dim=0 */ ((char *) (((double const  *) __pyx_v_ref_interaction_vector.data) + __pyx_t_25)) )))));
+
+    /* "smol/utils/cluster/correlations.pyx":303
+ *             p_i += interaction_tensor[ind_i]
+ *         o_view[1, n] = abs(p_f / I - ref_interaction_vector[n])
+ *         o_view[0, n] = abs(p_i / I - ref_interaction_vector[n])             # <<<<<<<<<<<<<<
+ *         n += 1
+ *     return out
+ */
+    __pyx_t_25 = __pyx_v_n;
+    __pyx_t_22 = 0;
+    __pyx_t_23 = __pyx_v_n;
+    *((double *) ( /* dim=1 */ ((char *) (((double *) ( /* dim=0 */ (__pyx_v_o_view.data + __pyx_t_22 * __pyx_v_o_view.strides[0]) )) + __pyx_t_23)) )) = fabs(((__pyx_v_p_i / ((double)__pyx_v_I)) - (*((double const  *) ( /* dim=0 */ ((char *) (((double const  *) __pyx_v_ref_interaction_vector.data) + __pyx_t_25)) )))));
+
+    /* "smol/utils/cluster/correlations.pyx":304
+ *         o_view[1, n] = abs(p_f / I - ref_interaction_vector[n])
+ *         o_view[0, n] = abs(p_i / I - ref_interaction_vector[n])
+ *         n += 1             # <<<<<<<<<<<<<<
+ *     return out
+ * 
+ */
+    __pyx_v_n = (__pyx_v_n + 1);
+
+    /* "smol/utils/cluster/correlations.pyx":291
+ * 
+ *     n = 1
+ *     for tensor_indices, interaction_tensor, indices in orbit_list:             # <<<<<<<<<<<<<<
+ *         I = indices.shape[0] # cluster index
+ *         J = indices.shape[1] # index within cluster
+ */
+  }
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "smol/utils/cluster/correlations.pyx":305
+ *         o_view[0, n] = abs(p_i / I - ref_interaction_vector[n])
+ *         n += 1
+ *     return out             # <<<<<<<<<<<<<<
+ * 
+ * 
+ */
+  __Pyx_XDECREF(__pyx_r);
+  __Pyx_INCREF(__pyx_v_out);
+  __pyx_r = __pyx_v_out;
+  goto __pyx_L0;
+
+  /* "smol/utils/cluster/correlations.pyx":252
+ * 
+ * 
+ * cpdef interaction_distance_single_flip(const long[::1] occu_f,             # <<<<<<<<<<<<<<
+ *                                        const long[::1] occu_i,
+ *                                        const double[::1] ref_interaction_vector,
+ */
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_XDECREF(__pyx_t_4);
+  __PYX_XDEC_MEMVIEW(&__pyx_t_5, 1);
+  __PYX_XDEC_MEMVIEW(&__pyx_t_6, 1);
+  __Pyx_XDECREF(__pyx_t_8);
+  __Pyx_XDECREF(__pyx_t_9);
+  __PYX_XDEC_MEMVIEW(&__pyx_t_11, 1);
+  __PYX_XDEC_MEMVIEW(&__pyx_t_12, 1);
+  __PYX_XDEC_MEMVIEW(&__pyx_t_13, 1);
+  __Pyx_AddTraceback("smol.utils.cluster.correlations.interaction_distance_single_flip", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = 0;
+  __pyx_L0:;
+  __PYX_XDEC_MEMVIEW(&__pyx_v_indices, 1);
+  __PYX_XDEC_MEMVIEW(&__pyx_v_tensor_indices, 1);
+  __PYX_XDEC_MEMVIEW(&__pyx_v_interaction_tensor, 1);
+  __Pyx_XDECREF(__pyx_v_out);
+  __PYX_XDEC_MEMVIEW(&__pyx_v_o_view, 1);
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* Python wrapper */
+static PyObject *__pyx_pw_4smol_5utils_7cluster_12correlations_11interaction_distance_single_flip(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static char __pyx_doc_4smol_5utils_7cluster_12correlations_10interaction_distance_single_flip[] = "Computes the absolute distance of two cluster interaction vectors separated by a\n    single flip and a given correlation vector.\n\n    Unfortunately this scales just as bad as computing the full interaction vector.\n\n    Args:\n        occu_f (ndarray):\n            encoded occupancy array with flip\n        occu_i (ndarray):\n            encoded occupancy array without flip\n        ref_interaction_vector (ndarray):\n            reference cluster interaction vector\n        num_interactions (int):\n            total number of cluster interactions (orbits in cluster subspace).\n        site_orbit_list:\n            Information of all orbits that include the flip site.\n            List of tuples each with\n            (cluster ratio, flat tensor index array, flat cluster interaction tensor,\n             site indices of clusters)\n\n    Returns:\n        ndarray: 2D with cluster interaction vector distances from reference for each of\n        occu_i and occu_f\n    ";
+static PyObject *__pyx_pw_4smol_5utils_7cluster_12correlations_11interaction_distance_single_flip(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
+  __Pyx_memviewslice __pyx_v_occu_f = { 0, 0, { 0 }, { 0 }, { 0 } };
+  __Pyx_memviewslice __pyx_v_occu_i = { 0, 0, { 0 }, { 0 }, { 0 } };
+  __Pyx_memviewslice __pyx_v_ref_interaction_vector = { 0, 0, { 0 }, { 0 }, { 0 } };
+  int __pyx_v_num_interactions;
+  PyObject *__pyx_v_orbit_list = 0;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("interaction_distance_single_flip (wrapper)", 0);
+  {
+    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_occu_f,&__pyx_n_s_occu_i,&__pyx_n_s_ref_interaction_vector,&__pyx_n_s_num_interactions,&__pyx_n_s_orbit_list,0};
+    PyObject* values[5] = {0,0,0,0,0};
+    if (unlikely(__pyx_kwds)) {
+      Py_ssize_t kw_args;
+      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
+      switch (pos_args) {
+        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
+        CYTHON_FALLTHROUGH;
+        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
+        CYTHON_FALLTHROUGH;
+        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
+        CYTHON_FALLTHROUGH;
+        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
+        CYTHON_FALLTHROUGH;
+        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
+        CYTHON_FALLTHROUGH;
+        case  0: break;
+        default: goto __pyx_L5_argtuple_error;
+      }
+      kw_args = PyDict_Size(__pyx_kwds);
+      switch (pos_args) {
+        case  0:
+        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_occu_f)) != 0)) kw_args--;
+        else goto __pyx_L5_argtuple_error;
+        CYTHON_FALLTHROUGH;
+        case  1:
+        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_occu_i)) != 0)) kw_args--;
+        else {
+          __Pyx_RaiseArgtupleInvalid("interaction_distance_single_flip", 1, 5, 5, 1); __PYX_ERR(0, 252, __pyx_L3_error)
+        }
+        CYTHON_FALLTHROUGH;
+        case  2:
+        if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_ref_interaction_vector)) != 0)) kw_args--;
+        else {
+          __Pyx_RaiseArgtupleInvalid("interaction_distance_single_flip", 1, 5, 5, 2); __PYX_ERR(0, 252, __pyx_L3_error)
+        }
+        CYTHON_FALLTHROUGH;
+        case  3:
+        if (likely((values[3] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_num_interactions)) != 0)) kw_args--;
+        else {
+          __Pyx_RaiseArgtupleInvalid("interaction_distance_single_flip", 1, 5, 5, 3); __PYX_ERR(0, 252, __pyx_L3_error)
+        }
+        CYTHON_FALLTHROUGH;
+        case  4:
+        if (likely((values[4] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_orbit_list)) != 0)) kw_args--;
+        else {
+          __Pyx_RaiseArgtupleInvalid("interaction_distance_single_flip", 1, 5, 5, 4); __PYX_ERR(0, 252, __pyx_L3_error)
+        }
+      }
+      if (unlikely(kw_args > 0)) {
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "interaction_distance_single_flip") < 0)) __PYX_ERR(0, 252, __pyx_L3_error)
+      }
+    } else if (PyTuple_GET_SIZE(__pyx_args) != 5) {
+      goto __pyx_L5_argtuple_error;
+    } else {
+      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
+      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
+      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
+      values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
+      values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
+    }
+    __pyx_v_occu_f = __Pyx_PyObject_to_MemoryviewSlice_dc_long__const__(values[0], 0); if (unlikely(!__pyx_v_occu_f.memview)) __PYX_ERR(0, 252, __pyx_L3_error)
+    __pyx_v_occu_i = __Pyx_PyObject_to_MemoryviewSlice_dc_long__const__(values[1], 0); if (unlikely(!__pyx_v_occu_i.memview)) __PYX_ERR(0, 253, __pyx_L3_error)
+    __pyx_v_ref_interaction_vector = __Pyx_PyObject_to_MemoryviewSlice_dc_double__const__(values[2], 0); if (unlikely(!__pyx_v_ref_interaction_vector.memview)) __PYX_ERR(0, 254, __pyx_L3_error)
+    __pyx_v_num_interactions = __Pyx_PyInt_As_int(values[3]); if (unlikely((__pyx_v_num_interactions == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 255, __pyx_L3_error)
+    __pyx_v_orbit_list = ((PyObject*)values[4]);
+  }
+  goto __pyx_L4_argument_unpacking_done;
+  __pyx_L5_argtuple_error:;
+  __Pyx_RaiseArgtupleInvalid("interaction_distance_single_flip", 1, 5, 5, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 252, __pyx_L3_error)
+  __pyx_L3_error:;
+  __Pyx_AddTraceback("smol.utils.cluster.correlations.interaction_distance_single_flip", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_RefNannyFinishContext();
+  return NULL;
+  __pyx_L4_argument_unpacking_done:;
+  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_orbit_list), (&PyList_Type), 1, "orbit_list", 1))) __PYX_ERR(0, 256, __pyx_L1_error)
+  __pyx_r = __pyx_pf_4smol_5utils_7cluster_12correlations_10interaction_distance_single_flip(__pyx_self, __pyx_v_occu_f, __pyx_v_occu_i, __pyx_v_ref_interaction_vector, __pyx_v_num_interactions, __pyx_v_orbit_list);
+
+  /* function exit code */
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static PyObject *__pyx_pf_4smol_5utils_7cluster_12correlations_10interaction_distance_single_flip(CYTHON_UNUSED PyObject *__pyx_self, __Pyx_memviewslice __pyx_v_occu_f, __Pyx_memviewslice __pyx_v_occu_i, __Pyx_memviewslice __pyx_v_ref_interaction_vector, int __pyx_v_num_interactions, PyObject *__pyx_v_orbit_list) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("interaction_distance_single_flip", 0);
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_1 = __pyx_f_4smol_5utils_7cluster_12correlations_interaction_distance_single_flip(__pyx_v_occu_f, __pyx_v_occu_i, __pyx_v_ref_interaction_vector, __pyx_v_num_interactions, __pyx_v_orbit_list, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 252, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_r = __pyx_t_1;
+  __pyx_t_1 = 0;
+  goto __pyx_L0;
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_AddTraceback("smol.utils.cluster.correlations.interaction_distance_single_flip", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __PYX_XDEC_MEMVIEW(&__pyx_v_occu_f, 1);
+  __PYX_XDEC_MEMVIEW(&__pyx_v_occu_i, 1);
+  __PYX_XDEC_MEMVIEW(&__pyx_v_ref_interaction_vector, 1);
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "smol/utils/cluster/correlations.pyx":308
+ * 
+ * 
+ * cpdef delta_ewald_single_flip(const long[::1] occu_f,             # <<<<<<<<<<<<<<
+ *                               const long[::1] occu_i,
+ *                               const double[:, ::1] ewald_matrix,
+ */
+
+static PyObject *__pyx_pw_4smol_5utils_7cluster_12correlations_13delta_ewald_single_flip(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static PyObject *__pyx_f_4smol_5utils_7cluster_12correlations_delta_ewald_single_flip(__Pyx_memviewslice __pyx_v_occu_f, __Pyx_memviewslice __pyx_v_occu_i, __Pyx_memviewslice __pyx_v_ewald_matrix, __Pyx_memviewslice __pyx_v_ewald_indices, int const __pyx_v_site_ind, CYTHON_UNUSED int __pyx_skip_dispatch) {
+  int __pyx_v_i;
+  int __pyx_v_j;
+  int __pyx_v_k;
+  int __pyx_v_add;
+  int __pyx_v_sub;
+  double __pyx_v_out;
+  double __pyx_v_out_k;
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  Py_ssize_t __pyx_t_1;
+  Py_ssize_t __pyx_t_2;
+  Py_ssize_t __pyx_t_3;
+  Py_ssize_t __pyx_t_4;
+  Py_ssize_t __pyx_t_5;
+  int __pyx_t_6;
+  int __pyx_t_7;
+  int __pyx_t_8;
+  PyObject *__pyx_t_9 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("delta_ewald_single_flip", 0);
+
+  /* "smol/utils/cluster/correlations.pyx":333
+ *     cdef int i, j, k, add, sub
+ *     cdef bint ok
+ *     cdef double out = 0             # <<<<<<<<<<<<<<
+ *     cdef double out_k
+ * 
+ */
+  __pyx_v_out = 0.0;
+
+  /* "smol/utils/cluster/correlations.pyx":337
+ * 
+ *     # values of -1 are vacancies and hence don't have ewald indices
+ *     add = ewald_indices[site_ind, occu_f[site_ind]]             # <<<<<<<<<<<<<<
+ *     sub = ewald_indices[site_ind, occu_i[site_ind]]
+ * 
+ */
+  __pyx_t_1 = __pyx_v_site_ind;
+  __pyx_t_2 = __pyx_v_site_ind;
+  __pyx_t_3 = (*((long const  *) ( /* dim=0 */ ((char *) (((long const  *) __pyx_v_occu_f.data) + __pyx_t_1)) )));
+  __pyx_v_add = (*((long const  *) ( /* dim=1 */ ((char *) (((long const  *) ( /* dim=0 */ (__pyx_v_ewald_indices.data + __pyx_t_2 * __pyx_v_ewald_indices.strides[0]) )) + __pyx_t_3)) )));
+
+  /* "smol/utils/cluster/correlations.pyx":338
+ *     # values of -1 are vacancies and hence don't have ewald indices
+ *     add = ewald_indices[site_ind, occu_f[site_ind]]
+ *     sub = ewald_indices[site_ind, occu_i[site_ind]]             # <<<<<<<<<<<<<<
+ * 
+ *     for k in range(occu_f.shape[0]):
+ */
+  __pyx_t_1 = __pyx_v_site_ind;
+  __pyx_t_3 = __pyx_v_site_ind;
+  __pyx_t_2 = (*((long const  *) ( /* dim=0 */ ((char *) (((long const  *) __pyx_v_occu_i.data) + __pyx_t_1)) )));
+  __pyx_v_sub = (*((long const  *) ( /* dim=1 */ ((char *) (((long const  *) ( /* dim=0 */ (__pyx_v_ewald_indices.data + __pyx_t_3 * __pyx_v_ewald_indices.strides[0]) )) + __pyx_t_2)) )));
+
+  /* "smol/utils/cluster/correlations.pyx":340
+ *     sub = ewald_indices[site_ind, occu_i[site_ind]]
+ * 
+ *     for k in range(occu_f.shape[0]):             # <<<<<<<<<<<<<<
+ *         i = ewald_indices[k, occu_f[k]]
+ *         out_k = 0
+ */
+  __pyx_t_4 = (__pyx_v_occu_f.shape[0]);
+  __pyx_t_5 = __pyx_t_4;
+  for (__pyx_t_6 = 0; __pyx_t_6 < __pyx_t_5; __pyx_t_6+=1) {
+    __pyx_v_k = __pyx_t_6;
+
+    /* "smol/utils/cluster/correlations.pyx":341
+ * 
+ *     for k in range(occu_f.shape[0]):
+ *         i = ewald_indices[k, occu_f[k]]             # <<<<<<<<<<<<<<
+ *         out_k = 0
+ *         if i != -1 and add != -1:
+ */
+    __pyx_t_1 = __pyx_v_k;
+    __pyx_t_2 = __pyx_v_k;
+    __pyx_t_3 = (*((long const  *) ( /* dim=0 */ ((char *) (((long const  *) __pyx_v_occu_f.data) + __pyx_t_1)) )));
+    __pyx_v_i = (*((long const  *) ( /* dim=1 */ ((char *) (((long const  *) ( /* dim=0 */ (__pyx_v_ewald_indices.data + __pyx_t_2 * __pyx_v_ewald_indices.strides[0]) )) + __pyx_t_3)) )));
+
+    /* "smol/utils/cluster/correlations.pyx":342
+ *     for k in range(occu_f.shape[0]):
+ *         i = ewald_indices[k, occu_f[k]]
+ *         out_k = 0             # <<<<<<<<<<<<<<
+ *         if i != -1 and add != -1:
+ *             if i != add:
+ */
+    __pyx_v_out_k = 0.0;
+
+    /* "smol/utils/cluster/correlations.pyx":343
+ *         i = ewald_indices[k, occu_f[k]]
+ *         out_k = 0
+ *         if i != -1 and add != -1:             # <<<<<<<<<<<<<<
+ *             if i != add:
+ *                 out_k = out_k + 2 * ewald_matrix[i, add]
+ */
+    __pyx_t_8 = ((__pyx_v_i != -1L) != 0);
+    if (__pyx_t_8) {
+    } else {
+      __pyx_t_7 = __pyx_t_8;
+      goto __pyx_L6_bool_binop_done;
+    }
+    __pyx_t_8 = ((__pyx_v_add != -1L) != 0);
+    __pyx_t_7 = __pyx_t_8;
+    __pyx_L6_bool_binop_done:;
+    if (__pyx_t_7) {
+
+      /* "smol/utils/cluster/correlations.pyx":344
+ *         out_k = 0
+ *         if i != -1 and add != -1:
+ *             if i != add:             # <<<<<<<<<<<<<<
+ *                 out_k = out_k + 2 * ewald_matrix[i, add]
+ *             else:
+ */
+      __pyx_t_7 = ((__pyx_v_i != __pyx_v_add) != 0);
+      if (__pyx_t_7) {
+
+        /* "smol/utils/cluster/correlations.pyx":345
+ *         if i != -1 and add != -1:
+ *             if i != add:
+ *                 out_k = out_k + 2 * ewald_matrix[i, add]             # <<<<<<<<<<<<<<
+ *             else:
+ *                 out_k = out_k + ewald_matrix[i, add]
+ */
+        __pyx_t_1 = __pyx_v_i;
+        __pyx_t_3 = __pyx_v_add;
+        __pyx_v_out_k = (__pyx_v_out_k + (2.0 * (*((double const  *) ( /* dim=1 */ ((char *) (((double const  *) ( /* dim=0 */ (__pyx_v_ewald_matrix.data + __pyx_t_1 * __pyx_v_ewald_matrix.strides[0]) )) + __pyx_t_3)) )))));
+
+        /* "smol/utils/cluster/correlations.pyx":344
+ *         out_k = 0
+ *         if i != -1 and add != -1:
+ *             if i != add:             # <<<<<<<<<<<<<<
+ *                 out_k = out_k + 2 * ewald_matrix[i, add]
+ *             else:
+ */
+        goto __pyx_L8;
+      }
+
+      /* "smol/utils/cluster/correlations.pyx":347
+ *                 out_k = out_k + 2 * ewald_matrix[i, add]
+ *             else:
+ *                 out_k = out_k + ewald_matrix[i, add]             # <<<<<<<<<<<<<<
+ * 
+ *         j = ewald_indices[k, occu_i[k]]
+ */
+      /*else*/ {
+        __pyx_t_3 = __pyx_v_i;
+        __pyx_t_1 = __pyx_v_add;
+        __pyx_v_out_k = (__pyx_v_out_k + (*((double const  *) ( /* dim=1 */ ((char *) (((double const  *) ( /* dim=0 */ (__pyx_v_ewald_matrix.data + __pyx_t_3 * __pyx_v_ewald_matrix.strides[0]) )) + __pyx_t_1)) ))));
+      }
+      __pyx_L8:;
+
+      /* "smol/utils/cluster/correlations.pyx":343
+ *         i = ewald_indices[k, occu_f[k]]
+ *         out_k = 0
+ *         if i != -1 and add != -1:             # <<<<<<<<<<<<<<
+ *             if i != add:
+ *                 out_k = out_k + 2 * ewald_matrix[i, add]
+ */
+    }
+
+    /* "smol/utils/cluster/correlations.pyx":349
+ *                 out_k = out_k + ewald_matrix[i, add]
+ * 
+ *         j = ewald_indices[k, occu_i[k]]             # <<<<<<<<<<<<<<
+ *         if j != -1 and sub != -1:
+ *             if j != sub:
+ */
+    __pyx_t_1 = __pyx_v_k;
+    __pyx_t_3 = __pyx_v_k;
+    __pyx_t_2 = (*((long const  *) ( /* dim=0 */ ((char *) (((long const  *) __pyx_v_occu_i.data) + __pyx_t_1)) )));
+    __pyx_v_j = (*((long const  *) ( /* dim=1 */ ((char *) (((long const  *) ( /* dim=0 */ (__pyx_v_ewald_indices.data + __pyx_t_3 * __pyx_v_ewald_indices.strides[0]) )) + __pyx_t_2)) )));
+
+    /* "smol/utils/cluster/correlations.pyx":350
+ * 
+ *         j = ewald_indices[k, occu_i[k]]
+ *         if j != -1 and sub != -1:             # <<<<<<<<<<<<<<
+ *             if j != sub:
+ *                 out_k = out_k - 2 * ewald_matrix[j, sub]
+ */
+    __pyx_t_8 = ((__pyx_v_j != -1L) != 0);
+    if (__pyx_t_8) {
+    } else {
+      __pyx_t_7 = __pyx_t_8;
+      goto __pyx_L10_bool_binop_done;
+    }
+    __pyx_t_8 = ((__pyx_v_sub != -1L) != 0);
+    __pyx_t_7 = __pyx_t_8;
+    __pyx_L10_bool_binop_done:;
+    if (__pyx_t_7) {
+
+      /* "smol/utils/cluster/correlations.pyx":351
+ *         j = ewald_indices[k, occu_i[k]]
+ *         if j != -1 and sub != -1:
+ *             if j != sub:             # <<<<<<<<<<<<<<
+ *                 out_k = out_k - 2 * ewald_matrix[j, sub]
+ *             else:
+ */
+      __pyx_t_7 = ((__pyx_v_j != __pyx_v_sub) != 0);
+      if (__pyx_t_7) {
+
+        /* "smol/utils/cluster/correlations.pyx":352
+ *         if j != -1 and sub != -1:
+ *             if j != sub:
+ *                 out_k = out_k - 2 * ewald_matrix[j, sub]             # <<<<<<<<<<<<<<
+ *             else:
+ *                 out_k = out_k - ewald_matrix[j, sub]
+ */
+        __pyx_t_1 = __pyx_v_j;
+        __pyx_t_2 = __pyx_v_sub;
+        __pyx_v_out_k = (__pyx_v_out_k - (2.0 * (*((double const  *) ( /* dim=1 */ ((char *) (((double const  *) ( /* dim=0 */ (__pyx_v_ewald_matrix.data + __pyx_t_1 * __pyx_v_ewald_matrix.strides[0]) )) + __pyx_t_2)) )))));
+
+        /* "smol/utils/cluster/correlations.pyx":351
+ *         j = ewald_indices[k, occu_i[k]]
+ *         if j != -1 and sub != -1:
+ *             if j != sub:             # <<<<<<<<<<<<<<
+ *                 out_k = out_k - 2 * ewald_matrix[j, sub]
+ *             else:
+ */
+        goto __pyx_L12;
+      }
+
+      /* "smol/utils/cluster/correlations.pyx":354
+ *                 out_k = out_k - 2 * ewald_matrix[j, sub]
+ *             else:
+ *                 out_k = out_k - ewald_matrix[j, sub]             # <<<<<<<<<<<<<<
+ *         out += out_k
+ *     return out
+ */
+      /*else*/ {
+        __pyx_t_2 = __pyx_v_j;
+        __pyx_t_1 = __pyx_v_sub;
+        __pyx_v_out_k = (__pyx_v_out_k - (*((double const  *) ( /* dim=1 */ ((char *) (((double const  *) ( /* dim=0 */ (__pyx_v_ewald_matrix.data + __pyx_t_2 * __pyx_v_ewald_matrix.strides[0]) )) + __pyx_t_1)) ))));
+      }
+      __pyx_L12:;
+
+      /* "smol/utils/cluster/correlations.pyx":350
+ * 
+ *         j = ewald_indices[k, occu_i[k]]
+ *         if j != -1 and sub != -1:             # <<<<<<<<<<<<<<
+ *             if j != sub:
+ *                 out_k = out_k - 2 * ewald_matrix[j, sub]
+ */
+    }
+
+    /* "smol/utils/cluster/correlations.pyx":355
+ *             else:
+ *                 out_k = out_k - ewald_matrix[j, sub]
+ *         out += out_k             # <<<<<<<<<<<<<<
+ *     return out
+ */
+    __pyx_v_out = (__pyx_v_out + __pyx_v_out_k);
+  }
+
+  /* "smol/utils/cluster/correlations.pyx":356
+ *                 out_k = out_k - ewald_matrix[j, sub]
+ *         out += out_k
+ *     return out             # <<<<<<<<<<<<<<
+ */
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_9 = PyFloat_FromDouble(__pyx_v_out); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 356, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_9);
+  __pyx_r = __pyx_t_9;
+  __pyx_t_9 = 0;
+  goto __pyx_L0;
+
+  /* "smol/utils/cluster/correlations.pyx":308
+ * 
+ * 
+ * cpdef delta_ewald_single_flip(const long[::1] occu_f,             # <<<<<<<<<<<<<<
+ *                               const long[::1] occu_i,
+ *                               const double[:, ::1] ewald_matrix,
+ */
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_9);
+  __Pyx_AddTraceback("smol.utils.cluster.correlations.delta_ewald_single_flip", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* Python wrapper */
+static PyObject *__pyx_pw_4smol_5utils_7cluster_12correlations_13delta_ewald_single_flip(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static char __pyx_doc_4smol_5utils_7cluster_12correlations_12delta_ewald_single_flip[] = "Compute the change in electrostatic interaction energy from a flip.\n\n    Args:\n        occu_f (ndarray):\n            encoded occupancy array with flip\n        occu_i (ndarray):\n            encoded occupancy array without flip\n        ewald_matrix (ndarray):\n            Ewald matrix for electrostatic interactions\n        ewald_indices (ndarray):\n            2D array of indices corresponding to a specific site occupation\n            in the ewald matrix\n        site_ind (int):\n            site index for site being flipped\n\n    Returns:\n        float: electrostatic interaction energy difference\n    ";
+static PyObject *__pyx_pw_4smol_5utils_7cluster_12correlations_13delta_ewald_single_flip(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
+  __Pyx_memviewslice __pyx_v_occu_f = { 0, 0, { 0 }, { 0 }, { 0 } };
+  __Pyx_memviewslice __pyx_v_occu_i = { 0, 0, { 0 }, { 0 }, { 0 } };
+  __Pyx_memviewslice __pyx_v_ewald_matrix = { 0, 0, { 0 }, { 0 }, { 0 } };
+  __Pyx_memviewslice __pyx_v_ewald_indices = { 0, 0, { 0 }, { 0 }, { 0 } };
+  int __pyx_v_site_ind;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("delta_ewald_single_flip (wrapper)", 0);
+  {
+    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_occu_f,&__pyx_n_s_occu_i,&__pyx_n_s_ewald_matrix,&__pyx_n_s_ewald_indices,&__pyx_n_s_site_ind,0};
+    PyObject* values[5] = {0,0,0,0,0};
+    if (unlikely(__pyx_kwds)) {
+      Py_ssize_t kw_args;
+      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
+      switch (pos_args) {
+        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
+        CYTHON_FALLTHROUGH;
+        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
+        CYTHON_FALLTHROUGH;
+        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
+        CYTHON_FALLTHROUGH;
+        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
+        CYTHON_FALLTHROUGH;
+        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
+        CYTHON_FALLTHROUGH;
+        case  0: break;
+        default: goto __pyx_L5_argtuple_error;
+      }
+      kw_args = PyDict_Size(__pyx_kwds);
+      switch (pos_args) {
+        case  0:
+        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_occu_f)) != 0)) kw_args--;
+        else goto __pyx_L5_argtuple_error;
+        CYTHON_FALLTHROUGH;
+        case  1:
+        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_occu_i)) != 0)) kw_args--;
+        else {
+          __Pyx_RaiseArgtupleInvalid("delta_ewald_single_flip", 1, 5, 5, 1); __PYX_ERR(0, 308, __pyx_L3_error)
+        }
+        CYTHON_FALLTHROUGH;
+        case  2:
+        if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_ewald_matrix)) != 0)) kw_args--;
+        else {
+          __Pyx_RaiseArgtupleInvalid("delta_ewald_single_flip", 1, 5, 5, 2); __PYX_ERR(0, 308, __pyx_L3_error)
+        }
+        CYTHON_FALLTHROUGH;
+        case  3:
+        if (likely((values[3] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_ewald_indices)) != 0)) kw_args--;
+        else {
+          __Pyx_RaiseArgtupleInvalid("delta_ewald_single_flip", 1, 5, 5, 3); __PYX_ERR(0, 308, __pyx_L3_error)
+        }
+        CYTHON_FALLTHROUGH;
+        case  4:
+        if (likely((values[4] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_site_ind)) != 0)) kw_args--;
+        else {
+          __Pyx_RaiseArgtupleInvalid("delta_ewald_single_flip", 1, 5, 5, 4); __PYX_ERR(0, 308, __pyx_L3_error)
+        }
+      }
+      if (unlikely(kw_args > 0)) {
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "delta_ewald_single_flip") < 0)) __PYX_ERR(0, 308, __pyx_L3_error)
+      }
+    } else if (PyTuple_GET_SIZE(__pyx_args) != 5) {
+      goto __pyx_L5_argtuple_error;
+    } else {
+      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
+      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
+      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
+      values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
+      values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
+    }
+    __pyx_v_occu_f = __Pyx_PyObject_to_MemoryviewSlice_dc_long__const__(values[0], 0); if (unlikely(!__pyx_v_occu_f.memview)) __PYX_ERR(0, 308, __pyx_L3_error)
+    __pyx_v_occu_i = __Pyx_PyObject_to_MemoryviewSlice_dc_long__const__(values[1], 0); if (unlikely(!__pyx_v_occu_i.memview)) __PYX_ERR(0, 309, __pyx_L3_error)
+    __pyx_v_ewald_matrix = __Pyx_PyObject_to_MemoryviewSlice_d_dc_double__const__(values[2], 0); if (unlikely(!__pyx_v_ewald_matrix.memview)) __PYX_ERR(0, 310, __pyx_L3_error)
+    __pyx_v_ewald_indices = __Pyx_PyObject_to_MemoryviewSlice_d_dc_long__const__(values[3], 0); if (unlikely(!__pyx_v_ewald_indices.memview)) __PYX_ERR(0, 311, __pyx_L3_error)
+    __pyx_v_site_ind = __Pyx_PyInt_As_int(values[4]); if (unlikely((__pyx_v_site_ind == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 312, __pyx_L3_error)
+  }
+  goto __pyx_L4_argument_unpacking_done;
+  __pyx_L5_argtuple_error:;
+  __Pyx_RaiseArgtupleInvalid("delta_ewald_single_flip", 1, 5, 5, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 308, __pyx_L3_error)
+  __pyx_L3_error:;
+  __Pyx_AddTraceback("smol.utils.cluster.correlations.delta_ewald_single_flip", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_RefNannyFinishContext();
+  return NULL;
+  __pyx_L4_argument_unpacking_done:;
+  __pyx_r = __pyx_pf_4smol_5utils_7cluster_12correlations_12delta_ewald_single_flip(__pyx_self, __pyx_v_occu_f, __pyx_v_occu_i, __pyx_v_ewald_matrix, __pyx_v_ewald_indices, __pyx_v_site_ind);
+
+  /* function exit code */
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static PyObject *__pyx_pf_4smol_5utils_7cluster_12correlations_12delta_ewald_single_flip(CYTHON_UNUSED PyObject *__pyx_self, __Pyx_memviewslice __pyx_v_occu_f, __Pyx_memviewslice __pyx_v_occu_i, __Pyx_memviewslice __pyx_v_ewald_matrix, __Pyx_memviewslice __pyx_v_ewald_indices, int __pyx_v_site_ind) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("delta_ewald_single_flip", 0);
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_1 = __pyx_f_4smol_5utils_7cluster_12correlations_delta_ewald_single_flip(__pyx_v_occu_f, __pyx_v_occu_i, __pyx_v_ewald_matrix, __pyx_v_ewald_indices, __pyx_v_site_ind, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 308, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_r = __pyx_t_1;
+  __pyx_t_1 = 0;
+  goto __pyx_L0;
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_AddTraceback("smol.utils.cluster.correlations.delta_ewald_single_flip", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __PYX_XDEC_MEMVIEW(&__pyx_v_occu_f, 1);
+  __PYX_XDEC_MEMVIEW(&__pyx_v_occu_i, 1);
+  __PYX_XDEC_MEMVIEW(&__pyx_v_ewald_matrix, 1);
+  __PYX_XDEC_MEMVIEW(&__pyx_v_ewald_indices, 1);
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "../../../../../tmp/build-env-f9bdzduv/lib/python3.10/site-packages/numpy/__init__.pxd":734
  * ctypedef npy_cdouble     complex_t
- *
+ * 
  * cdef inline object PyArray_MultiIterNew1(a):             # <<<<<<<<<<<<<<
  *     return PyArray_MultiIterNew(1, <void*>a)
- *
+ * 
  */
 
 static CYTHON_INLINE PyObject *__pyx_f_5numpy_PyArray_MultiIterNew1(PyObject *__pyx_v_a) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("PyArray_MultiIterNew1", 0);
 
-  /* "../../miniconda3/envs/matx_310/lib/python3.10/site-packages/numpy/__init__.pxd":735
- *
+  /* "../../../../../tmp/build-env-f9bdzduv/lib/python3.10/site-packages/numpy/__init__.pxd":735
+ * 
  * cdef inline object PyArray_MultiIterNew1(a):
  *     return PyArray_MultiIterNew(1, <void*>a)             # <<<<<<<<<<<<<<
- *
+ * 
  * cdef inline object PyArray_MultiIterNew2(a, b):
  */
   __Pyx_XDECREF(__pyx_r);
   __pyx_t_1 = PyArray_MultiIterNew(1, ((void *)__pyx_v_a)); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 735, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* "../../miniconda3/envs/matx_310/lib/python3.10/site-packages/numpy/__init__.pxd":734
+  /* "../../../../../tmp/build-env-f9bdzduv/lib/python3.10/site-packages/numpy/__init__.pxd":734
  * ctypedef npy_cdouble     complex_t
- *
+ * 
  * cdef inline object PyArray_MultiIterNew1(a):             # <<<<<<<<<<<<<<
  *     return PyArray_MultiIterNew(1, <void*>a)
- *
+ * 
  */
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_AddTraceback("numpy.PyArray_MultiIterNew1", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "../../miniconda3/envs/matx_310/lib/python3.10/site-packages/numpy/__init__.pxd":737
+/* "../../../../../tmp/build-env-f9bdzduv/lib/python3.10/site-packages/numpy/__init__.pxd":737
  *     return PyArray_MultiIterNew(1, <void*>a)
- *
+ * 
  * cdef inline object PyArray_MultiIterNew2(a, b):             # <<<<<<<<<<<<<<
  *     return PyArray_MultiIterNew(2, <void*>a, <void*>b)
- *
+ * 
  */
 
 static CYTHON_INLINE PyObject *__pyx_f_5numpy_PyArray_MultiIterNew2(PyObject *__pyx_v_a, PyObject *__pyx_v_b) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("PyArray_MultiIterNew2", 0);
 
-  /* "../../miniconda3/envs/matx_310/lib/python3.10/site-packages/numpy/__init__.pxd":738
- *
+  /* "../../../../../tmp/build-env-f9bdzduv/lib/python3.10/site-packages/numpy/__init__.pxd":738
+ * 
  * cdef inline object PyArray_MultiIterNew2(a, b):
  *     return PyArray_MultiIterNew(2, <void*>a, <void*>b)             # <<<<<<<<<<<<<<
- *
+ * 
  * cdef inline object PyArray_MultiIterNew3(a, b, c):
  */
   __Pyx_XDECREF(__pyx_r);
   __pyx_t_1 = PyArray_MultiIterNew(2, ((void *)__pyx_v_a), ((void *)__pyx_v_b)); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 738, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* "../../miniconda3/envs/matx_310/lib/python3.10/site-packages/numpy/__init__.pxd":737
+  /* "../../../../../tmp/build-env-f9bdzduv/lib/python3.10/site-packages/numpy/__init__.pxd":737
  *     return PyArray_MultiIterNew(1, <void*>a)
- *
+ * 
  * cdef inline object PyArray_MultiIterNew2(a, b):             # <<<<<<<<<<<<<<
  *     return PyArray_MultiIterNew(2, <void*>a, <void*>b)
- *
+ * 
  */
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_AddTraceback("numpy.PyArray_MultiIterNew2", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "../../miniconda3/envs/matx_310/lib/python3.10/site-packages/numpy/__init__.pxd":740
+/* "../../../../../tmp/build-env-f9bdzduv/lib/python3.10/site-packages/numpy/__init__.pxd":740
  *     return PyArray_MultiIterNew(2, <void*>a, <void*>b)
- *
+ * 
  * cdef inline object PyArray_MultiIterNew3(a, b, c):             # <<<<<<<<<<<<<<
  *     return PyArray_MultiIterNew(3, <void*>a, <void*>b, <void*> c)
- *
+ * 
  */
 
 static CYTHON_INLINE PyObject *__pyx_f_5numpy_PyArray_MultiIterNew3(PyObject *__pyx_v_a, PyObject *__pyx_v_b, PyObject *__pyx_v_c) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("PyArray_MultiIterNew3", 0);
 
-  /* "../../miniconda3/envs/matx_310/lib/python3.10/site-packages/numpy/__init__.pxd":741
- *
+  /* "../../../../../tmp/build-env-f9bdzduv/lib/python3.10/site-packages/numpy/__init__.pxd":741
+ * 
  * cdef inline object PyArray_MultiIterNew3(a, b, c):
  *     return PyArray_MultiIterNew(3, <void*>a, <void*>b, <void*> c)             # <<<<<<<<<<<<<<
- *
+ * 
  * cdef inline object PyArray_MultiIterNew4(a, b, c, d):
  */
   __Pyx_XDECREF(__pyx_r);
   __pyx_t_1 = PyArray_MultiIterNew(3, ((void *)__pyx_v_a), ((void *)__pyx_v_b), ((void *)__pyx_v_c)); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 741, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* "../../miniconda3/envs/matx_310/lib/python3.10/site-packages/numpy/__init__.pxd":740
+  /* "../../../../../tmp/build-env-f9bdzduv/lib/python3.10/site-packages/numpy/__init__.pxd":740
  *     return PyArray_MultiIterNew(2, <void*>a, <void*>b)
- *
+ * 
  * cdef inline object PyArray_MultiIterNew3(a, b, c):             # <<<<<<<<<<<<<<
  *     return PyArray_MultiIterNew(3, <void*>a, <void*>b, <void*> c)
- *
+ * 
  */
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_AddTraceback("numpy.PyArray_MultiIterNew3", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "../../miniconda3/envs/matx_310/lib/python3.10/site-packages/numpy/__init__.pxd":743
+/* "../../../../../tmp/build-env-f9bdzduv/lib/python3.10/site-packages/numpy/__init__.pxd":743
  *     return PyArray_MultiIterNew(3, <void*>a, <void*>b, <void*> c)
- *
+ * 
  * cdef inline object PyArray_MultiIterNew4(a, b, c, d):             # <<<<<<<<<<<<<<
  *     return PyArray_MultiIterNew(4, <void*>a, <void*>b, <void*>c, <void*> d)
- *
+ * 
  */
 
 static CYTHON_INLINE PyObject *__pyx_f_5numpy_PyArray_MultiIterNew4(PyObject *__pyx_v_a, PyObject *__pyx_v_b, PyObject *__pyx_v_c, PyObject *__pyx_v_d) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("PyArray_MultiIterNew4", 0);
 
-  /* "../../miniconda3/envs/matx_310/lib/python3.10/site-packages/numpy/__init__.pxd":744
- *
+  /* "../../../../../tmp/build-env-f9bdzduv/lib/python3.10/site-packages/numpy/__init__.pxd":744
+ * 
  * cdef inline object PyArray_MultiIterNew4(a, b, c, d):
  *     return PyArray_MultiIterNew(4, <void*>a, <void*>b, <void*>c, <void*> d)             # <<<<<<<<<<<<<<
- *
+ * 
  * cdef inline object PyArray_MultiIterNew5(a, b, c, d, e):
  */
   __Pyx_XDECREF(__pyx_r);
   __pyx_t_1 = PyArray_MultiIterNew(4, ((void *)__pyx_v_a), ((void *)__pyx_v_b), ((void *)__pyx_v_c), ((void *)__pyx_v_d)); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 744, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* "../../miniconda3/envs/matx_310/lib/python3.10/site-packages/numpy/__init__.pxd":743
+  /* "../../../../../tmp/build-env-f9bdzduv/lib/python3.10/site-packages/numpy/__init__.pxd":743
  *     return PyArray_MultiIterNew(3, <void*>a, <void*>b, <void*> c)
- *
+ * 
  * cdef inline object PyArray_MultiIterNew4(a, b, c, d):             # <<<<<<<<<<<<<<
  *     return PyArray_MultiIterNew(4, <void*>a, <void*>b, <void*>c, <void*> d)
- *
+ * 
  */
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_AddTraceback("numpy.PyArray_MultiIterNew4", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "../../miniconda3/envs/matx_310/lib/python3.10/site-packages/numpy/__init__.pxd":746
+/* "../../../../../tmp/build-env-f9bdzduv/lib/python3.10/site-packages/numpy/__init__.pxd":746
  *     return PyArray_MultiIterNew(4, <void*>a, <void*>b, <void*>c, <void*> d)
- *
+ * 
  * cdef inline object PyArray_MultiIterNew5(a, b, c, d, e):             # <<<<<<<<<<<<<<
  *     return PyArray_MultiIterNew(5, <void*>a, <void*>b, <void*>c, <void*> d, <void*> e)
- *
+ * 
  */
 
 static CYTHON_INLINE PyObject *__pyx_f_5numpy_PyArray_MultiIterNew5(PyObject *__pyx_v_a, PyObject *__pyx_v_b, PyObject *__pyx_v_c, PyObject *__pyx_v_d, PyObject *__pyx_v_e) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("PyArray_MultiIterNew5", 0);
 
-  /* "../../miniconda3/envs/matx_310/lib/python3.10/site-packages/numpy/__init__.pxd":747
- *
+  /* "../../../../../tmp/build-env-f9bdzduv/lib/python3.10/site-packages/numpy/__init__.pxd":747
+ * 
  * cdef inline object PyArray_MultiIterNew5(a, b, c, d, e):
  *     return PyArray_MultiIterNew(5, <void*>a, <void*>b, <void*>c, <void*> d, <void*> e)             # <<<<<<<<<<<<<<
- *
+ * 
  * cdef inline tuple PyDataType_SHAPE(dtype d):
  */
   __Pyx_XDECREF(__pyx_r);
   __pyx_t_1 = PyArray_MultiIterNew(5, ((void *)__pyx_v_a), ((void *)__pyx_v_b), ((void *)__pyx_v_c), ((void *)__pyx_v_d), ((void *)__pyx_v_e)); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 747, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* "../../miniconda3/envs/matx_310/lib/python3.10/site-packages/numpy/__init__.pxd":746
+  /* "../../../../../tmp/build-env-f9bdzduv/lib/python3.10/site-packages/numpy/__init__.pxd":746
  *     return PyArray_MultiIterNew(4, <void*>a, <void*>b, <void*>c, <void*> d)
- *
+ * 
  * cdef inline object PyArray_MultiIterNew5(a, b, c, d, e):             # <<<<<<<<<<<<<<
  *     return PyArray_MultiIterNew(5, <void*>a, <void*>b, <void*>c, <void*> d, <void*> e)
- *
+ * 
  */
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_AddTraceback("numpy.PyArray_MultiIterNew5", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "../../miniconda3/envs/matx_310/lib/python3.10/site-packages/numpy/__init__.pxd":749
+/* "../../../../../tmp/build-env-f9bdzduv/lib/python3.10/site-packages/numpy/__init__.pxd":749
  *     return PyArray_MultiIterNew(5, <void*>a, <void*>b, <void*>c, <void*> d, <void*> e)
- *
+ * 
  * cdef inline tuple PyDataType_SHAPE(dtype d):             # <<<<<<<<<<<<<<
  *     if PyDataType_HASSUBARRAY(d):
  *         return <tuple>d.subarray.shape
  */
 
 static CYTHON_INLINE PyObject *__pyx_f_5numpy_PyDataType_SHAPE(PyArray_Descr *__pyx_v_d) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   int __pyx_t_1;
   __Pyx_RefNannySetupContext("PyDataType_SHAPE", 0);
 
-  /* "../../miniconda3/envs/matx_310/lib/python3.10/site-packages/numpy/__init__.pxd":750
- *
+  /* "../../../../../tmp/build-env-f9bdzduv/lib/python3.10/site-packages/numpy/__init__.pxd":750
+ * 
  * cdef inline tuple PyDataType_SHAPE(dtype d):
  *     if PyDataType_HASSUBARRAY(d):             # <<<<<<<<<<<<<<
  *         return <tuple>d.subarray.shape
  *     else:
  */
   __pyx_t_1 = (PyDataType_HASSUBARRAY(__pyx_v_d) != 0);
   if (__pyx_t_1) {
 
-    /* "../../miniconda3/envs/matx_310/lib/python3.10/site-packages/numpy/__init__.pxd":751
+    /* "../../../../../tmp/build-env-f9bdzduv/lib/python3.10/site-packages/numpy/__init__.pxd":751
  * cdef inline tuple PyDataType_SHAPE(dtype d):
  *     if PyDataType_HASSUBARRAY(d):
  *         return <tuple>d.subarray.shape             # <<<<<<<<<<<<<<
  *     else:
  *         return ()
  */
     __Pyx_XDECREF(__pyx_r);
     __Pyx_INCREF(((PyObject*)__pyx_v_d->subarray->shape));
     __pyx_r = ((PyObject*)__pyx_v_d->subarray->shape);
     goto __pyx_L0;
 
-    /* "../../miniconda3/envs/matx_310/lib/python3.10/site-packages/numpy/__init__.pxd":750
- *
+    /* "../../../../../tmp/build-env-f9bdzduv/lib/python3.10/site-packages/numpy/__init__.pxd":750
+ * 
  * cdef inline tuple PyDataType_SHAPE(dtype d):
  *     if PyDataType_HASSUBARRAY(d):             # <<<<<<<<<<<<<<
  *         return <tuple>d.subarray.shape
  *     else:
  */
   }
 
-  /* "../../miniconda3/envs/matx_310/lib/python3.10/site-packages/numpy/__init__.pxd":753
+  /* "../../../../../tmp/build-env-f9bdzduv/lib/python3.10/site-packages/numpy/__init__.pxd":753
  *         return <tuple>d.subarray.shape
  *     else:
  *         return ()             # <<<<<<<<<<<<<<
- *
- *
+ * 
+ * 
  */
   /*else*/ {
     __Pyx_XDECREF(__pyx_r);
     __Pyx_INCREF(__pyx_empty_tuple);
     __pyx_r = __pyx_empty_tuple;
     goto __pyx_L0;
   }
 
-  /* "../../miniconda3/envs/matx_310/lib/python3.10/site-packages/numpy/__init__.pxd":749
+  /* "../../../../../tmp/build-env-f9bdzduv/lib/python3.10/site-packages/numpy/__init__.pxd":749
  *     return PyArray_MultiIterNew(5, <void*>a, <void*>b, <void*>c, <void*> d, <void*> e)
- *
+ * 
  * cdef inline tuple PyDataType_SHAPE(dtype d):             # <<<<<<<<<<<<<<
  *     if PyDataType_HASSUBARRAY(d):
  *         return <tuple>d.subarray.shape
  */
 
   /* function exit code */
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "../../miniconda3/envs/matx_310/lib/python3.10/site-packages/numpy/__init__.pxd":928
+/* "../../../../../tmp/build-env-f9bdzduv/lib/python3.10/site-packages/numpy/__init__.pxd":928
  *     int _import_umath() except -1
- *
+ * 
  * cdef inline void set_array_base(ndarray arr, object base):             # <<<<<<<<<<<<<<
  *     Py_INCREF(base) # important to do this before stealing the reference below!
  *     PyArray_SetBaseObject(arr, base)
  */
 
 static CYTHON_INLINE void __pyx_f_5numpy_set_array_base(PyArrayObject *__pyx_v_arr, PyObject *__pyx_v_base) {
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("set_array_base", 0);
 
-  /* "../../miniconda3/envs/matx_310/lib/python3.10/site-packages/numpy/__init__.pxd":929
- *
+  /* "../../../../../tmp/build-env-f9bdzduv/lib/python3.10/site-packages/numpy/__init__.pxd":929
+ * 
  * cdef inline void set_array_base(ndarray arr, object base):
  *     Py_INCREF(base) # important to do this before stealing the reference below!             # <<<<<<<<<<<<<<
  *     PyArray_SetBaseObject(arr, base)
- *
+ * 
  */
   Py_INCREF(__pyx_v_base);
 
-  /* "../../miniconda3/envs/matx_310/lib/python3.10/site-packages/numpy/__init__.pxd":930
+  /* "../../../../../tmp/build-env-f9bdzduv/lib/python3.10/site-packages/numpy/__init__.pxd":930
  * cdef inline void set_array_base(ndarray arr, object base):
  *     Py_INCREF(base) # important to do this before stealing the reference below!
  *     PyArray_SetBaseObject(arr, base)             # <<<<<<<<<<<<<<
- *
+ * 
  * cdef inline object get_array_base(ndarray arr):
  */
   (void)(PyArray_SetBaseObject(__pyx_v_arr, __pyx_v_base));
 
-  /* "../../miniconda3/envs/matx_310/lib/python3.10/site-packages/numpy/__init__.pxd":928
+  /* "../../../../../tmp/build-env-f9bdzduv/lib/python3.10/site-packages/numpy/__init__.pxd":928
  *     int _import_umath() except -1
- *
+ * 
  * cdef inline void set_array_base(ndarray arr, object base):             # <<<<<<<<<<<<<<
  *     Py_INCREF(base) # important to do this before stealing the reference below!
  *     PyArray_SetBaseObject(arr, base)
  */
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
 }
 
-/* "../../miniconda3/envs/matx_310/lib/python3.10/site-packages/numpy/__init__.pxd":932
+/* "../../../../../tmp/build-env-f9bdzduv/lib/python3.10/site-packages/numpy/__init__.pxd":932
  *     PyArray_SetBaseObject(arr, base)
- *
+ * 
  * cdef inline object get_array_base(ndarray arr):             # <<<<<<<<<<<<<<
  *     base = PyArray_BASE(arr)
  *     if base is NULL:
  */
 
 static CYTHON_INLINE PyObject *__pyx_f_5numpy_get_array_base(PyArrayObject *__pyx_v_arr) {
   PyObject *__pyx_v_base;
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   int __pyx_t_1;
   __Pyx_RefNannySetupContext("get_array_base", 0);
 
-  /* "../../miniconda3/envs/matx_310/lib/python3.10/site-packages/numpy/__init__.pxd":933
- *
+  /* "../../../../../tmp/build-env-f9bdzduv/lib/python3.10/site-packages/numpy/__init__.pxd":933
+ * 
  * cdef inline object get_array_base(ndarray arr):
  *     base = PyArray_BASE(arr)             # <<<<<<<<<<<<<<
  *     if base is NULL:
  *         return None
  */
   __pyx_v_base = PyArray_BASE(__pyx_v_arr);
 
-  /* "../../miniconda3/envs/matx_310/lib/python3.10/site-packages/numpy/__init__.pxd":934
+  /* "../../../../../tmp/build-env-f9bdzduv/lib/python3.10/site-packages/numpy/__init__.pxd":934
  * cdef inline object get_array_base(ndarray arr):
  *     base = PyArray_BASE(arr)
  *     if base is NULL:             # <<<<<<<<<<<<<<
  *         return None
  *     return <object>base
  */
   __pyx_t_1 = ((__pyx_v_base == NULL) != 0);
   if (__pyx_t_1) {
 
-    /* "../../miniconda3/envs/matx_310/lib/python3.10/site-packages/numpy/__init__.pxd":935
+    /* "../../../../../tmp/build-env-f9bdzduv/lib/python3.10/site-packages/numpy/__init__.pxd":935
  *     base = PyArray_BASE(arr)
  *     if base is NULL:
  *         return None             # <<<<<<<<<<<<<<
  *     return <object>base
- *
+ * 
  */
     __Pyx_XDECREF(__pyx_r);
     __pyx_r = Py_None; __Pyx_INCREF(Py_None);
     goto __pyx_L0;
 
-    /* "../../miniconda3/envs/matx_310/lib/python3.10/site-packages/numpy/__init__.pxd":934
+    /* "../../../../../tmp/build-env-f9bdzduv/lib/python3.10/site-packages/numpy/__init__.pxd":934
  * cdef inline object get_array_base(ndarray arr):
  *     base = PyArray_BASE(arr)
  *     if base is NULL:             # <<<<<<<<<<<<<<
  *         return None
  *     return <object>base
  */
   }
 
-  /* "../../miniconda3/envs/matx_310/lib/python3.10/site-packages/numpy/__init__.pxd":936
+  /* "../../../../../tmp/build-env-f9bdzduv/lib/python3.10/site-packages/numpy/__init__.pxd":936
  *     if base is NULL:
  *         return None
  *     return <object>base             # <<<<<<<<<<<<<<
- *
+ * 
  * # Versions of the import_* functions which are more suitable for
  */
   __Pyx_XDECREF(__pyx_r);
   __Pyx_INCREF(((PyObject *)__pyx_v_base));
   __pyx_r = ((PyObject *)__pyx_v_base);
   goto __pyx_L0;
 
-  /* "../../miniconda3/envs/matx_310/lib/python3.10/site-packages/numpy/__init__.pxd":932
+  /* "../../../../../tmp/build-env-f9bdzduv/lib/python3.10/site-packages/numpy/__init__.pxd":932
  *     PyArray_SetBaseObject(arr, base)
- *
+ * 
  * cdef inline object get_array_base(ndarray arr):             # <<<<<<<<<<<<<<
  *     base = PyArray_BASE(arr)
  *     if base is NULL:
  */
 
   /* function exit code */
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "../../miniconda3/envs/matx_310/lib/python3.10/site-packages/numpy/__init__.pxd":940
+/* "../../../../../tmp/build-env-f9bdzduv/lib/python3.10/site-packages/numpy/__init__.pxd":940
  * # Versions of the import_* functions which are more suitable for
  * # Cython code.
  * cdef inline int import_array() except -1:             # <<<<<<<<<<<<<<
  *     try:
  *         __pyx_import_array()
  */
 
@@ -6252,15 +6781,15 @@
   PyObject *__pyx_t_7 = NULL;
   PyObject *__pyx_t_8 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("import_array", 0);
 
-  /* "../../miniconda3/envs/matx_310/lib/python3.10/site-packages/numpy/__init__.pxd":941
+  /* "../../../../../tmp/build-env-f9bdzduv/lib/python3.10/site-packages/numpy/__init__.pxd":941
  * # Cython code.
  * cdef inline int import_array() except -1:
  *     try:             # <<<<<<<<<<<<<<
  *         __pyx_import_array()
  *     except Exception:
  */
   {
@@ -6268,84 +6797,84 @@
     __Pyx_PyThreadState_assign
     __Pyx_ExceptionSave(&__pyx_t_1, &__pyx_t_2, &__pyx_t_3);
     __Pyx_XGOTREF(__pyx_t_1);
     __Pyx_XGOTREF(__pyx_t_2);
     __Pyx_XGOTREF(__pyx_t_3);
     /*try:*/ {
 
-      /* "../../miniconda3/envs/matx_310/lib/python3.10/site-packages/numpy/__init__.pxd":942
+      /* "../../../../../tmp/build-env-f9bdzduv/lib/python3.10/site-packages/numpy/__init__.pxd":942
  * cdef inline int import_array() except -1:
  *     try:
  *         __pyx_import_array()             # <<<<<<<<<<<<<<
  *     except Exception:
  *         raise ImportError("numpy.core.multiarray failed to import")
  */
       __pyx_t_4 = _import_array(); if (unlikely(__pyx_t_4 == ((int)-1))) __PYX_ERR(1, 942, __pyx_L3_error)
 
-      /* "../../miniconda3/envs/matx_310/lib/python3.10/site-packages/numpy/__init__.pxd":941
+      /* "../../../../../tmp/build-env-f9bdzduv/lib/python3.10/site-packages/numpy/__init__.pxd":941
  * # Cython code.
  * cdef inline int import_array() except -1:
  *     try:             # <<<<<<<<<<<<<<
  *         __pyx_import_array()
  *     except Exception:
  */
     }
     __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
     __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
     __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
     goto __pyx_L8_try_end;
     __pyx_L3_error:;
 
-    /* "../../miniconda3/envs/matx_310/lib/python3.10/site-packages/numpy/__init__.pxd":943
+    /* "../../../../../tmp/build-env-f9bdzduv/lib/python3.10/site-packages/numpy/__init__.pxd":943
  *     try:
  *         __pyx_import_array()
  *     except Exception:             # <<<<<<<<<<<<<<
  *         raise ImportError("numpy.core.multiarray failed to import")
- *
+ * 
  */
     __pyx_t_4 = __Pyx_PyErr_ExceptionMatches(((PyObject *)(&((PyTypeObject*)PyExc_Exception)[0])));
     if (__pyx_t_4) {
       __Pyx_AddTraceback("numpy.import_array", __pyx_clineno, __pyx_lineno, __pyx_filename);
       if (__Pyx_GetException(&__pyx_t_5, &__pyx_t_6, &__pyx_t_7) < 0) __PYX_ERR(1, 943, __pyx_L5_except_error)
       __Pyx_GOTREF(__pyx_t_5);
       __Pyx_GOTREF(__pyx_t_6);
       __Pyx_GOTREF(__pyx_t_7);
 
-      /* "../../miniconda3/envs/matx_310/lib/python3.10/site-packages/numpy/__init__.pxd":944
+      /* "../../../../../tmp/build-env-f9bdzduv/lib/python3.10/site-packages/numpy/__init__.pxd":944
  *         __pyx_import_array()
  *     except Exception:
  *         raise ImportError("numpy.core.multiarray failed to import")             # <<<<<<<<<<<<<<
- *
+ * 
  * cdef inline int import_umath() except -1:
  */
       __pyx_t_8 = __Pyx_PyObject_Call(__pyx_builtin_ImportError, __pyx_tuple_, NULL); if (unlikely(!__pyx_t_8)) __PYX_ERR(1, 944, __pyx_L5_except_error)
       __Pyx_GOTREF(__pyx_t_8);
       __Pyx_Raise(__pyx_t_8, 0, 0, 0);
       __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
       __PYX_ERR(1, 944, __pyx_L5_except_error)
     }
     goto __pyx_L5_except_error;
     __pyx_L5_except_error:;
 
-    /* "../../miniconda3/envs/matx_310/lib/python3.10/site-packages/numpy/__init__.pxd":941
+    /* "../../../../../tmp/build-env-f9bdzduv/lib/python3.10/site-packages/numpy/__init__.pxd":941
  * # Cython code.
  * cdef inline int import_array() except -1:
  *     try:             # <<<<<<<<<<<<<<
  *         __pyx_import_array()
  *     except Exception:
  */
     __Pyx_XGIVEREF(__pyx_t_1);
     __Pyx_XGIVEREF(__pyx_t_2);
     __Pyx_XGIVEREF(__pyx_t_3);
     __Pyx_ExceptionReset(__pyx_t_1, __pyx_t_2, __pyx_t_3);
     goto __pyx_L1_error;
     __pyx_L8_try_end:;
   }
 
-  /* "../../miniconda3/envs/matx_310/lib/python3.10/site-packages/numpy/__init__.pxd":940
+  /* "../../../../../tmp/build-env-f9bdzduv/lib/python3.10/site-packages/numpy/__init__.pxd":940
  * # Versions of the import_* functions which are more suitable for
  * # Cython code.
  * cdef inline int import_array() except -1:             # <<<<<<<<<<<<<<
  *     try:
  *         __pyx_import_array()
  */
 
@@ -6360,17 +6889,17 @@
   __Pyx_AddTraceback("numpy.import_array", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = -1;
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "../../miniconda3/envs/matx_310/lib/python3.10/site-packages/numpy/__init__.pxd":946
+/* "../../../../../tmp/build-env-f9bdzduv/lib/python3.10/site-packages/numpy/__init__.pxd":946
  *         raise ImportError("numpy.core.multiarray failed to import")
- *
+ * 
  * cdef inline int import_umath() except -1:             # <<<<<<<<<<<<<<
  *     try:
  *         _import_umath()
  */
 
 static CYTHON_INLINE int __pyx_f_5numpy_import_umath(void) {
   int __pyx_r;
@@ -6384,102 +6913,102 @@
   PyObject *__pyx_t_7 = NULL;
   PyObject *__pyx_t_8 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("import_umath", 0);
 
-  /* "../../miniconda3/envs/matx_310/lib/python3.10/site-packages/numpy/__init__.pxd":947
- *
+  /* "../../../../../tmp/build-env-f9bdzduv/lib/python3.10/site-packages/numpy/__init__.pxd":947
+ * 
  * cdef inline int import_umath() except -1:
  *     try:             # <<<<<<<<<<<<<<
  *         _import_umath()
  *     except Exception:
  */
   {
     __Pyx_PyThreadState_declare
     __Pyx_PyThreadState_assign
     __Pyx_ExceptionSave(&__pyx_t_1, &__pyx_t_2, &__pyx_t_3);
     __Pyx_XGOTREF(__pyx_t_1);
     __Pyx_XGOTREF(__pyx_t_2);
     __Pyx_XGOTREF(__pyx_t_3);
     /*try:*/ {
 
-      /* "../../miniconda3/envs/matx_310/lib/python3.10/site-packages/numpy/__init__.pxd":948
+      /* "../../../../../tmp/build-env-f9bdzduv/lib/python3.10/site-packages/numpy/__init__.pxd":948
  * cdef inline int import_umath() except -1:
  *     try:
  *         _import_umath()             # <<<<<<<<<<<<<<
  *     except Exception:
  *         raise ImportError("numpy.core.umath failed to import")
  */
       __pyx_t_4 = _import_umath(); if (unlikely(__pyx_t_4 == ((int)-1))) __PYX_ERR(1, 948, __pyx_L3_error)
 
-      /* "../../miniconda3/envs/matx_310/lib/python3.10/site-packages/numpy/__init__.pxd":947
- *
+      /* "../../../../../tmp/build-env-f9bdzduv/lib/python3.10/site-packages/numpy/__init__.pxd":947
+ * 
  * cdef inline int import_umath() except -1:
  *     try:             # <<<<<<<<<<<<<<
  *         _import_umath()
  *     except Exception:
  */
     }
     __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
     __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
     __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
     goto __pyx_L8_try_end;
     __pyx_L3_error:;
 
-    /* "../../miniconda3/envs/matx_310/lib/python3.10/site-packages/numpy/__init__.pxd":949
+    /* "../../../../../tmp/build-env-f9bdzduv/lib/python3.10/site-packages/numpy/__init__.pxd":949
  *     try:
  *         _import_umath()
  *     except Exception:             # <<<<<<<<<<<<<<
  *         raise ImportError("numpy.core.umath failed to import")
- *
+ * 
  */
     __pyx_t_4 = __Pyx_PyErr_ExceptionMatches(((PyObject *)(&((PyTypeObject*)PyExc_Exception)[0])));
     if (__pyx_t_4) {
       __Pyx_AddTraceback("numpy.import_umath", __pyx_clineno, __pyx_lineno, __pyx_filename);
       if (__Pyx_GetException(&__pyx_t_5, &__pyx_t_6, &__pyx_t_7) < 0) __PYX_ERR(1, 949, __pyx_L5_except_error)
       __Pyx_GOTREF(__pyx_t_5);
       __Pyx_GOTREF(__pyx_t_6);
       __Pyx_GOTREF(__pyx_t_7);
 
-      /* "../../miniconda3/envs/matx_310/lib/python3.10/site-packages/numpy/__init__.pxd":950
+      /* "../../../../../tmp/build-env-f9bdzduv/lib/python3.10/site-packages/numpy/__init__.pxd":950
  *         _import_umath()
  *     except Exception:
  *         raise ImportError("numpy.core.umath failed to import")             # <<<<<<<<<<<<<<
- *
+ * 
  * cdef inline int import_ufunc() except -1:
  */
       __pyx_t_8 = __Pyx_PyObject_Call(__pyx_builtin_ImportError, __pyx_tuple__2, NULL); if (unlikely(!__pyx_t_8)) __PYX_ERR(1, 950, __pyx_L5_except_error)
       __Pyx_GOTREF(__pyx_t_8);
       __Pyx_Raise(__pyx_t_8, 0, 0, 0);
       __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
       __PYX_ERR(1, 950, __pyx_L5_except_error)
     }
     goto __pyx_L5_except_error;
     __pyx_L5_except_error:;
 
-    /* "../../miniconda3/envs/matx_310/lib/python3.10/site-packages/numpy/__init__.pxd":947
- *
+    /* "../../../../../tmp/build-env-f9bdzduv/lib/python3.10/site-packages/numpy/__init__.pxd":947
+ * 
  * cdef inline int import_umath() except -1:
  *     try:             # <<<<<<<<<<<<<<
  *         _import_umath()
  *     except Exception:
  */
     __Pyx_XGIVEREF(__pyx_t_1);
     __Pyx_XGIVEREF(__pyx_t_2);
     __Pyx_XGIVEREF(__pyx_t_3);
     __Pyx_ExceptionReset(__pyx_t_1, __pyx_t_2, __pyx_t_3);
     goto __pyx_L1_error;
     __pyx_L8_try_end:;
   }
 
-  /* "../../miniconda3/envs/matx_310/lib/python3.10/site-packages/numpy/__init__.pxd":946
+  /* "../../../../../tmp/build-env-f9bdzduv/lib/python3.10/site-packages/numpy/__init__.pxd":946
  *         raise ImportError("numpy.core.multiarray failed to import")
- *
+ * 
  * cdef inline int import_umath() except -1:             # <<<<<<<<<<<<<<
  *     try:
  *         _import_umath()
  */
 
   /* function exit code */
   __pyx_r = 0;
@@ -6492,17 +7021,17 @@
   __Pyx_AddTraceback("numpy.import_umath", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = -1;
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "../../miniconda3/envs/matx_310/lib/python3.10/site-packages/numpy/__init__.pxd":952
+/* "../../../../../tmp/build-env-f9bdzduv/lib/python3.10/site-packages/numpy/__init__.pxd":952
  *         raise ImportError("numpy.core.umath failed to import")
- *
+ * 
  * cdef inline int import_ufunc() except -1:             # <<<<<<<<<<<<<<
  *     try:
  *         _import_umath()
  */
 
 static CYTHON_INLINE int __pyx_f_5numpy_import_ufunc(void) {
   int __pyx_r;
@@ -6516,102 +7045,102 @@
   PyObject *__pyx_t_7 = NULL;
   PyObject *__pyx_t_8 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("import_ufunc", 0);
 
-  /* "../../miniconda3/envs/matx_310/lib/python3.10/site-packages/numpy/__init__.pxd":953
- *
+  /* "../../../../../tmp/build-env-f9bdzduv/lib/python3.10/site-packages/numpy/__init__.pxd":953
+ * 
  * cdef inline int import_ufunc() except -1:
  *     try:             # <<<<<<<<<<<<<<
  *         _import_umath()
  *     except Exception:
  */
   {
     __Pyx_PyThreadState_declare
     __Pyx_PyThreadState_assign
     __Pyx_ExceptionSave(&__pyx_t_1, &__pyx_t_2, &__pyx_t_3);
     __Pyx_XGOTREF(__pyx_t_1);
     __Pyx_XGOTREF(__pyx_t_2);
     __Pyx_XGOTREF(__pyx_t_3);
     /*try:*/ {
 
-      /* "../../miniconda3/envs/matx_310/lib/python3.10/site-packages/numpy/__init__.pxd":954
+      /* "../../../../../tmp/build-env-f9bdzduv/lib/python3.10/site-packages/numpy/__init__.pxd":954
  * cdef inline int import_ufunc() except -1:
  *     try:
  *         _import_umath()             # <<<<<<<<<<<<<<
  *     except Exception:
  *         raise ImportError("numpy.core.umath failed to import")
  */
       __pyx_t_4 = _import_umath(); if (unlikely(__pyx_t_4 == ((int)-1))) __PYX_ERR(1, 954, __pyx_L3_error)
 
-      /* "../../miniconda3/envs/matx_310/lib/python3.10/site-packages/numpy/__init__.pxd":953
- *
+      /* "../../../../../tmp/build-env-f9bdzduv/lib/python3.10/site-packages/numpy/__init__.pxd":953
+ * 
  * cdef inline int import_ufunc() except -1:
  *     try:             # <<<<<<<<<<<<<<
  *         _import_umath()
  *     except Exception:
  */
     }
     __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
     __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
     __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
     goto __pyx_L8_try_end;
     __pyx_L3_error:;
 
-    /* "../../miniconda3/envs/matx_310/lib/python3.10/site-packages/numpy/__init__.pxd":955
+    /* "../../../../../tmp/build-env-f9bdzduv/lib/python3.10/site-packages/numpy/__init__.pxd":955
  *     try:
  *         _import_umath()
  *     except Exception:             # <<<<<<<<<<<<<<
  *         raise ImportError("numpy.core.umath failed to import")
- *
+ * 
  */
     __pyx_t_4 = __Pyx_PyErr_ExceptionMatches(((PyObject *)(&((PyTypeObject*)PyExc_Exception)[0])));
     if (__pyx_t_4) {
       __Pyx_AddTraceback("numpy.import_ufunc", __pyx_clineno, __pyx_lineno, __pyx_filename);
       if (__Pyx_GetException(&__pyx_t_5, &__pyx_t_6, &__pyx_t_7) < 0) __PYX_ERR(1, 955, __pyx_L5_except_error)
       __Pyx_GOTREF(__pyx_t_5);
       __Pyx_GOTREF(__pyx_t_6);
       __Pyx_GOTREF(__pyx_t_7);
 
-      /* "../../miniconda3/envs/matx_310/lib/python3.10/site-packages/numpy/__init__.pxd":956
+      /* "../../../../../tmp/build-env-f9bdzduv/lib/python3.10/site-packages/numpy/__init__.pxd":956
  *         _import_umath()
  *     except Exception:
  *         raise ImportError("numpy.core.umath failed to import")             # <<<<<<<<<<<<<<
- *
+ * 
  * cdef extern from *:
  */
       __pyx_t_8 = __Pyx_PyObject_Call(__pyx_builtin_ImportError, __pyx_tuple__2, NULL); if (unlikely(!__pyx_t_8)) __PYX_ERR(1, 956, __pyx_L5_except_error)
       __Pyx_GOTREF(__pyx_t_8);
       __Pyx_Raise(__pyx_t_8, 0, 0, 0);
       __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
       __PYX_ERR(1, 956, __pyx_L5_except_error)
     }
     goto __pyx_L5_except_error;
     __pyx_L5_except_error:;
 
-    /* "../../miniconda3/envs/matx_310/lib/python3.10/site-packages/numpy/__init__.pxd":953
- *
+    /* "../../../../../tmp/build-env-f9bdzduv/lib/python3.10/site-packages/numpy/__init__.pxd":953
+ * 
  * cdef inline int import_ufunc() except -1:
  *     try:             # <<<<<<<<<<<<<<
  *         _import_umath()
  *     except Exception:
  */
     __Pyx_XGIVEREF(__pyx_t_1);
     __Pyx_XGIVEREF(__pyx_t_2);
     __Pyx_XGIVEREF(__pyx_t_3);
     __Pyx_ExceptionReset(__pyx_t_1, __pyx_t_2, __pyx_t_3);
     goto __pyx_L1_error;
     __pyx_L8_try_end:;
   }
 
-  /* "../../miniconda3/envs/matx_310/lib/python3.10/site-packages/numpy/__init__.pxd":952
+  /* "../../../../../tmp/build-env-f9bdzduv/lib/python3.10/site-packages/numpy/__init__.pxd":952
  *         raise ImportError("numpy.core.umath failed to import")
- *
+ * 
  * cdef inline int import_ufunc() except -1:             # <<<<<<<<<<<<<<
  *     try:
  *         _import_umath()
  */
 
   /* function exit code */
   __pyx_r = 0;
@@ -6624,194 +7153,194 @@
   __Pyx_AddTraceback("numpy.import_ufunc", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = -1;
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "../../miniconda3/envs/matx_310/lib/python3.10/site-packages/numpy/__init__.pxd":966
- *
- *
+/* "../../../../../tmp/build-env-f9bdzduv/lib/python3.10/site-packages/numpy/__init__.pxd":966
+ * 
+ * 
  * cdef inline bint is_timedelta64_object(object obj):             # <<<<<<<<<<<<<<
  *     """
  *     Cython equivalent of `isinstance(obj, np.timedelta64)`
  */
 
 static CYTHON_INLINE int __pyx_f_5numpy_is_timedelta64_object(PyObject *__pyx_v_obj) {
   int __pyx_r;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("is_timedelta64_object", 0);
 
-  /* "../../miniconda3/envs/matx_310/lib/python3.10/site-packages/numpy/__init__.pxd":978
+  /* "../../../../../tmp/build-env-f9bdzduv/lib/python3.10/site-packages/numpy/__init__.pxd":978
  *     bool
  *     """
  *     return PyObject_TypeCheck(obj, &PyTimedeltaArrType_Type)             # <<<<<<<<<<<<<<
- *
- *
+ * 
+ * 
  */
   __pyx_r = PyObject_TypeCheck(__pyx_v_obj, (&PyTimedeltaArrType_Type));
   goto __pyx_L0;
 
-  /* "../../miniconda3/envs/matx_310/lib/python3.10/site-packages/numpy/__init__.pxd":966
- *
- *
+  /* "../../../../../tmp/build-env-f9bdzduv/lib/python3.10/site-packages/numpy/__init__.pxd":966
+ * 
+ * 
  * cdef inline bint is_timedelta64_object(object obj):             # <<<<<<<<<<<<<<
  *     """
  *     Cython equivalent of `isinstance(obj, np.timedelta64)`
  */
 
   /* function exit code */
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "../../miniconda3/envs/matx_310/lib/python3.10/site-packages/numpy/__init__.pxd":981
- *
- *
+/* "../../../../../tmp/build-env-f9bdzduv/lib/python3.10/site-packages/numpy/__init__.pxd":981
+ * 
+ * 
  * cdef inline bint is_datetime64_object(object obj):             # <<<<<<<<<<<<<<
  *     """
  *     Cython equivalent of `isinstance(obj, np.datetime64)`
  */
 
 static CYTHON_INLINE int __pyx_f_5numpy_is_datetime64_object(PyObject *__pyx_v_obj) {
   int __pyx_r;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("is_datetime64_object", 0);
 
-  /* "../../miniconda3/envs/matx_310/lib/python3.10/site-packages/numpy/__init__.pxd":993
+  /* "../../../../../tmp/build-env-f9bdzduv/lib/python3.10/site-packages/numpy/__init__.pxd":993
  *     bool
  *     """
  *     return PyObject_TypeCheck(obj, &PyDatetimeArrType_Type)             # <<<<<<<<<<<<<<
- *
- *
+ * 
+ * 
  */
   __pyx_r = PyObject_TypeCheck(__pyx_v_obj, (&PyDatetimeArrType_Type));
   goto __pyx_L0;
 
-  /* "../../miniconda3/envs/matx_310/lib/python3.10/site-packages/numpy/__init__.pxd":981
- *
- *
+  /* "../../../../../tmp/build-env-f9bdzduv/lib/python3.10/site-packages/numpy/__init__.pxd":981
+ * 
+ * 
  * cdef inline bint is_datetime64_object(object obj):             # <<<<<<<<<<<<<<
  *     """
  *     Cython equivalent of `isinstance(obj, np.datetime64)`
  */
 
   /* function exit code */
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "../../miniconda3/envs/matx_310/lib/python3.10/site-packages/numpy/__init__.pxd":996
- *
- *
+/* "../../../../../tmp/build-env-f9bdzduv/lib/python3.10/site-packages/numpy/__init__.pxd":996
+ * 
+ * 
  * cdef inline npy_datetime get_datetime64_value(object obj) nogil:             # <<<<<<<<<<<<<<
  *     """
  *     returns the int64 value underlying scalar numpy datetime64 object
  */
 
 static CYTHON_INLINE npy_datetime __pyx_f_5numpy_get_datetime64_value(PyObject *__pyx_v_obj) {
   npy_datetime __pyx_r;
 
-  /* "../../miniconda3/envs/matx_310/lib/python3.10/site-packages/numpy/__init__.pxd":1003
+  /* "../../../../../tmp/build-env-f9bdzduv/lib/python3.10/site-packages/numpy/__init__.pxd":1003
  *     also needed.  That can be found using `get_datetime64_unit`.
  *     """
  *     return (<PyDatetimeScalarObject*>obj).obval             # <<<<<<<<<<<<<<
- *
- *
+ * 
+ * 
  */
   __pyx_r = ((PyDatetimeScalarObject *)__pyx_v_obj)->obval;
   goto __pyx_L0;
 
-  /* "../../miniconda3/envs/matx_310/lib/python3.10/site-packages/numpy/__init__.pxd":996
- *
- *
+  /* "../../../../../tmp/build-env-f9bdzduv/lib/python3.10/site-packages/numpy/__init__.pxd":996
+ * 
+ * 
  * cdef inline npy_datetime get_datetime64_value(object obj) nogil:             # <<<<<<<<<<<<<<
  *     """
  *     returns the int64 value underlying scalar numpy datetime64 object
  */
 
   /* function exit code */
   __pyx_L0:;
   return __pyx_r;
 }
 
-/* "../../miniconda3/envs/matx_310/lib/python3.10/site-packages/numpy/__init__.pxd":1006
- *
- *
+/* "../../../../../tmp/build-env-f9bdzduv/lib/python3.10/site-packages/numpy/__init__.pxd":1006
+ * 
+ * 
  * cdef inline npy_timedelta get_timedelta64_value(object obj) nogil:             # <<<<<<<<<<<<<<
  *     """
  *     returns the int64 value underlying scalar numpy timedelta64 object
  */
 
 static CYTHON_INLINE npy_timedelta __pyx_f_5numpy_get_timedelta64_value(PyObject *__pyx_v_obj) {
   npy_timedelta __pyx_r;
 
-  /* "../../miniconda3/envs/matx_310/lib/python3.10/site-packages/numpy/__init__.pxd":1010
+  /* "../../../../../tmp/build-env-f9bdzduv/lib/python3.10/site-packages/numpy/__init__.pxd":1010
  *     returns the int64 value underlying scalar numpy timedelta64 object
  *     """
  *     return (<PyTimedeltaScalarObject*>obj).obval             # <<<<<<<<<<<<<<
- *
- *
+ * 
+ * 
  */
   __pyx_r = ((PyTimedeltaScalarObject *)__pyx_v_obj)->obval;
   goto __pyx_L0;
 
-  /* "../../miniconda3/envs/matx_310/lib/python3.10/site-packages/numpy/__init__.pxd":1006
- *
- *
+  /* "../../../../../tmp/build-env-f9bdzduv/lib/python3.10/site-packages/numpy/__init__.pxd":1006
+ * 
+ * 
  * cdef inline npy_timedelta get_timedelta64_value(object obj) nogil:             # <<<<<<<<<<<<<<
  *     """
  *     returns the int64 value underlying scalar numpy timedelta64 object
  */
 
   /* function exit code */
   __pyx_L0:;
   return __pyx_r;
 }
 
-/* "../../miniconda3/envs/matx_310/lib/python3.10/site-packages/numpy/__init__.pxd":1013
- *
- *
+/* "../../../../../tmp/build-env-f9bdzduv/lib/python3.10/site-packages/numpy/__init__.pxd":1013
+ * 
+ * 
  * cdef inline NPY_DATETIMEUNIT get_datetime64_unit(object obj) nogil:             # <<<<<<<<<<<<<<
  *     """
  *     returns the unit part of the dtype for a numpy datetime64 object.
  */
 
 static CYTHON_INLINE NPY_DATETIMEUNIT __pyx_f_5numpy_get_datetime64_unit(PyObject *__pyx_v_obj) {
   NPY_DATETIMEUNIT __pyx_r;
 
-  /* "../../miniconda3/envs/matx_310/lib/python3.10/site-packages/numpy/__init__.pxd":1017
+  /* "../../../../../tmp/build-env-f9bdzduv/lib/python3.10/site-packages/numpy/__init__.pxd":1017
  *     returns the unit part of the dtype for a numpy datetime64 object.
  *     """
  *     return <NPY_DATETIMEUNIT>(<PyDatetimeScalarObject*>obj).obmeta.base             # <<<<<<<<<<<<<<
  */
   __pyx_r = ((NPY_DATETIMEUNIT)((PyDatetimeScalarObject *)__pyx_v_obj)->obmeta.base);
   goto __pyx_L0;
 
-  /* "../../miniconda3/envs/matx_310/lib/python3.10/site-packages/numpy/__init__.pxd":1013
- *
- *
+  /* "../../../../../tmp/build-env-f9bdzduv/lib/python3.10/site-packages/numpy/__init__.pxd":1013
+ * 
+ * 
  * cdef inline NPY_DATETIMEUNIT get_datetime64_unit(object obj) nogil:             # <<<<<<<<<<<<<<
  *     """
  *     returns the unit part of the dtype for a numpy datetime64 object.
  */
 
   /* function exit code */
   __pyx_L0:;
   return __pyx_r;
 }
 
 /* "View.MemoryView":123
  *         cdef bint dtype_is_object
- *
+ * 
  *     def __cinit__(array self, tuple shape, Py_ssize_t itemsize, format not None,             # <<<<<<<<<<<<<<
  *                   mode="c", bint allocate_buffer=True):
- *
+ * 
  */
 
 /* Python wrapper */
 static int __pyx_array___cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
 static int __pyx_array___cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
   PyObject *__pyx_v_shape = 0;
   Py_ssize_t __pyx_v_itemsize;
@@ -6896,18 +7425,18 @@
     __pyx_v_format = values[2];
     __pyx_v_mode = values[3];
     if (values[4]) {
       __pyx_v_allocate_buffer = __Pyx_PyObject_IsTrue(values[4]); if (unlikely((__pyx_v_allocate_buffer == (int)-1) && PyErr_Occurred())) __PYX_ERR(2, 124, __pyx_L3_error)
     } else {
 
       /* "View.MemoryView":124
- *
+ * 
  *     def __cinit__(array self, tuple shape, Py_ssize_t itemsize, format not None,
  *                   mode="c", bint allocate_buffer=True):             # <<<<<<<<<<<<<<
- *
+ * 
  *         cdef int idx
  */
       __pyx_v_allocate_buffer = ((int)1);
     }
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
@@ -6921,18 +7450,18 @@
   if (unlikely(((PyObject *)__pyx_v_format) == Py_None)) {
     PyErr_Format(PyExc_TypeError, "Argument '%.200s' must not be None", "format"); __PYX_ERR(2, 123, __pyx_L1_error)
   }
   __pyx_r = __pyx_array___pyx_pf_15View_dot_MemoryView_5array___cinit__(((struct __pyx_array_obj *)__pyx_v_self), __pyx_v_shape, __pyx_v_itemsize, __pyx_v_format, __pyx_v_mode, __pyx_v_allocate_buffer);
 
   /* "View.MemoryView":123
  *         cdef bint dtype_is_object
- *
+ * 
  *     def __cinit__(array self, tuple shape, Py_ssize_t itemsize, format not None,             # <<<<<<<<<<<<<<
  *                   mode="c", bint allocate_buffer=True):
- *
+ * 
  */
 
   /* function exit code */
   goto __pyx_L0;
   __pyx_L1_error:;
   __pyx_r = -1;
   __pyx_L0:;
@@ -6963,112 +7492,112 @@
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__cinit__", 0);
   __Pyx_INCREF(__pyx_v_format);
 
   /* "View.MemoryView":130
  *         cdef PyObject **p
- *
+ * 
  *         self.ndim = <int> len(shape)             # <<<<<<<<<<<<<<
  *         self.itemsize = itemsize
- *
+ * 
  */
   if (unlikely(__pyx_v_shape == Py_None)) {
     PyErr_SetString(PyExc_TypeError, "object of type 'NoneType' has no len()");
     __PYX_ERR(2, 130, __pyx_L1_error)
   }
   __pyx_t_1 = PyTuple_GET_SIZE(__pyx_v_shape); if (unlikely(__pyx_t_1 == ((Py_ssize_t)-1))) __PYX_ERR(2, 130, __pyx_L1_error)
   __pyx_v_self->ndim = ((int)__pyx_t_1);
 
   /* "View.MemoryView":131
- *
+ * 
  *         self.ndim = <int> len(shape)
  *         self.itemsize = itemsize             # <<<<<<<<<<<<<<
- *
+ * 
  *         if not self.ndim:
  */
   __pyx_v_self->itemsize = __pyx_v_itemsize;
 
   /* "View.MemoryView":133
  *         self.itemsize = itemsize
- *
+ * 
  *         if not self.ndim:             # <<<<<<<<<<<<<<
  *             raise ValueError("Empty shape tuple for cython.array")
- *
+ * 
  */
   __pyx_t_2 = ((!(__pyx_v_self->ndim != 0)) != 0);
   if (unlikely(__pyx_t_2)) {
 
     /* "View.MemoryView":134
- *
+ * 
  *         if not self.ndim:
  *             raise ValueError("Empty shape tuple for cython.array")             # <<<<<<<<<<<<<<
- *
+ * 
  *         if itemsize <= 0:
  */
     __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__3, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 134, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_Raise(__pyx_t_3, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     __PYX_ERR(2, 134, __pyx_L1_error)
 
     /* "View.MemoryView":133
  *         self.itemsize = itemsize
- *
+ * 
  *         if not self.ndim:             # <<<<<<<<<<<<<<
  *             raise ValueError("Empty shape tuple for cython.array")
- *
+ * 
  */
   }
 
   /* "View.MemoryView":136
  *             raise ValueError("Empty shape tuple for cython.array")
- *
+ * 
  *         if itemsize <= 0:             # <<<<<<<<<<<<<<
  *             raise ValueError("itemsize <= 0 for cython.array")
- *
+ * 
  */
   __pyx_t_2 = ((__pyx_v_itemsize <= 0) != 0);
   if (unlikely(__pyx_t_2)) {
 
     /* "View.MemoryView":137
- *
+ * 
  *         if itemsize <= 0:
  *             raise ValueError("itemsize <= 0 for cython.array")             # <<<<<<<<<<<<<<
- *
+ * 
  *         if not isinstance(format, bytes):
  */
     __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__4, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 137, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_Raise(__pyx_t_3, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     __PYX_ERR(2, 137, __pyx_L1_error)
 
     /* "View.MemoryView":136
  *             raise ValueError("Empty shape tuple for cython.array")
- *
+ * 
  *         if itemsize <= 0:             # <<<<<<<<<<<<<<
  *             raise ValueError("itemsize <= 0 for cython.array")
- *
+ * 
  */
   }
 
   /* "View.MemoryView":139
  *             raise ValueError("itemsize <= 0 for cython.array")
- *
+ * 
  *         if not isinstance(format, bytes):             # <<<<<<<<<<<<<<
  *             format = format.encode('ASCII')
  *         self._format = format  # keep a reference to the byte string
  */
-  __pyx_t_2 = PyBytes_Check(__pyx_v_format);
+  __pyx_t_2 = PyBytes_Check(__pyx_v_format); 
   __pyx_t_4 = ((!(__pyx_t_2 != 0)) != 0);
   if (__pyx_t_4) {
 
     /* "View.MemoryView":140
- *
+ * 
  *         if not isinstance(format, bytes):
  *             format = format.encode('ASCII')             # <<<<<<<<<<<<<<
  *         self._format = format  # keep a reference to the byte string
  *         self.format = self._format
  */
     __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_format, __pyx_n_s_encode); if (unlikely(!__pyx_t_5)) __PYX_ERR(2, 140, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
@@ -7088,104 +7617,104 @@
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
     __Pyx_DECREF_SET(__pyx_v_format, __pyx_t_3);
     __pyx_t_3 = 0;
 
     /* "View.MemoryView":139
  *             raise ValueError("itemsize <= 0 for cython.array")
- *
+ * 
  *         if not isinstance(format, bytes):             # <<<<<<<<<<<<<<
  *             format = format.encode('ASCII')
  *         self._format = format  # keep a reference to the byte string
  */
   }
 
   /* "View.MemoryView":141
  *         if not isinstance(format, bytes):
  *             format = format.encode('ASCII')
  *         self._format = format  # keep a reference to the byte string             # <<<<<<<<<<<<<<
  *         self.format = self._format
- *
+ * 
  */
   if (!(likely(PyBytes_CheckExact(__pyx_v_format))||((__pyx_v_format) == Py_None)||((void)PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "bytes", Py_TYPE(__pyx_v_format)->tp_name), 0))) __PYX_ERR(2, 141, __pyx_L1_error)
   __pyx_t_3 = __pyx_v_format;
   __Pyx_INCREF(__pyx_t_3);
   __Pyx_GIVEREF(__pyx_t_3);
   __Pyx_GOTREF(__pyx_v_self->_format);
   __Pyx_DECREF(__pyx_v_self->_format);
   __pyx_v_self->_format = ((PyObject*)__pyx_t_3);
   __pyx_t_3 = 0;
 
   /* "View.MemoryView":142
  *             format = format.encode('ASCII')
  *         self._format = format  # keep a reference to the byte string
  *         self.format = self._format             # <<<<<<<<<<<<<<
- *
- *
+ * 
+ * 
  */
   if (unlikely(__pyx_v_self->_format == Py_None)) {
     PyErr_SetString(PyExc_TypeError, "expected bytes, NoneType found");
     __PYX_ERR(2, 142, __pyx_L1_error)
   }
   __pyx_t_7 = __Pyx_PyBytes_AsWritableString(__pyx_v_self->_format); if (unlikely((!__pyx_t_7) && PyErr_Occurred())) __PYX_ERR(2, 142, __pyx_L1_error)
   __pyx_v_self->format = __pyx_t_7;
 
   /* "View.MemoryView":145
- *
- *
+ * 
+ * 
  *         self._shape = <Py_ssize_t *> PyObject_Malloc(sizeof(Py_ssize_t)*self.ndim*2)             # <<<<<<<<<<<<<<
  *         self._strides = self._shape + self.ndim
- *
+ * 
  */
   __pyx_v_self->_shape = ((Py_ssize_t *)PyObject_Malloc((((sizeof(Py_ssize_t)) * __pyx_v_self->ndim) * 2)));
 
   /* "View.MemoryView":146
- *
+ * 
  *         self._shape = <Py_ssize_t *> PyObject_Malloc(sizeof(Py_ssize_t)*self.ndim*2)
  *         self._strides = self._shape + self.ndim             # <<<<<<<<<<<<<<
- *
+ * 
  *         if not self._shape:
  */
   __pyx_v_self->_strides = (__pyx_v_self->_shape + __pyx_v_self->ndim);
 
   /* "View.MemoryView":148
  *         self._strides = self._shape + self.ndim
- *
+ * 
  *         if not self._shape:             # <<<<<<<<<<<<<<
  *             raise MemoryError("unable to allocate shape and strides.")
- *
+ * 
  */
   __pyx_t_4 = ((!(__pyx_v_self->_shape != 0)) != 0);
   if (unlikely(__pyx_t_4)) {
 
     /* "View.MemoryView":149
- *
+ * 
  *         if not self._shape:
  *             raise MemoryError("unable to allocate shape and strides.")             # <<<<<<<<<<<<<<
- *
- *
+ * 
+ * 
  */
     __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_MemoryError, __pyx_tuple__5, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 149, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_Raise(__pyx_t_3, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     __PYX_ERR(2, 149, __pyx_L1_error)
 
     /* "View.MemoryView":148
  *         self._strides = self._shape + self.ndim
- *
+ * 
  *         if not self._shape:             # <<<<<<<<<<<<<<
  *             raise MemoryError("unable to allocate shape and strides.")
- *
+ * 
  */
   }
 
   /* "View.MemoryView":152
- *
- *
+ * 
+ * 
  *         for idx, dim in enumerate(shape):             # <<<<<<<<<<<<<<
  *             if dim <= 0:
  *                 raise ValueError("Invalid shape in axis %d: %d." % (idx, dim))
  */
   __pyx_t_8 = 0;
   __pyx_t_3 = __pyx_v_shape; __Pyx_INCREF(__pyx_t_3); __pyx_t_1 = 0;
   for (;;) {
@@ -7199,29 +7728,29 @@
     __pyx_t_9 = __Pyx_PyIndex_AsSsize_t(__pyx_t_5); if (unlikely((__pyx_t_9 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(2, 152, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
     __pyx_v_dim = __pyx_t_9;
     __pyx_v_idx = __pyx_t_8;
     __pyx_t_8 = (__pyx_t_8 + 1);
 
     /* "View.MemoryView":153
- *
+ * 
  *         for idx, dim in enumerate(shape):
  *             if dim <= 0:             # <<<<<<<<<<<<<<
  *                 raise ValueError("Invalid shape in axis %d: %d." % (idx, dim))
  *             self._shape[idx] = dim
  */
     __pyx_t_4 = ((__pyx_v_dim <= 0) != 0);
     if (unlikely(__pyx_t_4)) {
 
       /* "View.MemoryView":154
  *         for idx, dim in enumerate(shape):
  *             if dim <= 0:
  *                 raise ValueError("Invalid shape in axis %d: %d." % (idx, dim))             # <<<<<<<<<<<<<<
  *             self._shape[idx] = dim
- *
+ * 
  */
       __pyx_t_5 = __Pyx_PyInt_From_int(__pyx_v_idx); if (unlikely(!__pyx_t_5)) __PYX_ERR(2, 154, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_5);
       __pyx_t_6 = PyInt_FromSsize_t(__pyx_v_dim); if (unlikely(!__pyx_t_6)) __PYX_ERR(2, 154, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_6);
       __pyx_t_10 = PyTuple_New(2); if (unlikely(!__pyx_t_10)) __PYX_ERR(2, 154, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_10);
@@ -7238,43 +7767,43 @@
       __Pyx_GOTREF(__pyx_t_10);
       __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
       __Pyx_Raise(__pyx_t_10, 0, 0, 0);
       __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
       __PYX_ERR(2, 154, __pyx_L1_error)
 
       /* "View.MemoryView":153
- *
+ * 
  *         for idx, dim in enumerate(shape):
  *             if dim <= 0:             # <<<<<<<<<<<<<<
  *                 raise ValueError("Invalid shape in axis %d: %d." % (idx, dim))
  *             self._shape[idx] = dim
  */
     }
 
     /* "View.MemoryView":155
  *             if dim <= 0:
  *                 raise ValueError("Invalid shape in axis %d: %d." % (idx, dim))
  *             self._shape[idx] = dim             # <<<<<<<<<<<<<<
- *
+ * 
  *         cdef char order
  */
     (__pyx_v_self->_shape[__pyx_v_idx]) = __pyx_v_dim;
 
     /* "View.MemoryView":152
- *
- *
+ * 
+ * 
  *         for idx, dim in enumerate(shape):             # <<<<<<<<<<<<<<
  *             if dim <= 0:
  *                 raise ValueError("Invalid shape in axis %d: %d." % (idx, dim))
  */
   }
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
   /* "View.MemoryView":158
- *
+ * 
  *         cdef char order
  *         if mode == 'fortran':             # <<<<<<<<<<<<<<
  *             order = b'F'
  *             self.mode = u'fortran'
  */
   __pyx_t_4 = (__Pyx_PyString_Equals(__pyx_v_mode, __pyx_n_s_fortran, Py_EQ)); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(2, 158, __pyx_L1_error)
   if (__pyx_t_4) {
@@ -7298,15 +7827,15 @@
     __Pyx_INCREF(__pyx_n_u_fortran);
     __Pyx_GIVEREF(__pyx_n_u_fortran);
     __Pyx_GOTREF(__pyx_v_self->mode);
     __Pyx_DECREF(__pyx_v_self->mode);
     __pyx_v_self->mode = __pyx_n_u_fortran;
 
     /* "View.MemoryView":158
- *
+ * 
  *         cdef char order
  *         if mode == 'fortran':             # <<<<<<<<<<<<<<
  *             order = b'F'
  *             self.mode = u'fortran'
  */
     goto __pyx_L10;
   }
@@ -7353,15 +7882,15 @@
     goto __pyx_L10;
   }
 
   /* "View.MemoryView":165
  *             self.mode = u'c'
  *         else:
  *             raise ValueError("Invalid mode, expected 'c' or 'fortran', got %s" % mode)             # <<<<<<<<<<<<<<
- *
+ * 
  *         self.len = fill_contig_strides_array(self._shape, self._strides,
  */
   /*else*/ {
     __pyx_t_3 = __Pyx_PyString_FormatSafe(__pyx_kp_s_Invalid_mode_expected_c_or_fortr, __pyx_v_mode); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 165, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __pyx_t_10 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_3); if (unlikely(!__pyx_t_10)) __PYX_ERR(2, 165, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_10);
@@ -7370,105 +7899,105 @@
     __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
     __PYX_ERR(2, 165, __pyx_L1_error)
   }
   __pyx_L10:;
 
   /* "View.MemoryView":167
  *             raise ValueError("Invalid mode, expected 'c' or 'fortran', got %s" % mode)
- *
+ * 
  *         self.len = fill_contig_strides_array(self._shape, self._strides,             # <<<<<<<<<<<<<<
  *                                              itemsize, self.ndim, order)
- *
+ * 
  */
   __pyx_v_self->len = __pyx_fill_contig_strides_array(__pyx_v_self->_shape, __pyx_v_self->_strides, __pyx_v_itemsize, __pyx_v_self->ndim, __pyx_v_order);
 
   /* "View.MemoryView":170
  *                                              itemsize, self.ndim, order)
- *
+ * 
  *         self.free_data = allocate_buffer             # <<<<<<<<<<<<<<
  *         self.dtype_is_object = format == b'O'
  *         if allocate_buffer:
  */
   __pyx_v_self->free_data = __pyx_v_allocate_buffer;
 
   /* "View.MemoryView":171
- *
+ * 
  *         self.free_data = allocate_buffer
  *         self.dtype_is_object = format == b'O'             # <<<<<<<<<<<<<<
  *         if allocate_buffer:
- *
+ * 
  */
   __pyx_t_10 = PyObject_RichCompare(__pyx_v_format, __pyx_n_b_O, Py_EQ); __Pyx_XGOTREF(__pyx_t_10); if (unlikely(!__pyx_t_10)) __PYX_ERR(2, 171, __pyx_L1_error)
   __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_10); if (unlikely((__pyx_t_4 == (int)-1) && PyErr_Occurred())) __PYX_ERR(2, 171, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
   __pyx_v_self->dtype_is_object = __pyx_t_4;
 
   /* "View.MemoryView":172
  *         self.free_data = allocate_buffer
  *         self.dtype_is_object = format == b'O'
  *         if allocate_buffer:             # <<<<<<<<<<<<<<
- *
- *
+ * 
+ * 
  */
   __pyx_t_4 = (__pyx_v_allocate_buffer != 0);
   if (__pyx_t_4) {
 
     /* "View.MemoryView":175
- *
- *
+ * 
+ * 
  *             self.data = <char *>malloc(self.len)             # <<<<<<<<<<<<<<
  *             if not self.data:
  *                 raise MemoryError("unable to allocate array data.")
  */
     __pyx_v_self->data = ((char *)malloc(__pyx_v_self->len));
 
     /* "View.MemoryView":176
- *
+ * 
  *             self.data = <char *>malloc(self.len)
  *             if not self.data:             # <<<<<<<<<<<<<<
  *                 raise MemoryError("unable to allocate array data.")
- *
+ * 
  */
     __pyx_t_4 = ((!(__pyx_v_self->data != 0)) != 0);
     if (unlikely(__pyx_t_4)) {
 
       /* "View.MemoryView":177
  *             self.data = <char *>malloc(self.len)
  *             if not self.data:
  *                 raise MemoryError("unable to allocate array data.")             # <<<<<<<<<<<<<<
- *
+ * 
  *             if self.dtype_is_object:
  */
       __pyx_t_10 = __Pyx_PyObject_Call(__pyx_builtin_MemoryError, __pyx_tuple__6, NULL); if (unlikely(!__pyx_t_10)) __PYX_ERR(2, 177, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_10);
       __Pyx_Raise(__pyx_t_10, 0, 0, 0);
       __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
       __PYX_ERR(2, 177, __pyx_L1_error)
 
       /* "View.MemoryView":176
- *
+ * 
  *             self.data = <char *>malloc(self.len)
  *             if not self.data:             # <<<<<<<<<<<<<<
  *                 raise MemoryError("unable to allocate array data.")
- *
+ * 
  */
     }
 
     /* "View.MemoryView":179
  *                 raise MemoryError("unable to allocate array data.")
- *
+ * 
  *             if self.dtype_is_object:             # <<<<<<<<<<<<<<
  *                 p = <PyObject **> self.data
  *                 for i in range(self.len / itemsize):
  */
     __pyx_t_4 = (__pyx_v_self->dtype_is_object != 0);
     if (__pyx_t_4) {
 
       /* "View.MemoryView":180
- *
+ * 
  *             if self.dtype_is_object:
  *                 p = <PyObject **> self.data             # <<<<<<<<<<<<<<
  *                 for i in range(self.len / itemsize):
  *                     p[i] = Py_None
  */
       __pyx_v_p = ((PyObject **)__pyx_v_self->data);
 
@@ -7493,52 +8022,52 @@
         __pyx_v_i = __pyx_t_11;
 
         /* "View.MemoryView":182
  *                 p = <PyObject **> self.data
  *                 for i in range(self.len / itemsize):
  *                     p[i] = Py_None             # <<<<<<<<<<<<<<
  *                     Py_INCREF(Py_None)
- *
+ * 
  */
         (__pyx_v_p[__pyx_v_i]) = Py_None;
 
         /* "View.MemoryView":183
  *                 for i in range(self.len / itemsize):
  *                     p[i] = Py_None
  *                     Py_INCREF(Py_None)             # <<<<<<<<<<<<<<
- *
+ * 
  *     @cname('getbuffer')
  */
         Py_INCREF(Py_None);
       }
 
       /* "View.MemoryView":179
  *                 raise MemoryError("unable to allocate array data.")
- *
+ * 
  *             if self.dtype_is_object:             # <<<<<<<<<<<<<<
  *                 p = <PyObject **> self.data
  *                 for i in range(self.len / itemsize):
  */
     }
 
     /* "View.MemoryView":172
  *         self.free_data = allocate_buffer
  *         self.dtype_is_object = format == b'O'
  *         if allocate_buffer:             # <<<<<<<<<<<<<<
- *
- *
+ * 
+ * 
  */
   }
 
   /* "View.MemoryView":123
  *         cdef bint dtype_is_object
- *
+ * 
  *     def __cinit__(array self, tuple shape, Py_ssize_t itemsize, format not None,             # <<<<<<<<<<<<<<
  *                   mode="c", bint allocate_buffer=True):
- *
+ * 
  */
 
   /* function exit code */
   __pyx_r = 0;
   goto __pyx_L0;
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_3);
@@ -7550,15 +8079,15 @@
   __pyx_L0:;
   __Pyx_XDECREF(__pyx_v_format);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "View.MemoryView":186
- *
+ * 
  *     @cname('getbuffer')
  *     def __getbuffer__(self, Py_buffer *info, int flags):             # <<<<<<<<<<<<<<
  *         cdef int bufmode = -1
  *         if self.mode == u"c":
  */
 
 /* Python wrapper */
@@ -7757,85 +8286,85 @@
   __pyx_v_info->suboffsets = NULL;
 
   /* "View.MemoryView":200
  *         info.strides = self._strides
  *         info.suboffsets = NULL
  *         info.itemsize = self.itemsize             # <<<<<<<<<<<<<<
  *         info.readonly = 0
- *
+ * 
  */
   __pyx_t_5 = __pyx_v_self->itemsize;
   __pyx_v_info->itemsize = __pyx_t_5;
 
   /* "View.MemoryView":201
  *         info.suboffsets = NULL
  *         info.itemsize = self.itemsize
  *         info.readonly = 0             # <<<<<<<<<<<<<<
- *
+ * 
  *         if flags & PyBUF_FORMAT:
  */
   __pyx_v_info->readonly = 0;
 
   /* "View.MemoryView":203
  *         info.readonly = 0
- *
+ * 
  *         if flags & PyBUF_FORMAT:             # <<<<<<<<<<<<<<
  *             info.format = self.format
  *         else:
  */
   __pyx_t_1 = ((__pyx_v_flags & PyBUF_FORMAT) != 0);
   if (__pyx_t_1) {
 
     /* "View.MemoryView":204
- *
+ * 
  *         if flags & PyBUF_FORMAT:
  *             info.format = self.format             # <<<<<<<<<<<<<<
  *         else:
  *             info.format = NULL
  */
     __pyx_t_4 = __pyx_v_self->format;
     __pyx_v_info->format = __pyx_t_4;
 
     /* "View.MemoryView":203
  *         info.readonly = 0
- *
+ * 
  *         if flags & PyBUF_FORMAT:             # <<<<<<<<<<<<<<
  *             info.format = self.format
  *         else:
  */
     goto __pyx_L5;
   }
 
   /* "View.MemoryView":206
  *             info.format = self.format
  *         else:
  *             info.format = NULL             # <<<<<<<<<<<<<<
- *
+ * 
  *         info.obj = self
  */
   /*else*/ {
     __pyx_v_info->format = NULL;
   }
   __pyx_L5:;
 
   /* "View.MemoryView":208
  *             info.format = NULL
- *
+ * 
  *         info.obj = self             # <<<<<<<<<<<<<<
- *
+ * 
  *     __pyx_getbuffer = capsule(<void *> &__pyx_array_getbuffer, "getbuffer(obj, view, flags)")
  */
   __Pyx_INCREF(((PyObject *)__pyx_v_self));
   __Pyx_GIVEREF(((PyObject *)__pyx_v_self));
   __Pyx_GOTREF(__pyx_v_info->obj);
   __Pyx_DECREF(__pyx_v_info->obj);
   __pyx_v_info->obj = ((PyObject *)__pyx_v_self);
 
   /* "View.MemoryView":186
- *
+ * 
  *     @cname('getbuffer')
  *     def __getbuffer__(self, Py_buffer *info, int flags):             # <<<<<<<<<<<<<<
  *         cdef int bufmode = -1
  *         if self.mode == u"c":
  */
 
   /* function exit code */
@@ -7858,15 +8387,15 @@
   __pyx_L2:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "View.MemoryView":212
  *     __pyx_getbuffer = capsule(<void *> &__pyx_array_getbuffer, "getbuffer(obj, view, flags)")
- *
+ * 
  *     def __dealloc__(array self):             # <<<<<<<<<<<<<<
  *         if self.callback_free_data != NULL:
  *             self.callback_free_data(self.data)
  */
 
 /* Python wrapper */
 static void __pyx_array___dealloc__(PyObject *__pyx_v_self); /*proto*/
@@ -7881,15 +8410,15 @@
 
 static void __pyx_array___pyx_pf_15View_dot_MemoryView_5array_4__dealloc__(struct __pyx_array_obj *__pyx_v_self) {
   __Pyx_RefNannyDeclarations
   int __pyx_t_1;
   __Pyx_RefNannySetupContext("__dealloc__", 0);
 
   /* "View.MemoryView":213
- *
+ * 
  *     def __dealloc__(array self):
  *         if self.callback_free_data != NULL:             # <<<<<<<<<<<<<<
  *             self.callback_free_data(self.data)
  *         elif self.free_data:
  */
   __pyx_t_1 = ((__pyx_v_self->callback_free_data != NULL) != 0);
   if (__pyx_t_1) {
@@ -7900,15 +8429,15 @@
  *             self.callback_free_data(self.data)             # <<<<<<<<<<<<<<
  *         elif self.free_data:
  *             if self.dtype_is_object:
  */
     __pyx_v_self->callback_free_data(__pyx_v_self->data);
 
     /* "View.MemoryView":213
- *
+ * 
  *     def __dealloc__(array self):
  *         if self.callback_free_data != NULL:             # <<<<<<<<<<<<<<
  *             self.callback_free_data(self.data)
  *         elif self.free_data:
  */
     goto __pyx_L3;
   }
@@ -7952,15 +8481,15 @@
     }
 
     /* "View.MemoryView":219
  *                 refcount_objects_in_slice(self.data, self._shape,
  *                                           self._strides, self.ndim, False)
  *             free(self.data)             # <<<<<<<<<<<<<<
  *         PyObject_Free(self._shape)
- *
+ * 
  */
     free(__pyx_v_self->data);
 
     /* "View.MemoryView":215
  *         if self.callback_free_data != NULL:
  *             self.callback_free_data(self.data)
  *         elif self.free_data:             # <<<<<<<<<<<<<<
@@ -7970,37 +8499,37 @@
   }
   __pyx_L3:;
 
   /* "View.MemoryView":220
  *                                           self._strides, self.ndim, False)
  *             free(self.data)
  *         PyObject_Free(self._shape)             # <<<<<<<<<<<<<<
- *
+ * 
  *     @property
  */
   PyObject_Free(__pyx_v_self->_shape);
 
   /* "View.MemoryView":212
  *     __pyx_getbuffer = capsule(<void *> &__pyx_array_getbuffer, "getbuffer(obj, view, flags)")
- *
+ * 
  *     def __dealloc__(array self):             # <<<<<<<<<<<<<<
  *         if self.callback_free_data != NULL:
  *             self.callback_free_data(self.data)
  */
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
 }
 
 /* "View.MemoryView":223
- *
+ * 
  *     @property
  *     def memview(self):             # <<<<<<<<<<<<<<
  *         return self.get_memview()
- *
+ * 
  */
 
 /* Python wrapper */
 static PyObject *__pyx_pw_15View_dot_MemoryView_5array_7memview_1__get__(PyObject *__pyx_v_self); /*proto*/
 static PyObject *__pyx_pw_15View_dot_MemoryView_5array_7memview_1__get__(PyObject *__pyx_v_self) {
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
@@ -8021,45 +8550,45 @@
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__get__", 0);
 
   /* "View.MemoryView":224
  *     @property
  *     def memview(self):
  *         return self.get_memview()             # <<<<<<<<<<<<<<
- *
+ * 
  *     @cname('get_memview')
  */
   __Pyx_XDECREF(__pyx_r);
   __pyx_t_1 = ((struct __pyx_vtabstruct_array *)__pyx_v_self->__pyx_vtab)->get_memview(__pyx_v_self); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 224, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
   /* "View.MemoryView":223
- *
+ * 
  *     @property
  *     def memview(self):             # <<<<<<<<<<<<<<
  *         return self.get_memview()
- *
+ * 
  */
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_AddTraceback("View.MemoryView.array.memview.__get__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "View.MemoryView":227
- *
+ * 
  *     @cname('get_memview')
  *     cdef get_memview(self):             # <<<<<<<<<<<<<<
  *         flags =  PyBUF_ANY_CONTIGUOUS|PyBUF_FORMAT|PyBUF_WRITABLE
  *         return  memoryview(self, flags, self.dtype_is_object)
  */
 
 static PyObject *__pyx_array_get_memview(struct __pyx_array_obj *__pyx_v_self) {
@@ -8075,23 +8604,23 @@
   __Pyx_RefNannySetupContext("get_memview", 0);
 
   /* "View.MemoryView":228
  *     @cname('get_memview')
  *     cdef get_memview(self):
  *         flags =  PyBUF_ANY_CONTIGUOUS|PyBUF_FORMAT|PyBUF_WRITABLE             # <<<<<<<<<<<<<<
  *         return  memoryview(self, flags, self.dtype_is_object)
- *
+ * 
  */
   __pyx_v_flags = ((PyBUF_ANY_CONTIGUOUS | PyBUF_FORMAT) | PyBUF_WRITABLE);
 
   /* "View.MemoryView":229
  *     cdef get_memview(self):
  *         flags =  PyBUF_ANY_CONTIGUOUS|PyBUF_FORMAT|PyBUF_WRITABLE
  *         return  memoryview(self, flags, self.dtype_is_object)             # <<<<<<<<<<<<<<
- *
+ * 
  *     def __len__(self):
  */
   __Pyx_XDECREF(__pyx_r);
   __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_flags); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 229, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_t_2 = __Pyx_PyBool_FromLong(__pyx_v_self->dtype_is_object); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 229, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
@@ -8110,15 +8639,15 @@
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __pyx_r = __pyx_t_2;
   __pyx_t_2 = 0;
   goto __pyx_L0;
 
   /* "View.MemoryView":227
- *
+ * 
  *     @cname('get_memview')
  *     cdef get_memview(self):             # <<<<<<<<<<<<<<
  *         flags =  PyBUF_ANY_CONTIGUOUS|PyBUF_FORMAT|PyBUF_WRITABLE
  *         return  memoryview(self, flags, self.dtype_is_object)
  */
 
   /* function exit code */
@@ -8132,18 +8661,18 @@
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "View.MemoryView":231
  *         return  memoryview(self, flags, self.dtype_is_object)
- *
+ * 
  *     def __len__(self):             # <<<<<<<<<<<<<<
  *         return self._shape[0]
- *
+ * 
  */
 
 /* Python wrapper */
 static Py_ssize_t __pyx_array___len__(PyObject *__pyx_v_self); /*proto*/
 static Py_ssize_t __pyx_array___len__(PyObject *__pyx_v_self) {
   Py_ssize_t __pyx_r;
   __Pyx_RefNannyDeclarations
@@ -8157,43 +8686,43 @@
 
 static Py_ssize_t __pyx_array___pyx_pf_15View_dot_MemoryView_5array_6__len__(struct __pyx_array_obj *__pyx_v_self) {
   Py_ssize_t __pyx_r;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__len__", 0);
 
   /* "View.MemoryView":232
- *
+ * 
  *     def __len__(self):
  *         return self._shape[0]             # <<<<<<<<<<<<<<
- *
+ * 
  *     def __getattr__(self, attr):
  */
   __pyx_r = (__pyx_v_self->_shape[0]);
   goto __pyx_L0;
 
   /* "View.MemoryView":231
  *         return  memoryview(self, flags, self.dtype_is_object)
- *
+ * 
  *     def __len__(self):             # <<<<<<<<<<<<<<
  *         return self._shape[0]
- *
+ * 
  */
 
   /* function exit code */
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "View.MemoryView":234
  *         return self._shape[0]
- *
+ * 
  *     def __getattr__(self, attr):             # <<<<<<<<<<<<<<
  *         return getattr(self.memview, attr)
- *
+ * 
  */
 
 /* Python wrapper */
 static PyObject *__pyx_array___getattr__(PyObject *__pyx_v_self, PyObject *__pyx_v_attr); /*proto*/
 static PyObject *__pyx_array___getattr__(PyObject *__pyx_v_self, PyObject *__pyx_v_attr) {
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
@@ -8212,36 +8741,36 @@
   PyObject *__pyx_t_2 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__getattr__", 0);
 
   /* "View.MemoryView":235
- *
+ * 
  *     def __getattr__(self, attr):
  *         return getattr(self.memview, attr)             # <<<<<<<<<<<<<<
- *
+ * 
  *     def __getitem__(self, item):
  */
   __Pyx_XDECREF(__pyx_r);
   __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_memview); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 235, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_t_2 = __Pyx_GetAttr(__pyx_t_1, __pyx_v_attr); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 235, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __pyx_r = __pyx_t_2;
   __pyx_t_2 = 0;
   goto __pyx_L0;
 
   /* "View.MemoryView":234
  *         return self._shape[0]
- *
+ * 
  *     def __getattr__(self, attr):             # <<<<<<<<<<<<<<
  *         return getattr(self.memview, attr)
- *
+ * 
  */
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_XDECREF(__pyx_t_2);
   __Pyx_AddTraceback("View.MemoryView.array.__getattr__", __pyx_clineno, __pyx_lineno, __pyx_filename);
@@ -8250,18 +8779,18 @@
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "View.MemoryView":237
  *         return getattr(self.memview, attr)
- *
+ * 
  *     def __getitem__(self, item):             # <<<<<<<<<<<<<<
  *         return self.memview[item]
- *
+ * 
  */
 
 /* Python wrapper */
 static PyObject *__pyx_array___getitem__(PyObject *__pyx_v_self, PyObject *__pyx_v_item); /*proto*/
 static PyObject *__pyx_array___getitem__(PyObject *__pyx_v_self, PyObject *__pyx_v_item) {
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
@@ -8280,36 +8809,36 @@
   PyObject *__pyx_t_2 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__getitem__", 0);
 
   /* "View.MemoryView":238
- *
+ * 
  *     def __getitem__(self, item):
  *         return self.memview[item]             # <<<<<<<<<<<<<<
- *
+ * 
  *     def __setitem__(self, item, value):
  */
   __Pyx_XDECREF(__pyx_r);
   __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_memview); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 238, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_t_2 = __Pyx_PyObject_GetItem(__pyx_t_1, __pyx_v_item); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 238, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __pyx_r = __pyx_t_2;
   __pyx_t_2 = 0;
   goto __pyx_L0;
 
   /* "View.MemoryView":237
  *         return getattr(self.memview, attr)
- *
+ * 
  *     def __getitem__(self, item):             # <<<<<<<<<<<<<<
  *         return self.memview[item]
- *
+ * 
  */
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_XDECREF(__pyx_t_2);
   __Pyx_AddTraceback("View.MemoryView.array.__getitem__", __pyx_clineno, __pyx_lineno, __pyx_filename);
@@ -8318,18 +8847,18 @@
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "View.MemoryView":240
  *         return self.memview[item]
- *
+ * 
  *     def __setitem__(self, item, value):             # <<<<<<<<<<<<<<
  *         self.memview[item] = value
- *
+ * 
  */
 
 /* Python wrapper */
 static int __pyx_array___setitem__(PyObject *__pyx_v_self, PyObject *__pyx_v_item, PyObject *__pyx_v_value); /*proto*/
 static int __pyx_array___setitem__(PyObject *__pyx_v_self, PyObject *__pyx_v_item, PyObject *__pyx_v_value) {
   int __pyx_r;
   __Pyx_RefNannyDeclarations
@@ -8347,31 +8876,31 @@
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__setitem__", 0);
 
   /* "View.MemoryView":241
- *
+ * 
  *     def __setitem__(self, item, value):
  *         self.memview[item] = value             # <<<<<<<<<<<<<<
- *
- *
+ * 
+ * 
  */
   __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_memview); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 241, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   if (unlikely(PyObject_SetItem(__pyx_t_1, __pyx_v_item, __pyx_v_value) < 0)) __PYX_ERR(2, 241, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
   /* "View.MemoryView":240
  *         return self.memview[item]
- *
+ * 
  *     def __setitem__(self, item, value):             # <<<<<<<<<<<<<<
  *         self.memview[item] = value
- *
+ * 
  */
 
   /* function exit code */
   __pyx_r = 0;
   goto __pyx_L0;
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
@@ -8492,15 +9021,15 @@
   __pyx_r = NULL;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "View.MemoryView":245
- *
+ * 
  * @cname("__pyx_array_new")
  * cdef array array_cwrapper(tuple shape, Py_ssize_t itemsize, char *format,             # <<<<<<<<<<<<<<
  *                           char *mode, char *buf):
  *     cdef array result
  */
 
 static struct __pyx_array_obj *__pyx_array_new(PyObject *__pyx_v_shape, Py_ssize_t __pyx_v_itemsize, char *__pyx_v_format, char *__pyx_v_mode, char *__pyx_v_buf) {
@@ -8515,24 +9044,24 @@
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("array_cwrapper", 0);
 
   /* "View.MemoryView":249
  *     cdef array result
- *
+ * 
  *     if buf == NULL:             # <<<<<<<<<<<<<<
  *         result = array(shape, itemsize, format, mode.decode('ASCII'))
  *     else:
  */
   __pyx_t_1 = ((__pyx_v_buf == NULL) != 0);
   if (__pyx_t_1) {
 
     /* "View.MemoryView":250
- *
+ * 
  *     if buf == NULL:
  *         result = array(shape, itemsize, format, mode.decode('ASCII'))             # <<<<<<<<<<<<<<
  *     else:
  *         result = array(shape, itemsize, format, mode.decode('ASCII'),
  */
     __pyx_t_2 = PyInt_FromSsize_t(__pyx_v_itemsize); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 250, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
@@ -8558,15 +9087,15 @@
     __Pyx_GOTREF(__pyx_t_4);
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
     __pyx_v_result = ((struct __pyx_array_obj *)__pyx_t_4);
     __pyx_t_4 = 0;
 
     /* "View.MemoryView":249
  *     cdef array result
- *
+ * 
  *     if buf == NULL:             # <<<<<<<<<<<<<<
  *         result = array(shape, itemsize, format, mode.decode('ASCII'))
  *     else:
  */
     goto __pyx_L3;
   }
 
@@ -8600,15 +9129,15 @@
     __pyx_t_3 = 0;
 
     /* "View.MemoryView":253
  *     else:
  *         result = array(shape, itemsize, format, mode.decode('ASCII'),
  *                        allocate_buffer=False)             # <<<<<<<<<<<<<<
  *         result.data = buf
- *
+ * 
  */
     __pyx_t_3 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 253, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_allocate_buffer, Py_False) < 0) __PYX_ERR(2, 253, __pyx_L1_error)
 
     /* "View.MemoryView":252
  *         result = array(shape, itemsize, format, mode.decode('ASCII'))
@@ -8624,35 +9153,35 @@
     __pyx_v_result = ((struct __pyx_array_obj *)__pyx_t_5);
     __pyx_t_5 = 0;
 
     /* "View.MemoryView":254
  *         result = array(shape, itemsize, format, mode.decode('ASCII'),
  *                        allocate_buffer=False)
  *         result.data = buf             # <<<<<<<<<<<<<<
- *
+ * 
  *     return result
  */
     __pyx_v_result->data = __pyx_v_buf;
   }
   __pyx_L3:;
 
   /* "View.MemoryView":256
  *         result.data = buf
- *
+ * 
  *     return result             # <<<<<<<<<<<<<<
- *
- *
+ * 
+ * 
  */
   __Pyx_XDECREF(((PyObject *)__pyx_r));
   __Pyx_INCREF(((PyObject *)__pyx_v_result));
   __pyx_r = __pyx_v_result;
   goto __pyx_L0;
 
   /* "View.MemoryView":245
- *
+ * 
  * @cname("__pyx_array_new")
  * cdef array array_cwrapper(tuple shape, Py_ssize_t itemsize, char *format,             # <<<<<<<<<<<<<<
  *                           char *mode, char *buf):
  *     cdef array result
  */
 
   /* function exit code */
@@ -8764,15 +9293,15 @@
 }
 
 /* "View.MemoryView":284
  *     def __init__(self, name):
  *         self.name = name
  *     def __repr__(self):             # <<<<<<<<<<<<<<
  *         return self.name
- *
+ * 
  */
 
 /* Python wrapper */
 static PyObject *__pyx_MemviewEnum___repr__(PyObject *__pyx_v_self); /*proto*/
 static PyObject *__pyx_MemviewEnum___repr__(PyObject *__pyx_v_self) {
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
@@ -8789,28 +9318,28 @@
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__repr__", 0);
 
   /* "View.MemoryView":285
  *         self.name = name
  *     def __repr__(self):
  *         return self.name             # <<<<<<<<<<<<<<
- *
+ * 
  * cdef generic = Enum("<strided and direct or indirect>")
  */
   __Pyx_XDECREF(__pyx_r);
   __Pyx_INCREF(__pyx_v_self->name);
   __pyx_r = __pyx_v_self->name;
   goto __pyx_L0;
 
   /* "View.MemoryView":284
  *     def __init__(self, name):
  *         self.name = name
  *     def __repr__(self):             # <<<<<<<<<<<<<<
  *         return self.name
- *
+ * 
  */
 
   /* function exit code */
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
@@ -9106,15 +9635,15 @@
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "View.MemoryView":299
- *
+ * 
  * @cname('__pyx_align_pointer')
  * cdef void *align_pointer(void *memory, size_t alignment) nogil:             # <<<<<<<<<<<<<<
  *     "Align pointer memory on a given boundary"
  *     cdef Py_intptr_t aligned_p = <Py_intptr_t> memory
  */
 
 static void *__pyx_align_pointer(void *__pyx_v_memory, size_t __pyx_v_alignment) {
@@ -9124,81 +9653,81 @@
   int __pyx_t_1;
 
   /* "View.MemoryView":301
  * cdef void *align_pointer(void *memory, size_t alignment) nogil:
  *     "Align pointer memory on a given boundary"
  *     cdef Py_intptr_t aligned_p = <Py_intptr_t> memory             # <<<<<<<<<<<<<<
  *     cdef size_t offset
- *
+ * 
  */
   __pyx_v_aligned_p = ((Py_intptr_t)__pyx_v_memory);
 
   /* "View.MemoryView":305
- *
+ * 
  *     with cython.cdivision(True):
  *         offset = aligned_p % alignment             # <<<<<<<<<<<<<<
- *
+ * 
  *     if offset > 0:
  */
   __pyx_v_offset = (__pyx_v_aligned_p % __pyx_v_alignment);
 
   /* "View.MemoryView":307
  *         offset = aligned_p % alignment
- *
+ * 
  *     if offset > 0:             # <<<<<<<<<<<<<<
  *         aligned_p += alignment - offset
- *
+ * 
  */
   __pyx_t_1 = ((__pyx_v_offset > 0) != 0);
   if (__pyx_t_1) {
 
     /* "View.MemoryView":308
- *
+ * 
  *     if offset > 0:
  *         aligned_p += alignment - offset             # <<<<<<<<<<<<<<
- *
+ * 
  *     return <void *> aligned_p
  */
     __pyx_v_aligned_p = (__pyx_v_aligned_p + (__pyx_v_alignment - __pyx_v_offset));
 
     /* "View.MemoryView":307
  *         offset = aligned_p % alignment
- *
+ * 
  *     if offset > 0:             # <<<<<<<<<<<<<<
  *         aligned_p += alignment - offset
- *
+ * 
  */
   }
 
   /* "View.MemoryView":310
  *         aligned_p += alignment - offset
- *
+ * 
  *     return <void *> aligned_p             # <<<<<<<<<<<<<<
- *
- *
+ * 
+ * 
  */
   __pyx_r = ((void *)__pyx_v_aligned_p);
   goto __pyx_L0;
 
   /* "View.MemoryView":299
- *
+ * 
  * @cname('__pyx_align_pointer')
  * cdef void *align_pointer(void *memory, size_t alignment) nogil:             # <<<<<<<<<<<<<<
  *     "Align pointer memory on a given boundary"
  *     cdef Py_intptr_t aligned_p = <Py_intptr_t> memory
  */
 
   /* function exit code */
   __pyx_L0:;
   return __pyx_r;
 }
 
 /* "View.MemoryView":346
  *     cdef __Pyx_TypeInfo *typeinfo
- *
+ * 
  *     def __cinit__(memoryview self, object obj, int flags, bint dtype_is_object=False):             # <<<<<<<<<<<<<<
  *         self.obj = obj
  *         self.flags = flags
  */
 
 /* Python wrapper */
 static int __pyx_memoryview___cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
@@ -9291,15 +9820,15 @@
   int __pyx_t_4;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__cinit__", 0);
 
   /* "View.MemoryView":347
- *
+ * 
  *     def __cinit__(memoryview self, object obj, int flags, bint dtype_is_object=False):
  *         self.obj = obj             # <<<<<<<<<<<<<<
  *         self.flags = flags
  *         if type(self) is memoryview or obj is not None:
  */
   __Pyx_INCREF(__pyx_v_obj);
   __Pyx_GIVEREF(__pyx_v_obj);
@@ -9356,23 +9885,23 @@
     if (__pyx_t_1) {
 
       /* "View.MemoryView":352
  *             __Pyx_GetBuffer(obj, &self.view, flags)
  *             if <PyObject *> self.view.obj == NULL:
  *                 (<__pyx_buffer *> &self.view).obj = Py_None             # <<<<<<<<<<<<<<
  *                 Py_INCREF(Py_None)
- *
+ * 
  */
       ((Py_buffer *)(&__pyx_v_self->view))->obj = Py_None;
 
       /* "View.MemoryView":353
  *             if <PyObject *> self.view.obj == NULL:
  *                 (<__pyx_buffer *> &self.view).obj = Py_None
  *                 Py_INCREF(Py_None)             # <<<<<<<<<<<<<<
- *
+ * 
  *         if not __PYX_CYTHON_ATOMICS_ENABLED():
  */
       Py_INCREF(Py_None);
 
       /* "View.MemoryView":351
  *         if type(self) is memoryview or obj is not None:
  *             __Pyx_GetBuffer(obj, &self.view, flags)
@@ -9389,15 +9918,15 @@
  *             __Pyx_GetBuffer(obj, &self.view, flags)
  *             if <PyObject *> self.view.obj == NULL:
  */
   }
 
   /* "View.MemoryView":355
  *                 Py_INCREF(Py_None)
- *
+ * 
  *         if not __PYX_CYTHON_ATOMICS_ENABLED():             # <<<<<<<<<<<<<<
  *             global __pyx_memoryview_thread_locks_used
  *             if __pyx_memoryview_thread_locks_used < THREAD_LOCKS_PREALLOCATED:
  */
   __pyx_t_1 = ((!(__PYX_CYTHON_ATOMICS_ENABLED() != 0)) != 0);
   if (__pyx_t_1) {
 
@@ -9458,67 +9987,67 @@
       __pyx_v_self->lock = PyThread_allocate_lock();
 
       /* "View.MemoryView":362
  *             if self.lock is NULL:
  *                 self.lock = PyThread_allocate_lock()
  *                 if self.lock is NULL:             # <<<<<<<<<<<<<<
  *                     raise MemoryError
- *
+ * 
  */
       __pyx_t_1 = ((__pyx_v_self->lock == NULL) != 0);
       if (unlikely(__pyx_t_1)) {
 
         /* "View.MemoryView":363
  *                 self.lock = PyThread_allocate_lock()
  *                 if self.lock is NULL:
  *                     raise MemoryError             # <<<<<<<<<<<<<<
- *
+ * 
  *         if flags & PyBUF_FORMAT:
  */
         PyErr_NoMemory(); __PYX_ERR(2, 363, __pyx_L1_error)
 
         /* "View.MemoryView":362
  *             if self.lock is NULL:
  *                 self.lock = PyThread_allocate_lock()
  *                 if self.lock is NULL:             # <<<<<<<<<<<<<<
  *                     raise MemoryError
- *
+ * 
  */
       }
 
       /* "View.MemoryView":360
  *                 self.lock = __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used]
  *                 __pyx_memoryview_thread_locks_used += 1
  *             if self.lock is NULL:             # <<<<<<<<<<<<<<
  *                 self.lock = PyThread_allocate_lock()
  *                 if self.lock is NULL:
  */
     }
 
     /* "View.MemoryView":355
  *                 Py_INCREF(Py_None)
- *
+ * 
  *         if not __PYX_CYTHON_ATOMICS_ENABLED():             # <<<<<<<<<<<<<<
  *             global __pyx_memoryview_thread_locks_used
  *             if __pyx_memoryview_thread_locks_used < THREAD_LOCKS_PREALLOCATED:
  */
   }
 
   /* "View.MemoryView":365
  *                     raise MemoryError
- *
+ * 
  *         if flags & PyBUF_FORMAT:             # <<<<<<<<<<<<<<
  *             self.dtype_is_object = (self.view.format[0] == b'O' and self.view.format[1] == b'\0')
  *         else:
  */
   __pyx_t_1 = ((__pyx_v_flags & PyBUF_FORMAT) != 0);
   if (__pyx_t_1) {
 
     /* "View.MemoryView":366
- *
+ * 
  *         if flags & PyBUF_FORMAT:
  *             self.dtype_is_object = (self.view.format[0] == b'O' and self.view.format[1] == b'\0')             # <<<<<<<<<<<<<<
  *         else:
  *             self.dtype_is_object = dtype_is_object
  */
     __pyx_t_2 = (((__pyx_v_self->view.format[0]) == 'O') != 0);
     if (__pyx_t_2) {
@@ -9529,55 +10058,55 @@
     __pyx_t_2 = (((__pyx_v_self->view.format[1]) == '\x00') != 0);
     __pyx_t_1 = __pyx_t_2;
     __pyx_L12_bool_binop_done:;
     __pyx_v_self->dtype_is_object = __pyx_t_1;
 
     /* "View.MemoryView":365
  *                     raise MemoryError
- *
+ * 
  *         if flags & PyBUF_FORMAT:             # <<<<<<<<<<<<<<
  *             self.dtype_is_object = (self.view.format[0] == b'O' and self.view.format[1] == b'\0')
  *         else:
  */
     goto __pyx_L11;
   }
 
   /* "View.MemoryView":368
  *             self.dtype_is_object = (self.view.format[0] == b'O' and self.view.format[1] == b'\0')
  *         else:
  *             self.dtype_is_object = dtype_is_object             # <<<<<<<<<<<<<<
- *
+ * 
  *         self.acquisition_count_aligned_p = <__pyx_atomic_int *> align_pointer(
  */
   /*else*/ {
     __pyx_v_self->dtype_is_object = __pyx_v_dtype_is_object;
   }
   __pyx_L11:;
 
   /* "View.MemoryView":370
  *             self.dtype_is_object = dtype_is_object
- *
+ * 
  *         self.acquisition_count_aligned_p = <__pyx_atomic_int *> align_pointer(             # <<<<<<<<<<<<<<
  *                   <void *> &self.acquisition_count[0], sizeof(__pyx_atomic_int))
  *         self.typeinfo = NULL
  */
   __pyx_v_self->acquisition_count_aligned_p = ((__pyx_atomic_int *)__pyx_align_pointer(((void *)(&(__pyx_v_self->acquisition_count[0]))), (sizeof(__pyx_atomic_int))));
 
   /* "View.MemoryView":372
  *         self.acquisition_count_aligned_p = <__pyx_atomic_int *> align_pointer(
  *                   <void *> &self.acquisition_count[0], sizeof(__pyx_atomic_int))
  *         self.typeinfo = NULL             # <<<<<<<<<<<<<<
- *
+ * 
  *     def __dealloc__(memoryview self):
  */
   __pyx_v_self->typeinfo = NULL;
 
   /* "View.MemoryView":346
  *     cdef __Pyx_TypeInfo *typeinfo
- *
+ * 
  *     def __cinit__(memoryview self, object obj, int flags, bint dtype_is_object=False):             # <<<<<<<<<<<<<<
  *         self.obj = obj
  *         self.flags = flags
  */
 
   /* function exit code */
   __pyx_r = 0;
@@ -9588,15 +10117,15 @@
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "View.MemoryView":374
  *         self.typeinfo = NULL
- *
+ * 
  *     def __dealloc__(memoryview self):             # <<<<<<<<<<<<<<
  *         if self.obj is not None:
  *             __Pyx_ReleaseBuffer(&self.view)
  */
 
 /* Python wrapper */
 static void __pyx_memoryview___dealloc__(PyObject *__pyx_v_self); /*proto*/
@@ -9618,76 +10147,76 @@
   int __pyx_t_4;
   int __pyx_t_5;
   PyThread_type_lock __pyx_t_6;
   PyThread_type_lock __pyx_t_7;
   __Pyx_RefNannySetupContext("__dealloc__", 0);
 
   /* "View.MemoryView":375
- *
+ * 
  *     def __dealloc__(memoryview self):
  *         if self.obj is not None:             # <<<<<<<<<<<<<<
  *             __Pyx_ReleaseBuffer(&self.view)
  *         elif (<__pyx_buffer *> &self.view).obj == Py_None:
  */
   __pyx_t_1 = (__pyx_v_self->obj != Py_None);
   __pyx_t_2 = (__pyx_t_1 != 0);
   if (__pyx_t_2) {
 
     /* "View.MemoryView":376
  *     def __dealloc__(memoryview self):
  *         if self.obj is not None:
  *             __Pyx_ReleaseBuffer(&self.view)             # <<<<<<<<<<<<<<
  *         elif (<__pyx_buffer *> &self.view).obj == Py_None:
- *
+ * 
  */
     __Pyx_ReleaseBuffer((&__pyx_v_self->view));
 
     /* "View.MemoryView":375
- *
+ * 
  *     def __dealloc__(memoryview self):
  *         if self.obj is not None:             # <<<<<<<<<<<<<<
  *             __Pyx_ReleaseBuffer(&self.view)
  *         elif (<__pyx_buffer *> &self.view).obj == Py_None:
  */
     goto __pyx_L3;
   }
 
   /* "View.MemoryView":377
  *         if self.obj is not None:
  *             __Pyx_ReleaseBuffer(&self.view)
  *         elif (<__pyx_buffer *> &self.view).obj == Py_None:             # <<<<<<<<<<<<<<
- *
+ * 
  *             (<__pyx_buffer *> &self.view).obj = NULL
  */
   __pyx_t_2 = ((((Py_buffer *)(&__pyx_v_self->view))->obj == Py_None) != 0);
   if (__pyx_t_2) {
 
     /* "View.MemoryView":379
  *         elif (<__pyx_buffer *> &self.view).obj == Py_None:
- *
+ * 
  *             (<__pyx_buffer *> &self.view).obj = NULL             # <<<<<<<<<<<<<<
  *             Py_DECREF(Py_None)
- *
+ * 
  */
     ((Py_buffer *)(&__pyx_v_self->view))->obj = NULL;
 
     /* "View.MemoryView":380
- *
+ * 
  *             (<__pyx_buffer *> &self.view).obj = NULL
  *             Py_DECREF(Py_None)             # <<<<<<<<<<<<<<
- *
+ * 
  *         cdef int i
  */
     Py_DECREF(Py_None);
 
     /* "View.MemoryView":377
  *         if self.obj is not None:
  *             __Pyx_ReleaseBuffer(&self.view)
  *         elif (<__pyx_buffer *> &self.view).obj == Py_None:             # <<<<<<<<<<<<<<
- *
+ * 
  *             (<__pyx_buffer *> &self.view).obj = NULL
  */
   }
   __pyx_L3:;
 
   /* "View.MemoryView":384
  *         cdef int i
@@ -9789,15 +10318,15 @@
     }
     /*else*/ {
 
       /* "View.MemoryView":393
  *                     break
  *             else:
  *                 PyThread_free_lock(self.lock)             # <<<<<<<<<<<<<<
- *
+ * 
  *     cdef char *get_item_pointer(memoryview self, object index) except NULL:
  */
       PyThread_free_lock(__pyx_v_self->lock);
     }
     __pyx_L6_break:;
 
     /* "View.MemoryView":384
@@ -9807,27 +10336,27 @@
  *             for i in range(__pyx_memoryview_thread_locks_used):
  *                 if __pyx_memoryview_thread_locks[i] is self.lock:
  */
   }
 
   /* "View.MemoryView":374
  *         self.typeinfo = NULL
- *
+ * 
  *     def __dealloc__(memoryview self):             # <<<<<<<<<<<<<<
  *         if self.obj is not None:
  *             __Pyx_ReleaseBuffer(&self.view)
  */
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
 }
 
 /* "View.MemoryView":395
  *                 PyThread_free_lock(self.lock)
- *
+ * 
  *     cdef char *get_item_pointer(memoryview self, object index) except NULL:             # <<<<<<<<<<<<<<
  *         cdef Py_ssize_t dim
  *         cdef char *itemp = <char *> self.view.buf
  */
 
 static char *__pyx_memoryview_get_item_pointer(struct __pyx_memoryview_obj *__pyx_v_self, PyObject *__pyx_v_index) {
   Py_ssize_t __pyx_v_dim;
@@ -9847,25 +10376,25 @@
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("get_item_pointer", 0);
 
   /* "View.MemoryView":397
  *     cdef char *get_item_pointer(memoryview self, object index) except NULL:
  *         cdef Py_ssize_t dim
  *         cdef char *itemp = <char *> self.view.buf             # <<<<<<<<<<<<<<
- *
+ * 
  *         for dim, idx in enumerate(index):
  */
   __pyx_v_itemp = ((char *)__pyx_v_self->view.buf);
 
   /* "View.MemoryView":399
  *         cdef char *itemp = <char *> self.view.buf
- *
+ * 
  *         for dim, idx in enumerate(index):             # <<<<<<<<<<<<<<
  *             itemp = pybuffer_index(&self.view, itemp, idx, dim)
- *
+ * 
  */
   __pyx_t_1 = 0;
   if (likely(PyList_CheckExact(__pyx_v_index)) || PyTuple_CheckExact(__pyx_v_index)) {
     __pyx_t_2 = __pyx_v_index; __Pyx_INCREF(__pyx_t_2); __pyx_t_3 = 0;
     __pyx_t_4 = NULL;
   } else {
     __pyx_t_3 = -1; __pyx_t_2 = PyObject_GetIter(__pyx_v_index); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 399, __pyx_L1_error)
@@ -9905,47 +10434,47 @@
     }
     __Pyx_XDECREF_SET(__pyx_v_idx, __pyx_t_5);
     __pyx_t_5 = 0;
     __pyx_v_dim = __pyx_t_1;
     __pyx_t_1 = (__pyx_t_1 + 1);
 
     /* "View.MemoryView":400
- *
+ * 
  *         for dim, idx in enumerate(index):
  *             itemp = pybuffer_index(&self.view, itemp, idx, dim)             # <<<<<<<<<<<<<<
- *
+ * 
  *         return itemp
  */
     __pyx_t_6 = __Pyx_PyIndex_AsSsize_t(__pyx_v_idx); if (unlikely((__pyx_t_6 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(2, 400, __pyx_L1_error)
     __pyx_t_7 = __pyx_pybuffer_index((&__pyx_v_self->view), __pyx_v_itemp, __pyx_t_6, __pyx_v_dim); if (unlikely(__pyx_t_7 == ((char *)NULL))) __PYX_ERR(2, 400, __pyx_L1_error)
     __pyx_v_itemp = __pyx_t_7;
 
     /* "View.MemoryView":399
  *         cdef char *itemp = <char *> self.view.buf
- *
+ * 
  *         for dim, idx in enumerate(index):             # <<<<<<<<<<<<<<
  *             itemp = pybuffer_index(&self.view, itemp, idx, dim)
- *
+ * 
  */
   }
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
   /* "View.MemoryView":402
  *             itemp = pybuffer_index(&self.view, itemp, idx, dim)
- *
+ * 
  *         return itemp             # <<<<<<<<<<<<<<
- *
- *
+ * 
+ * 
  */
   __pyx_r = __pyx_v_itemp;
   goto __pyx_L0;
 
   /* "View.MemoryView":395
  *                 PyThread_free_lock(self.lock)
- *
+ * 
  *     cdef char *get_item_pointer(memoryview self, object index) except NULL:             # <<<<<<<<<<<<<<
  *         cdef Py_ssize_t dim
  *         cdef char *itemp = <char *> self.view.buf
  */
 
   /* function exit code */
   __pyx_L1_error:;
@@ -9956,16 +10485,16 @@
   __pyx_L0:;
   __Pyx_XDECREF(__pyx_v_idx);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "View.MemoryView":405
- *
- *
+ * 
+ * 
  *     def __getitem__(memoryview self, object index):             # <<<<<<<<<<<<<<
  *         if index is Ellipsis:
  *             return self
  */
 
 /* Python wrapper */
 static PyObject *__pyx_memoryview___getitem__(PyObject *__pyx_v_self, PyObject *__pyx_v_index); /*proto*/
@@ -9994,65 +10523,65 @@
   char *__pyx_t_6;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__getitem__", 0);
 
   /* "View.MemoryView":406
- *
+ * 
  *     def __getitem__(memoryview self, object index):
  *         if index is Ellipsis:             # <<<<<<<<<<<<<<
  *             return self
- *
+ * 
  */
   __pyx_t_1 = (__pyx_v_index == __pyx_builtin_Ellipsis);
   __pyx_t_2 = (__pyx_t_1 != 0);
   if (__pyx_t_2) {
 
     /* "View.MemoryView":407
  *     def __getitem__(memoryview self, object index):
  *         if index is Ellipsis:
  *             return self             # <<<<<<<<<<<<<<
- *
+ * 
  *         have_slices, indices = _unellipsify(index, self.view.ndim)
  */
     __Pyx_XDECREF(__pyx_r);
     __Pyx_INCREF(((PyObject *)__pyx_v_self));
     __pyx_r = ((PyObject *)__pyx_v_self);
     goto __pyx_L0;
 
     /* "View.MemoryView":406
- *
+ * 
  *     def __getitem__(memoryview self, object index):
  *         if index is Ellipsis:             # <<<<<<<<<<<<<<
  *             return self
- *
+ * 
  */
   }
 
   /* "View.MemoryView":409
  *             return self
- *
+ * 
  *         have_slices, indices = _unellipsify(index, self.view.ndim)             # <<<<<<<<<<<<<<
- *
+ * 
  *         cdef char *itemp
  */
   __pyx_t_3 = _unellipsify(__pyx_v_index, __pyx_v_self->view.ndim); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 409, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   if (likely(__pyx_t_3 != Py_None)) {
     PyObject* sequence = __pyx_t_3;
     Py_ssize_t size = __Pyx_PySequence_SIZE(sequence);
     if (unlikely(size != 2)) {
       if (size > 2) __Pyx_RaiseTooManyValuesError(2);
       else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
       __PYX_ERR(2, 409, __pyx_L1_error)
     }
     #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-    __pyx_t_4 = PyTuple_GET_ITEM(sequence, 0);
-    __pyx_t_5 = PyTuple_GET_ITEM(sequence, 1);
+    __pyx_t_4 = PyTuple_GET_ITEM(sequence, 0); 
+    __pyx_t_5 = PyTuple_GET_ITEM(sequence, 1); 
     __Pyx_INCREF(__pyx_t_4);
     __Pyx_INCREF(__pyx_t_5);
     #else
     __pyx_t_4 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_4)) __PYX_ERR(2, 409, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
     __pyx_t_5 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_5)) __PYX_ERR(2, 409, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
@@ -10063,15 +10592,15 @@
   }
   __pyx_v_have_slices = __pyx_t_4;
   __pyx_t_4 = 0;
   __pyx_v_indices = __pyx_t_5;
   __pyx_t_5 = 0;
 
   /* "View.MemoryView":412
- *
+ * 
  *         cdef char *itemp
  *         if have_slices:             # <<<<<<<<<<<<<<
  *             return memview_slice(self, indices)
  *         else:
  */
   __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_v_have_slices); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(2, 412, __pyx_L1_error)
   if (__pyx_t_2) {
@@ -10087,51 +10616,51 @@
     __pyx_t_3 = ((PyObject *)__pyx_memview_slice(__pyx_v_self, __pyx_v_indices)); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 413, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __pyx_r = __pyx_t_3;
     __pyx_t_3 = 0;
     goto __pyx_L0;
 
     /* "View.MemoryView":412
- *
+ * 
  *         cdef char *itemp
  *         if have_slices:             # <<<<<<<<<<<<<<
  *             return memview_slice(self, indices)
  *         else:
  */
   }
 
   /* "View.MemoryView":415
  *             return memview_slice(self, indices)
  *         else:
  *             itemp = self.get_item_pointer(indices)             # <<<<<<<<<<<<<<
  *             return self.convert_item_to_object(itemp)
- *
+ * 
  */
   /*else*/ {
     __pyx_t_6 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->get_item_pointer(__pyx_v_self, __pyx_v_indices); if (unlikely(__pyx_t_6 == ((char *)NULL))) __PYX_ERR(2, 415, __pyx_L1_error)
     __pyx_v_itemp = __pyx_t_6;
 
     /* "View.MemoryView":416
  *         else:
  *             itemp = self.get_item_pointer(indices)
  *             return self.convert_item_to_object(itemp)             # <<<<<<<<<<<<<<
- *
+ * 
  *     def __setitem__(memoryview self, object index, object value):
  */
     __Pyx_XDECREF(__pyx_r);
     __pyx_t_3 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->convert_item_to_object(__pyx_v_self, __pyx_v_itemp); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 416, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __pyx_r = __pyx_t_3;
     __pyx_t_3 = 0;
     goto __pyx_L0;
   }
 
   /* "View.MemoryView":405
- *
- *
+ * 
+ * 
  *     def __getitem__(memoryview self, object index):             # <<<<<<<<<<<<<<
  *         if index is Ellipsis:
  *             return self
  */
 
   /* function exit code */
   __pyx_L1_error:;
@@ -10146,15 +10675,15 @@
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "View.MemoryView":418
  *             return self.convert_item_to_object(itemp)
- *
+ * 
  *     def __setitem__(memoryview self, object index, object value):             # <<<<<<<<<<<<<<
  *         if self.view.readonly:
  *             raise TypeError("Cannot assign to read-only memoryview")
  */
 
 /* Python wrapper */
 static int __pyx_memoryview___setitem__(PyObject *__pyx_v_self, PyObject *__pyx_v_index, PyObject *__pyx_v_value); /*proto*/
@@ -10181,65 +10710,65 @@
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__setitem__", 0);
   __Pyx_INCREF(__pyx_v_index);
 
   /* "View.MemoryView":419
- *
+ * 
  *     def __setitem__(memoryview self, object index, object value):
  *         if self.view.readonly:             # <<<<<<<<<<<<<<
  *             raise TypeError("Cannot assign to read-only memoryview")
- *
+ * 
  */
   __pyx_t_1 = (__pyx_v_self->view.readonly != 0);
   if (unlikely(__pyx_t_1)) {
 
     /* "View.MemoryView":420
  *     def __setitem__(memoryview self, object index, object value):
  *         if self.view.readonly:
  *             raise TypeError("Cannot assign to read-only memoryview")             # <<<<<<<<<<<<<<
- *
+ * 
  *         have_slices, index = _unellipsify(index, self.view.ndim)
  */
     __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__10, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 420, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __Pyx_Raise(__pyx_t_2, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
     __PYX_ERR(2, 420, __pyx_L1_error)
 
     /* "View.MemoryView":419
- *
+ * 
  *     def __setitem__(memoryview self, object index, object value):
  *         if self.view.readonly:             # <<<<<<<<<<<<<<
  *             raise TypeError("Cannot assign to read-only memoryview")
- *
+ * 
  */
   }
 
   /* "View.MemoryView":422
  *             raise TypeError("Cannot assign to read-only memoryview")
- *
+ * 
  *         have_slices, index = _unellipsify(index, self.view.ndim)             # <<<<<<<<<<<<<<
- *
+ * 
  *         if have_slices:
  */
   __pyx_t_2 = _unellipsify(__pyx_v_index, __pyx_v_self->view.ndim); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 422, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   if (likely(__pyx_t_2 != Py_None)) {
     PyObject* sequence = __pyx_t_2;
     Py_ssize_t size = __Pyx_PySequence_SIZE(sequence);
     if (unlikely(size != 2)) {
       if (size > 2) __Pyx_RaiseTooManyValuesError(2);
       else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
       __PYX_ERR(2, 422, __pyx_L1_error)
     }
     #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-    __pyx_t_3 = PyTuple_GET_ITEM(sequence, 0);
-    __pyx_t_4 = PyTuple_GET_ITEM(sequence, 1);
+    __pyx_t_3 = PyTuple_GET_ITEM(sequence, 0); 
+    __pyx_t_4 = PyTuple_GET_ITEM(sequence, 1); 
     __Pyx_INCREF(__pyx_t_3);
     __Pyx_INCREF(__pyx_t_4);
     #else
     __pyx_t_3 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 422, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __pyx_t_4 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_4)) __PYX_ERR(2, 422, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
@@ -10251,24 +10780,24 @@
   __pyx_v_have_slices = __pyx_t_3;
   __pyx_t_3 = 0;
   __Pyx_DECREF_SET(__pyx_v_index, __pyx_t_4);
   __pyx_t_4 = 0;
 
   /* "View.MemoryView":424
  *         have_slices, index = _unellipsify(index, self.view.ndim)
- *
+ * 
  *         if have_slices:             # <<<<<<<<<<<<<<
  *             obj = self.is_slice(value)
  *             if obj:
  */
   __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_v_have_slices); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(2, 424, __pyx_L1_error)
   if (__pyx_t_1) {
 
     /* "View.MemoryView":425
- *
+ * 
  *         if have_slices:
  *             obj = self.is_slice(value)             # <<<<<<<<<<<<<<
  *             if obj:
  *                 self.setitem_slice_assignment(self[index], obj)
  */
     __pyx_t_2 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->is_slice(__pyx_v_self, __pyx_v_value); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 425, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
@@ -10325,39 +10854,39 @@
       __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
       __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
     }
     __pyx_L5:;
 
     /* "View.MemoryView":424
  *         have_slices, index = _unellipsify(index, self.view.ndim)
- *
+ * 
  *         if have_slices:             # <<<<<<<<<<<<<<
  *             obj = self.is_slice(value)
  *             if obj:
  */
     goto __pyx_L4;
   }
 
   /* "View.MemoryView":431
  *                 self.setitem_slice_assign_scalar(self[index], value)
  *         else:
  *             self.setitem_indexed(index, value)             # <<<<<<<<<<<<<<
- *
+ * 
  *     cdef is_slice(self, obj):
  */
   /*else*/ {
     __pyx_t_2 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->setitem_indexed(__pyx_v_self, __pyx_v_index, __pyx_v_value); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 431, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   }
   __pyx_L4:;
 
   /* "View.MemoryView":418
  *             return self.convert_item_to_object(itemp)
- *
+ * 
  *     def __setitem__(memoryview self, object index, object value):             # <<<<<<<<<<<<<<
  *         if self.view.readonly:
  *             raise TypeError("Cannot assign to read-only memoryview")
  */
 
   /* function exit code */
   __pyx_r = 0;
@@ -10374,15 +10903,15 @@
   __Pyx_XDECREF(__pyx_v_index);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "View.MemoryView":433
  *             self.setitem_indexed(index, value)
- *
+ * 
  *     cdef is_slice(self, obj):             # <<<<<<<<<<<<<<
  *         if not isinstance(obj, memoryview):
  *             try:
  */
 
 static PyObject *__pyx_memoryview_is_slice(struct __pyx_memoryview_obj *__pyx_v_self, PyObject *__pyx_v_obj) {
   PyObject *__pyx_r = NULL;
@@ -10399,21 +10928,21 @@
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("is_slice", 0);
   __Pyx_INCREF(__pyx_v_obj);
 
   /* "View.MemoryView":434
- *
+ * 
  *     cdef is_slice(self, obj):
  *         if not isinstance(obj, memoryview):             # <<<<<<<<<<<<<<
  *             try:
  *                 obj = memoryview(obj, self.flags & ~PyBUF_WRITABLE | PyBUF_ANY_CONTIGUOUS,
  */
-  __pyx_t_1 = __Pyx_TypeCheck(__pyx_v_obj, __pyx_memoryview_type);
+  __pyx_t_1 = __Pyx_TypeCheck(__pyx_v_obj, __pyx_memoryview_type); 
   __pyx_t_2 = ((!(__pyx_t_1 != 0)) != 0);
   if (__pyx_t_2) {
 
     /* "View.MemoryView":435
  *     cdef is_slice(self, obj):
  *         if not isinstance(obj, memoryview):
  *             try:             # <<<<<<<<<<<<<<
@@ -10491,29 +11020,29 @@
       __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
 
       /* "View.MemoryView":438
  *                 obj = memoryview(obj, self.flags & ~PyBUF_WRITABLE | PyBUF_ANY_CONTIGUOUS,
  *                                  self.dtype_is_object)
  *             except TypeError:             # <<<<<<<<<<<<<<
  *                 return None
- *
+ * 
  */
       __pyx_t_9 = __Pyx_PyErr_ExceptionMatches(__pyx_builtin_TypeError);
       if (__pyx_t_9) {
         __Pyx_AddTraceback("View.MemoryView.memoryview.is_slice", __pyx_clineno, __pyx_lineno, __pyx_filename);
         if (__Pyx_GetException(&__pyx_t_7, &__pyx_t_8, &__pyx_t_6) < 0) __PYX_ERR(2, 438, __pyx_L6_except_error)
         __Pyx_GOTREF(__pyx_t_7);
         __Pyx_GOTREF(__pyx_t_8);
         __Pyx_GOTREF(__pyx_t_6);
 
         /* "View.MemoryView":439
  *                                  self.dtype_is_object)
  *             except TypeError:
  *                 return None             # <<<<<<<<<<<<<<
- *
+ * 
  *         return obj
  */
         __Pyx_XDECREF(__pyx_r);
         __pyx_r = Py_None; __Pyx_INCREF(Py_None);
         __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
         __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
         __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
@@ -10540,37 +11069,37 @@
       __Pyx_XGIVEREF(__pyx_t_5);
       __Pyx_ExceptionReset(__pyx_t_3, __pyx_t_4, __pyx_t_5);
       goto __pyx_L0;
       __pyx_L9_try_end:;
     }
 
     /* "View.MemoryView":434
- *
+ * 
  *     cdef is_slice(self, obj):
  *         if not isinstance(obj, memoryview):             # <<<<<<<<<<<<<<
  *             try:
  *                 obj = memoryview(obj, self.flags & ~PyBUF_WRITABLE | PyBUF_ANY_CONTIGUOUS,
  */
   }
 
   /* "View.MemoryView":441
  *                 return None
- *
+ * 
  *         return obj             # <<<<<<<<<<<<<<
- *
+ * 
  *     cdef setitem_slice_assignment(self, dst, src):
  */
   __Pyx_XDECREF(__pyx_r);
   __Pyx_INCREF(__pyx_v_obj);
   __pyx_r = __pyx_v_obj;
   goto __pyx_L0;
 
   /* "View.MemoryView":433
  *             self.setitem_indexed(index, value)
- *
+ * 
  *     cdef is_slice(self, obj):             # <<<<<<<<<<<<<<
  *         if not isinstance(obj, memoryview):
  *             try:
  */
 
   /* function exit code */
   __pyx_L1_error:;
@@ -10584,15 +11113,15 @@
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "View.MemoryView":443
  *         return obj
- *
+ * 
  *     cdef setitem_slice_assignment(self, dst, src):             # <<<<<<<<<<<<<<
  *         cdef __Pyx_memviewslice dst_slice
  *         cdef __Pyx_memviewslice src_slice
  */
 
 static PyObject *__pyx_memoryview_setitem_slice_assignment(struct __pyx_memoryview_obj *__pyx_v_self, PyObject *__pyx_v_dst, PyObject *__pyx_v_src) {
   __Pyx_memviewslice __pyx_v_dst_slice;
@@ -10608,60 +11137,60 @@
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("setitem_slice_assignment", 0);
 
   /* "View.MemoryView":447
  *         cdef __Pyx_memviewslice src_slice
- *
+ * 
  *         memoryview_copy_contents(get_slice_from_memview(src, &src_slice)[0],             # <<<<<<<<<<<<<<
  *                                  get_slice_from_memview(dst, &dst_slice)[0],
  *                                  src.ndim, dst.ndim, self.dtype_is_object)
  */
   if (!(likely(((__pyx_v_src) == Py_None) || likely(__Pyx_TypeTest(__pyx_v_src, __pyx_memoryview_type))))) __PYX_ERR(2, 447, __pyx_L1_error)
   __pyx_t_1 = __pyx_memoryview_get_slice_from_memoryview(((struct __pyx_memoryview_obj *)__pyx_v_src), (&__pyx_v_src_slice)); if (unlikely(__pyx_t_1 == ((__Pyx_memviewslice *)NULL))) __PYX_ERR(2, 447, __pyx_L1_error)
 
   /* "View.MemoryView":448
- *
+ * 
  *         memoryview_copy_contents(get_slice_from_memview(src, &src_slice)[0],
  *                                  get_slice_from_memview(dst, &dst_slice)[0],             # <<<<<<<<<<<<<<
  *                                  src.ndim, dst.ndim, self.dtype_is_object)
- *
+ * 
  */
   if (!(likely(((__pyx_v_dst) == Py_None) || likely(__Pyx_TypeTest(__pyx_v_dst, __pyx_memoryview_type))))) __PYX_ERR(2, 448, __pyx_L1_error)
   __pyx_t_2 = __pyx_memoryview_get_slice_from_memoryview(((struct __pyx_memoryview_obj *)__pyx_v_dst), (&__pyx_v_dst_slice)); if (unlikely(__pyx_t_2 == ((__Pyx_memviewslice *)NULL))) __PYX_ERR(2, 448, __pyx_L1_error)
 
   /* "View.MemoryView":449
  *         memoryview_copy_contents(get_slice_from_memview(src, &src_slice)[0],
  *                                  get_slice_from_memview(dst, &dst_slice)[0],
  *                                  src.ndim, dst.ndim, self.dtype_is_object)             # <<<<<<<<<<<<<<
- *
+ * 
  *     cdef setitem_slice_assign_scalar(self, memoryview dst, value):
  */
   __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_src, __pyx_n_s_ndim); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 449, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __pyx_t_4 = __Pyx_PyInt_As_int(__pyx_t_3); if (unlikely((__pyx_t_4 == (int)-1) && PyErr_Occurred())) __PYX_ERR(2, 449, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_dst, __pyx_n_s_ndim); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 449, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __pyx_t_5 = __Pyx_PyInt_As_int(__pyx_t_3); if (unlikely((__pyx_t_5 == (int)-1) && PyErr_Occurred())) __PYX_ERR(2, 449, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
   /* "View.MemoryView":447
  *         cdef __Pyx_memviewslice src_slice
- *
+ * 
  *         memoryview_copy_contents(get_slice_from_memview(src, &src_slice)[0],             # <<<<<<<<<<<<<<
  *                                  get_slice_from_memview(dst, &dst_slice)[0],
  *                                  src.ndim, dst.ndim, self.dtype_is_object)
  */
   __pyx_t_6 = __pyx_memoryview_copy_contents((__pyx_t_1[0]), (__pyx_t_2[0]), __pyx_t_4, __pyx_t_5, __pyx_v_self->dtype_is_object); if (unlikely(__pyx_t_6 == ((int)-1))) __PYX_ERR(2, 447, __pyx_L1_error)
 
   /* "View.MemoryView":443
  *         return obj
- *
+ * 
  *     cdef setitem_slice_assignment(self, dst, src):             # <<<<<<<<<<<<<<
  *         cdef __Pyx_memviewslice dst_slice
  *         cdef __Pyx_memviewslice src_slice
  */
 
   /* function exit code */
   __pyx_r = Py_None; __Pyx_INCREF(Py_None);
@@ -10674,15 +11203,15 @@
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "View.MemoryView":451
  *                                  src.ndim, dst.ndim, self.dtype_is_object)
- *
+ * 
  *     cdef setitem_slice_assign_scalar(self, memoryview dst, value):             # <<<<<<<<<<<<<<
  *         cdef int array[128]
  *         cdef void *tmp = NULL
  */
 
 static PyObject *__pyx_memoryview_setitem_slice_assign_scalar(struct __pyx_memoryview_obj *__pyx_v_self, struct __pyx_memoryview_obj *__pyx_v_dst, PyObject *__pyx_v_value) {
   int __pyx_v_array[0x80];
@@ -10710,40 +11239,40 @@
   __Pyx_RefNannySetupContext("setitem_slice_assign_scalar", 0);
 
   /* "View.MemoryView":453
  *     cdef setitem_slice_assign_scalar(self, memoryview dst, value):
  *         cdef int array[128]
  *         cdef void *tmp = NULL             # <<<<<<<<<<<<<<
  *         cdef void *item
- *
+ * 
  */
   __pyx_v_tmp = NULL;
 
   /* "View.MemoryView":458
  *         cdef __Pyx_memviewslice *dst_slice
  *         cdef __Pyx_memviewslice tmp_slice
  *         dst_slice = get_slice_from_memview(dst, &tmp_slice)             # <<<<<<<<<<<<<<
- *
+ * 
  *         if <size_t>self.view.itemsize > sizeof(array):
  */
   __pyx_t_1 = __pyx_memoryview_get_slice_from_memoryview(__pyx_v_dst, (&__pyx_v_tmp_slice)); if (unlikely(__pyx_t_1 == ((__Pyx_memviewslice *)NULL))) __PYX_ERR(2, 458, __pyx_L1_error)
   __pyx_v_dst_slice = __pyx_t_1;
 
   /* "View.MemoryView":460
  *         dst_slice = get_slice_from_memview(dst, &tmp_slice)
- *
+ * 
  *         if <size_t>self.view.itemsize > sizeof(array):             # <<<<<<<<<<<<<<
  *             tmp = PyMem_Malloc(self.view.itemsize)
  *             if tmp == NULL:
  */
   __pyx_t_2 = ((((size_t)__pyx_v_self->view.itemsize) > (sizeof(__pyx_v_array))) != 0);
   if (__pyx_t_2) {
 
     /* "View.MemoryView":461
- *
+ * 
  *         if <size_t>self.view.itemsize > sizeof(array):
  *             tmp = PyMem_Malloc(self.view.itemsize)             # <<<<<<<<<<<<<<
  *             if tmp == NULL:
  *                 raise MemoryError
  */
     __pyx_v_tmp = PyMem_Malloc(__pyx_v_self->view.itemsize);
 
@@ -10782,45 +11311,45 @@
  *         else:
  *             item = <void *> array
  */
     __pyx_v_item = __pyx_v_tmp;
 
     /* "View.MemoryView":460
  *         dst_slice = get_slice_from_memview(dst, &tmp_slice)
- *
+ * 
  *         if <size_t>self.view.itemsize > sizeof(array):             # <<<<<<<<<<<<<<
  *             tmp = PyMem_Malloc(self.view.itemsize)
  *             if tmp == NULL:
  */
     goto __pyx_L3;
   }
 
   /* "View.MemoryView":466
  *             item = tmp
  *         else:
  *             item = <void *> array             # <<<<<<<<<<<<<<
- *
+ * 
  *         try:
  */
   /*else*/ {
     __pyx_v_item = ((void *)__pyx_v_array);
   }
   __pyx_L3:;
 
   /* "View.MemoryView":468
  *             item = <void *> array
- *
+ * 
  *         try:             # <<<<<<<<<<<<<<
  *             if self.dtype_is_object:
  *                 (<PyObject **> item)[0] = <PyObject *> value
  */
   /*try:*/ {
 
     /* "View.MemoryView":469
- *
+ * 
  *         try:
  *             if self.dtype_is_object:             # <<<<<<<<<<<<<<
  *                 (<PyObject **> item)[0] = <PyObject *> value
  *             else:
  */
     __pyx_t_2 = (__pyx_v_self->dtype_is_object != 0);
     if (__pyx_t_2) {
@@ -10831,61 +11360,61 @@
  *                 (<PyObject **> item)[0] = <PyObject *> value             # <<<<<<<<<<<<<<
  *             else:
  *                 self.assign_item_from_object(<char *> item, value)
  */
       (((PyObject **)__pyx_v_item)[0]) = ((PyObject *)__pyx_v_value);
 
       /* "View.MemoryView":469
- *
+ * 
  *         try:
  *             if self.dtype_is_object:             # <<<<<<<<<<<<<<
  *                 (<PyObject **> item)[0] = <PyObject *> value
  *             else:
  */
       goto __pyx_L8;
     }
 
     /* "View.MemoryView":472
  *                 (<PyObject **> item)[0] = <PyObject *> value
  *             else:
  *                 self.assign_item_from_object(<char *> item, value)             # <<<<<<<<<<<<<<
- *
- *
+ * 
+ * 
  */
     /*else*/ {
       __pyx_t_3 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->assign_item_from_object(__pyx_v_self, ((char *)__pyx_v_item), __pyx_v_value); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 472, __pyx_L6_error)
       __Pyx_GOTREF(__pyx_t_3);
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     }
     __pyx_L8:;
 
     /* "View.MemoryView":476
- *
- *
+ * 
+ * 
  *             if self.view.suboffsets != NULL:             # <<<<<<<<<<<<<<
  *                 assert_direct_dimensions(self.view.suboffsets, self.view.ndim)
  *             slice_assign_scalar(dst_slice, dst.view.ndim, self.view.itemsize,
  */
     __pyx_t_2 = ((__pyx_v_self->view.suboffsets != NULL) != 0);
     if (__pyx_t_2) {
 
       /* "View.MemoryView":477
- *
+ * 
  *             if self.view.suboffsets != NULL:
  *                 assert_direct_dimensions(self.view.suboffsets, self.view.ndim)             # <<<<<<<<<<<<<<
  *             slice_assign_scalar(dst_slice, dst.view.ndim, self.view.itemsize,
  *                                 item, self.dtype_is_object)
  */
       __pyx_t_3 = assert_direct_dimensions(__pyx_v_self->view.suboffsets, __pyx_v_self->view.ndim); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 477, __pyx_L6_error)
       __Pyx_GOTREF(__pyx_t_3);
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
       /* "View.MemoryView":476
- *
- *
+ * 
+ * 
  *             if self.view.suboffsets != NULL:             # <<<<<<<<<<<<<<
  *                 assert_direct_dimensions(self.view.suboffsets, self.view.ndim)
  *             slice_assign_scalar(dst_slice, dst.view.ndim, self.view.itemsize,
  */
     }
 
     /* "View.MemoryView":478
@@ -10898,15 +11427,15 @@
     __pyx_memoryview_slice_assign_scalar(__pyx_v_dst_slice, __pyx_v_dst->view.ndim, __pyx_v_self->view.itemsize, __pyx_v_item, __pyx_v_self->dtype_is_object);
   }
 
   /* "View.MemoryView":481
  *                                 item, self.dtype_is_object)
  *         finally:
  *             PyMem_Free(tmp)             # <<<<<<<<<<<<<<
- *
+ * 
  *     cdef setitem_indexed(self, index, value):
  */
   /*finally:*/ {
     /*normal exit:*/{
       PyMem_Free(__pyx_v_tmp);
       goto __pyx_L7;
     }
@@ -10943,15 +11472,15 @@
       goto __pyx_L1_error;
     }
     __pyx_L7:;
   }
 
   /* "View.MemoryView":451
  *                                  src.ndim, dst.ndim, self.dtype_is_object)
- *
+ * 
  *     cdef setitem_slice_assign_scalar(self, memoryview dst, value):             # <<<<<<<<<<<<<<
  *         cdef int array[128]
  *         cdef void *tmp = NULL
  */
 
   /* function exit code */
   __pyx_r = Py_None; __Pyx_INCREF(Py_None);
@@ -10964,15 +11493,15 @@
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "View.MemoryView":483
  *             PyMem_Free(tmp)
- *
+ * 
  *     cdef setitem_indexed(self, index, value):             # <<<<<<<<<<<<<<
  *         cdef char *itemp = self.get_item_pointer(index)
  *         self.assign_item_from_object(itemp, value)
  */
 
 static PyObject *__pyx_memoryview_setitem_indexed(struct __pyx_memoryview_obj *__pyx_v_self, PyObject *__pyx_v_index, PyObject *__pyx_v_value) {
   char *__pyx_v_itemp;
@@ -10982,37 +11511,37 @@
   PyObject *__pyx_t_2 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("setitem_indexed", 0);
 
   /* "View.MemoryView":484
- *
+ * 
  *     cdef setitem_indexed(self, index, value):
  *         cdef char *itemp = self.get_item_pointer(index)             # <<<<<<<<<<<<<<
  *         self.assign_item_from_object(itemp, value)
- *
+ * 
  */
   __pyx_t_1 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->get_item_pointer(__pyx_v_self, __pyx_v_index); if (unlikely(__pyx_t_1 == ((char *)NULL))) __PYX_ERR(2, 484, __pyx_L1_error)
   __pyx_v_itemp = __pyx_t_1;
 
   /* "View.MemoryView":485
  *     cdef setitem_indexed(self, index, value):
  *         cdef char *itemp = self.get_item_pointer(index)
  *         self.assign_item_from_object(itemp, value)             # <<<<<<<<<<<<<<
- *
+ * 
  *     cdef convert_item_to_object(self, char *itemp):
  */
   __pyx_t_2 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->assign_item_from_object(__pyx_v_self, __pyx_v_itemp, __pyx_v_value); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 485, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
   /* "View.MemoryView":483
  *             PyMem_Free(tmp)
- *
+ * 
  *     cdef setitem_indexed(self, index, value):             # <<<<<<<<<<<<<<
  *         cdef char *itemp = self.get_item_pointer(index)
  *         self.assign_item_from_object(itemp, value)
  */
 
   /* function exit code */
   __pyx_r = Py_None; __Pyx_INCREF(Py_None);
@@ -11025,15 +11554,15 @@
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "View.MemoryView":487
  *         self.assign_item_from_object(itemp, value)
- *
+ * 
  *     cdef convert_item_to_object(self, char *itemp):             # <<<<<<<<<<<<<<
  *         """Only used if instantiated manually by the user, or if Cython doesn't
  *         know how to convert the type"""
  */
 
 static PyObject *__pyx_memoryview_convert_item_to_object(struct __pyx_memoryview_obj *__pyx_v_self, char *__pyx_v_itemp) {
   PyObject *__pyx_v_struct = NULL;
@@ -11058,35 +11587,35 @@
   __Pyx_RefNannySetupContext("convert_item_to_object", 0);
 
   /* "View.MemoryView":490
  *         """Only used if instantiated manually by the user, or if Cython doesn't
  *         know how to convert the type"""
  *         import struct             # <<<<<<<<<<<<<<
  *         cdef bytes bytesitem
- *
+ * 
  */
   __pyx_t_1 = __Pyx_Import(__pyx_n_s_struct, 0, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 490, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_v_struct = __pyx_t_1;
   __pyx_t_1 = 0;
 
   /* "View.MemoryView":493
  *         cdef bytes bytesitem
- *
+ * 
  *         bytesitem = itemp[:self.view.itemsize]             # <<<<<<<<<<<<<<
  *         try:
  *             result = struct.unpack(self.view.format, bytesitem)
  */
   __pyx_t_1 = __Pyx_PyBytes_FromStringAndSize(__pyx_v_itemp + 0, __pyx_v_self->view.itemsize - 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 493, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_v_bytesitem = ((PyObject*)__pyx_t_1);
   __pyx_t_1 = 0;
 
   /* "View.MemoryView":494
- *
+ * 
  *         bytesitem = itemp[:self.view.itemsize]
  *         try:             # <<<<<<<<<<<<<<
  *             result = struct.unpack(self.view.format, bytesitem)
  *         except struct.error:
  */
   {
     __Pyx_PyThreadState_declare
@@ -11155,15 +11684,15 @@
         __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
       }
       __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
       __pyx_v_result = __pyx_t_1;
       __pyx_t_1 = 0;
 
       /* "View.MemoryView":494
- *
+ * 
  *         bytesitem = itemp[:self.view.itemsize]
  *         try:             # <<<<<<<<<<<<<<
  *             result = struct.unpack(self.view.format, bytesitem)
  *         except struct.error:
  */
     }
 
@@ -11171,24 +11700,24 @@
  *             raise ValueError("Unable to convert item to object")
  *         else:
  *             if len(self.view.format) == 1:             # <<<<<<<<<<<<<<
  *                 return result[0]
  *             return result
  */
     /*else:*/ {
-      __pyx_t_10 = strlen(__pyx_v_self->view.format);
+      __pyx_t_10 = strlen(__pyx_v_self->view.format); 
       __pyx_t_11 = ((__pyx_t_10 == 1) != 0);
       if (__pyx_t_11) {
 
         /* "View.MemoryView":500
  *         else:
  *             if len(self.view.format) == 1:
  *                 return result[0]             # <<<<<<<<<<<<<<
  *             return result
- *
+ * 
  */
         __Pyx_XDECREF(__pyx_r);
         __pyx_t_1 = __Pyx_GetItemInt(__pyx_v_result, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 500, __pyx_L5_except_error)
         __Pyx_GOTREF(__pyx_t_1);
         __pyx_r = __pyx_t_1;
         __pyx_t_1 = 0;
         goto __pyx_L6_except_return;
@@ -11202,15 +11731,15 @@
  */
       }
 
       /* "View.MemoryView":501
  *             if len(self.view.format) == 1:
  *                 return result[0]
  *             return result             # <<<<<<<<<<<<<<
- *
+ * 
  *     cdef assign_item_from_object(self, char *itemp, object value):
  */
       __Pyx_XDECREF(__pyx_r);
       __Pyx_INCREF(__pyx_v_result);
       __pyx_r = __pyx_v_result;
       goto __pyx_L6_except_return;
     }
@@ -11255,15 +11784,15 @@
       __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
       __PYX_ERR(2, 497, __pyx_L5_except_error)
     }
     goto __pyx_L5_except_error;
     __pyx_L5_except_error:;
 
     /* "View.MemoryView":494
- *
+ * 
  *         bytesitem = itemp[:self.view.itemsize]
  *         try:             # <<<<<<<<<<<<<<
  *             result = struct.unpack(self.view.format, bytesitem)
  *         except struct.error:
  */
     __Pyx_XGIVEREF(__pyx_t_2);
     __Pyx_XGIVEREF(__pyx_t_3);
@@ -11276,15 +11805,15 @@
     __Pyx_XGIVEREF(__pyx_t_4);
     __Pyx_ExceptionReset(__pyx_t_2, __pyx_t_3, __pyx_t_4);
     goto __pyx_L0;
   }
 
   /* "View.MemoryView":487
  *         self.assign_item_from_object(itemp, value)
- *
+ * 
  *     cdef convert_item_to_object(self, char *itemp):             # <<<<<<<<<<<<<<
  *         """Only used if instantiated manually by the user, or if Cython doesn't
  *         know how to convert the type"""
  */
 
   /* function exit code */
   __pyx_L1_error:;
@@ -11302,15 +11831,15 @@
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "View.MemoryView":503
  *             return result
- *
+ * 
  *     cdef assign_item_from_object(self, char *itemp, object value):             # <<<<<<<<<<<<<<
  *         """Only used if instantiated manually by the user, or if Cython doesn't
  *         know how to convert the type"""
  */
 
 static PyObject *__pyx_memoryview_assign_item_from_object(struct __pyx_memoryview_obj *__pyx_v_self, char *__pyx_v_itemp, PyObject *__pyx_v_value) {
   PyObject *__pyx_v_struct = NULL;
@@ -11348,25 +11877,25 @@
   __pyx_t_1 = __Pyx_Import(__pyx_n_s_struct, 0, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 506, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_v_struct = __pyx_t_1;
   __pyx_t_1 = 0;
 
   /* "View.MemoryView":511
  *         cdef Py_ssize_t i
- *
+ * 
  *         if isinstance(value, tuple):             # <<<<<<<<<<<<<<
  *             bytesvalue = struct.pack(self.view.format, *value)
  *         else:
  */
-  __pyx_t_2 = PyTuple_Check(__pyx_v_value);
+  __pyx_t_2 = PyTuple_Check(__pyx_v_value); 
   __pyx_t_3 = (__pyx_t_2 != 0);
   if (__pyx_t_3) {
 
     /* "View.MemoryView":512
- *
+ * 
  *         if isinstance(value, tuple):
  *             bytesvalue = struct.pack(self.view.format, *value)             # <<<<<<<<<<<<<<
  *         else:
  *             bytesvalue = struct.pack(self.view.format, value)
  */
     __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_struct, __pyx_n_s_pack); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 512, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
@@ -11389,27 +11918,27 @@
     __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
     if (!(likely(PyBytes_CheckExact(__pyx_t_4))||((__pyx_t_4) == Py_None)||((void)PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "bytes", Py_TYPE(__pyx_t_4)->tp_name), 0))) __PYX_ERR(2, 512, __pyx_L1_error)
     __pyx_v_bytesvalue = ((PyObject*)__pyx_t_4);
     __pyx_t_4 = 0;
 
     /* "View.MemoryView":511
  *         cdef Py_ssize_t i
- *
+ * 
  *         if isinstance(value, tuple):             # <<<<<<<<<<<<<<
  *             bytesvalue = struct.pack(self.view.format, *value)
  *         else:
  */
     goto __pyx_L3;
   }
 
   /* "View.MemoryView":514
  *             bytesvalue = struct.pack(self.view.format, *value)
  *         else:
  *             bytesvalue = struct.pack(self.view.format, value)             # <<<<<<<<<<<<<<
- *
+ * 
  *         for i, c in enumerate(bytesvalue):
  */
   /*else*/ {
     __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_v_struct, __pyx_n_s_pack); if (unlikely(!__pyx_t_6)) __PYX_ERR(2, 514, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_6);
     __pyx_t_1 = __Pyx_PyBytes_FromString(__pyx_v_self->view.format); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 514, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
@@ -11464,18 +11993,18 @@
     __pyx_v_bytesvalue = ((PyObject*)__pyx_t_4);
     __pyx_t_4 = 0;
   }
   __pyx_L3:;
 
   /* "View.MemoryView":516
  *             bytesvalue = struct.pack(self.view.format, value)
- *
+ * 
  *         for i, c in enumerate(bytesvalue):             # <<<<<<<<<<<<<<
  *             itemp[i] = c
- *
+ * 
  */
   __pyx_t_9 = 0;
   if (unlikely(__pyx_v_bytesvalue == Py_None)) {
     PyErr_SetString(PyExc_TypeError, "'NoneType' is not iterable");
     __PYX_ERR(2, 516, __pyx_L1_error)
   }
   __Pyx_INCREF(__pyx_v_bytesvalue);
@@ -11483,45 +12012,45 @@
   __pyx_t_12 = PyBytes_AS_STRING(__pyx_t_10);
   __pyx_t_13 = (__pyx_t_12 + PyBytes_GET_SIZE(__pyx_t_10));
   for (__pyx_t_14 = __pyx_t_12; __pyx_t_14 < __pyx_t_13; __pyx_t_14++) {
     __pyx_t_11 = __pyx_t_14;
     __pyx_v_c = (__pyx_t_11[0]);
 
     /* "View.MemoryView":517
- *
+ * 
  *         for i, c in enumerate(bytesvalue):
  *             itemp[i] = c             # <<<<<<<<<<<<<<
- *
+ * 
  *     @cname('getbuffer')
  */
     __pyx_v_i = __pyx_t_9;
 
     /* "View.MemoryView":516
  *             bytesvalue = struct.pack(self.view.format, value)
- *
+ * 
  *         for i, c in enumerate(bytesvalue):             # <<<<<<<<<<<<<<
  *             itemp[i] = c
- *
+ * 
  */
     __pyx_t_9 = (__pyx_t_9 + 1);
 
     /* "View.MemoryView":517
- *
+ * 
  *         for i, c in enumerate(bytesvalue):
  *             itemp[i] = c             # <<<<<<<<<<<<<<
- *
+ * 
  *     @cname('getbuffer')
  */
     (__pyx_v_itemp[__pyx_v_i]) = __pyx_v_c;
   }
   __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
 
   /* "View.MemoryView":503
  *             return result
- *
+ * 
  *     cdef assign_item_from_object(self, char *itemp, object value):             # <<<<<<<<<<<<<<
  *         """Only used if instantiated manually by the user, or if Cython doesn't
  *         know how to convert the type"""
  */
 
   /* function exit code */
   __pyx_r = Py_None; __Pyx_INCREF(Py_None);
@@ -11540,15 +12069,15 @@
   __Pyx_XDECREF(__pyx_v_bytesvalue);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "View.MemoryView":520
- *
+ * 
  *     @cname('getbuffer')
  *     def __getbuffer__(self, Py_buffer *info, int flags):             # <<<<<<<<<<<<<<
  *         if flags & PyBUF_WRITABLE and self.view.readonly:
  *             raise ValueError("Cannot create writable memory view from read-only memoryview")
  */
 
 /* Python wrapper */
@@ -11587,15 +12116,15 @@
   __Pyx_GIVEREF(__pyx_v_info->obj);
 
   /* "View.MemoryView":521
  *     @cname('getbuffer')
  *     def __getbuffer__(self, Py_buffer *info, int flags):
  *         if flags & PyBUF_WRITABLE and self.view.readonly:             # <<<<<<<<<<<<<<
  *             raise ValueError("Cannot create writable memory view from read-only memoryview")
- *
+ * 
  */
   __pyx_t_2 = ((__pyx_v_flags & PyBUF_WRITABLE) != 0);
   if (__pyx_t_2) {
   } else {
     __pyx_t_1 = __pyx_t_2;
     goto __pyx_L4_bool_binop_done;
   }
@@ -11604,212 +12133,212 @@
   __pyx_L4_bool_binop_done:;
   if (unlikely(__pyx_t_1)) {
 
     /* "View.MemoryView":522
  *     def __getbuffer__(self, Py_buffer *info, int flags):
  *         if flags & PyBUF_WRITABLE and self.view.readonly:
  *             raise ValueError("Cannot create writable memory view from read-only memoryview")             # <<<<<<<<<<<<<<
- *
+ * 
  *         if flags & PyBUF_ND:
  */
     __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__12, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 522, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_Raise(__pyx_t_3, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     __PYX_ERR(2, 522, __pyx_L1_error)
 
     /* "View.MemoryView":521
  *     @cname('getbuffer')
  *     def __getbuffer__(self, Py_buffer *info, int flags):
  *         if flags & PyBUF_WRITABLE and self.view.readonly:             # <<<<<<<<<<<<<<
  *             raise ValueError("Cannot create writable memory view from read-only memoryview")
- *
+ * 
  */
   }
 
   /* "View.MemoryView":524
  *             raise ValueError("Cannot create writable memory view from read-only memoryview")
- *
+ * 
  *         if flags & PyBUF_ND:             # <<<<<<<<<<<<<<
  *             info.shape = self.view.shape
  *         else:
  */
   __pyx_t_1 = ((__pyx_v_flags & PyBUF_ND) != 0);
   if (__pyx_t_1) {
 
     /* "View.MemoryView":525
- *
+ * 
  *         if flags & PyBUF_ND:
  *             info.shape = self.view.shape             # <<<<<<<<<<<<<<
  *         else:
  *             info.shape = NULL
  */
     __pyx_t_4 = __pyx_v_self->view.shape;
     __pyx_v_info->shape = __pyx_t_4;
 
     /* "View.MemoryView":524
  *             raise ValueError("Cannot create writable memory view from read-only memoryview")
- *
+ * 
  *         if flags & PyBUF_ND:             # <<<<<<<<<<<<<<
  *             info.shape = self.view.shape
  *         else:
  */
     goto __pyx_L6;
   }
 
   /* "View.MemoryView":527
  *             info.shape = self.view.shape
  *         else:
  *             info.shape = NULL             # <<<<<<<<<<<<<<
- *
+ * 
  *         if flags & PyBUF_STRIDES:
  */
   /*else*/ {
     __pyx_v_info->shape = NULL;
   }
   __pyx_L6:;
 
   /* "View.MemoryView":529
  *             info.shape = NULL
- *
+ * 
  *         if flags & PyBUF_STRIDES:             # <<<<<<<<<<<<<<
  *             info.strides = self.view.strides
  *         else:
  */
   __pyx_t_1 = ((__pyx_v_flags & PyBUF_STRIDES) != 0);
   if (__pyx_t_1) {
 
     /* "View.MemoryView":530
- *
+ * 
  *         if flags & PyBUF_STRIDES:
  *             info.strides = self.view.strides             # <<<<<<<<<<<<<<
  *         else:
  *             info.strides = NULL
  */
     __pyx_t_4 = __pyx_v_self->view.strides;
     __pyx_v_info->strides = __pyx_t_4;
 
     /* "View.MemoryView":529
  *             info.shape = NULL
- *
+ * 
  *         if flags & PyBUF_STRIDES:             # <<<<<<<<<<<<<<
  *             info.strides = self.view.strides
  *         else:
  */
     goto __pyx_L7;
   }
 
   /* "View.MemoryView":532
  *             info.strides = self.view.strides
  *         else:
  *             info.strides = NULL             # <<<<<<<<<<<<<<
- *
+ * 
  *         if flags & PyBUF_INDIRECT:
  */
   /*else*/ {
     __pyx_v_info->strides = NULL;
   }
   __pyx_L7:;
 
   /* "View.MemoryView":534
  *             info.strides = NULL
- *
+ * 
  *         if flags & PyBUF_INDIRECT:             # <<<<<<<<<<<<<<
  *             info.suboffsets = self.view.suboffsets
  *         else:
  */
   __pyx_t_1 = ((__pyx_v_flags & PyBUF_INDIRECT) != 0);
   if (__pyx_t_1) {
 
     /* "View.MemoryView":535
- *
+ * 
  *         if flags & PyBUF_INDIRECT:
  *             info.suboffsets = self.view.suboffsets             # <<<<<<<<<<<<<<
  *         else:
  *             info.suboffsets = NULL
  */
     __pyx_t_4 = __pyx_v_self->view.suboffsets;
     __pyx_v_info->suboffsets = __pyx_t_4;
 
     /* "View.MemoryView":534
  *             info.strides = NULL
- *
+ * 
  *         if flags & PyBUF_INDIRECT:             # <<<<<<<<<<<<<<
  *             info.suboffsets = self.view.suboffsets
  *         else:
  */
     goto __pyx_L8;
   }
 
   /* "View.MemoryView":537
  *             info.suboffsets = self.view.suboffsets
  *         else:
  *             info.suboffsets = NULL             # <<<<<<<<<<<<<<
- *
+ * 
  *         if flags & PyBUF_FORMAT:
  */
   /*else*/ {
     __pyx_v_info->suboffsets = NULL;
   }
   __pyx_L8:;
 
   /* "View.MemoryView":539
  *             info.suboffsets = NULL
- *
+ * 
  *         if flags & PyBUF_FORMAT:             # <<<<<<<<<<<<<<
  *             info.format = self.view.format
  *         else:
  */
   __pyx_t_1 = ((__pyx_v_flags & PyBUF_FORMAT) != 0);
   if (__pyx_t_1) {
 
     /* "View.MemoryView":540
- *
+ * 
  *         if flags & PyBUF_FORMAT:
  *             info.format = self.view.format             # <<<<<<<<<<<<<<
  *         else:
  *             info.format = NULL
  */
     __pyx_t_5 = __pyx_v_self->view.format;
     __pyx_v_info->format = __pyx_t_5;
 
     /* "View.MemoryView":539
  *             info.suboffsets = NULL
- *
+ * 
  *         if flags & PyBUF_FORMAT:             # <<<<<<<<<<<<<<
  *             info.format = self.view.format
  *         else:
  */
     goto __pyx_L9;
   }
 
   /* "View.MemoryView":542
  *             info.format = self.view.format
  *         else:
  *             info.format = NULL             # <<<<<<<<<<<<<<
- *
+ * 
  *         info.buf = self.view.buf
  */
   /*else*/ {
     __pyx_v_info->format = NULL;
   }
   __pyx_L9:;
 
   /* "View.MemoryView":544
  *             info.format = NULL
- *
+ * 
  *         info.buf = self.view.buf             # <<<<<<<<<<<<<<
  *         info.ndim = self.view.ndim
  *         info.itemsize = self.view.itemsize
  */
   __pyx_t_6 = __pyx_v_self->view.buf;
   __pyx_v_info->buf = __pyx_t_6;
 
   /* "View.MemoryView":545
- *
+ * 
  *         info.buf = self.view.buf
  *         info.ndim = self.view.ndim             # <<<<<<<<<<<<<<
  *         info.itemsize = self.view.itemsize
  *         info.len = self.view.len
  */
   __pyx_t_7 = __pyx_v_self->view.ndim;
   __pyx_v_info->ndim = __pyx_t_7;
@@ -11835,34 +12364,34 @@
   __pyx_v_info->len = __pyx_t_8;
 
   /* "View.MemoryView":548
  *         info.itemsize = self.view.itemsize
  *         info.len = self.view.len
  *         info.readonly = self.view.readonly             # <<<<<<<<<<<<<<
  *         info.obj = self
- *
+ * 
  */
   __pyx_t_1 = __pyx_v_self->view.readonly;
   __pyx_v_info->readonly = __pyx_t_1;
 
   /* "View.MemoryView":549
  *         info.len = self.view.len
  *         info.readonly = self.view.readonly
  *         info.obj = self             # <<<<<<<<<<<<<<
- *
+ * 
  *     __pyx_getbuffer = capsule(<void *> &__pyx_memoryview_getbuffer, "getbuffer(obj, view, flags)")
  */
   __Pyx_INCREF(((PyObject *)__pyx_v_self));
   __Pyx_GIVEREF(((PyObject *)__pyx_v_self));
   __Pyx_GOTREF(__pyx_v_info->obj);
   __Pyx_DECREF(__pyx_v_info->obj);
   __pyx_v_info->obj = ((PyObject *)__pyx_v_self);
 
   /* "View.MemoryView":520
- *
+ * 
  *     @cname('getbuffer')
  *     def __getbuffer__(self, Py_buffer *info, int flags):             # <<<<<<<<<<<<<<
  *         if flags & PyBUF_WRITABLE and self.view.readonly:
  *             raise ValueError("Cannot create writable memory view from read-only memoryview")
  */
 
   /* function exit code */
@@ -11884,15 +12413,15 @@
   }
   __pyx_L2:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "View.MemoryView":555
- *
+ * 
  *     @property
  *     def T(self):             # <<<<<<<<<<<<<<
  *         cdef _memoryviewslice result = memoryview_copy(self)
  *         transpose_memslice(&result.from_slice)
  */
 
 /* Python wrapper */
@@ -11933,32 +12462,32 @@
   __pyx_t_1 = 0;
 
   /* "View.MemoryView":557
  *     def T(self):
  *         cdef _memoryviewslice result = memoryview_copy(self)
  *         transpose_memslice(&result.from_slice)             # <<<<<<<<<<<<<<
  *         return result
- *
+ * 
  */
   __pyx_t_2 = __pyx_memslice_transpose((&__pyx_v_result->from_slice)); if (unlikely(__pyx_t_2 == ((int)0))) __PYX_ERR(2, 557, __pyx_L1_error)
 
   /* "View.MemoryView":558
  *         cdef _memoryviewslice result = memoryview_copy(self)
  *         transpose_memslice(&result.from_slice)
  *         return result             # <<<<<<<<<<<<<<
- *
+ * 
  *     @property
  */
   __Pyx_XDECREF(__pyx_r);
   __Pyx_INCREF(((PyObject *)__pyx_v_result));
   __pyx_r = ((PyObject *)__pyx_v_result);
   goto __pyx_L0;
 
   /* "View.MemoryView":555
- *
+ * 
  *     @property
  *     def T(self):             # <<<<<<<<<<<<<<
  *         cdef _memoryviewslice result = memoryview_copy(self)
  *         transpose_memslice(&result.from_slice)
  */
 
   /* function exit code */
@@ -11970,19 +12499,19 @@
   __Pyx_XDECREF((PyObject *)__pyx_v_result);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "View.MemoryView":561
- *
+ * 
  *     @property
  *     def base(self):             # <<<<<<<<<<<<<<
  *         return self.obj
- *
+ * 
  */
 
 /* Python wrapper */
 static PyObject *__pyx_pw_15View_dot_MemoryView_10memoryview_4base_1__get__(PyObject *__pyx_v_self); /*proto*/
 static PyObject *__pyx_pw_15View_dot_MemoryView_10memoryview_4base_1__get__(PyObject *__pyx_v_self) {
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
@@ -11999,43 +12528,43 @@
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__get__", 0);
 
   /* "View.MemoryView":562
  *     @property
  *     def base(self):
  *         return self.obj             # <<<<<<<<<<<<<<
- *
+ * 
  *     @property
  */
   __Pyx_XDECREF(__pyx_r);
   __Pyx_INCREF(__pyx_v_self->obj);
   __pyx_r = __pyx_v_self->obj;
   goto __pyx_L0;
 
   /* "View.MemoryView":561
- *
+ * 
  *     @property
  *     def base(self):             # <<<<<<<<<<<<<<
  *         return self.obj
- *
+ * 
  */
 
   /* function exit code */
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "View.MemoryView":565
- *
+ * 
  *     @property
  *     def shape(self):             # <<<<<<<<<<<<<<
  *         return tuple([length for length in self.view.shape[:self.view.ndim]])
- *
+ * 
  */
 
 /* Python wrapper */
 static PyObject *__pyx_pw_15View_dot_MemoryView_10memoryview_5shape_1__get__(PyObject *__pyx_v_self); /*proto*/
 static PyObject *__pyx_pw_15View_dot_MemoryView_10memoryview_5shape_1__get__(PyObject *__pyx_v_self) {
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
@@ -12061,15 +12590,15 @@
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__get__", 0);
 
   /* "View.MemoryView":566
  *     @property
  *     def shape(self):
  *         return tuple([length for length in self.view.shape[:self.view.ndim]])             # <<<<<<<<<<<<<<
- *
+ * 
  *     @property
  */
   __Pyx_XDECREF(__pyx_r);
   __pyx_t_1 = PyList_New(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 566, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_t_3 = (__pyx_v_self->view.shape + __pyx_v_self->view.ndim);
   for (__pyx_t_4 = __pyx_v_self->view.shape; __pyx_t_4 < __pyx_t_3; __pyx_t_4++) {
@@ -12084,19 +12613,19 @@
   __Pyx_GOTREF(__pyx_t_5);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __pyx_r = __pyx_t_5;
   __pyx_t_5 = 0;
   goto __pyx_L0;
 
   /* "View.MemoryView":565
- *
+ * 
  *     @property
  *     def shape(self):             # <<<<<<<<<<<<<<
  *         return tuple([length for length in self.view.shape[:self.view.ndim]])
- *
+ * 
  */
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_XDECREF(__pyx_t_5);
   __Pyx_AddTraceback("View.MemoryView.memoryview.shape.__get__", __pyx_clineno, __pyx_lineno, __pyx_filename);
@@ -12104,19 +12633,19 @@
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "View.MemoryView":569
- *
+ * 
  *     @property
  *     def strides(self):             # <<<<<<<<<<<<<<
  *         if self.view.strides == NULL:
- *
+ * 
  */
 
 /* Python wrapper */
 static PyObject *__pyx_pw_15View_dot_MemoryView_10memoryview_7strides_1__get__(PyObject *__pyx_v_self); /*proto*/
 static PyObject *__pyx_pw_15View_dot_MemoryView_10memoryview_7strides_1__get__(PyObject *__pyx_v_self) {
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
@@ -12143,47 +12672,47 @@
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__get__", 0);
 
   /* "View.MemoryView":570
  *     @property
  *     def strides(self):
  *         if self.view.strides == NULL:             # <<<<<<<<<<<<<<
- *
+ * 
  *             raise ValueError("Buffer view does not expose strides")
  */
   __pyx_t_1 = ((__pyx_v_self->view.strides == NULL) != 0);
   if (unlikely(__pyx_t_1)) {
 
     /* "View.MemoryView":572
  *         if self.view.strides == NULL:
- *
+ * 
  *             raise ValueError("Buffer view does not expose strides")             # <<<<<<<<<<<<<<
- *
+ * 
  *         return tuple([stride for stride in self.view.strides[:self.view.ndim]])
  */
     __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__13, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 572, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __Pyx_Raise(__pyx_t_2, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
     __PYX_ERR(2, 572, __pyx_L1_error)
 
     /* "View.MemoryView":570
  *     @property
  *     def strides(self):
  *         if self.view.strides == NULL:             # <<<<<<<<<<<<<<
- *
+ * 
  *             raise ValueError("Buffer view does not expose strides")
  */
   }
 
   /* "View.MemoryView":574
  *             raise ValueError("Buffer view does not expose strides")
- *
+ * 
  *         return tuple([stride for stride in self.view.strides[:self.view.ndim]])             # <<<<<<<<<<<<<<
- *
+ * 
  *     @property
  */
   __Pyx_XDECREF(__pyx_r);
   __pyx_t_2 = PyList_New(0); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 574, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_t_4 = (__pyx_v_self->view.strides + __pyx_v_self->view.ndim);
   for (__pyx_t_5 = __pyx_v_self->view.strides; __pyx_t_5 < __pyx_t_4; __pyx_t_5++) {
@@ -12198,19 +12727,19 @@
   __Pyx_GOTREF(__pyx_t_6);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __pyx_r = __pyx_t_6;
   __pyx_t_6 = 0;
   goto __pyx_L0;
 
   /* "View.MemoryView":569
- *
+ * 
  *     @property
  *     def strides(self):             # <<<<<<<<<<<<<<
  *         if self.view.strides == NULL:
- *
+ * 
  */
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_2);
   __Pyx_XDECREF(__pyx_t_6);
   __Pyx_AddTraceback("View.MemoryView.memoryview.strides.__get__", __pyx_clineno, __pyx_lineno, __pyx_filename);
@@ -12218,15 +12747,15 @@
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "View.MemoryView":577
- *
+ * 
  *     @property
  *     def suboffsets(self):             # <<<<<<<<<<<<<<
  *         if self.view.suboffsets == NULL:
  *             return (-1,) * self.view.ndim
  */
 
 /* Python wrapper */
@@ -12258,24 +12787,24 @@
   __Pyx_RefNannySetupContext("__get__", 0);
 
   /* "View.MemoryView":578
  *     @property
  *     def suboffsets(self):
  *         if self.view.suboffsets == NULL:             # <<<<<<<<<<<<<<
  *             return (-1,) * self.view.ndim
- *
+ * 
  */
   __pyx_t_1 = ((__pyx_v_self->view.suboffsets == NULL) != 0);
   if (__pyx_t_1) {
 
     /* "View.MemoryView":579
  *     def suboffsets(self):
  *         if self.view.suboffsets == NULL:
  *             return (-1,) * self.view.ndim             # <<<<<<<<<<<<<<
- *
+ * 
  *         return tuple([suboffset for suboffset in self.view.suboffsets[:self.view.ndim]])
  */
     __Pyx_XDECREF(__pyx_r);
     __pyx_t_2 = __Pyx_PyInt_From_int(__pyx_v_self->view.ndim); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 579, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __pyx_t_3 = PyNumber_Multiply(__pyx_tuple__14, __pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 579, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
@@ -12285,23 +12814,23 @@
     goto __pyx_L0;
 
     /* "View.MemoryView":578
  *     @property
  *     def suboffsets(self):
  *         if self.view.suboffsets == NULL:             # <<<<<<<<<<<<<<
  *             return (-1,) * self.view.ndim
- *
+ * 
  */
   }
 
   /* "View.MemoryView":581
  *             return (-1,) * self.view.ndim
- *
+ * 
  *         return tuple([suboffset for suboffset in self.view.suboffsets[:self.view.ndim]])             # <<<<<<<<<<<<<<
- *
+ * 
  *     @property
  */
   __Pyx_XDECREF(__pyx_r);
   __pyx_t_3 = PyList_New(0); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 581, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __pyx_t_5 = (__pyx_v_self->view.suboffsets + __pyx_v_self->view.ndim);
   for (__pyx_t_6 = __pyx_v_self->view.suboffsets; __pyx_t_6 < __pyx_t_5; __pyx_t_6++) {
@@ -12316,15 +12845,15 @@
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __pyx_r = __pyx_t_2;
   __pyx_t_2 = 0;
   goto __pyx_L0;
 
   /* "View.MemoryView":577
- *
+ * 
  *     @property
  *     def suboffsets(self):             # <<<<<<<<<<<<<<
  *         if self.view.suboffsets == NULL:
  *             return (-1,) * self.view.ndim
  */
 
   /* function exit code */
@@ -12336,19 +12865,19 @@
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "View.MemoryView":584
- *
+ * 
  *     @property
  *     def ndim(self):             # <<<<<<<<<<<<<<
  *         return self.view.ndim
- *
+ * 
  */
 
 /* Python wrapper */
 static PyObject *__pyx_pw_15View_dot_MemoryView_10memoryview_4ndim_1__get__(PyObject *__pyx_v_self); /*proto*/
 static PyObject *__pyx_pw_15View_dot_MemoryView_10memoryview_4ndim_1__get__(PyObject *__pyx_v_self) {
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
@@ -12369,49 +12898,49 @@
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__get__", 0);
 
   /* "View.MemoryView":585
  *     @property
  *     def ndim(self):
  *         return self.view.ndim             # <<<<<<<<<<<<<<
- *
+ * 
  *     @property
  */
   __Pyx_XDECREF(__pyx_r);
   __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_self->view.ndim); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 585, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
   /* "View.MemoryView":584
- *
+ * 
  *     @property
  *     def ndim(self):             # <<<<<<<<<<<<<<
  *         return self.view.ndim
- *
+ * 
  */
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_AddTraceback("View.MemoryView.memoryview.ndim.__get__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "View.MemoryView":588
- *
+ * 
  *     @property
  *     def itemsize(self):             # <<<<<<<<<<<<<<
  *         return self.view.itemsize
- *
+ * 
  */
 
 /* Python wrapper */
 static PyObject *__pyx_pw_15View_dot_MemoryView_10memoryview_8itemsize_1__get__(PyObject *__pyx_v_self); /*proto*/
 static PyObject *__pyx_pw_15View_dot_MemoryView_10memoryview_8itemsize_1__get__(PyObject *__pyx_v_self) {
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
@@ -12432,49 +12961,49 @@
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__get__", 0);
 
   /* "View.MemoryView":589
  *     @property
  *     def itemsize(self):
  *         return self.view.itemsize             # <<<<<<<<<<<<<<
- *
+ * 
  *     @property
  */
   __Pyx_XDECREF(__pyx_r);
   __pyx_t_1 = PyInt_FromSsize_t(__pyx_v_self->view.itemsize); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 589, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
   /* "View.MemoryView":588
- *
+ * 
  *     @property
  *     def itemsize(self):             # <<<<<<<<<<<<<<
  *         return self.view.itemsize
- *
+ * 
  */
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_AddTraceback("View.MemoryView.memoryview.itemsize.__get__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "View.MemoryView":592
- *
+ * 
  *     @property
  *     def nbytes(self):             # <<<<<<<<<<<<<<
  *         return self.size * self.view.itemsize
- *
+ * 
  */
 
 /* Python wrapper */
 static PyObject *__pyx_pw_15View_dot_MemoryView_10memoryview_6nbytes_1__get__(PyObject *__pyx_v_self); /*proto*/
 static PyObject *__pyx_pw_15View_dot_MemoryView_10memoryview_6nbytes_1__get__(PyObject *__pyx_v_self) {
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
@@ -12497,15 +13026,15 @@
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__get__", 0);
 
   /* "View.MemoryView":593
  *     @property
  *     def nbytes(self):
  *         return self.size * self.view.itemsize             # <<<<<<<<<<<<<<
- *
+ * 
  *     @property
  */
   __Pyx_XDECREF(__pyx_r);
   __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_size); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 593, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_t_2 = PyInt_FromSsize_t(__pyx_v_self->view.itemsize); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 593, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
@@ -12514,19 +13043,19 @@
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __pyx_r = __pyx_t_3;
   __pyx_t_3 = 0;
   goto __pyx_L0;
 
   /* "View.MemoryView":592
- *
+ * 
  *     @property
  *     def nbytes(self):             # <<<<<<<<<<<<<<
  *         return self.size * self.view.itemsize
- *
+ * 
  */
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_XDECREF(__pyx_t_2);
   __Pyx_XDECREF(__pyx_t_3);
@@ -12535,15 +13064,15 @@
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "View.MemoryView":596
- *
+ * 
  *     @property
  *     def size(self):             # <<<<<<<<<<<<<<
  *         if self._size is None:
  *             result = 1
  */
 
 /* Python wrapper */
@@ -12576,94 +13105,94 @@
   __Pyx_RefNannySetupContext("__get__", 0);
 
   /* "View.MemoryView":597
  *     @property
  *     def size(self):
  *         if self._size is None:             # <<<<<<<<<<<<<<
  *             result = 1
- *
+ * 
  */
   __pyx_t_1 = (__pyx_v_self->_size == Py_None);
   __pyx_t_2 = (__pyx_t_1 != 0);
   if (__pyx_t_2) {
 
     /* "View.MemoryView":598
  *     def size(self):
  *         if self._size is None:
  *             result = 1             # <<<<<<<<<<<<<<
- *
+ * 
  *             for length in self.view.shape[:self.view.ndim]:
  */
     __Pyx_INCREF(__pyx_int_1);
     __pyx_v_result = __pyx_int_1;
 
     /* "View.MemoryView":600
  *             result = 1
- *
+ * 
  *             for length in self.view.shape[:self.view.ndim]:             # <<<<<<<<<<<<<<
  *                 result *= length
- *
+ * 
  */
     __pyx_t_4 = (__pyx_v_self->view.shape + __pyx_v_self->view.ndim);
     for (__pyx_t_5 = __pyx_v_self->view.shape; __pyx_t_5 < __pyx_t_4; __pyx_t_5++) {
       __pyx_t_3 = __pyx_t_5;
       __pyx_t_6 = PyInt_FromSsize_t((__pyx_t_3[0])); if (unlikely(!__pyx_t_6)) __PYX_ERR(2, 600, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_6);
       __Pyx_XDECREF_SET(__pyx_v_length, __pyx_t_6);
       __pyx_t_6 = 0;
 
       /* "View.MemoryView":601
- *
+ * 
  *             for length in self.view.shape[:self.view.ndim]:
  *                 result *= length             # <<<<<<<<<<<<<<
- *
+ * 
  *             self._size = result
  */
       __pyx_t_6 = PyNumber_InPlaceMultiply(__pyx_v_result, __pyx_v_length); if (unlikely(!__pyx_t_6)) __PYX_ERR(2, 601, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_6);
       __Pyx_DECREF_SET(__pyx_v_result, __pyx_t_6);
       __pyx_t_6 = 0;
     }
 
     /* "View.MemoryView":603
  *                 result *= length
- *
+ * 
  *             self._size = result             # <<<<<<<<<<<<<<
- *
+ * 
  *         return self._size
  */
     __Pyx_INCREF(__pyx_v_result);
     __Pyx_GIVEREF(__pyx_v_result);
     __Pyx_GOTREF(__pyx_v_self->_size);
     __Pyx_DECREF(__pyx_v_self->_size);
     __pyx_v_self->_size = __pyx_v_result;
 
     /* "View.MemoryView":597
  *     @property
  *     def size(self):
  *         if self._size is None:             # <<<<<<<<<<<<<<
  *             result = 1
- *
+ * 
  */
   }
 
   /* "View.MemoryView":605
  *             self._size = result
- *
+ * 
  *         return self._size             # <<<<<<<<<<<<<<
- *
+ * 
  *     def __len__(self):
  */
   __Pyx_XDECREF(__pyx_r);
   __Pyx_INCREF(__pyx_v_self->_size);
   __pyx_r = __pyx_v_self->_size;
   goto __pyx_L0;
 
   /* "View.MemoryView":596
- *
+ * 
  *     @property
  *     def size(self):             # <<<<<<<<<<<<<<
  *         if self._size is None:
  *             result = 1
  */
 
   /* function exit code */
@@ -12677,15 +13206,15 @@
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "View.MemoryView":607
  *         return self._size
- *
+ * 
  *     def __len__(self):             # <<<<<<<<<<<<<<
  *         if self.view.ndim >= 1:
  *             return self.view.shape[0]
  */
 
 /* Python wrapper */
 static Py_ssize_t __pyx_memoryview___len__(PyObject *__pyx_v_self); /*proto*/
@@ -12703,69 +13232,69 @@
 static Py_ssize_t __pyx_memoryview___pyx_pf_15View_dot_MemoryView_10memoryview_10__len__(struct __pyx_memoryview_obj *__pyx_v_self) {
   Py_ssize_t __pyx_r;
   __Pyx_RefNannyDeclarations
   int __pyx_t_1;
   __Pyx_RefNannySetupContext("__len__", 0);
 
   /* "View.MemoryView":608
- *
+ * 
  *     def __len__(self):
  *         if self.view.ndim >= 1:             # <<<<<<<<<<<<<<
  *             return self.view.shape[0]
- *
+ * 
  */
   __pyx_t_1 = ((__pyx_v_self->view.ndim >= 1) != 0);
   if (__pyx_t_1) {
 
     /* "View.MemoryView":609
  *     def __len__(self):
  *         if self.view.ndim >= 1:
  *             return self.view.shape[0]             # <<<<<<<<<<<<<<
- *
+ * 
  *         return 0
  */
     __pyx_r = (__pyx_v_self->view.shape[0]);
     goto __pyx_L0;
 
     /* "View.MemoryView":608
- *
+ * 
  *     def __len__(self):
  *         if self.view.ndim >= 1:             # <<<<<<<<<<<<<<
  *             return self.view.shape[0]
- *
+ * 
  */
   }
 
   /* "View.MemoryView":611
  *             return self.view.shape[0]
- *
+ * 
  *         return 0             # <<<<<<<<<<<<<<
- *
+ * 
  *     def __repr__(self):
  */
   __pyx_r = 0;
   goto __pyx_L0;
 
   /* "View.MemoryView":607
  *         return self._size
- *
+ * 
  *     def __len__(self):             # <<<<<<<<<<<<<<
  *         if self.view.ndim >= 1:
  *             return self.view.shape[0]
  */
 
   /* function exit code */
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "View.MemoryView":613
  *         return 0
- *
+ * 
  *     def __repr__(self):             # <<<<<<<<<<<<<<
  *         return "<MemoryView of %r at 0x%x>" % (self.base.__class__.__name__,
  *                                                id(self))
  */
 
 /* Python wrapper */
 static PyObject *__pyx_memoryview___repr__(PyObject *__pyx_v_self); /*proto*/
@@ -12788,19 +13317,19 @@
   PyObject *__pyx_t_3 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__repr__", 0);
 
   /* "View.MemoryView":614
- *
+ * 
  *     def __repr__(self):
  *         return "<MemoryView of %r at 0x%x>" % (self.base.__class__.__name__,             # <<<<<<<<<<<<<<
  *                                                id(self))
- *
+ * 
  */
   __Pyx_XDECREF(__pyx_r);
   __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_base); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 614, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_class); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 614, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
@@ -12808,26 +13337,26 @@
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
   /* "View.MemoryView":615
  *     def __repr__(self):
  *         return "<MemoryView of %r at 0x%x>" % (self.base.__class__.__name__,
  *                                                id(self))             # <<<<<<<<<<<<<<
- *
+ * 
  *     def __str__(self):
  */
   __pyx_t_2 = __Pyx_PyObject_CallOneArg(__pyx_builtin_id, ((PyObject *)__pyx_v_self)); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 615, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
 
   /* "View.MemoryView":614
- *
+ * 
  *     def __repr__(self):
  *         return "<MemoryView of %r at 0x%x>" % (self.base.__class__.__name__,             # <<<<<<<<<<<<<<
  *                                                id(self))
- *
+ * 
  */
   __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 614, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_GIVEREF(__pyx_t_1);
   PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_1);
   __Pyx_GIVEREF(__pyx_t_2);
   PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_t_2);
@@ -12838,15 +13367,15 @@
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __pyx_r = __pyx_t_2;
   __pyx_t_2 = 0;
   goto __pyx_L0;
 
   /* "View.MemoryView":613
  *         return 0
- *
+ * 
  *     def __repr__(self):             # <<<<<<<<<<<<<<
  *         return "<MemoryView of %r at 0x%x>" % (self.base.__class__.__name__,
  *                                                id(self))
  */
 
   /* function exit code */
   __pyx_L1_error:;
@@ -12859,18 +13388,18 @@
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "View.MemoryView":617
  *                                                id(self))
- *
+ * 
  *     def __str__(self):             # <<<<<<<<<<<<<<
  *         return "<MemoryView of %r object>" % (self.base.__class__.__name__,)
- *
+ * 
  */
 
 /* Python wrapper */
 static PyObject *__pyx_memoryview___str__(PyObject *__pyx_v_self); /*proto*/
 static PyObject *__pyx_memoryview___str__(PyObject *__pyx_v_self) {
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
@@ -12889,19 +13418,19 @@
   PyObject *__pyx_t_2 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__str__", 0);
 
   /* "View.MemoryView":618
- *
+ * 
  *     def __str__(self):
  *         return "<MemoryView of %r object>" % (self.base.__class__.__name__,)             # <<<<<<<<<<<<<<
- *
- *
+ * 
+ * 
  */
   __Pyx_XDECREF(__pyx_r);
   __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_base); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 618, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_class); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 618, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
@@ -12918,18 +13447,18 @@
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
   /* "View.MemoryView":617
  *                                                id(self))
- *
+ * 
  *     def __str__(self):             # <<<<<<<<<<<<<<
  *         return "<MemoryView of %r object>" % (self.base.__class__.__name__,)
- *
+ * 
  */
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_XDECREF(__pyx_t_2);
   __Pyx_AddTraceback("View.MemoryView.memoryview.__str__", __pyx_clineno, __pyx_lineno, __pyx_filename);
@@ -12937,16 +13466,16 @@
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "View.MemoryView":621
- *
- *
+ * 
+ * 
  *     def is_c_contig(self):             # <<<<<<<<<<<<<<
  *         cdef __Pyx_memviewslice *mslice
  *         cdef __Pyx_memviewslice tmp
  */
 
 /* Python wrapper */
 static PyObject *__pyx_memoryview_is_c_contig(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
@@ -12974,36 +13503,36 @@
   __Pyx_RefNannySetupContext("is_c_contig", 0);
 
   /* "View.MemoryView":624
  *         cdef __Pyx_memviewslice *mslice
  *         cdef __Pyx_memviewslice tmp
  *         mslice = get_slice_from_memview(self, &tmp)             # <<<<<<<<<<<<<<
  *         return slice_is_contig(mslice[0], 'C', self.view.ndim)
- *
+ * 
  */
   __pyx_t_1 = __pyx_memoryview_get_slice_from_memoryview(__pyx_v_self, (&__pyx_v_tmp)); if (unlikely(__pyx_t_1 == ((__Pyx_memviewslice *)NULL))) __PYX_ERR(2, 624, __pyx_L1_error)
   __pyx_v_mslice = __pyx_t_1;
 
   /* "View.MemoryView":625
  *         cdef __Pyx_memviewslice tmp
  *         mslice = get_slice_from_memview(self, &tmp)
  *         return slice_is_contig(mslice[0], 'C', self.view.ndim)             # <<<<<<<<<<<<<<
- *
+ * 
  *     def is_f_contig(self):
  */
   __Pyx_XDECREF(__pyx_r);
   __pyx_t_2 = __Pyx_PyBool_FromLong(__pyx_memviewslice_is_contig((__pyx_v_mslice[0]), 'C', __pyx_v_self->view.ndim)); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 625, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_r = __pyx_t_2;
   __pyx_t_2 = 0;
   goto __pyx_L0;
 
   /* "View.MemoryView":621
- *
- *
+ * 
+ * 
  *     def is_c_contig(self):             # <<<<<<<<<<<<<<
  *         cdef __Pyx_memviewslice *mslice
  *         cdef __Pyx_memviewslice tmp
  */
 
   /* function exit code */
   __pyx_L1_error:;
@@ -13014,15 +13543,15 @@
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "View.MemoryView":627
  *         return slice_is_contig(mslice[0], 'C', self.view.ndim)
- *
+ * 
  *     def is_f_contig(self):             # <<<<<<<<<<<<<<
  *         cdef __Pyx_memviewslice *mslice
  *         cdef __Pyx_memviewslice tmp
  */
 
 /* Python wrapper */
 static PyObject *__pyx_memoryview_is_f_contig(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
@@ -13050,36 +13579,36 @@
   __Pyx_RefNannySetupContext("is_f_contig", 0);
 
   /* "View.MemoryView":630
  *         cdef __Pyx_memviewslice *mslice
  *         cdef __Pyx_memviewslice tmp
  *         mslice = get_slice_from_memview(self, &tmp)             # <<<<<<<<<<<<<<
  *         return slice_is_contig(mslice[0], 'F', self.view.ndim)
- *
+ * 
  */
   __pyx_t_1 = __pyx_memoryview_get_slice_from_memoryview(__pyx_v_self, (&__pyx_v_tmp)); if (unlikely(__pyx_t_1 == ((__Pyx_memviewslice *)NULL))) __PYX_ERR(2, 630, __pyx_L1_error)
   __pyx_v_mslice = __pyx_t_1;
 
   /* "View.MemoryView":631
  *         cdef __Pyx_memviewslice tmp
  *         mslice = get_slice_from_memview(self, &tmp)
  *         return slice_is_contig(mslice[0], 'F', self.view.ndim)             # <<<<<<<<<<<<<<
- *
+ * 
  *     def copy(self):
  */
   __Pyx_XDECREF(__pyx_r);
   __pyx_t_2 = __Pyx_PyBool_FromLong(__pyx_memviewslice_is_contig((__pyx_v_mslice[0]), 'F', __pyx_v_self->view.ndim)); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 631, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_r = __pyx_t_2;
   __pyx_t_2 = 0;
   goto __pyx_L0;
 
   /* "View.MemoryView":627
  *         return slice_is_contig(mslice[0], 'C', self.view.ndim)
- *
+ * 
  *     def is_f_contig(self):             # <<<<<<<<<<<<<<
  *         cdef __Pyx_memviewslice *mslice
  *         cdef __Pyx_memviewslice tmp
  */
 
   /* function exit code */
   __pyx_L1_error:;
@@ -13090,15 +13619,15 @@
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "View.MemoryView":633
  *         return slice_is_contig(mslice[0], 'F', self.view.ndim)
- *
+ * 
  *     def copy(self):             # <<<<<<<<<<<<<<
  *         cdef __Pyx_memviewslice mslice
  *         cdef int flags = self.flags & ~PyBUF_F_CONTIGUOUS
  */
 
 /* Python wrapper */
 static PyObject *__pyx_memoryview_copy(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
@@ -13125,55 +13654,55 @@
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("copy", 0);
 
   /* "View.MemoryView":635
  *     def copy(self):
  *         cdef __Pyx_memviewslice mslice
  *         cdef int flags = self.flags & ~PyBUF_F_CONTIGUOUS             # <<<<<<<<<<<<<<
- *
+ * 
  *         slice_copy(self, &mslice)
  */
   __pyx_v_flags = (__pyx_v_self->flags & (~PyBUF_F_CONTIGUOUS));
 
   /* "View.MemoryView":637
  *         cdef int flags = self.flags & ~PyBUF_F_CONTIGUOUS
- *
+ * 
  *         slice_copy(self, &mslice)             # <<<<<<<<<<<<<<
  *         mslice = slice_copy_contig(&mslice, "c", self.view.ndim,
  *                                    self.view.itemsize,
  */
   __pyx_memoryview_slice_copy(__pyx_v_self, (&__pyx_v_mslice));
 
   /* "View.MemoryView":638
- *
+ * 
  *         slice_copy(self, &mslice)
  *         mslice = slice_copy_contig(&mslice, "c", self.view.ndim,             # <<<<<<<<<<<<<<
  *                                    self.view.itemsize,
  *                                    flags|PyBUF_C_CONTIGUOUS,
  */
   __pyx_t_1 = __pyx_memoryview_copy_new_contig((&__pyx_v_mslice), ((char *)"c"), __pyx_v_self->view.ndim, __pyx_v_self->view.itemsize, (__pyx_v_flags | PyBUF_C_CONTIGUOUS), __pyx_v_self->dtype_is_object); if (unlikely(PyErr_Occurred())) __PYX_ERR(2, 638, __pyx_L1_error)
   __pyx_v_mslice = __pyx_t_1;
 
   /* "View.MemoryView":643
  *                                    self.dtype_is_object)
- *
+ * 
  *         return memoryview_copy_from_slice(self, &mslice)             # <<<<<<<<<<<<<<
- *
+ * 
  *     def copy_fortran(self):
  */
   __Pyx_XDECREF(__pyx_r);
   __pyx_t_2 = __pyx_memoryview_copy_object_from_slice(__pyx_v_self, (&__pyx_v_mslice)); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 643, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_r = __pyx_t_2;
   __pyx_t_2 = 0;
   goto __pyx_L0;
 
   /* "View.MemoryView":633
  *         return slice_is_contig(mslice[0], 'F', self.view.ndim)
- *
+ * 
  *     def copy(self):             # <<<<<<<<<<<<<<
  *         cdef __Pyx_memviewslice mslice
  *         cdef int flags = self.flags & ~PyBUF_F_CONTIGUOUS
  */
 
   /* function exit code */
   __pyx_L1_error:;
@@ -13184,15 +13713,15 @@
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "View.MemoryView":645
  *         return memoryview_copy_from_slice(self, &mslice)
- *
+ * 
  *     def copy_fortran(self):             # <<<<<<<<<<<<<<
  *         cdef __Pyx_memviewslice src, dst
  *         cdef int flags = self.flags & ~PyBUF_C_CONTIGUOUS
  */
 
 /* Python wrapper */
 static PyObject *__pyx_memoryview_copy_fortran(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
@@ -13220,55 +13749,55 @@
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("copy_fortran", 0);
 
   /* "View.MemoryView":647
  *     def copy_fortran(self):
  *         cdef __Pyx_memviewslice src, dst
  *         cdef int flags = self.flags & ~PyBUF_C_CONTIGUOUS             # <<<<<<<<<<<<<<
- *
+ * 
  *         slice_copy(self, &src)
  */
   __pyx_v_flags = (__pyx_v_self->flags & (~PyBUF_C_CONTIGUOUS));
 
   /* "View.MemoryView":649
  *         cdef int flags = self.flags & ~PyBUF_C_CONTIGUOUS
- *
+ * 
  *         slice_copy(self, &src)             # <<<<<<<<<<<<<<
  *         dst = slice_copy_contig(&src, "fortran", self.view.ndim,
  *                                 self.view.itemsize,
  */
   __pyx_memoryview_slice_copy(__pyx_v_self, (&__pyx_v_src));
 
   /* "View.MemoryView":650
- *
+ * 
  *         slice_copy(self, &src)
  *         dst = slice_copy_contig(&src, "fortran", self.view.ndim,             # <<<<<<<<<<<<<<
  *                                 self.view.itemsize,
  *                                 flags|PyBUF_F_CONTIGUOUS,
  */
   __pyx_t_1 = __pyx_memoryview_copy_new_contig((&__pyx_v_src), ((char *)"fortran"), __pyx_v_self->view.ndim, __pyx_v_self->view.itemsize, (__pyx_v_flags | PyBUF_F_CONTIGUOUS), __pyx_v_self->dtype_is_object); if (unlikely(PyErr_Occurred())) __PYX_ERR(2, 650, __pyx_L1_error)
   __pyx_v_dst = __pyx_t_1;
 
   /* "View.MemoryView":655
  *                                 self.dtype_is_object)
- *
+ * 
  *         return memoryview_copy_from_slice(self, &dst)             # <<<<<<<<<<<<<<
- *
- *
+ * 
+ * 
  */
   __Pyx_XDECREF(__pyx_r);
   __pyx_t_2 = __pyx_memoryview_copy_object_from_slice(__pyx_v_self, (&__pyx_v_dst)); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 655, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_r = __pyx_t_2;
   __pyx_t_2 = 0;
   goto __pyx_L0;
 
   /* "View.MemoryView":645
  *         return memoryview_copy_from_slice(self, &mslice)
- *
+ * 
  *     def copy_fortran(self):             # <<<<<<<<<<<<<<
  *         cdef __Pyx_memviewslice src, dst
  *         cdef int flags = self.flags & ~PyBUF_C_CONTIGUOUS
  */
 
   /* function exit code */
   __pyx_L1_error:;
@@ -13391,15 +13920,15 @@
   __pyx_r = NULL;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "View.MemoryView":659
- *
+ * 
  * @cname('__pyx_memoryview_new')
  * cdef memoryview_cwrapper(object o, int flags, bint dtype_is_object, __Pyx_TypeInfo *typeinfo):             # <<<<<<<<<<<<<<
  *     cdef memoryview result = memoryview(o, flags, dtype_is_object)
  *     result.typeinfo = typeinfo
  */
 
 static PyObject *__pyx_memoryview_new(PyObject *__pyx_v_o, int __pyx_v_flags, int __pyx_v_dtype_is_object, __Pyx_TypeInfo *__pyx_v_typeinfo) {
@@ -13443,32 +13972,32 @@
   __pyx_t_2 = 0;
 
   /* "View.MemoryView":661
  * cdef memoryview_cwrapper(object o, int flags, bint dtype_is_object, __Pyx_TypeInfo *typeinfo):
  *     cdef memoryview result = memoryview(o, flags, dtype_is_object)
  *     result.typeinfo = typeinfo             # <<<<<<<<<<<<<<
  *     return result
- *
+ * 
  */
   __pyx_v_result->typeinfo = __pyx_v_typeinfo;
 
   /* "View.MemoryView":662
  *     cdef memoryview result = memoryview(o, flags, dtype_is_object)
  *     result.typeinfo = typeinfo
  *     return result             # <<<<<<<<<<<<<<
- *
+ * 
  * @cname('__pyx_memoryview_check')
  */
   __Pyx_XDECREF(__pyx_r);
   __Pyx_INCREF(((PyObject *)__pyx_v_result));
   __pyx_r = ((PyObject *)__pyx_v_result);
   goto __pyx_L0;
 
   /* "View.MemoryView":659
- *
+ * 
  * @cname('__pyx_memoryview_new')
  * cdef memoryview_cwrapper(object o, int flags, bint dtype_is_object, __Pyx_TypeInfo *typeinfo):             # <<<<<<<<<<<<<<
  *     cdef memoryview result = memoryview(o, flags, dtype_is_object)
  *     result.typeinfo = typeinfo
  */
 
   /* function exit code */
@@ -13482,55 +14011,55 @@
   __Pyx_XDECREF((PyObject *)__pyx_v_result);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "View.MemoryView":665
- *
+ * 
  * @cname('__pyx_memoryview_check')
  * cdef inline bint memoryview_check(object o):             # <<<<<<<<<<<<<<
  *     return isinstance(o, memoryview)
- *
+ * 
  */
 
 static CYTHON_INLINE int __pyx_memoryview_check(PyObject *__pyx_v_o) {
   int __pyx_r;
   __Pyx_RefNannyDeclarations
   int __pyx_t_1;
   __Pyx_RefNannySetupContext("memoryview_check", 0);
 
   /* "View.MemoryView":666
  * @cname('__pyx_memoryview_check')
  * cdef inline bint memoryview_check(object o):
  *     return isinstance(o, memoryview)             # <<<<<<<<<<<<<<
- *
+ * 
  * cdef tuple _unellipsify(object index, int ndim):
  */
-  __pyx_t_1 = __Pyx_TypeCheck(__pyx_v_o, __pyx_memoryview_type);
+  __pyx_t_1 = __Pyx_TypeCheck(__pyx_v_o, __pyx_memoryview_type); 
   __pyx_r = __pyx_t_1;
   goto __pyx_L0;
 
   /* "View.MemoryView":665
- *
+ * 
  * @cname('__pyx_memoryview_check')
  * cdef inline bint memoryview_check(object o):             # <<<<<<<<<<<<<<
  *     return isinstance(o, memoryview)
- *
+ * 
  */
 
   /* function exit code */
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "View.MemoryView":668
  *     return isinstance(o, memoryview)
- *
+ * 
  * cdef tuple _unellipsify(object index, int ndim):             # <<<<<<<<<<<<<<
  *     """
  *     Replace all ellipses with full slices and fill incomplete indices with
  */
 
 static PyObject *_unellipsify(PyObject *__pyx_v_index, int __pyx_v_ndim) {
   PyObject *__pyx_v_tup = NULL;
@@ -13561,15 +14090,15 @@
   /* "View.MemoryView":673
  *     full slices.
  *     """
  *     if not isinstance(index, tuple):             # <<<<<<<<<<<<<<
  *         tup = (index,)
  *     else:
  */
-  __pyx_t_1 = PyTuple_Check(__pyx_v_index);
+  __pyx_t_1 = PyTuple_Check(__pyx_v_index); 
   __pyx_t_2 = ((!(__pyx_t_1 != 0)) != 0);
   if (__pyx_t_2) {
 
     /* "View.MemoryView":674
  *     """
  *     if not isinstance(index, tuple):
  *         tup = (index,)             # <<<<<<<<<<<<<<
@@ -13594,37 +14123,37 @@
     goto __pyx_L3;
   }
 
   /* "View.MemoryView":676
  *         tup = (index,)
  *     else:
  *         tup = index             # <<<<<<<<<<<<<<
- *
+ * 
  *     result = []
  */
   /*else*/ {
     __Pyx_INCREF(__pyx_v_index);
     __pyx_v_tup = __pyx_v_index;
   }
   __pyx_L3:;
 
   /* "View.MemoryView":678
  *         tup = index
- *
+ * 
  *     result = []             # <<<<<<<<<<<<<<
  *     have_slices = False
  *     seen_ellipsis = False
  */
   __pyx_t_3 = PyList_New(0); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 678, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __pyx_v_result = ((PyObject*)__pyx_t_3);
   __pyx_t_3 = 0;
 
   /* "View.MemoryView":679
- *
+ * 
  *     result = []
  *     have_slices = False             # <<<<<<<<<<<<<<
  *     seen_ellipsis = False
  *     for idx, item in enumerate(tup):
  */
   __pyx_v_have_slices = 0;
 
@@ -13787,18 +14316,18 @@
     }
 
     /* "View.MemoryView":690
  *             have_slices = True
  *         else:
  *             if not isinstance(item, slice) and not PyIndex_Check(item):             # <<<<<<<<<<<<<<
  *                 raise TypeError("Cannot index with type '%s'" % type(item))
- *
+ * 
  */
     /*else*/ {
-      __pyx_t_2 = PySlice_Check(__pyx_v_item);
+      __pyx_t_2 = PySlice_Check(__pyx_v_item); 
       __pyx_t_10 = ((!(__pyx_t_2 != 0)) != 0);
       if (__pyx_t_10) {
       } else {
         __pyx_t_1 = __pyx_t_10;
         goto __pyx_L9_bool_binop_done;
       }
       __pyx_t_10 = ((!(PyIndex_Check(__pyx_v_item) != 0)) != 0);
@@ -13806,15 +14335,15 @@
       __pyx_L9_bool_binop_done:;
       if (unlikely(__pyx_t_1)) {
 
         /* "View.MemoryView":691
  *         else:
  *             if not isinstance(item, slice) and not PyIndex_Check(item):
  *                 raise TypeError("Cannot index with type '%s'" % type(item))             # <<<<<<<<<<<<<<
- *
+ * 
  *             have_slices = have_slices or isinstance(item, slice)
  */
         __pyx_t_7 = __Pyx_PyString_FormatSafe(__pyx_kp_s_Cannot_index_with_type_s, ((PyObject *)Py_TYPE(__pyx_v_item))); if (unlikely(!__pyx_t_7)) __PYX_ERR(2, 691, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_7);
         __pyx_t_11 = __Pyx_PyObject_CallOneArg(__pyx_builtin_TypeError, __pyx_t_7); if (unlikely(!__pyx_t_11)) __PYX_ERR(2, 691, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_11);
         __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
@@ -13823,42 +14352,42 @@
         __PYX_ERR(2, 691, __pyx_L1_error)
 
         /* "View.MemoryView":690
  *             have_slices = True
  *         else:
  *             if not isinstance(item, slice) and not PyIndex_Check(item):             # <<<<<<<<<<<<<<
  *                 raise TypeError("Cannot index with type '%s'" % type(item))
- *
+ * 
  */
       }
 
       /* "View.MemoryView":693
  *                 raise TypeError("Cannot index with type '%s'" % type(item))
- *
+ * 
  *             have_slices = have_slices or isinstance(item, slice)             # <<<<<<<<<<<<<<
  *             result.append(item)
- *
+ * 
  */
       __pyx_t_10 = (__pyx_v_have_slices != 0);
       if (!__pyx_t_10) {
       } else {
         __pyx_t_1 = __pyx_t_10;
         goto __pyx_L11_bool_binop_done;
       }
-      __pyx_t_10 = PySlice_Check(__pyx_v_item);
+      __pyx_t_10 = PySlice_Check(__pyx_v_item); 
       __pyx_t_2 = (__pyx_t_10 != 0);
       __pyx_t_1 = __pyx_t_2;
       __pyx_L11_bool_binop_done:;
       __pyx_v_have_slices = __pyx_t_1;
 
       /* "View.MemoryView":694
- *
+ * 
  *             have_slices = have_slices or isinstance(item, slice)
  *             result.append(item)             # <<<<<<<<<<<<<<
- *
+ * 
  *     nslices = ndim - len(result)
  */
       __pyx_t_9 = __Pyx_PyList_Append(__pyx_v_result, __pyx_v_item); if (unlikely(__pyx_t_9 == ((int)-1))) __PYX_ERR(2, 694, __pyx_L1_error)
     }
     __pyx_L6:;
 
     /* "View.MemoryView":681
@@ -13870,37 +14399,37 @@
  */
   }
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
   /* "View.MemoryView":696
  *             result.append(item)
- *
+ * 
  *     nslices = ndim - len(result)             # <<<<<<<<<<<<<<
  *     if nslices:
  *         result.extend([slice(None)] * nslices)
  */
   __pyx_t_5 = PyList_GET_SIZE(__pyx_v_result); if (unlikely(__pyx_t_5 == ((Py_ssize_t)-1))) __PYX_ERR(2, 696, __pyx_L1_error)
   __pyx_v_nslices = (__pyx_v_ndim - __pyx_t_5);
 
   /* "View.MemoryView":697
- *
+ * 
  *     nslices = ndim - len(result)
  *     if nslices:             # <<<<<<<<<<<<<<
  *         result.extend([slice(None)] * nslices)
- *
+ * 
  */
   __pyx_t_1 = (__pyx_v_nslices != 0);
   if (__pyx_t_1) {
 
     /* "View.MemoryView":698
  *     nslices = ndim - len(result)
  *     if nslices:
  *         result.extend([slice(None)] * nslices)             # <<<<<<<<<<<<<<
- *
+ * 
  *     return have_slices or nslices, tuple(result)
  */
     __pyx_t_3 = PyList_New(1 * ((__pyx_v_nslices<0) ? 0:__pyx_v_nslices)); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 698, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     { Py_ssize_t __pyx_temp;
       for (__pyx_temp=0; __pyx_temp < __pyx_v_nslices; __pyx_temp++) {
         __Pyx_INCREF(__pyx_slice__17);
@@ -13908,27 +14437,27 @@
         PyList_SET_ITEM(__pyx_t_3, __pyx_temp, __pyx_slice__17);
       }
     }
     __pyx_t_9 = __Pyx_PyList_Extend(__pyx_v_result, __pyx_t_3); if (unlikely(__pyx_t_9 == ((int)-1))) __PYX_ERR(2, 698, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
     /* "View.MemoryView":697
- *
+ * 
  *     nslices = ndim - len(result)
  *     if nslices:             # <<<<<<<<<<<<<<
  *         result.extend([slice(None)] * nslices)
- *
+ * 
  */
   }
 
   /* "View.MemoryView":700
  *         result.extend([slice(None)] * nslices)
- *
+ * 
  *     return have_slices or nslices, tuple(result)             # <<<<<<<<<<<<<<
- *
+ * 
  * cdef assert_direct_dimensions(Py_ssize_t *suboffsets, int ndim):
  */
   __Pyx_XDECREF(__pyx_r);
   if (!__pyx_v_have_slices) {
   } else {
     __pyx_t_4 = __Pyx_PyBool_FromLong(__pyx_v_have_slices); if (unlikely(!__pyx_t_4)) __PYX_ERR(2, 700, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
@@ -13953,15 +14482,15 @@
   __pyx_t_4 = 0;
   __pyx_r = ((PyObject*)__pyx_t_11);
   __pyx_t_11 = 0;
   goto __pyx_L0;
 
   /* "View.MemoryView":668
  *     return isinstance(o, memoryview)
- *
+ * 
  * cdef tuple _unellipsify(object index, int ndim):             # <<<<<<<<<<<<<<
  *     """
  *     Replace all ellipses with full slices and fill incomplete indices with
  */
 
   /* function exit code */
   __pyx_L1_error:;
@@ -13979,15 +14508,15 @@
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "View.MemoryView":702
  *     return have_slices or nslices, tuple(result)
- *
+ * 
  * cdef assert_direct_dimensions(Py_ssize_t *suboffsets, int ndim):             # <<<<<<<<<<<<<<
  *     for suboffset in suboffsets[:ndim]:
  *         if suboffset >= 0:
  */
 
 static PyObject *assert_direct_dimensions(Py_ssize_t *__pyx_v_suboffsets, int __pyx_v_ndim) {
   Py_ssize_t __pyx_v_suboffset;
@@ -14000,15 +14529,15 @@
   PyObject *__pyx_t_5 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("assert_direct_dimensions", 0);
 
   /* "View.MemoryView":703
- *
+ * 
  * cdef assert_direct_dimensions(Py_ssize_t *suboffsets, int ndim):
  *     for suboffset in suboffsets[:ndim]:             # <<<<<<<<<<<<<<
  *         if suboffset >= 0:
  *             raise ValueError("Indirect dimensions not supported")
  */
   __pyx_t_2 = (__pyx_v_suboffsets + __pyx_v_ndim);
   for (__pyx_t_3 = __pyx_v_suboffsets; __pyx_t_3 < __pyx_t_2; __pyx_t_3++) {
@@ -14016,45 +14545,45 @@
     __pyx_v_suboffset = (__pyx_t_1[0]);
 
     /* "View.MemoryView":704
  * cdef assert_direct_dimensions(Py_ssize_t *suboffsets, int ndim):
  *     for suboffset in suboffsets[:ndim]:
  *         if suboffset >= 0:             # <<<<<<<<<<<<<<
  *             raise ValueError("Indirect dimensions not supported")
- *
+ * 
  */
     __pyx_t_4 = ((__pyx_v_suboffset >= 0) != 0);
     if (unlikely(__pyx_t_4)) {
 
       /* "View.MemoryView":705
  *     for suboffset in suboffsets[:ndim]:
  *         if suboffset >= 0:
  *             raise ValueError("Indirect dimensions not supported")             # <<<<<<<<<<<<<<
- *
- *
+ * 
+ * 
  */
       __pyx_t_5 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__18, NULL); if (unlikely(!__pyx_t_5)) __PYX_ERR(2, 705, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_5);
       __Pyx_Raise(__pyx_t_5, 0, 0, 0);
       __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
       __PYX_ERR(2, 705, __pyx_L1_error)
 
       /* "View.MemoryView":704
  * cdef assert_direct_dimensions(Py_ssize_t *suboffsets, int ndim):
  *     for suboffset in suboffsets[:ndim]:
  *         if suboffset >= 0:             # <<<<<<<<<<<<<<
  *             raise ValueError("Indirect dimensions not supported")
- *
+ * 
  */
     }
   }
 
   /* "View.MemoryView":702
  *     return have_slices or nslices, tuple(result)
- *
+ * 
  * cdef assert_direct_dimensions(Py_ssize_t *suboffsets, int ndim):             # <<<<<<<<<<<<<<
  *     for suboffset in suboffsets[:ndim]:
  *         if suboffset >= 0:
  */
 
   /* function exit code */
   __pyx_r = Py_None; __Pyx_INCREF(Py_None);
@@ -14066,15 +14595,15 @@
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "View.MemoryView":712
- *
+ * 
  * @cname('__pyx_memview_slice')
  * cdef memoryview memview_slice(memoryview memview, object indices):             # <<<<<<<<<<<<<<
  *     cdef int new_ndim = 0, suboffset_dim = -1, dim
  *     cdef bint negative_step
  */
 
 static struct __pyx_memoryview_obj *__pyx_memview_slice(struct __pyx_memoryview_obj *__pyx_v_memview, PyObject *__pyx_v_indices) {
@@ -14120,51 +14649,51 @@
  *     cdef bint negative_step
  *     cdef __Pyx_memviewslice src, dst
  */
   __pyx_v_new_ndim = 0;
   __pyx_v_suboffset_dim = -1;
 
   /* "View.MemoryView":720
- *
- *
+ * 
+ * 
  *     memset(&dst, 0, sizeof(dst))             # <<<<<<<<<<<<<<
- *
+ * 
  *     cdef _memoryviewslice memviewsliceobj
  */
   (void)(memset((&__pyx_v_dst), 0, (sizeof(__pyx_v_dst))));
 
   /* "View.MemoryView":724
  *     cdef _memoryviewslice memviewsliceobj
- *
+ * 
  *     assert memview.view.ndim > 0             # <<<<<<<<<<<<<<
- *
+ * 
  *     if isinstance(memview, _memoryviewslice):
  */
   #ifndef CYTHON_WITHOUT_ASSERTIONS
   if (unlikely(!Py_OptimizeFlag)) {
     if (unlikely(!((__pyx_v_memview->view.ndim > 0) != 0))) {
       PyErr_SetNone(PyExc_AssertionError);
       __PYX_ERR(2, 724, __pyx_L1_error)
     }
   }
   #endif
 
   /* "View.MemoryView":726
  *     assert memview.view.ndim > 0
- *
+ * 
  *     if isinstance(memview, _memoryviewslice):             # <<<<<<<<<<<<<<
  *         memviewsliceobj = memview
  *         p_src = &memviewsliceobj.from_slice
  */
-  __pyx_t_1 = __Pyx_TypeCheck(((PyObject *)__pyx_v_memview), __pyx_memoryviewslice_type);
+  __pyx_t_1 = __Pyx_TypeCheck(((PyObject *)__pyx_v_memview), __pyx_memoryviewslice_type); 
   __pyx_t_2 = (__pyx_t_1 != 0);
   if (__pyx_t_2) {
 
     /* "View.MemoryView":727
- *
+ * 
  *     if isinstance(memview, _memoryviewslice):
  *         memviewsliceobj = memview             # <<<<<<<<<<<<<<
  *         p_src = &memviewsliceobj.from_slice
  *     else:
  */
     if (!(likely(((((PyObject *)__pyx_v_memview)) == Py_None) || likely(__Pyx_TypeTest(((PyObject *)__pyx_v_memview), __pyx_memoryviewslice_type))))) __PYX_ERR(2, 727, __pyx_L1_error)
     __pyx_t_3 = ((PyObject *)__pyx_v_memview);
@@ -14179,84 +14708,84 @@
  *     else:
  *         slice_copy(memview, &src)
  */
     __pyx_v_p_src = (&__pyx_v_memviewsliceobj->from_slice);
 
     /* "View.MemoryView":726
  *     assert memview.view.ndim > 0
- *
+ * 
  *     if isinstance(memview, _memoryviewslice):             # <<<<<<<<<<<<<<
  *         memviewsliceobj = memview
  *         p_src = &memviewsliceobj.from_slice
  */
     goto __pyx_L3;
   }
 
   /* "View.MemoryView":730
  *         p_src = &memviewsliceobj.from_slice
  *     else:
  *         slice_copy(memview, &src)             # <<<<<<<<<<<<<<
  *         p_src = &src
- *
+ * 
  */
   /*else*/ {
     __pyx_memoryview_slice_copy(__pyx_v_memview, (&__pyx_v_src));
 
     /* "View.MemoryView":731
  *     else:
  *         slice_copy(memview, &src)
  *         p_src = &src             # <<<<<<<<<<<<<<
- *
- *
+ * 
+ * 
  */
     __pyx_v_p_src = (&__pyx_v_src);
   }
   __pyx_L3:;
 
   /* "View.MemoryView":737
- *
- *
+ * 
+ * 
  *     dst.memview = p_src.memview             # <<<<<<<<<<<<<<
  *     dst.data = p_src.data
- *
+ * 
  */
   __pyx_t_4 = __pyx_v_p_src->memview;
   __pyx_v_dst.memview = __pyx_t_4;
 
   /* "View.MemoryView":738
- *
+ * 
  *     dst.memview = p_src.memview
  *     dst.data = p_src.data             # <<<<<<<<<<<<<<
- *
- *
+ * 
+ * 
  */
   __pyx_t_5 = __pyx_v_p_src->data;
   __pyx_v_dst.data = __pyx_t_5;
 
   /* "View.MemoryView":743
- *
- *
+ * 
+ * 
  *     cdef __Pyx_memviewslice *p_dst = &dst             # <<<<<<<<<<<<<<
  *     cdef int *p_suboffset_dim = &suboffset_dim
  *     cdef Py_ssize_t start, stop, step
  */
   __pyx_v_p_dst = (&__pyx_v_dst);
 
   /* "View.MemoryView":744
- *
+ * 
  *     cdef __Pyx_memviewslice *p_dst = &dst
  *     cdef int *p_suboffset_dim = &suboffset_dim             # <<<<<<<<<<<<<<
  *     cdef Py_ssize_t start, stop, step
  *     cdef bint have_start, have_stop, have_step
  */
   __pyx_v_p_suboffset_dim = (&__pyx_v_suboffset_dim);
 
   /* "View.MemoryView":748
  *     cdef bint have_start, have_stop, have_step
- *
+ * 
  *     for dim, index in enumerate(indices):             # <<<<<<<<<<<<<<
  *         if PyIndex_Check(index):
  *             slice_memviewslice(
  */
   __pyx_t_6 = 0;
   if (likely(PyList_CheckExact(__pyx_v_indices)) || PyTuple_CheckExact(__pyx_v_indices)) {
     __pyx_t_3 = __pyx_v_indices; __Pyx_INCREF(__pyx_t_3); __pyx_t_7 = 0;
@@ -14299,15 +14828,15 @@
     }
     __Pyx_XDECREF_SET(__pyx_v_index, __pyx_t_9);
     __pyx_t_9 = 0;
     __pyx_v_dim = __pyx_t_6;
     __pyx_t_6 = (__pyx_t_6 + 1);
 
     /* "View.MemoryView":749
- *
+ * 
  *     for dim, index in enumerate(indices):
  *         if PyIndex_Check(index):             # <<<<<<<<<<<<<<
  *             slice_memviewslice(
  *                 p_dst, p_src.shape[dim], p_src.strides[dim], p_src.suboffsets[dim],
  */
     __pyx_t_2 = (PyIndex_Check(__pyx_v_index) != 0);
     if (__pyx_t_2) {
@@ -14327,15 +14856,15 @@
  *             slice_memviewslice(             # <<<<<<<<<<<<<<
  *                 p_dst, p_src.shape[dim], p_src.strides[dim], p_src.suboffsets[dim],
  *                 dim, new_ndim, p_suboffset_dim,
  */
       __pyx_t_11 = __pyx_memoryview_slice_memviewslice(__pyx_v_p_dst, (__pyx_v_p_src->shape[__pyx_v_dim]), (__pyx_v_p_src->strides[__pyx_v_dim]), (__pyx_v_p_src->suboffsets[__pyx_v_dim]), __pyx_v_dim, __pyx_v_new_ndim, __pyx_v_p_suboffset_dim, __pyx_t_10, 0, 0, 0, 0, 0, 0); if (unlikely(__pyx_t_11 == ((int)-1))) __PYX_ERR(2, 750, __pyx_L1_error)
 
       /* "View.MemoryView":749
- *
+ * 
  *     for dim, index in enumerate(indices):
  *         if PyIndex_Check(index):             # <<<<<<<<<<<<<<
  *             slice_memviewslice(
  *                 p_dst, p_src.shape[dim], p_src.strides[dim], p_src.suboffsets[dim],
  */
       goto __pyx_L6;
     }
@@ -14421,15 +14950,15 @@
       __pyx_v_start = __pyx_t_10;
 
       /* "View.MemoryView":763
  *         else:
  *             start = index.start or 0
  *             stop = index.stop or 0             # <<<<<<<<<<<<<<
  *             step = index.step or 0
- *
+ * 
  */
       __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_v_index, __pyx_n_s_stop); if (unlikely(!__pyx_t_9)) __PYX_ERR(2, 763, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_9);
       __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_t_9); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(2, 763, __pyx_L1_error)
       if (!__pyx_t_1) {
         __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
       } else {
@@ -14442,15 +14971,15 @@
       __pyx_L9_bool_binop_done:;
       __pyx_v_stop = __pyx_t_10;
 
       /* "View.MemoryView":764
  *             start = index.start or 0
  *             stop = index.stop or 0
  *             step = index.step or 0             # <<<<<<<<<<<<<<
- *
+ * 
  *             have_start = index.start is not None
  */
       __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_v_index, __pyx_n_s_step); if (unlikely(!__pyx_t_9)) __PYX_ERR(2, 764, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_9);
       __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_t_9); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(2, 764, __pyx_L1_error)
       if (!__pyx_t_1) {
         __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
@@ -14462,94 +14991,94 @@
       }
       __pyx_t_10 = 0;
       __pyx_L11_bool_binop_done:;
       __pyx_v_step = __pyx_t_10;
 
       /* "View.MemoryView":766
  *             step = index.step or 0
- *
+ * 
  *             have_start = index.start is not None             # <<<<<<<<<<<<<<
  *             have_stop = index.stop is not None
  *             have_step = index.step is not None
  */
       __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_v_index, __pyx_n_s_start); if (unlikely(!__pyx_t_9)) __PYX_ERR(2, 766, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_9);
       __pyx_t_1 = (__pyx_t_9 != Py_None);
       __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
       __pyx_v_have_start = __pyx_t_1;
 
       /* "View.MemoryView":767
- *
+ * 
  *             have_start = index.start is not None
  *             have_stop = index.stop is not None             # <<<<<<<<<<<<<<
  *             have_step = index.step is not None
- *
+ * 
  */
       __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_v_index, __pyx_n_s_stop); if (unlikely(!__pyx_t_9)) __PYX_ERR(2, 767, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_9);
       __pyx_t_1 = (__pyx_t_9 != Py_None);
       __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
       __pyx_v_have_stop = __pyx_t_1;
 
       /* "View.MemoryView":768
  *             have_start = index.start is not None
  *             have_stop = index.stop is not None
  *             have_step = index.step is not None             # <<<<<<<<<<<<<<
- *
+ * 
  *             slice_memviewslice(
  */
       __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_v_index, __pyx_n_s_step); if (unlikely(!__pyx_t_9)) __PYX_ERR(2, 768, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_9);
       __pyx_t_1 = (__pyx_t_9 != Py_None);
       __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
       __pyx_v_have_step = __pyx_t_1;
 
       /* "View.MemoryView":770
  *             have_step = index.step is not None
- *
+ * 
  *             slice_memviewslice(             # <<<<<<<<<<<<<<
  *                 p_dst, p_src.shape[dim], p_src.strides[dim], p_src.suboffsets[dim],
  *                 dim, new_ndim, p_suboffset_dim,
  */
       __pyx_t_11 = __pyx_memoryview_slice_memviewslice(__pyx_v_p_dst, (__pyx_v_p_src->shape[__pyx_v_dim]), (__pyx_v_p_src->strides[__pyx_v_dim]), (__pyx_v_p_src->suboffsets[__pyx_v_dim]), __pyx_v_dim, __pyx_v_new_ndim, __pyx_v_p_suboffset_dim, __pyx_v_start, __pyx_v_stop, __pyx_v_step, __pyx_v_have_start, __pyx_v_have_stop, __pyx_v_have_step, 1); if (unlikely(__pyx_t_11 == ((int)-1))) __PYX_ERR(2, 770, __pyx_L1_error)
 
       /* "View.MemoryView":776
  *                 have_start, have_stop, have_step,
  *                 True)
  *             new_ndim += 1             # <<<<<<<<<<<<<<
- *
+ * 
  *     if isinstance(memview, _memoryviewslice):
  */
       __pyx_v_new_ndim = (__pyx_v_new_ndim + 1);
     }
     __pyx_L6:;
 
     /* "View.MemoryView":748
  *     cdef bint have_start, have_stop, have_step
- *
+ * 
  *     for dim, index in enumerate(indices):             # <<<<<<<<<<<<<<
  *         if PyIndex_Check(index):
  *             slice_memviewslice(
  */
   }
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
   /* "View.MemoryView":778
  *             new_ndim += 1
- *
+ * 
  *     if isinstance(memview, _memoryviewslice):             # <<<<<<<<<<<<<<
  *         return memoryview_fromslice(dst, new_ndim,
  *                                     memviewsliceobj.to_object_func,
  */
-  __pyx_t_1 = __Pyx_TypeCheck(((PyObject *)__pyx_v_memview), __pyx_memoryviewslice_type);
+  __pyx_t_1 = __Pyx_TypeCheck(((PyObject *)__pyx_v_memview), __pyx_memoryviewslice_type); 
   __pyx_t_2 = (__pyx_t_1 != 0);
   if (__pyx_t_2) {
 
     /* "View.MemoryView":779
- *
+ * 
  *     if isinstance(memview, _memoryviewslice):
  *         return memoryview_fromslice(dst, new_ndim,             # <<<<<<<<<<<<<<
  *                                     memviewsliceobj.to_object_func,
  *                                     memviewsliceobj.to_dtype_func,
  */
     __Pyx_XDECREF(((PyObject *)__pyx_r));
 
@@ -14568,71 +15097,71 @@
  *                                     memviewsliceobj.to_dtype_func,             # <<<<<<<<<<<<<<
  *                                     memview.dtype_is_object)
  *     else:
  */
     if (unlikely(!__pyx_v_memviewsliceobj)) { __Pyx_RaiseUnboundLocalError("memviewsliceobj"); __PYX_ERR(2, 781, __pyx_L1_error) }
 
     /* "View.MemoryView":779
- *
+ * 
  *     if isinstance(memview, _memoryviewslice):
  *         return memoryview_fromslice(dst, new_ndim,             # <<<<<<<<<<<<<<
  *                                     memviewsliceobj.to_object_func,
  *                                     memviewsliceobj.to_dtype_func,
  */
     __pyx_t_3 = __pyx_memoryview_fromslice(__pyx_v_dst, __pyx_v_new_ndim, __pyx_v_memviewsliceobj->to_object_func, __pyx_v_memviewsliceobj->to_dtype_func, __pyx_v_memview->dtype_is_object); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 779, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     if (!(likely(((__pyx_t_3) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_3, __pyx_memoryview_type))))) __PYX_ERR(2, 779, __pyx_L1_error)
     __pyx_r = ((struct __pyx_memoryview_obj *)__pyx_t_3);
     __pyx_t_3 = 0;
     goto __pyx_L0;
 
     /* "View.MemoryView":778
  *             new_ndim += 1
- *
+ * 
  *     if isinstance(memview, _memoryviewslice):             # <<<<<<<<<<<<<<
  *         return memoryview_fromslice(dst, new_ndim,
  *                                     memviewsliceobj.to_object_func,
  */
   }
 
   /* "View.MemoryView":784
  *                                     memview.dtype_is_object)
  *     else:
  *         return memoryview_fromslice(dst, new_ndim, NULL, NULL,             # <<<<<<<<<<<<<<
  *                                     memview.dtype_is_object)
- *
+ * 
  */
   /*else*/ {
     __Pyx_XDECREF(((PyObject *)__pyx_r));
 
     /* "View.MemoryView":785
  *     else:
  *         return memoryview_fromslice(dst, new_ndim, NULL, NULL,
  *                                     memview.dtype_is_object)             # <<<<<<<<<<<<<<
- *
- *
+ * 
+ * 
  */
     __pyx_t_3 = __pyx_memoryview_fromslice(__pyx_v_dst, __pyx_v_new_ndim, NULL, NULL, __pyx_v_memview->dtype_is_object); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 784, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
 
     /* "View.MemoryView":784
  *                                     memview.dtype_is_object)
  *     else:
  *         return memoryview_fromslice(dst, new_ndim, NULL, NULL,             # <<<<<<<<<<<<<<
  *                                     memview.dtype_is_object)
- *
+ * 
  */
     if (!(likely(((__pyx_t_3) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_3, __pyx_memoryview_type))))) __PYX_ERR(2, 784, __pyx_L1_error)
     __pyx_r = ((struct __pyx_memoryview_obj *)__pyx_t_3);
     __pyx_t_3 = 0;
     goto __pyx_L0;
   }
 
   /* "View.MemoryView":712
- *
+ * 
  * @cname('__pyx_memview_slice')
  * cdef memoryview memview_slice(memoryview memview, object indices):             # <<<<<<<<<<<<<<
  *     cdef int new_ndim = 0, suboffset_dim = -1, dim
  *     cdef bint negative_step
  */
 
   /* function exit code */
@@ -14646,15 +15175,15 @@
   __Pyx_XDECREF(__pyx_v_index);
   __Pyx_XGIVEREF((PyObject *)__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "View.MemoryView":809
- *
+ * 
  * @cname('__pyx_memoryview_slice_memviewslice')
  * cdef int slice_memviewslice(             # <<<<<<<<<<<<<<
  *         __Pyx_memviewslice *dst,
  *         Py_ssize_t shape, Py_ssize_t stride, Py_ssize_t suboffset,
  */
 
 static int __pyx_memoryview_slice_memviewslice(__Pyx_memviewslice *__pyx_v_dst, Py_ssize_t __pyx_v_shape, Py_ssize_t __pyx_v_stride, Py_ssize_t __pyx_v_suboffset, int __pyx_v_dim, int __pyx_v_new_ndim, int *__pyx_v_suboffset_dim, Py_ssize_t __pyx_v_start, Py_ssize_t __pyx_v_stop, Py_ssize_t __pyx_v_step, int __pyx_v_have_start, int __pyx_v_have_stop, int __pyx_v_have_step, int __pyx_v_is_slice) {
@@ -14666,44 +15195,44 @@
   int __pyx_t_3;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
 
   /* "View.MemoryView":829
  *     cdef bint negative_step
- *
+ * 
  *     if not is_slice:             # <<<<<<<<<<<<<<
- *
+ * 
  *         if start < 0:
  */
   __pyx_t_1 = ((!(__pyx_v_is_slice != 0)) != 0);
   if (__pyx_t_1) {
 
     /* "View.MemoryView":831
  *     if not is_slice:
- *
+ * 
  *         if start < 0:             # <<<<<<<<<<<<<<
  *             start += shape
  *         if not 0 <= start < shape:
  */
     __pyx_t_1 = ((__pyx_v_start < 0) != 0);
     if (__pyx_t_1) {
 
       /* "View.MemoryView":832
- *
+ * 
  *         if start < 0:
  *             start += shape             # <<<<<<<<<<<<<<
  *         if not 0 <= start < shape:
  *             _err_dim(IndexError, "Index out of bounds (axis %d)", dim)
  */
       __pyx_v_start = (__pyx_v_start + __pyx_v_shape);
 
       /* "View.MemoryView":831
  *     if not is_slice:
- *
+ * 
  *         if start < 0:             # <<<<<<<<<<<<<<
  *             start += shape
  *         if not 0 <= start < shape:
  */
     }
 
     /* "View.MemoryView":833
@@ -14721,42 +15250,42 @@
     if (__pyx_t_2) {
 
       /* "View.MemoryView":834
  *             start += shape
  *         if not 0 <= start < shape:
  *             _err_dim(IndexError, "Index out of bounds (axis %d)", dim)             # <<<<<<<<<<<<<<
  *     else:
- *
+ * 
  */
       __pyx_t_3 = __pyx_memoryview_err_dim(__pyx_builtin_IndexError, ((char *)"Index out of bounds (axis %d)"), __pyx_v_dim); if (unlikely(__pyx_t_3 == ((int)-1))) __PYX_ERR(2, 834, __pyx_L1_error)
 
       /* "View.MemoryView":833
  *         if start < 0:
  *             start += shape
  *         if not 0 <= start < shape:             # <<<<<<<<<<<<<<
  *             _err_dim(IndexError, "Index out of bounds (axis %d)", dim)
  *     else:
  */
     }
 
     /* "View.MemoryView":829
  *     cdef bint negative_step
- *
+ * 
  *     if not is_slice:             # <<<<<<<<<<<<<<
- *
+ * 
  *         if start < 0:
  */
     goto __pyx_L3;
   }
 
   /* "View.MemoryView":837
  *     else:
- *
+ * 
  *         negative_step = have_step != 0 and step < 0             # <<<<<<<<<<<<<<
- *
+ * 
  *         if have_step and step == 0:
  */
   /*else*/ {
     __pyx_t_1 = ((__pyx_v_have_step != 0) != 0);
     if (__pyx_t_1) {
     } else {
       __pyx_t_2 = __pyx_t_1;
@@ -14765,60 +15294,60 @@
     __pyx_t_1 = ((__pyx_v_step < 0) != 0);
     __pyx_t_2 = __pyx_t_1;
     __pyx_L6_bool_binop_done:;
     __pyx_v_negative_step = __pyx_t_2;
 
     /* "View.MemoryView":839
  *         negative_step = have_step != 0 and step < 0
- *
+ * 
  *         if have_step and step == 0:             # <<<<<<<<<<<<<<
  *             _err_dim(ValueError, "Step may not be zero (axis %d)", dim)
- *
+ * 
  */
     __pyx_t_1 = (__pyx_v_have_step != 0);
     if (__pyx_t_1) {
     } else {
       __pyx_t_2 = __pyx_t_1;
       goto __pyx_L9_bool_binop_done;
     }
     __pyx_t_1 = ((__pyx_v_step == 0) != 0);
     __pyx_t_2 = __pyx_t_1;
     __pyx_L9_bool_binop_done:;
     if (__pyx_t_2) {
 
       /* "View.MemoryView":840
- *
+ * 
  *         if have_step and step == 0:
  *             _err_dim(ValueError, "Step may not be zero (axis %d)", dim)             # <<<<<<<<<<<<<<
- *
- *
+ * 
+ * 
  */
       __pyx_t_3 = __pyx_memoryview_err_dim(__pyx_builtin_ValueError, ((char *)"Step may not be zero (axis %d)"), __pyx_v_dim); if (unlikely(__pyx_t_3 == ((int)-1))) __PYX_ERR(2, 840, __pyx_L1_error)
 
       /* "View.MemoryView":839
  *         negative_step = have_step != 0 and step < 0
- *
+ * 
  *         if have_step and step == 0:             # <<<<<<<<<<<<<<
  *             _err_dim(ValueError, "Step may not be zero (axis %d)", dim)
- *
+ * 
  */
     }
 
     /* "View.MemoryView":843
- *
- *
+ * 
+ * 
  *         if have_start:             # <<<<<<<<<<<<<<
  *             if start < 0:
  *                 start += shape
  */
     __pyx_t_2 = (__pyx_v_have_start != 0);
     if (__pyx_t_2) {
 
       /* "View.MemoryView":844
- *
+ * 
  *         if have_start:
  *             if start < 0:             # <<<<<<<<<<<<<<
  *                 start += shape
  *                 if start < 0:
  */
       __pyx_t_2 = ((__pyx_v_start < 0) != 0);
       if (__pyx_t_2) {
@@ -14857,15 +15386,15 @@
  *                 if start < 0:             # <<<<<<<<<<<<<<
  *                     start = 0
  *             elif start >= shape:
  */
         }
 
         /* "View.MemoryView":844
- *
+ * 
  *         if have_start:
  *             if start < 0:             # <<<<<<<<<<<<<<
  *                 start += shape
  *                 if start < 0:
  */
         goto __pyx_L12;
       }
@@ -14928,16 +15457,16 @@
  *                 if negative_step:
  *                     start = shape - 1
  */
       }
       __pyx_L12:;
 
       /* "View.MemoryView":843
- *
- *
+ * 
+ * 
  *         if have_start:             # <<<<<<<<<<<<<<
  *             if start < 0:
  *                 start += shape
  */
       goto __pyx_L11;
     }
 
@@ -14971,36 +15500,36 @@
         goto __pyx_L15;
       }
 
       /* "View.MemoryView":857
  *                 start = shape - 1
  *             else:
  *                 start = 0             # <<<<<<<<<<<<<<
- *
+ * 
  *         if have_stop:
  */
       /*else*/ {
         __pyx_v_start = 0;
       }
       __pyx_L15:;
     }
     __pyx_L11:;
 
     /* "View.MemoryView":859
  *                 start = 0
- *
+ * 
  *         if have_stop:             # <<<<<<<<<<<<<<
  *             if stop < 0:
  *                 stop += shape
  */
     __pyx_t_2 = (__pyx_v_have_stop != 0);
     if (__pyx_t_2) {
 
       /* "View.MemoryView":860
- *
+ * 
  *         if have_stop:
  *             if stop < 0:             # <<<<<<<<<<<<<<
  *                 stop += shape
  *                 if stop < 0:
  */
       __pyx_t_2 = ((__pyx_v_stop < 0) != 0);
       if (__pyx_t_2) {
@@ -15039,15 +15568,15 @@
  *                 if stop < 0:             # <<<<<<<<<<<<<<
  *                     stop = 0
  *             elif stop > shape:
  */
         }
 
         /* "View.MemoryView":860
- *
+ * 
  *         if have_stop:
  *             if stop < 0:             # <<<<<<<<<<<<<<
  *                 stop += shape
  *                 if stop < 0:
  */
         goto __pyx_L17;
       }
@@ -15079,15 +15608,15 @@
  *         else:
  */
       }
       __pyx_L17:;
 
       /* "View.MemoryView":859
  *                 start = 0
- *
+ * 
  *         if have_stop:             # <<<<<<<<<<<<<<
  *             if stop < 0:
  *                 stop += shape
  */
       goto __pyx_L16;
     }
 
@@ -15121,200 +15650,200 @@
         goto __pyx_L19;
       }
 
       /* "View.MemoryView":870
  *                 stop = -1
  *             else:
  *                 stop = shape             # <<<<<<<<<<<<<<
- *
+ * 
  *         if not have_step:
  */
       /*else*/ {
         __pyx_v_stop = __pyx_v_shape;
       }
       __pyx_L19:;
     }
     __pyx_L16:;
 
     /* "View.MemoryView":872
  *                 stop = shape
- *
+ * 
  *         if not have_step:             # <<<<<<<<<<<<<<
  *             step = 1
- *
+ * 
  */
     __pyx_t_2 = ((!(__pyx_v_have_step != 0)) != 0);
     if (__pyx_t_2) {
 
       /* "View.MemoryView":873
- *
+ * 
  *         if not have_step:
  *             step = 1             # <<<<<<<<<<<<<<
- *
- *
+ * 
+ * 
  */
       __pyx_v_step = 1;
 
       /* "View.MemoryView":872
  *                 stop = shape
- *
+ * 
  *         if not have_step:             # <<<<<<<<<<<<<<
  *             step = 1
- *
+ * 
  */
     }
 
     /* "View.MemoryView":877
- *
+ * 
  *         with cython.cdivision(True):
  *             new_shape = (stop - start) // step             # <<<<<<<<<<<<<<
- *
+ * 
  *             if (stop - start) - step * new_shape:
  */
     __pyx_v_new_shape = ((__pyx_v_stop - __pyx_v_start) / __pyx_v_step);
 
     /* "View.MemoryView":879
  *             new_shape = (stop - start) // step
- *
+ * 
  *             if (stop - start) - step * new_shape:             # <<<<<<<<<<<<<<
  *                 new_shape += 1
- *
+ * 
  */
     __pyx_t_2 = (((__pyx_v_stop - __pyx_v_start) - (__pyx_v_step * __pyx_v_new_shape)) != 0);
     if (__pyx_t_2) {
 
       /* "View.MemoryView":880
- *
+ * 
  *             if (stop - start) - step * new_shape:
  *                 new_shape += 1             # <<<<<<<<<<<<<<
- *
+ * 
  *         if new_shape < 0:
  */
       __pyx_v_new_shape = (__pyx_v_new_shape + 1);
 
       /* "View.MemoryView":879
  *             new_shape = (stop - start) // step
- *
+ * 
  *             if (stop - start) - step * new_shape:             # <<<<<<<<<<<<<<
  *                 new_shape += 1
- *
+ * 
  */
     }
 
     /* "View.MemoryView":882
  *                 new_shape += 1
- *
+ * 
  *         if new_shape < 0:             # <<<<<<<<<<<<<<
  *             new_shape = 0
- *
+ * 
  */
     __pyx_t_2 = ((__pyx_v_new_shape < 0) != 0);
     if (__pyx_t_2) {
 
       /* "View.MemoryView":883
- *
+ * 
  *         if new_shape < 0:
  *             new_shape = 0             # <<<<<<<<<<<<<<
- *
- *
+ * 
+ * 
  */
       __pyx_v_new_shape = 0;
 
       /* "View.MemoryView":882
  *                 new_shape += 1
- *
+ * 
  *         if new_shape < 0:             # <<<<<<<<<<<<<<
  *             new_shape = 0
- *
+ * 
  */
     }
 
     /* "View.MemoryView":886
- *
- *
+ * 
+ * 
  *         dst.strides[new_ndim] = stride * step             # <<<<<<<<<<<<<<
  *         dst.shape[new_ndim] = new_shape
  *         dst.suboffsets[new_ndim] = suboffset
  */
     (__pyx_v_dst->strides[__pyx_v_new_ndim]) = (__pyx_v_stride * __pyx_v_step);
 
     /* "View.MemoryView":887
- *
+ * 
  *         dst.strides[new_ndim] = stride * step
  *         dst.shape[new_ndim] = new_shape             # <<<<<<<<<<<<<<
  *         dst.suboffsets[new_ndim] = suboffset
- *
+ * 
  */
     (__pyx_v_dst->shape[__pyx_v_new_ndim]) = __pyx_v_new_shape;
 
     /* "View.MemoryView":888
  *         dst.strides[new_ndim] = stride * step
  *         dst.shape[new_ndim] = new_shape
  *         dst.suboffsets[new_ndim] = suboffset             # <<<<<<<<<<<<<<
- *
- *
+ * 
+ * 
  */
     (__pyx_v_dst->suboffsets[__pyx_v_new_ndim]) = __pyx_v_suboffset;
   }
   __pyx_L3:;
 
   /* "View.MemoryView":891
- *
- *
+ * 
+ * 
  *     if suboffset_dim[0] < 0:             # <<<<<<<<<<<<<<
  *         dst.data += start * stride
  *     else:
  */
   __pyx_t_2 = (((__pyx_v_suboffset_dim[0]) < 0) != 0);
   if (__pyx_t_2) {
 
     /* "View.MemoryView":892
- *
+ * 
  *     if suboffset_dim[0] < 0:
  *         dst.data += start * stride             # <<<<<<<<<<<<<<
  *     else:
  *         dst.suboffsets[suboffset_dim[0]] += start * stride
  */
     __pyx_v_dst->data = (__pyx_v_dst->data + (__pyx_v_start * __pyx_v_stride));
 
     /* "View.MemoryView":891
- *
- *
+ * 
+ * 
  *     if suboffset_dim[0] < 0:             # <<<<<<<<<<<<<<
  *         dst.data += start * stride
  *     else:
  */
     goto __pyx_L23;
   }
 
   /* "View.MemoryView":894
  *         dst.data += start * stride
  *     else:
  *         dst.suboffsets[suboffset_dim[0]] += start * stride             # <<<<<<<<<<<<<<
- *
+ * 
  *     if suboffset >= 0:
  */
   /*else*/ {
     __pyx_t_3 = (__pyx_v_suboffset_dim[0]);
     (__pyx_v_dst->suboffsets[__pyx_t_3]) = ((__pyx_v_dst->suboffsets[__pyx_t_3]) + (__pyx_v_start * __pyx_v_stride));
   }
   __pyx_L23:;
 
   /* "View.MemoryView":896
  *         dst.suboffsets[suboffset_dim[0]] += start * stride
- *
+ * 
  *     if suboffset >= 0:             # <<<<<<<<<<<<<<
  *         if not is_slice:
  *             if new_ndim == 0:
  */
   __pyx_t_2 = ((__pyx_v_suboffset >= 0) != 0);
   if (__pyx_t_2) {
 
     /* "View.MemoryView":897
- *
+ * 
  *     if suboffset >= 0:
  *         if not is_slice:             # <<<<<<<<<<<<<<
  *             if new_ndim == 0:
  *                 dst.data = (<char **> dst.data)[0] + suboffset
  */
     __pyx_t_2 = ((!(__pyx_v_is_slice != 0)) != 0);
     if (__pyx_t_2) {
@@ -15365,56 +15894,56 @@
  *             suboffset_dim[0] = new_ndim
  */
         __pyx_t_3 = __pyx_memoryview_err_dim(__pyx_builtin_IndexError, ((char *)"All dimensions preceding dimension %d must be indexed and not sliced"), __pyx_v_dim); if (unlikely(__pyx_t_3 == ((int)-1))) __PYX_ERR(2, 901, __pyx_L1_error)
       }
       __pyx_L26:;
 
       /* "View.MemoryView":897
- *
+ * 
  *     if suboffset >= 0:
  *         if not is_slice:             # <<<<<<<<<<<<<<
  *             if new_ndim == 0:
  *                 dst.data = (<char **> dst.data)[0] + suboffset
  */
       goto __pyx_L25;
     }
 
     /* "View.MemoryView":904
  *                                      "must be indexed and not sliced", dim)
  *         else:
  *             suboffset_dim[0] = new_ndim             # <<<<<<<<<<<<<<
- *
+ * 
  *     return 0
  */
     /*else*/ {
       (__pyx_v_suboffset_dim[0]) = __pyx_v_new_ndim;
     }
     __pyx_L25:;
 
     /* "View.MemoryView":896
  *         dst.suboffsets[suboffset_dim[0]] += start * stride
- *
+ * 
  *     if suboffset >= 0:             # <<<<<<<<<<<<<<
  *         if not is_slice:
  *             if new_ndim == 0:
  */
   }
 
   /* "View.MemoryView":906
  *             suboffset_dim[0] = new_ndim
- *
+ * 
  *     return 0             # <<<<<<<<<<<<<<
- *
- *
+ * 
+ * 
  */
   __pyx_r = 0;
   goto __pyx_L0;
 
   /* "View.MemoryView":809
- *
+ * 
  * @cname('__pyx_memoryview_slice_memviewslice')
  * cdef int slice_memviewslice(             # <<<<<<<<<<<<<<
  *         __Pyx_memviewslice *dst,
  *         Py_ssize_t shape, Py_ssize_t stride, Py_ssize_t suboffset,
  */
 
   /* function exit code */
@@ -15430,15 +15959,15 @@
   }
   __pyx_r = -1;
   __pyx_L0:;
   return __pyx_r;
 }
 
 /* "View.MemoryView":912
- *
+ * 
  * @cname('__pyx_pybuffer_index')
  * cdef char *pybuffer_index(Py_buffer *view, char *bufp, Py_ssize_t index,             # <<<<<<<<<<<<<<
  *                           Py_ssize_t dim) except NULL:
  *     cdef Py_ssize_t shape, stride, suboffset = -1
  */
 
 static char *__pyx_pybuffer_index(Py_buffer *__pyx_v_view, char *__pyx_v_bufp, Py_ssize_t __pyx_v_index, Py_ssize_t __pyx_v_dim) {
@@ -15468,31 +15997,31 @@
   __pyx_v_suboffset = -1L;
 
   /* "View.MemoryView":915
  *                           Py_ssize_t dim) except NULL:
  *     cdef Py_ssize_t shape, stride, suboffset = -1
  *     cdef Py_ssize_t itemsize = view.itemsize             # <<<<<<<<<<<<<<
  *     cdef char *resultp
- *
+ * 
  */
   __pyx_t_1 = __pyx_v_view->itemsize;
   __pyx_v_itemsize = __pyx_t_1;
 
   /* "View.MemoryView":918
  *     cdef char *resultp
- *
+ * 
  *     if view.ndim == 0:             # <<<<<<<<<<<<<<
  *         shape = view.len / itemsize
  *         stride = itemsize
  */
   __pyx_t_2 = ((__pyx_v_view->ndim == 0) != 0);
   if (__pyx_t_2) {
 
     /* "View.MemoryView":919
- *
+ * 
  *     if view.ndim == 0:
  *         shape = view.len / itemsize             # <<<<<<<<<<<<<<
  *         stride = itemsize
  *     else:
  */
     if (unlikely(__pyx_v_itemsize == 0)) {
       PyErr_SetString(PyExc_ZeroDivisionError, "integer division or modulo by zero");
@@ -15511,15 +16040,15 @@
  *     else:
  *         shape = view.shape[dim]
  */
     __pyx_v_stride = __pyx_v_itemsize;
 
     /* "View.MemoryView":918
  *     cdef char *resultp
- *
+ * 
  *     if view.ndim == 0:             # <<<<<<<<<<<<<<
  *         shape = view.len / itemsize
  *         stride = itemsize
  */
     goto __pyx_L3;
   }
 
@@ -15543,73 +16072,73 @@
     __pyx_v_stride = (__pyx_v_view->strides[__pyx_v_dim]);
 
     /* "View.MemoryView":924
  *         shape = view.shape[dim]
  *         stride = view.strides[dim]
  *         if view.suboffsets != NULL:             # <<<<<<<<<<<<<<
  *             suboffset = view.suboffsets[dim]
- *
+ * 
  */
     __pyx_t_2 = ((__pyx_v_view->suboffsets != NULL) != 0);
     if (__pyx_t_2) {
 
       /* "View.MemoryView":925
  *         stride = view.strides[dim]
  *         if view.suboffsets != NULL:
  *             suboffset = view.suboffsets[dim]             # <<<<<<<<<<<<<<
- *
+ * 
  *     if index < 0:
  */
       __pyx_v_suboffset = (__pyx_v_view->suboffsets[__pyx_v_dim]);
 
       /* "View.MemoryView":924
  *         shape = view.shape[dim]
  *         stride = view.strides[dim]
  *         if view.suboffsets != NULL:             # <<<<<<<<<<<<<<
  *             suboffset = view.suboffsets[dim]
- *
+ * 
  */
     }
   }
   __pyx_L3:;
 
   /* "View.MemoryView":927
  *             suboffset = view.suboffsets[dim]
- *
+ * 
  *     if index < 0:             # <<<<<<<<<<<<<<
  *         index += view.shape[dim]
  *         if index < 0:
  */
   __pyx_t_2 = ((__pyx_v_index < 0) != 0);
   if (__pyx_t_2) {
 
     /* "View.MemoryView":928
- *
+ * 
  *     if index < 0:
  *         index += view.shape[dim]             # <<<<<<<<<<<<<<
  *         if index < 0:
  *             raise IndexError("Out of bounds on buffer access (axis %d)" % dim)
  */
     __pyx_v_index = (__pyx_v_index + (__pyx_v_view->shape[__pyx_v_dim]));
 
     /* "View.MemoryView":929
  *     if index < 0:
  *         index += view.shape[dim]
  *         if index < 0:             # <<<<<<<<<<<<<<
  *             raise IndexError("Out of bounds on buffer access (axis %d)" % dim)
- *
+ * 
  */
     __pyx_t_2 = ((__pyx_v_index < 0) != 0);
     if (unlikely(__pyx_t_2)) {
 
       /* "View.MemoryView":930
  *         index += view.shape[dim]
  *         if index < 0:
  *             raise IndexError("Out of bounds on buffer access (axis %d)" % dim)             # <<<<<<<<<<<<<<
- *
+ * 
  *     if index >= shape:
  */
       __pyx_t_3 = PyInt_FromSsize_t(__pyx_v_dim); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 930, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_3);
       __pyx_t_4 = __Pyx_PyString_Format(__pyx_kp_s_Out_of_bounds_on_buffer_access_a, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(2, 930, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_4);
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
@@ -15621,42 +16150,42 @@
       __PYX_ERR(2, 930, __pyx_L1_error)
 
       /* "View.MemoryView":929
  *     if index < 0:
  *         index += view.shape[dim]
  *         if index < 0:             # <<<<<<<<<<<<<<
  *             raise IndexError("Out of bounds on buffer access (axis %d)" % dim)
- *
+ * 
  */
     }
 
     /* "View.MemoryView":927
  *             suboffset = view.suboffsets[dim]
- *
+ * 
  *     if index < 0:             # <<<<<<<<<<<<<<
  *         index += view.shape[dim]
  *         if index < 0:
  */
   }
 
   /* "View.MemoryView":932
  *             raise IndexError("Out of bounds on buffer access (axis %d)" % dim)
- *
+ * 
  *     if index >= shape:             # <<<<<<<<<<<<<<
  *         raise IndexError("Out of bounds on buffer access (axis %d)" % dim)
- *
+ * 
  */
   __pyx_t_2 = ((__pyx_v_index >= __pyx_v_shape) != 0);
   if (unlikely(__pyx_t_2)) {
 
     /* "View.MemoryView":933
- *
+ * 
  *     if index >= shape:
  *         raise IndexError("Out of bounds on buffer access (axis %d)" % dim)             # <<<<<<<<<<<<<<
- *
+ * 
  *     resultp = bufp + index * stride
  */
     __pyx_t_3 = PyInt_FromSsize_t(__pyx_v_dim); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 933, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __pyx_t_4 = __Pyx_PyString_Format(__pyx_kp_s_Out_of_bounds_on_buffer_access_a, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(2, 933, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
@@ -15665,70 +16194,70 @@
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
     __Pyx_Raise(__pyx_t_3, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     __PYX_ERR(2, 933, __pyx_L1_error)
 
     /* "View.MemoryView":932
  *             raise IndexError("Out of bounds on buffer access (axis %d)" % dim)
- *
+ * 
  *     if index >= shape:             # <<<<<<<<<<<<<<
  *         raise IndexError("Out of bounds on buffer access (axis %d)" % dim)
- *
+ * 
  */
   }
 
   /* "View.MemoryView":935
  *         raise IndexError("Out of bounds on buffer access (axis %d)" % dim)
- *
+ * 
  *     resultp = bufp + index * stride             # <<<<<<<<<<<<<<
  *     if suboffset >= 0:
  *         resultp = (<char **> resultp)[0] + suboffset
  */
   __pyx_v_resultp = (__pyx_v_bufp + (__pyx_v_index * __pyx_v_stride));
 
   /* "View.MemoryView":936
- *
+ * 
  *     resultp = bufp + index * stride
  *     if suboffset >= 0:             # <<<<<<<<<<<<<<
  *         resultp = (<char **> resultp)[0] + suboffset
- *
+ * 
  */
   __pyx_t_2 = ((__pyx_v_suboffset >= 0) != 0);
   if (__pyx_t_2) {
 
     /* "View.MemoryView":937
  *     resultp = bufp + index * stride
  *     if suboffset >= 0:
  *         resultp = (<char **> resultp)[0] + suboffset             # <<<<<<<<<<<<<<
- *
+ * 
  *     return resultp
  */
     __pyx_v_resultp = ((((char **)__pyx_v_resultp)[0]) + __pyx_v_suboffset);
 
     /* "View.MemoryView":936
- *
+ * 
  *     resultp = bufp + index * stride
  *     if suboffset >= 0:             # <<<<<<<<<<<<<<
  *         resultp = (<char **> resultp)[0] + suboffset
- *
+ * 
  */
   }
 
   /* "View.MemoryView":939
  *         resultp = (<char **> resultp)[0] + suboffset
- *
+ * 
  *     return resultp             # <<<<<<<<<<<<<<
- *
- *
+ * 
+ * 
  */
   __pyx_r = __pyx_v_resultp;
   goto __pyx_L0;
 
   /* "View.MemoryView":912
- *
+ * 
  * @cname('__pyx_pybuffer_index')
  * cdef char *pybuffer_index(Py_buffer *view, char *bufp, Py_ssize_t index,             # <<<<<<<<<<<<<<
  *                           Py_ssize_t dim) except NULL:
  *     cdef Py_ssize_t shape, stride, suboffset = -1
  */
 
   /* function exit code */
@@ -15739,19 +16268,19 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "View.MemoryView":945
- *
+ * 
  * @cname('__pyx_memslice_transpose')
  * cdef int transpose_memslice(__Pyx_memviewslice *memslice) nogil except 0:             # <<<<<<<<<<<<<<
  *     cdef int ndim = memslice.memview.view.ndim
- *
+ * 
  */
 
 static int __pyx_memslice_transpose(__Pyx_memviewslice *__pyx_v_memslice) {
   int __pyx_v_ndim;
   Py_ssize_t *__pyx_v_shape;
   Py_ssize_t *__pyx_v_strides;
   int __pyx_v_i;
@@ -15770,42 +16299,42 @@
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
 
   /* "View.MemoryView":946
  * @cname('__pyx_memslice_transpose')
  * cdef int transpose_memslice(__Pyx_memviewslice *memslice) nogil except 0:
  *     cdef int ndim = memslice.memview.view.ndim             # <<<<<<<<<<<<<<
- *
+ * 
  *     cdef Py_ssize_t *shape = memslice.shape
  */
   __pyx_t_1 = __pyx_v_memslice->memview->view.ndim;
   __pyx_v_ndim = __pyx_t_1;
 
   /* "View.MemoryView":948
  *     cdef int ndim = memslice.memview.view.ndim
- *
+ * 
  *     cdef Py_ssize_t *shape = memslice.shape             # <<<<<<<<<<<<<<
  *     cdef Py_ssize_t *strides = memslice.strides
- *
+ * 
  */
   __pyx_t_2 = __pyx_v_memslice->shape;
   __pyx_v_shape = __pyx_t_2;
 
   /* "View.MemoryView":949
- *
+ * 
  *     cdef Py_ssize_t *shape = memslice.shape
  *     cdef Py_ssize_t *strides = memslice.strides             # <<<<<<<<<<<<<<
- *
- *
+ * 
+ * 
  */
   __pyx_t_2 = __pyx_v_memslice->strides;
   __pyx_v_strides = __pyx_t_2;
 
   /* "View.MemoryView":953
- *
+ * 
  *     cdef int i, j
  *     for i in range(ndim / 2):             # <<<<<<<<<<<<<<
  *         j = ndim - 1 - i
  *         strides[i], strides[j] = strides[j], strides[i]
  */
   __pyx_t_3 = (__pyx_v_ndim / 2);
   __pyx_t_4 = __pyx_t_3;
@@ -15822,86 +16351,86 @@
     __pyx_v_j = ((__pyx_v_ndim - 1) - __pyx_v_i);
 
     /* "View.MemoryView":955
  *     for i in range(ndim / 2):
  *         j = ndim - 1 - i
  *         strides[i], strides[j] = strides[j], strides[i]             # <<<<<<<<<<<<<<
  *         shape[i], shape[j] = shape[j], shape[i]
- *
+ * 
  */
     __pyx_t_5 = (__pyx_v_strides[__pyx_v_j]);
     __pyx_t_6 = (__pyx_v_strides[__pyx_v_i]);
     (__pyx_v_strides[__pyx_v_i]) = __pyx_t_5;
     (__pyx_v_strides[__pyx_v_j]) = __pyx_t_6;
 
     /* "View.MemoryView":956
  *         j = ndim - 1 - i
  *         strides[i], strides[j] = strides[j], strides[i]
  *         shape[i], shape[j] = shape[j], shape[i]             # <<<<<<<<<<<<<<
- *
+ * 
  *         if memslice.suboffsets[i] >= 0 or memslice.suboffsets[j] >= 0:
  */
     __pyx_t_6 = (__pyx_v_shape[__pyx_v_j]);
     __pyx_t_5 = (__pyx_v_shape[__pyx_v_i]);
     (__pyx_v_shape[__pyx_v_i]) = __pyx_t_6;
     (__pyx_v_shape[__pyx_v_j]) = __pyx_t_5;
 
     /* "View.MemoryView":958
  *         shape[i], shape[j] = shape[j], shape[i]
- *
+ * 
  *         if memslice.suboffsets[i] >= 0 or memslice.suboffsets[j] >= 0:             # <<<<<<<<<<<<<<
  *             _err(ValueError, "Cannot transpose memoryview with indirect dimensions")
- *
+ * 
  */
     __pyx_t_8 = (((__pyx_v_memslice->suboffsets[__pyx_v_i]) >= 0) != 0);
     if (!__pyx_t_8) {
     } else {
       __pyx_t_7 = __pyx_t_8;
       goto __pyx_L6_bool_binop_done;
     }
     __pyx_t_8 = (((__pyx_v_memslice->suboffsets[__pyx_v_j]) >= 0) != 0);
     __pyx_t_7 = __pyx_t_8;
     __pyx_L6_bool_binop_done:;
     if (__pyx_t_7) {
 
       /* "View.MemoryView":959
- *
+ * 
  *         if memslice.suboffsets[i] >= 0 or memslice.suboffsets[j] >= 0:
  *             _err(ValueError, "Cannot transpose memoryview with indirect dimensions")             # <<<<<<<<<<<<<<
- *
+ * 
  *     return 1
  */
       __pyx_t_9 = __pyx_memoryview_err(__pyx_builtin_ValueError, ((char *)"Cannot transpose memoryview with indirect dimensions")); if (unlikely(__pyx_t_9 == ((int)-1))) __PYX_ERR(2, 959, __pyx_L1_error)
 
       /* "View.MemoryView":958
  *         shape[i], shape[j] = shape[j], shape[i]
- *
+ * 
  *         if memslice.suboffsets[i] >= 0 or memslice.suboffsets[j] >= 0:             # <<<<<<<<<<<<<<
  *             _err(ValueError, "Cannot transpose memoryview with indirect dimensions")
- *
+ * 
  */
     }
   }
 
   /* "View.MemoryView":961
  *             _err(ValueError, "Cannot transpose memoryview with indirect dimensions")
- *
+ * 
  *     return 1             # <<<<<<<<<<<<<<
- *
- *
+ * 
+ * 
  */
   __pyx_r = 1;
   goto __pyx_L0;
 
   /* "View.MemoryView":945
- *
+ * 
  * @cname('__pyx_memslice_transpose')
  * cdef int transpose_memslice(__Pyx_memviewslice *memslice) nogil except 0:             # <<<<<<<<<<<<<<
  *     cdef int ndim = memslice.memview.view.ndim
- *
+ * 
  */
 
   /* function exit code */
   __pyx_L1_error:;
   {
     #ifdef WITH_THREAD
     PyGILState_STATE __pyx_gilstate_save = __Pyx_PyGILState_Ensure();
@@ -15914,18 +16443,18 @@
   __pyx_r = 0;
   __pyx_L0:;
   return __pyx_r;
 }
 
 /* "View.MemoryView":978
  *     cdef int (*to_dtype_func)(char *, object) except 0
- *
+ * 
  *     def __dealloc__(self):             # <<<<<<<<<<<<<<
  *         __PYX_XDEC_MEMVIEW(&self.from_slice, 1)
- *
+ * 
  */
 
 /* Python wrapper */
 static void __pyx_memoryviewslice___dealloc__(PyObject *__pyx_v_self); /*proto*/
 static void __pyx_memoryviewslice___dealloc__(PyObject *__pyx_v_self) {
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__dealloc__ (wrapper)", 0);
@@ -15936,37 +16465,37 @@
 }
 
 static void __pyx_memoryviewslice___pyx_pf_15View_dot_MemoryView_16_memoryviewslice___dealloc__(struct __pyx_memoryviewslice_obj *__pyx_v_self) {
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__dealloc__", 0);
 
   /* "View.MemoryView":979
- *
+ * 
  *     def __dealloc__(self):
  *         __PYX_XDEC_MEMVIEW(&self.from_slice, 1)             # <<<<<<<<<<<<<<
- *
+ * 
  *     cdef convert_item_to_object(self, char *itemp):
  */
   __PYX_XDEC_MEMVIEW((&__pyx_v_self->from_slice), 1);
 
   /* "View.MemoryView":978
  *     cdef int (*to_dtype_func)(char *, object) except 0
- *
+ * 
  *     def __dealloc__(self):             # <<<<<<<<<<<<<<
  *         __PYX_XDEC_MEMVIEW(&self.from_slice, 1)
- *
+ * 
  */
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
 }
 
 /* "View.MemoryView":981
  *         __PYX_XDEC_MEMVIEW(&self.from_slice, 1)
- *
+ * 
  *     cdef convert_item_to_object(self, char *itemp):             # <<<<<<<<<<<<<<
  *         if self.to_object_func != NULL:
  *             return self.to_object_func(itemp)
  */
 
 static PyObject *__pyx_memoryviewslice_convert_item_to_object(struct __pyx_memoryviewslice_obj *__pyx_v_self, char *__pyx_v_itemp) {
   PyObject *__pyx_r = NULL;
@@ -15975,15 +16504,15 @@
   PyObject *__pyx_t_2 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("convert_item_to_object", 0);
 
   /* "View.MemoryView":982
- *
+ * 
  *     cdef convert_item_to_object(self, char *itemp):
  *         if self.to_object_func != NULL:             # <<<<<<<<<<<<<<
  *             return self.to_object_func(itemp)
  *         else:
  */
   __pyx_t_1 = ((__pyx_v_self->to_object_func != NULL) != 0);
   if (__pyx_t_1) {
@@ -15999,41 +16528,41 @@
     __pyx_t_2 = __pyx_v_self->to_object_func(__pyx_v_itemp); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 983, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __pyx_r = __pyx_t_2;
     __pyx_t_2 = 0;
     goto __pyx_L0;
 
     /* "View.MemoryView":982
- *
+ * 
  *     cdef convert_item_to_object(self, char *itemp):
  *         if self.to_object_func != NULL:             # <<<<<<<<<<<<<<
  *             return self.to_object_func(itemp)
  *         else:
  */
   }
 
   /* "View.MemoryView":985
  *             return self.to_object_func(itemp)
  *         else:
  *             return memoryview.convert_item_to_object(self, itemp)             # <<<<<<<<<<<<<<
- *
+ * 
  *     cdef assign_item_from_object(self, char *itemp, object value):
  */
   /*else*/ {
     __Pyx_XDECREF(__pyx_r);
     __pyx_t_2 = __pyx_memoryview_convert_item_to_object(((struct __pyx_memoryview_obj *)__pyx_v_self), __pyx_v_itemp); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 985, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __pyx_r = __pyx_t_2;
     __pyx_t_2 = 0;
     goto __pyx_L0;
   }
 
   /* "View.MemoryView":981
  *         __PYX_XDEC_MEMVIEW(&self.from_slice, 1)
- *
+ * 
  *     cdef convert_item_to_object(self, char *itemp):             # <<<<<<<<<<<<<<
  *         if self.to_object_func != NULL:
  *             return self.to_object_func(itemp)
  */
 
   /* function exit code */
   __pyx_L1_error:;
@@ -16044,15 +16573,15 @@
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "View.MemoryView":987
  *             return memoryview.convert_item_to_object(self, itemp)
- *
+ * 
  *     cdef assign_item_from_object(self, char *itemp, object value):             # <<<<<<<<<<<<<<
  *         if self.to_dtype_func != NULL:
  *             self.to_dtype_func(itemp, value)
  */
 
 static PyObject *__pyx_memoryviewslice_assign_item_from_object(struct __pyx_memoryviewslice_obj *__pyx_v_self, char *__pyx_v_itemp, PyObject *__pyx_v_value) {
   PyObject *__pyx_r = NULL;
@@ -16062,15 +16591,15 @@
   PyObject *__pyx_t_3 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("assign_item_from_object", 0);
 
   /* "View.MemoryView":988
- *
+ * 
  *     cdef assign_item_from_object(self, char *itemp, object value):
  *         if self.to_dtype_func != NULL:             # <<<<<<<<<<<<<<
  *             self.to_dtype_func(itemp, value)
  *         else:
  */
   __pyx_t_1 = ((__pyx_v_self->to_dtype_func != NULL) != 0);
   if (__pyx_t_1) {
@@ -16081,40 +16610,40 @@
  *             self.to_dtype_func(itemp, value)             # <<<<<<<<<<<<<<
  *         else:
  *             memoryview.assign_item_from_object(self, itemp, value)
  */
     __pyx_t_2 = __pyx_v_self->to_dtype_func(__pyx_v_itemp, __pyx_v_value); if (unlikely(__pyx_t_2 == ((int)0))) __PYX_ERR(2, 989, __pyx_L1_error)
 
     /* "View.MemoryView":988
- *
+ * 
  *     cdef assign_item_from_object(self, char *itemp, object value):
  *         if self.to_dtype_func != NULL:             # <<<<<<<<<<<<<<
  *             self.to_dtype_func(itemp, value)
  *         else:
  */
     goto __pyx_L3;
   }
 
   /* "View.MemoryView":991
  *             self.to_dtype_func(itemp, value)
  *         else:
  *             memoryview.assign_item_from_object(self, itemp, value)             # <<<<<<<<<<<<<<
- *
+ * 
  *     @property
  */
   /*else*/ {
     __pyx_t_3 = __pyx_memoryview_assign_item_from_object(((struct __pyx_memoryview_obj *)__pyx_v_self), __pyx_v_itemp, __pyx_v_value); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 991, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   }
   __pyx_L3:;
 
   /* "View.MemoryView":987
  *             return memoryview.convert_item_to_object(self, itemp)
- *
+ * 
  *     cdef assign_item_from_object(self, char *itemp, object value):             # <<<<<<<<<<<<<<
  *         if self.to_dtype_func != NULL:
  *             self.to_dtype_func(itemp, value)
  */
 
   /* function exit code */
   __pyx_r = Py_None; __Pyx_INCREF(Py_None);
@@ -16126,19 +16655,19 @@
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "View.MemoryView":994
- *
+ * 
  *     @property
  *     def base(self):             # <<<<<<<<<<<<<<
  *         return self.from_object
- *
+ * 
  */
 
 /* Python wrapper */
 static PyObject *__pyx_pw_15View_dot_MemoryView_16_memoryviewslice_4base_1__get__(PyObject *__pyx_v_self); /*proto*/
 static PyObject *__pyx_pw_15View_dot_MemoryView_16_memoryviewslice_4base_1__get__(PyObject *__pyx_v_self) {
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
@@ -16155,28 +16684,28 @@
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__get__", 0);
 
   /* "View.MemoryView":995
  *     @property
  *     def base(self):
  *         return self.from_object             # <<<<<<<<<<<<<<
- *
+ * 
  *     __pyx_getbuffer = capsule(<void *> &__pyx_memoryview_getbuffer, "getbuffer(obj, view, flags)")
  */
   __Pyx_XDECREF(__pyx_r);
   __Pyx_INCREF(__pyx_v_self->from_object);
   __pyx_r = __pyx_v_self->from_object;
   goto __pyx_L0;
 
   /* "View.MemoryView":994
- *
+ * 
  *     @property
  *     def base(self):             # <<<<<<<<<<<<<<
  *         return self.from_object
- *
+ * 
  */
 
   /* function exit code */
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
@@ -16292,15 +16821,15 @@
   __pyx_r = NULL;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "View.MemoryView":1001
- *
+ * 
  * @cname('__pyx_memoryview_fromslice')
  * cdef memoryview_fromslice(__Pyx_memviewslice memviewslice,             # <<<<<<<<<<<<<<
  *                           int ndim,
  *                           object (*to_object_func)(char *),
  */
 
 static PyObject *__pyx_memoryview_fromslice(__Pyx_memviewslice __pyx_v_memviewslice, int __pyx_v_ndim, PyObject *(*__pyx_v_to_object_func)(char *), int (*__pyx_v_to_dtype_func)(char *, PyObject *), int __pyx_v_dtype_is_object) {
@@ -16321,47 +16850,47 @@
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("memoryview_fromslice", 0);
 
   /* "View.MemoryView":1009
  *     cdef _memoryviewslice result
- *
+ * 
  *     if <PyObject *> memviewslice.memview == Py_None:             # <<<<<<<<<<<<<<
  *         return None
- *
+ * 
  */
   __pyx_t_1 = ((((PyObject *)__pyx_v_memviewslice.memview) == Py_None) != 0);
   if (__pyx_t_1) {
 
     /* "View.MemoryView":1010
- *
+ * 
  *     if <PyObject *> memviewslice.memview == Py_None:
  *         return None             # <<<<<<<<<<<<<<
- *
- *
+ * 
+ * 
  */
     __Pyx_XDECREF(__pyx_r);
     __pyx_r = Py_None; __Pyx_INCREF(Py_None);
     goto __pyx_L0;
 
     /* "View.MemoryView":1009
  *     cdef _memoryviewslice result
- *
+ * 
  *     if <PyObject *> memviewslice.memview == Py_None:             # <<<<<<<<<<<<<<
  *         return None
- *
+ * 
  */
   }
 
   /* "View.MemoryView":1015
- *
- *
+ * 
+ * 
  *     result = _memoryviewslice(None, 0, dtype_is_object)             # <<<<<<<<<<<<<<
- *
+ * 
  *     result.from_slice = memviewslice
  */
   __pyx_t_2 = __Pyx_PyBool_FromLong(__pyx_v_dtype_is_object); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 1015, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_t_3 = PyTuple_New(3); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 1015, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_INCREF(Py_None);
@@ -16377,67 +16906,67 @@
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __pyx_v_result = ((struct __pyx_memoryviewslice_obj *)__pyx_t_2);
   __pyx_t_2 = 0;
 
   /* "View.MemoryView":1017
  *     result = _memoryviewslice(None, 0, dtype_is_object)
- *
+ * 
  *     result.from_slice = memviewslice             # <<<<<<<<<<<<<<
  *     __PYX_INC_MEMVIEW(&memviewslice, 1)
- *
+ * 
  */
   __pyx_v_result->from_slice = __pyx_v_memviewslice;
 
   /* "View.MemoryView":1018
- *
+ * 
  *     result.from_slice = memviewslice
  *     __PYX_INC_MEMVIEW(&memviewslice, 1)             # <<<<<<<<<<<<<<
- *
+ * 
  *     result.from_object = (<memoryview> memviewslice.memview).base
  */
   __PYX_INC_MEMVIEW((&__pyx_v_memviewslice), 1);
 
   /* "View.MemoryView":1020
  *     __PYX_INC_MEMVIEW(&memviewslice, 1)
- *
+ * 
  *     result.from_object = (<memoryview> memviewslice.memview).base             # <<<<<<<<<<<<<<
  *     result.typeinfo = memviewslice.memview.typeinfo
- *
+ * 
  */
   __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_memviewslice.memview), __pyx_n_s_base); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 1020, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_GIVEREF(__pyx_t_2);
   __Pyx_GOTREF(__pyx_v_result->from_object);
   __Pyx_DECREF(__pyx_v_result->from_object);
   __pyx_v_result->from_object = __pyx_t_2;
   __pyx_t_2 = 0;
 
   /* "View.MemoryView":1021
- *
+ * 
  *     result.from_object = (<memoryview> memviewslice.memview).base
  *     result.typeinfo = memviewslice.memview.typeinfo             # <<<<<<<<<<<<<<
- *
+ * 
  *     result.view = memviewslice.memview.view
  */
   __pyx_t_4 = __pyx_v_memviewslice.memview->typeinfo;
   __pyx_v_result->__pyx_base.typeinfo = __pyx_t_4;
 
   /* "View.MemoryView":1023
  *     result.typeinfo = memviewslice.memview.typeinfo
- *
+ * 
  *     result.view = memviewslice.memview.view             # <<<<<<<<<<<<<<
  *     result.view.buf = <void *> memviewslice.data
  *     result.view.ndim = ndim
  */
   __pyx_t_5 = __pyx_v_memviewslice.memview->view;
   __pyx_v_result->__pyx_base.view = __pyx_t_5;
 
   /* "View.MemoryView":1024
- *
+ * 
  *     result.view = memviewslice.memview.view
  *     result.view.buf = <void *> memviewslice.data             # <<<<<<<<<<<<<<
  *     result.view.ndim = ndim
  *     (<__pyx_buffer *> &result.view).obj = Py_None
  */
   __pyx_v_result->__pyx_base.view.buf = ((void *)__pyx_v_memviewslice.data);
 
@@ -16451,97 +16980,97 @@
   __pyx_v_result->__pyx_base.view.ndim = __pyx_v_ndim;
 
   /* "View.MemoryView":1026
  *     result.view.buf = <void *> memviewslice.data
  *     result.view.ndim = ndim
  *     (<__pyx_buffer *> &result.view).obj = Py_None             # <<<<<<<<<<<<<<
  *     Py_INCREF(Py_None)
- *
+ * 
  */
   ((Py_buffer *)(&__pyx_v_result->__pyx_base.view))->obj = Py_None;
 
   /* "View.MemoryView":1027
  *     result.view.ndim = ndim
  *     (<__pyx_buffer *> &result.view).obj = Py_None
  *     Py_INCREF(Py_None)             # <<<<<<<<<<<<<<
- *
+ * 
  *     if (<memoryview>memviewslice.memview).flags & PyBUF_WRITABLE:
  */
   Py_INCREF(Py_None);
 
   /* "View.MemoryView":1029
  *     Py_INCREF(Py_None)
- *
+ * 
  *     if (<memoryview>memviewslice.memview).flags & PyBUF_WRITABLE:             # <<<<<<<<<<<<<<
  *         result.flags = PyBUF_RECORDS
  *     else:
  */
   __pyx_t_1 = ((((struct __pyx_memoryview_obj *)__pyx_v_memviewslice.memview)->flags & PyBUF_WRITABLE) != 0);
   if (__pyx_t_1) {
 
     /* "View.MemoryView":1030
- *
+ * 
  *     if (<memoryview>memviewslice.memview).flags & PyBUF_WRITABLE:
  *         result.flags = PyBUF_RECORDS             # <<<<<<<<<<<<<<
  *     else:
  *         result.flags = PyBUF_RECORDS_RO
  */
     __pyx_v_result->__pyx_base.flags = PyBUF_RECORDS;
 
     /* "View.MemoryView":1029
  *     Py_INCREF(Py_None)
- *
+ * 
  *     if (<memoryview>memviewslice.memview).flags & PyBUF_WRITABLE:             # <<<<<<<<<<<<<<
  *         result.flags = PyBUF_RECORDS
  *     else:
  */
     goto __pyx_L4;
   }
 
   /* "View.MemoryView":1032
  *         result.flags = PyBUF_RECORDS
  *     else:
  *         result.flags = PyBUF_RECORDS_RO             # <<<<<<<<<<<<<<
- *
+ * 
  *     result.view.shape = <Py_ssize_t *> result.from_slice.shape
  */
   /*else*/ {
     __pyx_v_result->__pyx_base.flags = PyBUF_RECORDS_RO;
   }
   __pyx_L4:;
 
   /* "View.MemoryView":1034
  *         result.flags = PyBUF_RECORDS_RO
- *
+ * 
  *     result.view.shape = <Py_ssize_t *> result.from_slice.shape             # <<<<<<<<<<<<<<
  *     result.view.strides = <Py_ssize_t *> result.from_slice.strides
- *
+ * 
  */
   __pyx_v_result->__pyx_base.view.shape = ((Py_ssize_t *)__pyx_v_result->from_slice.shape);
 
   /* "View.MemoryView":1035
- *
+ * 
  *     result.view.shape = <Py_ssize_t *> result.from_slice.shape
  *     result.view.strides = <Py_ssize_t *> result.from_slice.strides             # <<<<<<<<<<<<<<
- *
- *
+ * 
+ * 
  */
   __pyx_v_result->__pyx_base.view.strides = ((Py_ssize_t *)__pyx_v_result->from_slice.strides);
 
   /* "View.MemoryView":1038
- *
- *
+ * 
+ * 
  *     result.view.suboffsets = NULL             # <<<<<<<<<<<<<<
  *     for suboffset in result.from_slice.suboffsets[:ndim]:
  *         if suboffset >= 0:
  */
   __pyx_v_result->__pyx_base.view.suboffsets = NULL;
 
   /* "View.MemoryView":1039
- *
+ * 
  *     result.view.suboffsets = NULL
  *     for suboffset in result.from_slice.suboffsets[:ndim]:             # <<<<<<<<<<<<<<
  *         if suboffset >= 0:
  *             result.view.suboffsets = <Py_ssize_t *> result.from_slice.suboffsets
  */
   __pyx_t_7 = (__pyx_v_result->from_slice.suboffsets + __pyx_v_ndim);
   for (__pyx_t_8 = __pyx_v_result->from_slice.suboffsets; __pyx_t_8 < __pyx_t_7; __pyx_t_8++) {
@@ -16559,23 +17088,23 @@
     if (__pyx_t_1) {
 
       /* "View.MemoryView":1041
  *     for suboffset in result.from_slice.suboffsets[:ndim]:
  *         if suboffset >= 0:
  *             result.view.suboffsets = <Py_ssize_t *> result.from_slice.suboffsets             # <<<<<<<<<<<<<<
  *             break
- *
+ * 
  */
       __pyx_v_result->__pyx_base.view.suboffsets = ((Py_ssize_t *)__pyx_v_result->from_slice.suboffsets);
 
       /* "View.MemoryView":1042
  *         if suboffset >= 0:
  *             result.view.suboffsets = <Py_ssize_t *> result.from_slice.suboffsets
  *             break             # <<<<<<<<<<<<<<
- *
+ * 
  *     result.view.len = result.view.itemsize
  */
       goto __pyx_L6_break;
 
       /* "View.MemoryView":1040
  *     result.view.suboffsets = NULL
  *     for suboffset in result.from_slice.suboffsets[:ndim]:
@@ -16585,86 +17114,86 @@
  */
     }
   }
   __pyx_L6_break:;
 
   /* "View.MemoryView":1044
  *             break
- *
+ * 
  *     result.view.len = result.view.itemsize             # <<<<<<<<<<<<<<
  *     for length in result.view.shape[:ndim]:
  *         result.view.len *= length
  */
   __pyx_t_9 = __pyx_v_result->__pyx_base.view.itemsize;
   __pyx_v_result->__pyx_base.view.len = __pyx_t_9;
 
   /* "View.MemoryView":1045
- *
+ * 
  *     result.view.len = result.view.itemsize
  *     for length in result.view.shape[:ndim]:             # <<<<<<<<<<<<<<
  *         result.view.len *= length
- *
+ * 
  */
   __pyx_t_7 = (__pyx_v_result->__pyx_base.view.shape + __pyx_v_ndim);
   for (__pyx_t_8 = __pyx_v_result->__pyx_base.view.shape; __pyx_t_8 < __pyx_t_7; __pyx_t_8++) {
     __pyx_t_6 = __pyx_t_8;
     __pyx_t_2 = PyInt_FromSsize_t((__pyx_t_6[0])); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 1045, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __Pyx_XDECREF_SET(__pyx_v_length, __pyx_t_2);
     __pyx_t_2 = 0;
 
     /* "View.MemoryView":1046
  *     result.view.len = result.view.itemsize
  *     for length in result.view.shape[:ndim]:
  *         result.view.len *= length             # <<<<<<<<<<<<<<
- *
+ * 
  *     result.to_object_func = to_object_func
  */
     __pyx_t_2 = PyInt_FromSsize_t(__pyx_v_result->__pyx_base.view.len); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 1046, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __pyx_t_3 = PyNumber_InPlaceMultiply(__pyx_t_2, __pyx_v_length); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 1046, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
     __pyx_t_9 = __Pyx_PyIndex_AsSsize_t(__pyx_t_3); if (unlikely((__pyx_t_9 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(2, 1046, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     __pyx_v_result->__pyx_base.view.len = __pyx_t_9;
   }
 
   /* "View.MemoryView":1048
  *         result.view.len *= length
- *
+ * 
  *     result.to_object_func = to_object_func             # <<<<<<<<<<<<<<
  *     result.to_dtype_func = to_dtype_func
- *
+ * 
  */
   __pyx_v_result->to_object_func = __pyx_v_to_object_func;
 
   /* "View.MemoryView":1049
- *
+ * 
  *     result.to_object_func = to_object_func
  *     result.to_dtype_func = to_dtype_func             # <<<<<<<<<<<<<<
- *
+ * 
  *     return result
  */
   __pyx_v_result->to_dtype_func = __pyx_v_to_dtype_func;
 
   /* "View.MemoryView":1051
  *     result.to_dtype_func = to_dtype_func
- *
+ * 
  *     return result             # <<<<<<<<<<<<<<
- *
+ * 
  * @cname('__pyx_memoryview_get_slice_from_memoryview')
  */
   __Pyx_XDECREF(__pyx_r);
   __Pyx_INCREF(((PyObject *)__pyx_v_result));
   __pyx_r = ((PyObject *)__pyx_v_result);
   goto __pyx_L0;
 
   /* "View.MemoryView":1001
- *
+ * 
  * @cname('__pyx_memoryview_fromslice')
  * cdef memoryview_fromslice(__Pyx_memviewslice memviewslice,             # <<<<<<<<<<<<<<
  *                           int ndim,
  *                           object (*to_object_func)(char *),
  */
 
   /* function exit code */
@@ -16678,15 +17207,15 @@
   __Pyx_XDECREF(__pyx_v_length);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "View.MemoryView":1054
- *
+ * 
  * @cname('__pyx_memoryview_get_slice_from_memoryview')
  * cdef __Pyx_memviewslice *get_slice_from_memview(memoryview memview,             # <<<<<<<<<<<<<<
  *                                                    __Pyx_memviewslice *mslice) except NULL:
  *     cdef _memoryviewslice obj
  */
 
 static __Pyx_memviewslice *__pyx_memoryview_get_slice_from_memoryview(struct __pyx_memoryview_obj *__pyx_v_memview, __Pyx_memviewslice *__pyx_v_mslice) {
@@ -16704,15 +17233,15 @@
   /* "View.MemoryView":1057
  *                                                    __Pyx_memviewslice *mslice) except NULL:
  *     cdef _memoryviewslice obj
  *     if isinstance(memview, _memoryviewslice):             # <<<<<<<<<<<<<<
  *         obj = memview
  *         return &obj.from_slice
  */
-  __pyx_t_1 = __Pyx_TypeCheck(((PyObject *)__pyx_v_memview), __pyx_memoryviewslice_type);
+  __pyx_t_1 = __Pyx_TypeCheck(((PyObject *)__pyx_v_memview), __pyx_memoryviewslice_type); 
   __pyx_t_2 = (__pyx_t_1 != 0);
   if (__pyx_t_2) {
 
     /* "View.MemoryView":1058
  *     cdef _memoryviewslice obj
  *     if isinstance(memview, _memoryviewslice):
  *         obj = memview             # <<<<<<<<<<<<<<
@@ -16745,32 +17274,32 @@
   }
 
   /* "View.MemoryView":1061
  *         return &obj.from_slice
  *     else:
  *         slice_copy(memview, mslice)             # <<<<<<<<<<<<<<
  *         return mslice
- *
+ * 
  */
   /*else*/ {
     __pyx_memoryview_slice_copy(__pyx_v_memview, __pyx_v_mslice);
 
     /* "View.MemoryView":1062
  *     else:
  *         slice_copy(memview, mslice)
  *         return mslice             # <<<<<<<<<<<<<<
- *
+ * 
  * @cname('__pyx_memoryview_slice_copy')
  */
     __pyx_r = __pyx_v_mslice;
     goto __pyx_L0;
   }
 
   /* "View.MemoryView":1054
- *
+ * 
  * @cname('__pyx_memoryview_get_slice_from_memoryview')
  * cdef __Pyx_memviewslice *get_slice_from_memview(memoryview memview,             # <<<<<<<<<<<<<<
  *                                                    __Pyx_memviewslice *mslice) except NULL:
  *     cdef _memoryviewslice obj
  */
 
   /* function exit code */
@@ -16781,15 +17310,15 @@
   __pyx_L0:;
   __Pyx_XDECREF((PyObject *)__pyx_v_obj);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "View.MemoryView":1065
- *
+ * 
  * @cname('__pyx_memoryview_slice_copy')
  * cdef void slice_copy(memoryview memview, __Pyx_memviewslice *dst):             # <<<<<<<<<<<<<<
  *     cdef int dim
  *     cdef (Py_ssize_t*) shape, strides, suboffsets
  */
 
 static void __pyx_memoryview_slice_copy(struct __pyx_memoryview_obj *__pyx_v_memview, __Pyx_memviewslice *__pyx_v_dst) {
@@ -16803,119 +17332,119 @@
   int __pyx_t_3;
   int __pyx_t_4;
   Py_ssize_t __pyx_t_5;
   __Pyx_RefNannySetupContext("slice_copy", 0);
 
   /* "View.MemoryView":1069
  *     cdef (Py_ssize_t*) shape, strides, suboffsets
- *
+ * 
  *     shape = memview.view.shape             # <<<<<<<<<<<<<<
  *     strides = memview.view.strides
  *     suboffsets = memview.view.suboffsets
  */
   __pyx_t_1 = __pyx_v_memview->view.shape;
   __pyx_v_shape = __pyx_t_1;
 
   /* "View.MemoryView":1070
- *
+ * 
  *     shape = memview.view.shape
  *     strides = memview.view.strides             # <<<<<<<<<<<<<<
  *     suboffsets = memview.view.suboffsets
- *
+ * 
  */
   __pyx_t_1 = __pyx_v_memview->view.strides;
   __pyx_v_strides = __pyx_t_1;
 
   /* "View.MemoryView":1071
  *     shape = memview.view.shape
  *     strides = memview.view.strides
  *     suboffsets = memview.view.suboffsets             # <<<<<<<<<<<<<<
- *
+ * 
  *     dst.memview = <__pyx_memoryview *> memview
  */
   __pyx_t_1 = __pyx_v_memview->view.suboffsets;
   __pyx_v_suboffsets = __pyx_t_1;
 
   /* "View.MemoryView":1073
  *     suboffsets = memview.view.suboffsets
- *
+ * 
  *     dst.memview = <__pyx_memoryview *> memview             # <<<<<<<<<<<<<<
  *     dst.data = <char *> memview.view.buf
- *
+ * 
  */
   __pyx_v_dst->memview = ((struct __pyx_memoryview_obj *)__pyx_v_memview);
 
   /* "View.MemoryView":1074
- *
+ * 
  *     dst.memview = <__pyx_memoryview *> memview
  *     dst.data = <char *> memview.view.buf             # <<<<<<<<<<<<<<
- *
+ * 
  *     for dim in range(memview.view.ndim):
  */
   __pyx_v_dst->data = ((char *)__pyx_v_memview->view.buf);
 
   /* "View.MemoryView":1076
  *     dst.data = <char *> memview.view.buf
- *
+ * 
  *     for dim in range(memview.view.ndim):             # <<<<<<<<<<<<<<
  *         dst.shape[dim] = shape[dim]
  *         dst.strides[dim] = strides[dim]
  */
   __pyx_t_2 = __pyx_v_memview->view.ndim;
   __pyx_t_3 = __pyx_t_2;
   for (__pyx_t_4 = 0; __pyx_t_4 < __pyx_t_3; __pyx_t_4+=1) {
     __pyx_v_dim = __pyx_t_4;
 
     /* "View.MemoryView":1077
- *
+ * 
  *     for dim in range(memview.view.ndim):
  *         dst.shape[dim] = shape[dim]             # <<<<<<<<<<<<<<
  *         dst.strides[dim] = strides[dim]
  *         dst.suboffsets[dim] = suboffsets[dim] if suboffsets else -1
  */
     (__pyx_v_dst->shape[__pyx_v_dim]) = (__pyx_v_shape[__pyx_v_dim]);
 
     /* "View.MemoryView":1078
  *     for dim in range(memview.view.ndim):
  *         dst.shape[dim] = shape[dim]
  *         dst.strides[dim] = strides[dim]             # <<<<<<<<<<<<<<
  *         dst.suboffsets[dim] = suboffsets[dim] if suboffsets else -1
- *
+ * 
  */
     (__pyx_v_dst->strides[__pyx_v_dim]) = (__pyx_v_strides[__pyx_v_dim]);
 
     /* "View.MemoryView":1079
  *         dst.shape[dim] = shape[dim]
  *         dst.strides[dim] = strides[dim]
  *         dst.suboffsets[dim] = suboffsets[dim] if suboffsets else -1             # <<<<<<<<<<<<<<
- *
+ * 
  * @cname('__pyx_memoryview_copy_object')
  */
     if ((__pyx_v_suboffsets != 0)) {
       __pyx_t_5 = (__pyx_v_suboffsets[__pyx_v_dim]);
     } else {
       __pyx_t_5 = -1L;
     }
     (__pyx_v_dst->suboffsets[__pyx_v_dim]) = __pyx_t_5;
   }
 
   /* "View.MemoryView":1065
- *
+ * 
  * @cname('__pyx_memoryview_slice_copy')
  * cdef void slice_copy(memoryview memview, __Pyx_memviewslice *dst):             # <<<<<<<<<<<<<<
  *     cdef int dim
  *     cdef (Py_ssize_t*) shape, strides, suboffsets
  */
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
 }
 
 /* "View.MemoryView":1082
- *
+ * 
  * @cname('__pyx_memoryview_copy_object')
  * cdef memoryview_copy(memoryview memview):             # <<<<<<<<<<<<<<
  *     "Create a new memoryview object"
  *     cdef __Pyx_memviewslice memviewslice
  */
 
 static PyObject *__pyx_memoryview_copy_object(struct __pyx_memoryview_obj *__pyx_v_memview) {
@@ -16929,34 +17458,34 @@
   __Pyx_RefNannySetupContext("memoryview_copy", 0);
 
   /* "View.MemoryView":1085
  *     "Create a new memoryview object"
  *     cdef __Pyx_memviewslice memviewslice
  *     slice_copy(memview, &memviewslice)             # <<<<<<<<<<<<<<
  *     return memoryview_copy_from_slice(memview, &memviewslice)
- *
+ * 
  */
   __pyx_memoryview_slice_copy(__pyx_v_memview, (&__pyx_v_memviewslice));
 
   /* "View.MemoryView":1086
  *     cdef __Pyx_memviewslice memviewslice
  *     slice_copy(memview, &memviewslice)
  *     return memoryview_copy_from_slice(memview, &memviewslice)             # <<<<<<<<<<<<<<
- *
+ * 
  * @cname('__pyx_memoryview_copy_object_from_slice')
  */
   __Pyx_XDECREF(__pyx_r);
   __pyx_t_1 = __pyx_memoryview_copy_object_from_slice(__pyx_v_memview, (&__pyx_v_memviewslice)); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 1086, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
   /* "View.MemoryView":1082
- *
+ * 
  * @cname('__pyx_memoryview_copy_object')
  * cdef memoryview_copy(memoryview memview):             # <<<<<<<<<<<<<<
  *     "Create a new memoryview object"
  *     cdef __Pyx_memviewslice memviewslice
  */
 
   /* function exit code */
@@ -16967,15 +17496,15 @@
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "View.MemoryView":1089
- *
+ * 
  * @cname('__pyx_memoryview_copy_object_from_slice')
  * cdef memoryview_copy_from_slice(memoryview memview, __Pyx_memviewslice *memviewslice):             # <<<<<<<<<<<<<<
  *     """
  *     Create a new memoryview object from a given memoryview object and slice.
  */
 
 static PyObject *__pyx_memoryview_copy_object_from_slice(struct __pyx_memoryview_obj *__pyx_v_memview, __Pyx_memviewslice *__pyx_v_memviewslice) {
@@ -16991,25 +17520,25 @@
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("memoryview_copy_from_slice", 0);
 
   /* "View.MemoryView":1096
  *     cdef int (*to_dtype_func)(char *, object) except 0
- *
+ * 
  *     if isinstance(memview, _memoryviewslice):             # <<<<<<<<<<<<<<
  *         to_object_func = (<_memoryviewslice> memview).to_object_func
  *         to_dtype_func = (<_memoryviewslice> memview).to_dtype_func
  */
-  __pyx_t_1 = __Pyx_TypeCheck(((PyObject *)__pyx_v_memview), __pyx_memoryviewslice_type);
+  __pyx_t_1 = __Pyx_TypeCheck(((PyObject *)__pyx_v_memview), __pyx_memoryviewslice_type); 
   __pyx_t_2 = (__pyx_t_1 != 0);
   if (__pyx_t_2) {
 
     /* "View.MemoryView":1097
- *
+ * 
  *     if isinstance(memview, _memoryviewslice):
  *         to_object_func = (<_memoryviewslice> memview).to_object_func             # <<<<<<<<<<<<<<
  *         to_dtype_func = (<_memoryviewslice> memview).to_dtype_func
  *     else:
  */
     __pyx_t_3 = ((struct __pyx_memoryviewslice_obj *)__pyx_v_memview)->to_object_func;
     __pyx_v_to_object_func = __pyx_t_3;
@@ -17022,67 +17551,67 @@
  *         to_object_func = NULL
  */
     __pyx_t_4 = ((struct __pyx_memoryviewslice_obj *)__pyx_v_memview)->to_dtype_func;
     __pyx_v_to_dtype_func = __pyx_t_4;
 
     /* "View.MemoryView":1096
  *     cdef int (*to_dtype_func)(char *, object) except 0
- *
+ * 
  *     if isinstance(memview, _memoryviewslice):             # <<<<<<<<<<<<<<
  *         to_object_func = (<_memoryviewslice> memview).to_object_func
  *         to_dtype_func = (<_memoryviewslice> memview).to_dtype_func
  */
     goto __pyx_L3;
   }
 
   /* "View.MemoryView":1100
  *         to_dtype_func = (<_memoryviewslice> memview).to_dtype_func
  *     else:
  *         to_object_func = NULL             # <<<<<<<<<<<<<<
  *         to_dtype_func = NULL
- *
+ * 
  */
   /*else*/ {
     __pyx_v_to_object_func = NULL;
 
     /* "View.MemoryView":1101
  *     else:
  *         to_object_func = NULL
  *         to_dtype_func = NULL             # <<<<<<<<<<<<<<
- *
+ * 
  *     return memoryview_fromslice(memviewslice[0], memview.view.ndim,
  */
     __pyx_v_to_dtype_func = NULL;
   }
   __pyx_L3:;
 
   /* "View.MemoryView":1103
  *         to_dtype_func = NULL
- *
+ * 
  *     return memoryview_fromslice(memviewslice[0], memview.view.ndim,             # <<<<<<<<<<<<<<
  *                                 to_object_func, to_dtype_func,
  *                                 memview.dtype_is_object)
  */
   __Pyx_XDECREF(__pyx_r);
 
   /* "View.MemoryView":1105
  *     return memoryview_fromslice(memviewslice[0], memview.view.ndim,
  *                                 to_object_func, to_dtype_func,
  *                                 memview.dtype_is_object)             # <<<<<<<<<<<<<<
- *
- *
+ * 
+ * 
  */
   __pyx_t_5 = __pyx_memoryview_fromslice((__pyx_v_memviewslice[0]), __pyx_v_memview->view.ndim, __pyx_v_to_object_func, __pyx_v_to_dtype_func, __pyx_v_memview->dtype_is_object); if (unlikely(!__pyx_t_5)) __PYX_ERR(2, 1103, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_5);
   __pyx_r = __pyx_t_5;
   __pyx_t_5 = 0;
   goto __pyx_L0;
 
   /* "View.MemoryView":1089
- *
+ * 
  * @cname('__pyx_memoryview_copy_object_from_slice')
  * cdef memoryview_copy_from_slice(memoryview memview, __Pyx_memviewslice *memviewslice):             # <<<<<<<<<<<<<<
  *     """
  *     Create a new memoryview object from a given memoryview object and slice.
  */
 
   /* function exit code */
@@ -17093,27 +17622,27 @@
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "View.MemoryView":1111
- *
- *
+ * 
+ * 
  * cdef Py_ssize_t abs_py_ssize_t(Py_ssize_t arg) nogil:             # <<<<<<<<<<<<<<
  *     if arg < 0:
  *         return -arg
  */
 
 static Py_ssize_t abs_py_ssize_t(Py_ssize_t __pyx_v_arg) {
   Py_ssize_t __pyx_r;
   int __pyx_t_1;
 
   /* "View.MemoryView":1112
- *
+ * 
  * cdef Py_ssize_t abs_py_ssize_t(Py_ssize_t arg) nogil:
  *     if arg < 0:             # <<<<<<<<<<<<<<
  *         return -arg
  *     else:
  */
   __pyx_t_1 = ((__pyx_v_arg < 0) != 0);
   if (__pyx_t_1) {
@@ -17125,49 +17654,49 @@
  *     else:
  *         return arg
  */
     __pyx_r = (-__pyx_v_arg);
     goto __pyx_L0;
 
     /* "View.MemoryView":1112
- *
+ * 
  * cdef Py_ssize_t abs_py_ssize_t(Py_ssize_t arg) nogil:
  *     if arg < 0:             # <<<<<<<<<<<<<<
  *         return -arg
  *     else:
  */
   }
 
   /* "View.MemoryView":1115
  *         return -arg
  *     else:
  *         return arg             # <<<<<<<<<<<<<<
- *
+ * 
  * @cname('__pyx_get_best_slice_order')
  */
   /*else*/ {
     __pyx_r = __pyx_v_arg;
     goto __pyx_L0;
   }
 
   /* "View.MemoryView":1111
- *
- *
+ * 
+ * 
  * cdef Py_ssize_t abs_py_ssize_t(Py_ssize_t arg) nogil:             # <<<<<<<<<<<<<<
  *     if arg < 0:
  *         return -arg
  */
 
   /* function exit code */
   __pyx_L0:;
   return __pyx_r;
 }
 
 /* "View.MemoryView":1118
- *
+ * 
  * @cname('__pyx_get_best_slice_order')
  * cdef char get_best_order(__Pyx_memviewslice *mslice, int ndim) nogil:             # <<<<<<<<<<<<<<
  *     """
  *     Figure out the best memory access order for a given slice.
  */
 
 static char __pyx_get_best_slice_order(__Pyx_memviewslice *__pyx_v_mslice, int __pyx_v_ndim) {
@@ -17181,183 +17710,183 @@
   int __pyx_t_4;
 
   /* "View.MemoryView":1123
  *     """
  *     cdef int i
  *     cdef Py_ssize_t c_stride = 0             # <<<<<<<<<<<<<<
  *     cdef Py_ssize_t f_stride = 0
- *
+ * 
  */
   __pyx_v_c_stride = 0;
 
   /* "View.MemoryView":1124
  *     cdef int i
  *     cdef Py_ssize_t c_stride = 0
  *     cdef Py_ssize_t f_stride = 0             # <<<<<<<<<<<<<<
- *
+ * 
  *     for i in range(ndim - 1, -1, -1):
  */
   __pyx_v_f_stride = 0;
 
   /* "View.MemoryView":1126
  *     cdef Py_ssize_t f_stride = 0
- *
+ * 
  *     for i in range(ndim - 1, -1, -1):             # <<<<<<<<<<<<<<
  *         if mslice.shape[i] > 1:
  *             c_stride = mslice.strides[i]
  */
   for (__pyx_t_1 = (__pyx_v_ndim - 1); __pyx_t_1 > -1; __pyx_t_1-=1) {
     __pyx_v_i = __pyx_t_1;
 
     /* "View.MemoryView":1127
- *
+ * 
  *     for i in range(ndim - 1, -1, -1):
  *         if mslice.shape[i] > 1:             # <<<<<<<<<<<<<<
  *             c_stride = mslice.strides[i]
  *             break
  */
     __pyx_t_2 = (((__pyx_v_mslice->shape[__pyx_v_i]) > 1) != 0);
     if (__pyx_t_2) {
 
       /* "View.MemoryView":1128
  *     for i in range(ndim - 1, -1, -1):
  *         if mslice.shape[i] > 1:
  *             c_stride = mslice.strides[i]             # <<<<<<<<<<<<<<
  *             break
- *
+ * 
  */
       __pyx_v_c_stride = (__pyx_v_mslice->strides[__pyx_v_i]);
 
       /* "View.MemoryView":1129
  *         if mslice.shape[i] > 1:
  *             c_stride = mslice.strides[i]
  *             break             # <<<<<<<<<<<<<<
- *
+ * 
  *     for i in range(ndim):
  */
       goto __pyx_L4_break;
 
       /* "View.MemoryView":1127
- *
+ * 
  *     for i in range(ndim - 1, -1, -1):
  *         if mslice.shape[i] > 1:             # <<<<<<<<<<<<<<
  *             c_stride = mslice.strides[i]
  *             break
  */
     }
   }
   __pyx_L4_break:;
 
   /* "View.MemoryView":1131
  *             break
- *
+ * 
  *     for i in range(ndim):             # <<<<<<<<<<<<<<
  *         if mslice.shape[i] > 1:
  *             f_stride = mslice.strides[i]
  */
   __pyx_t_1 = __pyx_v_ndim;
   __pyx_t_3 = __pyx_t_1;
   for (__pyx_t_4 = 0; __pyx_t_4 < __pyx_t_3; __pyx_t_4+=1) {
     __pyx_v_i = __pyx_t_4;
 
     /* "View.MemoryView":1132
- *
+ * 
  *     for i in range(ndim):
  *         if mslice.shape[i] > 1:             # <<<<<<<<<<<<<<
  *             f_stride = mslice.strides[i]
  *             break
  */
     __pyx_t_2 = (((__pyx_v_mslice->shape[__pyx_v_i]) > 1) != 0);
     if (__pyx_t_2) {
 
       /* "View.MemoryView":1133
  *     for i in range(ndim):
  *         if mslice.shape[i] > 1:
  *             f_stride = mslice.strides[i]             # <<<<<<<<<<<<<<
  *             break
- *
+ * 
  */
       __pyx_v_f_stride = (__pyx_v_mslice->strides[__pyx_v_i]);
 
       /* "View.MemoryView":1134
  *         if mslice.shape[i] > 1:
  *             f_stride = mslice.strides[i]
  *             break             # <<<<<<<<<<<<<<
- *
+ * 
  *     if abs_py_ssize_t(c_stride) <= abs_py_ssize_t(f_stride):
  */
       goto __pyx_L7_break;
 
       /* "View.MemoryView":1132
- *
+ * 
  *     for i in range(ndim):
  *         if mslice.shape[i] > 1:             # <<<<<<<<<<<<<<
  *             f_stride = mslice.strides[i]
  *             break
  */
     }
   }
   __pyx_L7_break:;
 
   /* "View.MemoryView":1136
  *             break
- *
+ * 
  *     if abs_py_ssize_t(c_stride) <= abs_py_ssize_t(f_stride):             # <<<<<<<<<<<<<<
  *         return 'C'
  *     else:
  */
   __pyx_t_2 = ((abs_py_ssize_t(__pyx_v_c_stride) <= abs_py_ssize_t(__pyx_v_f_stride)) != 0);
   if (__pyx_t_2) {
 
     /* "View.MemoryView":1137
- *
+ * 
  *     if abs_py_ssize_t(c_stride) <= abs_py_ssize_t(f_stride):
  *         return 'C'             # <<<<<<<<<<<<<<
  *     else:
  *         return 'F'
  */
     __pyx_r = 'C';
     goto __pyx_L0;
 
     /* "View.MemoryView":1136
  *             break
- *
+ * 
  *     if abs_py_ssize_t(c_stride) <= abs_py_ssize_t(f_stride):             # <<<<<<<<<<<<<<
  *         return 'C'
  *     else:
  */
   }
 
   /* "View.MemoryView":1139
  *         return 'C'
  *     else:
  *         return 'F'             # <<<<<<<<<<<<<<
- *
+ * 
  * @cython.cdivision(True)
  */
   /*else*/ {
     __pyx_r = 'F';
     goto __pyx_L0;
   }
 
   /* "View.MemoryView":1118
- *
+ * 
  * @cname('__pyx_get_best_slice_order')
  * cdef char get_best_order(__Pyx_memviewslice *mslice, int ndim) nogil:             # <<<<<<<<<<<<<<
  *     """
  *     Figure out the best memory access order for a given slice.
  */
 
   /* function exit code */
   __pyx_L0:;
   return __pyx_r;
 }
 
 /* "View.MemoryView":1142
- *
+ * 
  * @cython.cdivision(True)
  * cdef void _copy_strided_to_strided(char *src_data, Py_ssize_t *src_strides,             # <<<<<<<<<<<<<<
  *                                    char *dst_data, Py_ssize_t *dst_strides,
  *                                    Py_ssize_t *src_shape, Py_ssize_t *dst_shape,
  */
 
 static void _copy_strided_to_strided(char *__pyx_v_src_data, Py_ssize_t *__pyx_v_src_strides, char *__pyx_v_dst_data, Py_ssize_t *__pyx_v_dst_strides, Py_ssize_t *__pyx_v_src_shape, Py_ssize_t *__pyx_v_dst_shape, int __pyx_v_ndim, size_t __pyx_v_itemsize) {
@@ -17370,15 +17899,15 @@
   int __pyx_t_2;
   int __pyx_t_3;
   Py_ssize_t __pyx_t_4;
   Py_ssize_t __pyx_t_5;
   Py_ssize_t __pyx_t_6;
 
   /* "View.MemoryView":1149
- *
+ * 
  *     cdef Py_ssize_t i
  *     cdef Py_ssize_t src_extent = src_shape[0]             # <<<<<<<<<<<<<<
  *     cdef Py_ssize_t dst_extent = dst_shape[0]
  *     cdef Py_ssize_t src_stride = src_strides[0]
  */
   __pyx_v_src_extent = (__pyx_v_src_shape[0]);
 
@@ -17392,39 +17921,39 @@
   __pyx_v_dst_extent = (__pyx_v_dst_shape[0]);
 
   /* "View.MemoryView":1151
  *     cdef Py_ssize_t src_extent = src_shape[0]
  *     cdef Py_ssize_t dst_extent = dst_shape[0]
  *     cdef Py_ssize_t src_stride = src_strides[0]             # <<<<<<<<<<<<<<
  *     cdef Py_ssize_t dst_stride = dst_strides[0]
- *
+ * 
  */
   __pyx_v_src_stride = (__pyx_v_src_strides[0]);
 
   /* "View.MemoryView":1152
  *     cdef Py_ssize_t dst_extent = dst_shape[0]
  *     cdef Py_ssize_t src_stride = src_strides[0]
  *     cdef Py_ssize_t dst_stride = dst_strides[0]             # <<<<<<<<<<<<<<
- *
+ * 
  *     if ndim == 1:
  */
   __pyx_v_dst_stride = (__pyx_v_dst_strides[0]);
 
   /* "View.MemoryView":1154
  *     cdef Py_ssize_t dst_stride = dst_strides[0]
- *
+ * 
  *     if ndim == 1:             # <<<<<<<<<<<<<<
  *        if (src_stride > 0 and dst_stride > 0 and
  *            <size_t> src_stride == itemsize == <size_t> dst_stride):
  */
   __pyx_t_1 = ((__pyx_v_ndim == 1) != 0);
   if (__pyx_t_1) {
 
     /* "View.MemoryView":1155
- *
+ * 
  *     if ndim == 1:
  *        if (src_stride > 0 and dst_stride > 0 and             # <<<<<<<<<<<<<<
  *            <size_t> src_stride == itemsize == <size_t> dst_stride):
  *            memcpy(dst_data, src_data, itemsize * dst_extent)
  */
     __pyx_t_2 = ((__pyx_v_src_stride > 0) != 0);
     if (__pyx_t_2) {
@@ -17451,15 +17980,15 @@
       __pyx_t_2 = (__pyx_v_itemsize == ((size_t)__pyx_v_dst_stride));
     }
     __pyx_t_3 = (__pyx_t_2 != 0);
     __pyx_t_1 = __pyx_t_3;
     __pyx_L5_bool_binop_done:;
 
     /* "View.MemoryView":1155
- *
+ * 
  *     if ndim == 1:
  *        if (src_stride > 0 and dst_stride > 0 and             # <<<<<<<<<<<<<<
  *            <size_t> src_stride == itemsize == <size_t> dst_stride):
  *            memcpy(dst_data, src_data, itemsize * dst_extent)
  */
     if (__pyx_t_1) {
 
@@ -17469,15 +17998,15 @@
  *            memcpy(dst_data, src_data, itemsize * dst_extent)             # <<<<<<<<<<<<<<
  *        else:
  *            for i in range(dst_extent):
  */
       (void)(memcpy(__pyx_v_dst_data, __pyx_v_src_data, (__pyx_v_itemsize * __pyx_v_dst_extent)));
 
       /* "View.MemoryView":1155
- *
+ * 
  *     if ndim == 1:
  *        if (src_stride > 0 and dst_stride > 0 and             # <<<<<<<<<<<<<<
  *            <size_t> src_stride == itemsize == <size_t> dst_stride):
  *            memcpy(dst_data, src_data, itemsize * dst_extent)
  */
       goto __pyx_L4;
     }
@@ -17523,15 +18052,15 @@
         __pyx_v_dst_data = (__pyx_v_dst_data + __pyx_v_dst_stride);
       }
     }
     __pyx_L4:;
 
     /* "View.MemoryView":1154
  *     cdef Py_ssize_t dst_stride = dst_strides[0]
- *
+ * 
  *     if ndim == 1:             # <<<<<<<<<<<<<<
  *        if (src_stride > 0 and dst_stride > 0 and
  *            <size_t> src_stride == itemsize == <size_t> dst_stride):
  */
     goto __pyx_L3;
   }
 
@@ -17558,73 +18087,73 @@
       _copy_strided_to_strided(__pyx_v_src_data, (__pyx_v_src_strides + 1), __pyx_v_dst_data, (__pyx_v_dst_strides + 1), (__pyx_v_src_shape + 1), (__pyx_v_dst_shape + 1), (__pyx_v_ndim - 1), __pyx_v_itemsize);
 
       /* "View.MemoryView":1169
  *                                      src_shape + 1, dst_shape + 1,
  *                                      ndim - 1, itemsize)
  *             src_data += src_stride             # <<<<<<<<<<<<<<
  *             dst_data += dst_stride
- *
+ * 
  */
       __pyx_v_src_data = (__pyx_v_src_data + __pyx_v_src_stride);
 
       /* "View.MemoryView":1170
  *                                      ndim - 1, itemsize)
  *             src_data += src_stride
  *             dst_data += dst_stride             # <<<<<<<<<<<<<<
- *
+ * 
  * cdef void copy_strided_to_strided(__Pyx_memviewslice *src,
  */
       __pyx_v_dst_data = (__pyx_v_dst_data + __pyx_v_dst_stride);
     }
   }
   __pyx_L3:;
 
   /* "View.MemoryView":1142
- *
+ * 
  * @cython.cdivision(True)
  * cdef void _copy_strided_to_strided(char *src_data, Py_ssize_t *src_strides,             # <<<<<<<<<<<<<<
  *                                    char *dst_data, Py_ssize_t *dst_strides,
  *                                    Py_ssize_t *src_shape, Py_ssize_t *dst_shape,
  */
 
   /* function exit code */
 }
 
 /* "View.MemoryView":1172
  *             dst_data += dst_stride
- *
+ * 
  * cdef void copy_strided_to_strided(__Pyx_memviewslice *src,             # <<<<<<<<<<<<<<
  *                                   __Pyx_memviewslice *dst,
  *                                   int ndim, size_t itemsize) nogil:
  */
 
 static void copy_strided_to_strided(__Pyx_memviewslice *__pyx_v_src, __Pyx_memviewslice *__pyx_v_dst, int __pyx_v_ndim, size_t __pyx_v_itemsize) {
 
   /* "View.MemoryView":1175
  *                                   __Pyx_memviewslice *dst,
  *                                   int ndim, size_t itemsize) nogil:
  *     _copy_strided_to_strided(src.data, src.strides, dst.data, dst.strides,             # <<<<<<<<<<<<<<
  *                              src.shape, dst.shape, ndim, itemsize)
- *
+ * 
  */
   _copy_strided_to_strided(__pyx_v_src->data, __pyx_v_src->strides, __pyx_v_dst->data, __pyx_v_dst->strides, __pyx_v_src->shape, __pyx_v_dst->shape, __pyx_v_ndim, __pyx_v_itemsize);
 
   /* "View.MemoryView":1172
  *             dst_data += dst_stride
- *
+ * 
  * cdef void copy_strided_to_strided(__Pyx_memviewslice *src,             # <<<<<<<<<<<<<<
  *                                   __Pyx_memviewslice *dst,
  *                                   int ndim, size_t itemsize) nogil:
  */
 
   /* function exit code */
 }
 
 /* "View.MemoryView":1179
- *
+ * 
  * @cname('__pyx_memoryview_slice_get_size')
  * cdef Py_ssize_t slice_get_size(__Pyx_memviewslice *src, int ndim) nogil:             # <<<<<<<<<<<<<<
  *     "Return the size of the memory occupied by the slice in number of bytes"
  *     cdef Py_ssize_t shape, size = src.memview.view.itemsize
  */
 
 static Py_ssize_t __pyx_memoryview_slice_get_size(__Pyx_memviewslice *__pyx_v_src, int __pyx_v_ndim) {
@@ -17636,67 +18165,67 @@
   Py_ssize_t *__pyx_t_3;
   Py_ssize_t *__pyx_t_4;
 
   /* "View.MemoryView":1181
  * cdef Py_ssize_t slice_get_size(__Pyx_memviewslice *src, int ndim) nogil:
  *     "Return the size of the memory occupied by the slice in number of bytes"
  *     cdef Py_ssize_t shape, size = src.memview.view.itemsize             # <<<<<<<<<<<<<<
- *
+ * 
  *     for shape in src.shape[:ndim]:
  */
   __pyx_t_1 = __pyx_v_src->memview->view.itemsize;
   __pyx_v_size = __pyx_t_1;
 
   /* "View.MemoryView":1183
  *     cdef Py_ssize_t shape, size = src.memview.view.itemsize
- *
+ * 
  *     for shape in src.shape[:ndim]:             # <<<<<<<<<<<<<<
  *         size *= shape
- *
+ * 
  */
   __pyx_t_3 = (__pyx_v_src->shape + __pyx_v_ndim);
   for (__pyx_t_4 = __pyx_v_src->shape; __pyx_t_4 < __pyx_t_3; __pyx_t_4++) {
     __pyx_t_2 = __pyx_t_4;
     __pyx_v_shape = (__pyx_t_2[0]);
 
     /* "View.MemoryView":1184
- *
+ * 
  *     for shape in src.shape[:ndim]:
  *         size *= shape             # <<<<<<<<<<<<<<
- *
+ * 
  *     return size
  */
     __pyx_v_size = (__pyx_v_size * __pyx_v_shape);
   }
 
   /* "View.MemoryView":1186
  *         size *= shape
- *
+ * 
  *     return size             # <<<<<<<<<<<<<<
- *
+ * 
  * @cname('__pyx_fill_contig_strides_array')
  */
   __pyx_r = __pyx_v_size;
   goto __pyx_L0;
 
   /* "View.MemoryView":1179
- *
+ * 
  * @cname('__pyx_memoryview_slice_get_size')
  * cdef Py_ssize_t slice_get_size(__Pyx_memviewslice *src, int ndim) nogil:             # <<<<<<<<<<<<<<
  *     "Return the size of the memory occupied by the slice in number of bytes"
  *     cdef Py_ssize_t shape, size = src.memview.view.itemsize
  */
 
   /* function exit code */
   __pyx_L0:;
   return __pyx_r;
 }
 
 /* "View.MemoryView":1189
- *
+ * 
  * @cname('__pyx_fill_contig_strides_array')
  * cdef Py_ssize_t fill_contig_strides_array(             # <<<<<<<<<<<<<<
  *                 Py_ssize_t *shape, Py_ssize_t *strides, Py_ssize_t stride,
  *                 int ndim, char order) nogil:
  */
 
 static Py_ssize_t __pyx_fill_contig_strides_array(Py_ssize_t *__pyx_v_shape, Py_ssize_t *__pyx_v_strides, Py_ssize_t __pyx_v_stride, int __pyx_v_ndim, char __pyx_v_order) {
@@ -17705,24 +18234,24 @@
   int __pyx_t_1;
   int __pyx_t_2;
   int __pyx_t_3;
   int __pyx_t_4;
 
   /* "View.MemoryView":1198
  *     cdef int idx
- *
+ * 
  *     if order == 'F':             # <<<<<<<<<<<<<<
  *         for idx in range(ndim):
  *             strides[idx] = stride
  */
   __pyx_t_1 = ((__pyx_v_order == 'F') != 0);
   if (__pyx_t_1) {
 
     /* "View.MemoryView":1199
- *
+ * 
  *     if order == 'F':
  *         for idx in range(ndim):             # <<<<<<<<<<<<<<
  *             strides[idx] = stride
  *             stride *= shape[idx]
  */
     __pyx_t_2 = __pyx_v_ndim;
     __pyx_t_3 = __pyx_t_2;
@@ -17746,15 +18275,15 @@
  *         for idx in range(ndim - 1, -1, -1):
  */
       __pyx_v_stride = (__pyx_v_stride * (__pyx_v_shape[__pyx_v_idx]));
     }
 
     /* "View.MemoryView":1198
  *     cdef int idx
- *
+ * 
  *     if order == 'F':             # <<<<<<<<<<<<<<
  *         for idx in range(ndim):
  *             strides[idx] = stride
  */
     goto __pyx_L3;
   }
 
@@ -17770,55 +18299,55 @@
       __pyx_v_idx = __pyx_t_2;
 
       /* "View.MemoryView":1204
  *     else:
  *         for idx in range(ndim - 1, -1, -1):
  *             strides[idx] = stride             # <<<<<<<<<<<<<<
  *             stride *= shape[idx]
- *
+ * 
  */
       (__pyx_v_strides[__pyx_v_idx]) = __pyx_v_stride;
 
       /* "View.MemoryView":1205
  *         for idx in range(ndim - 1, -1, -1):
  *             strides[idx] = stride
  *             stride *= shape[idx]             # <<<<<<<<<<<<<<
- *
+ * 
  *     return stride
  */
       __pyx_v_stride = (__pyx_v_stride * (__pyx_v_shape[__pyx_v_idx]));
     }
   }
   __pyx_L3:;
 
   /* "View.MemoryView":1207
  *             stride *= shape[idx]
- *
+ * 
  *     return stride             # <<<<<<<<<<<<<<
- *
+ * 
  * @cname('__pyx_memoryview_copy_data_to_temp')
  */
   __pyx_r = __pyx_v_stride;
   goto __pyx_L0;
 
   /* "View.MemoryView":1189
- *
+ * 
  * @cname('__pyx_fill_contig_strides_array')
  * cdef Py_ssize_t fill_contig_strides_array(             # <<<<<<<<<<<<<<
  *                 Py_ssize_t *shape, Py_ssize_t *strides, Py_ssize_t stride,
  *                 int ndim, char order) nogil:
  */
 
   /* function exit code */
   __pyx_L0:;
   return __pyx_r;
 }
 
 /* "View.MemoryView":1210
- *
+ * 
  * @cname('__pyx_memoryview_copy_data_to_temp')
  * cdef void *copy_data_to_temp(__Pyx_memviewslice *src,             # <<<<<<<<<<<<<<
  *                              __Pyx_memviewslice *tmpslice,
  *                              char order,
  */
 
 static void *__pyx_memoryview_copy_data_to_temp(__Pyx_memviewslice *__pyx_v_src, __Pyx_memviewslice *__pyx_v_tmpslice, char __pyx_v_order, int __pyx_v_ndim) {
@@ -17835,79 +18364,79 @@
   int __pyx_t_6;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
 
   /* "View.MemoryView":1221
  *     cdef void *result
- *
+ * 
  *     cdef size_t itemsize = src.memview.view.itemsize             # <<<<<<<<<<<<<<
  *     cdef size_t size = slice_get_size(src, ndim)
- *
+ * 
  */
   __pyx_t_1 = __pyx_v_src->memview->view.itemsize;
   __pyx_v_itemsize = __pyx_t_1;
 
   /* "View.MemoryView":1222
- *
+ * 
  *     cdef size_t itemsize = src.memview.view.itemsize
  *     cdef size_t size = slice_get_size(src, ndim)             # <<<<<<<<<<<<<<
- *
+ * 
  *     result = malloc(size)
  */
   __pyx_v_size = __pyx_memoryview_slice_get_size(__pyx_v_src, __pyx_v_ndim);
 
   /* "View.MemoryView":1224
  *     cdef size_t size = slice_get_size(src, ndim)
- *
+ * 
  *     result = malloc(size)             # <<<<<<<<<<<<<<
  *     if not result:
  *         _err(MemoryError, NULL)
  */
   __pyx_v_result = malloc(__pyx_v_size);
 
   /* "View.MemoryView":1225
- *
+ * 
  *     result = malloc(size)
  *     if not result:             # <<<<<<<<<<<<<<
  *         _err(MemoryError, NULL)
- *
+ * 
  */
   __pyx_t_2 = ((!(__pyx_v_result != 0)) != 0);
   if (__pyx_t_2) {
 
     /* "View.MemoryView":1226
  *     result = malloc(size)
  *     if not result:
  *         _err(MemoryError, NULL)             # <<<<<<<<<<<<<<
- *
- *
+ * 
+ * 
  */
     __pyx_t_3 = __pyx_memoryview_err(__pyx_builtin_MemoryError, NULL); if (unlikely(__pyx_t_3 == ((int)-1))) __PYX_ERR(2, 1226, __pyx_L1_error)
 
     /* "View.MemoryView":1225
- *
+ * 
  *     result = malloc(size)
  *     if not result:             # <<<<<<<<<<<<<<
  *         _err(MemoryError, NULL)
- *
+ * 
  */
   }
 
   /* "View.MemoryView":1229
- *
- *
+ * 
+ * 
  *     tmpslice.data = <char *> result             # <<<<<<<<<<<<<<
  *     tmpslice.memview = src.memview
  *     for i in range(ndim):
  */
   __pyx_v_tmpslice->data = ((char *)__pyx_v_result);
 
   /* "View.MemoryView":1230
- *
+ * 
  *     tmpslice.data = <char *> result
  *     tmpslice.memview = src.memview             # <<<<<<<<<<<<<<
  *     for i in range(ndim):
  *         tmpslice.shape[i] = src.shape[i]
  */
   __pyx_t_4 = __pyx_v_src->memview;
   __pyx_v_tmpslice->memview = __pyx_t_4;
@@ -17925,131 +18454,131 @@
     __pyx_v_i = __pyx_t_6;
 
     /* "View.MemoryView":1232
  *     tmpslice.memview = src.memview
  *     for i in range(ndim):
  *         tmpslice.shape[i] = src.shape[i]             # <<<<<<<<<<<<<<
  *         tmpslice.suboffsets[i] = -1
- *
+ * 
  */
     (__pyx_v_tmpslice->shape[__pyx_v_i]) = (__pyx_v_src->shape[__pyx_v_i]);
 
     /* "View.MemoryView":1233
  *     for i in range(ndim):
  *         tmpslice.shape[i] = src.shape[i]
  *         tmpslice.suboffsets[i] = -1             # <<<<<<<<<<<<<<
- *
+ * 
  *     fill_contig_strides_array(&tmpslice.shape[0], &tmpslice.strides[0], itemsize,
  */
     (__pyx_v_tmpslice->suboffsets[__pyx_v_i]) = -1L;
   }
 
   /* "View.MemoryView":1235
  *         tmpslice.suboffsets[i] = -1
- *
+ * 
  *     fill_contig_strides_array(&tmpslice.shape[0], &tmpslice.strides[0], itemsize,             # <<<<<<<<<<<<<<
  *                               ndim, order)
- *
+ * 
  */
   (void)(__pyx_fill_contig_strides_array((&(__pyx_v_tmpslice->shape[0])), (&(__pyx_v_tmpslice->strides[0])), __pyx_v_itemsize, __pyx_v_ndim, __pyx_v_order));
 
   /* "View.MemoryView":1239
- *
- *
+ * 
+ * 
  *     for i in range(ndim):             # <<<<<<<<<<<<<<
  *         if tmpslice.shape[i] == 1:
  *             tmpslice.strides[i] = 0
  */
   __pyx_t_3 = __pyx_v_ndim;
   __pyx_t_5 = __pyx_t_3;
   for (__pyx_t_6 = 0; __pyx_t_6 < __pyx_t_5; __pyx_t_6+=1) {
     __pyx_v_i = __pyx_t_6;
 
     /* "View.MemoryView":1240
- *
+ * 
  *     for i in range(ndim):
  *         if tmpslice.shape[i] == 1:             # <<<<<<<<<<<<<<
  *             tmpslice.strides[i] = 0
- *
+ * 
  */
     __pyx_t_2 = (((__pyx_v_tmpslice->shape[__pyx_v_i]) == 1) != 0);
     if (__pyx_t_2) {
 
       /* "View.MemoryView":1241
  *     for i in range(ndim):
  *         if tmpslice.shape[i] == 1:
  *             tmpslice.strides[i] = 0             # <<<<<<<<<<<<<<
- *
+ * 
  *     if slice_is_contig(src[0], order, ndim):
  */
       (__pyx_v_tmpslice->strides[__pyx_v_i]) = 0;
 
       /* "View.MemoryView":1240
- *
+ * 
  *     for i in range(ndim):
  *         if tmpslice.shape[i] == 1:             # <<<<<<<<<<<<<<
  *             tmpslice.strides[i] = 0
- *
+ * 
  */
     }
   }
 
   /* "View.MemoryView":1243
  *             tmpslice.strides[i] = 0
- *
+ * 
  *     if slice_is_contig(src[0], order, ndim):             # <<<<<<<<<<<<<<
  *         memcpy(result, src.data, size)
  *     else:
  */
   __pyx_t_2 = (__pyx_memviewslice_is_contig((__pyx_v_src[0]), __pyx_v_order, __pyx_v_ndim) != 0);
   if (__pyx_t_2) {
 
     /* "View.MemoryView":1244
- *
+ * 
  *     if slice_is_contig(src[0], order, ndim):
  *         memcpy(result, src.data, size)             # <<<<<<<<<<<<<<
  *     else:
  *         copy_strided_to_strided(src, tmpslice, ndim, itemsize)
  */
     (void)(memcpy(__pyx_v_result, __pyx_v_src->data, __pyx_v_size));
 
     /* "View.MemoryView":1243
  *             tmpslice.strides[i] = 0
- *
+ * 
  *     if slice_is_contig(src[0], order, ndim):             # <<<<<<<<<<<<<<
  *         memcpy(result, src.data, size)
  *     else:
  */
     goto __pyx_L9;
   }
 
   /* "View.MemoryView":1246
  *         memcpy(result, src.data, size)
  *     else:
  *         copy_strided_to_strided(src, tmpslice, ndim, itemsize)             # <<<<<<<<<<<<<<
- *
+ * 
  *     return result
  */
   /*else*/ {
     copy_strided_to_strided(__pyx_v_src, __pyx_v_tmpslice, __pyx_v_ndim, __pyx_v_itemsize);
   }
   __pyx_L9:;
 
   /* "View.MemoryView":1248
  *         copy_strided_to_strided(src, tmpslice, ndim, itemsize)
- *
+ * 
  *     return result             # <<<<<<<<<<<<<<
- *
- *
+ * 
+ * 
  */
   __pyx_r = __pyx_v_result;
   goto __pyx_L0;
 
   /* "View.MemoryView":1210
- *
+ * 
  * @cname('__pyx_memoryview_copy_data_to_temp')
  * cdef void *copy_data_to_temp(__Pyx_memviewslice *src,             # <<<<<<<<<<<<<<
  *                              __Pyx_memviewslice *tmpslice,
  *                              char order,
  */
 
   /* function exit code */
@@ -18065,15 +18594,15 @@
   }
   __pyx_r = NULL;
   __pyx_L0:;
   return __pyx_r;
 }
 
 /* "View.MemoryView":1253
- *
+ * 
  * @cname('__pyx_memoryview_err_extents')
  * cdef int _err_extents(int i, Py_ssize_t extent1,             # <<<<<<<<<<<<<<
  *                              Py_ssize_t extent2) except -1 with gil:
  *     raise ValueError("got differing extents in dimension %d (got %d and %d)" %
  */
 
 static int __pyx_memoryview_err_extents(int __pyx_v_i, Py_ssize_t __pyx_v_extent1, Py_ssize_t __pyx_v_extent2) {
@@ -18091,15 +18620,15 @@
   #endif
   __Pyx_RefNannySetupContext("_err_extents", 0);
 
   /* "View.MemoryView":1256
  *                              Py_ssize_t extent2) except -1 with gil:
  *     raise ValueError("got differing extents in dimension %d (got %d and %d)" %
  *                                                         (i, extent1, extent2))             # <<<<<<<<<<<<<<
- *
+ * 
  * @cname('__pyx_memoryview_err_dim')
  */
   __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_i); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 1256, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_t_2 = PyInt_FromSsize_t(__pyx_v_extent1); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 1256, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_t_3 = PyInt_FromSsize_t(__pyx_v_extent2); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 1256, __pyx_L1_error)
@@ -18117,28 +18646,28 @@
   __pyx_t_3 = 0;
 
   /* "View.MemoryView":1255
  * cdef int _err_extents(int i, Py_ssize_t extent1,
  *                              Py_ssize_t extent2) except -1 with gil:
  *     raise ValueError("got differing extents in dimension %d (got %d and %d)" %             # <<<<<<<<<<<<<<
  *                                                         (i, extent1, extent2))
- *
+ * 
  */
   __pyx_t_3 = __Pyx_PyString_Format(__pyx_kp_s_got_differing_extents_in_dimensi, __pyx_t_4); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 1255, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
   __pyx_t_4 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(2, 1255, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __Pyx_Raise(__pyx_t_4, 0, 0, 0);
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
   __PYX_ERR(2, 1255, __pyx_L1_error)
 
   /* "View.MemoryView":1253
- *
+ * 
  * @cname('__pyx_memoryview_err_extents')
  * cdef int _err_extents(int i, Py_ssize_t extent1,             # <<<<<<<<<<<<<<
  *                              Py_ssize_t extent2) except -1 with gil:
  *     raise ValueError("got differing extents in dimension %d (got %d and %d)" %
  */
 
   /* function exit code */
@@ -18153,19 +18682,19 @@
   #ifdef WITH_THREAD
   __Pyx_PyGILState_Release(__pyx_gilstate_save);
   #endif
   return __pyx_r;
 }
 
 /* "View.MemoryView":1259
- *
+ * 
  * @cname('__pyx_memoryview_err_dim')
  * cdef int _err_dim(object error, char *msg, int dim) except -1 with gil:             # <<<<<<<<<<<<<<
  *     raise error(msg.decode('ascii') % dim)
- *
+ * 
  */
 
 static int __pyx_memoryview_err_dim(PyObject *__pyx_v_error, char *__pyx_v_msg, int __pyx_v_dim) {
   int __pyx_r;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   PyObject *__pyx_t_2 = NULL;
@@ -18180,15 +18709,15 @@
   __Pyx_RefNannySetupContext("_err_dim", 0);
   __Pyx_INCREF(__pyx_v_error);
 
   /* "View.MemoryView":1260
  * @cname('__pyx_memoryview_err_dim')
  * cdef int _err_dim(object error, char *msg, int dim) except -1 with gil:
  *     raise error(msg.decode('ascii') % dim)             # <<<<<<<<<<<<<<
- *
+ * 
  * @cname('__pyx_memoryview_err')
  */
   __pyx_t_2 = __Pyx_decode_c_string(__pyx_v_msg, 0, strlen(__pyx_v_msg), NULL, NULL, PyUnicode_DecodeASCII); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 1260, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_t_3 = __Pyx_PyInt_From_int(__pyx_v_dim); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 1260, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __pyx_t_4 = PyUnicode_Format(__pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(2, 1260, __pyx_L1_error)
@@ -18213,19 +18742,19 @@
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __Pyx_Raise(__pyx_t_1, 0, 0, 0);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __PYX_ERR(2, 1260, __pyx_L1_error)
 
   /* "View.MemoryView":1259
- *
+ * 
  * @cname('__pyx_memoryview_err_dim')
  * cdef int _err_dim(object error, char *msg, int dim) except -1 with gil:             # <<<<<<<<<<<<<<
  *     raise error(msg.decode('ascii') % dim)
- *
+ * 
  */
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_XDECREF(__pyx_t_2);
   __Pyx_XDECREF(__pyx_t_3);
@@ -18237,15 +18766,15 @@
   #ifdef WITH_THREAD
   __Pyx_PyGILState_Release(__pyx_gilstate_save);
   #endif
   return __pyx_r;
 }
 
 /* "View.MemoryView":1263
- *
+ * 
  * @cname('__pyx_memoryview_err')
  * cdef int _err(object error, char *msg) except -1 with gil:             # <<<<<<<<<<<<<<
  *     if msg != NULL:
  *         raise error(msg.decode('ascii'))
  */
 
 static int __pyx_memoryview_err(PyObject *__pyx_v_error, char *__pyx_v_msg) {
@@ -18314,24 +18843,24 @@
  */
   }
 
   /* "View.MemoryView":1267
  *         raise error(msg.decode('ascii'))
  *     else:
  *         raise error             # <<<<<<<<<<<<<<
- *
+ * 
  * @cname('__pyx_memoryview_copy_contents')
  */
   /*else*/ {
     __Pyx_Raise(__pyx_v_error, 0, 0, 0);
     __PYX_ERR(2, 1267, __pyx_L1_error)
   }
 
   /* "View.MemoryView":1263
- *
+ * 
  * @cname('__pyx_memoryview_err')
  * cdef int _err(object error, char *msg) except -1 with gil:             # <<<<<<<<<<<<<<
  *     if msg != NULL:
  *         raise error(msg.decode('ascii'))
  */
 
   /* function exit code */
@@ -18347,15 +18876,15 @@
   #ifdef WITH_THREAD
   __Pyx_PyGILState_Release(__pyx_gilstate_save);
   #endif
   return __pyx_r;
 }
 
 /* "View.MemoryView":1270
- *
+ * 
  * @cname('__pyx_memoryview_copy_contents')
  * cdef int memoryview_copy_contents(__Pyx_memviewslice src,             # <<<<<<<<<<<<<<
  *                                   __Pyx_memviewslice dst,
  *                                   int src_ndim, int dst_ndim,
  */
 
 static int __pyx_memoryview_copy_contents(__Pyx_memviewslice __pyx_v_src, __Pyx_memviewslice __pyx_v_dst, int __pyx_v_src_ndim, int __pyx_v_dst_ndim, int __pyx_v_dtype_is_object) {
@@ -18418,106 +18947,106 @@
   __pyx_v_broadcasting = 0;
 
   /* "View.MemoryView":1283
  *     cdef char order = get_best_order(&src, src_ndim)
  *     cdef bint broadcasting = False
  *     cdef bint direct_copy = False             # <<<<<<<<<<<<<<
  *     cdef __Pyx_memviewslice tmp
- *
+ * 
  */
   __pyx_v_direct_copy = 0;
 
   /* "View.MemoryView":1286
  *     cdef __Pyx_memviewslice tmp
- *
+ * 
  *     if src_ndim < dst_ndim:             # <<<<<<<<<<<<<<
  *         broadcast_leading(&src, src_ndim, dst_ndim)
  *     elif dst_ndim < src_ndim:
  */
   __pyx_t_2 = ((__pyx_v_src_ndim < __pyx_v_dst_ndim) != 0);
   if (__pyx_t_2) {
 
     /* "View.MemoryView":1287
- *
+ * 
  *     if src_ndim < dst_ndim:
  *         broadcast_leading(&src, src_ndim, dst_ndim)             # <<<<<<<<<<<<<<
  *     elif dst_ndim < src_ndim:
  *         broadcast_leading(&dst, dst_ndim, src_ndim)
  */
     __pyx_memoryview_broadcast_leading((&__pyx_v_src), __pyx_v_src_ndim, __pyx_v_dst_ndim);
 
     /* "View.MemoryView":1286
  *     cdef __Pyx_memviewslice tmp
- *
+ * 
  *     if src_ndim < dst_ndim:             # <<<<<<<<<<<<<<
  *         broadcast_leading(&src, src_ndim, dst_ndim)
  *     elif dst_ndim < src_ndim:
  */
     goto __pyx_L3;
   }
 
   /* "View.MemoryView":1288
  *     if src_ndim < dst_ndim:
  *         broadcast_leading(&src, src_ndim, dst_ndim)
  *     elif dst_ndim < src_ndim:             # <<<<<<<<<<<<<<
  *         broadcast_leading(&dst, dst_ndim, src_ndim)
- *
+ * 
  */
   __pyx_t_2 = ((__pyx_v_dst_ndim < __pyx_v_src_ndim) != 0);
   if (__pyx_t_2) {
 
     /* "View.MemoryView":1289
  *         broadcast_leading(&src, src_ndim, dst_ndim)
  *     elif dst_ndim < src_ndim:
  *         broadcast_leading(&dst, dst_ndim, src_ndim)             # <<<<<<<<<<<<<<
- *
+ * 
  *     cdef int ndim = max(src_ndim, dst_ndim)
  */
     __pyx_memoryview_broadcast_leading((&__pyx_v_dst), __pyx_v_dst_ndim, __pyx_v_src_ndim);
 
     /* "View.MemoryView":1288
  *     if src_ndim < dst_ndim:
  *         broadcast_leading(&src, src_ndim, dst_ndim)
  *     elif dst_ndim < src_ndim:             # <<<<<<<<<<<<<<
  *         broadcast_leading(&dst, dst_ndim, src_ndim)
- *
+ * 
  */
   }
   __pyx_L3:;
 
   /* "View.MemoryView":1291
  *         broadcast_leading(&dst, dst_ndim, src_ndim)
- *
+ * 
  *     cdef int ndim = max(src_ndim, dst_ndim)             # <<<<<<<<<<<<<<
- *
+ * 
  *     for i in range(ndim):
  */
   __pyx_t_3 = __pyx_v_dst_ndim;
   __pyx_t_4 = __pyx_v_src_ndim;
   if (((__pyx_t_3 > __pyx_t_4) != 0)) {
     __pyx_t_5 = __pyx_t_3;
   } else {
     __pyx_t_5 = __pyx_t_4;
   }
   __pyx_v_ndim = __pyx_t_5;
 
   /* "View.MemoryView":1293
  *     cdef int ndim = max(src_ndim, dst_ndim)
- *
+ * 
  *     for i in range(ndim):             # <<<<<<<<<<<<<<
  *         if src.shape[i] != dst.shape[i]:
  *             if src.shape[i] == 1:
  */
   __pyx_t_5 = __pyx_v_ndim;
   __pyx_t_3 = __pyx_t_5;
   for (__pyx_t_4 = 0; __pyx_t_4 < __pyx_t_3; __pyx_t_4+=1) {
     __pyx_v_i = __pyx_t_4;
 
     /* "View.MemoryView":1294
- *
+ * 
  *     for i in range(ndim):
  *         if src.shape[i] != dst.shape[i]:             # <<<<<<<<<<<<<<
  *             if src.shape[i] == 1:
  *                 broadcasting = True
  */
     __pyx_t_2 = (((__pyx_v_src.shape[__pyx_v_i]) != (__pyx_v_dst.shape[__pyx_v_i])) != 0);
     if (__pyx_t_2) {
@@ -18560,215 +19089,215 @@
         goto __pyx_L7;
       }
 
       /* "View.MemoryView":1299
  *                 src.strides[i] = 0
  *             else:
  *                 _err_extents(i, dst.shape[i], src.shape[i])             # <<<<<<<<<<<<<<
- *
+ * 
  *         if src.suboffsets[i] >= 0:
  */
       /*else*/ {
         __pyx_t_6 = __pyx_memoryview_err_extents(__pyx_v_i, (__pyx_v_dst.shape[__pyx_v_i]), (__pyx_v_src.shape[__pyx_v_i])); if (unlikely(__pyx_t_6 == ((int)-1))) __PYX_ERR(2, 1299, __pyx_L1_error)
       }
       __pyx_L7:;
 
       /* "View.MemoryView":1294
- *
+ * 
  *     for i in range(ndim):
  *         if src.shape[i] != dst.shape[i]:             # <<<<<<<<<<<<<<
  *             if src.shape[i] == 1:
  *                 broadcasting = True
  */
     }
 
     /* "View.MemoryView":1301
  *                 _err_extents(i, dst.shape[i], src.shape[i])
- *
+ * 
  *         if src.suboffsets[i] >= 0:             # <<<<<<<<<<<<<<
  *             _err_dim(ValueError, "Dimension %d is not direct", i)
- *
+ * 
  */
     __pyx_t_2 = (((__pyx_v_src.suboffsets[__pyx_v_i]) >= 0) != 0);
     if (__pyx_t_2) {
 
       /* "View.MemoryView":1302
- *
+ * 
  *         if src.suboffsets[i] >= 0:
  *             _err_dim(ValueError, "Dimension %d is not direct", i)             # <<<<<<<<<<<<<<
- *
+ * 
  *     if slices_overlap(&src, &dst, ndim, itemsize):
  */
       __pyx_t_6 = __pyx_memoryview_err_dim(__pyx_builtin_ValueError, ((char *)"Dimension %d is not direct"), __pyx_v_i); if (unlikely(__pyx_t_6 == ((int)-1))) __PYX_ERR(2, 1302, __pyx_L1_error)
 
       /* "View.MemoryView":1301
  *                 _err_extents(i, dst.shape[i], src.shape[i])
- *
+ * 
  *         if src.suboffsets[i] >= 0:             # <<<<<<<<<<<<<<
  *             _err_dim(ValueError, "Dimension %d is not direct", i)
- *
+ * 
  */
     }
   }
 
   /* "View.MemoryView":1304
  *             _err_dim(ValueError, "Dimension %d is not direct", i)
- *
+ * 
  *     if slices_overlap(&src, &dst, ndim, itemsize):             # <<<<<<<<<<<<<<
- *
+ * 
  *         if not slice_is_contig(src, order, ndim):
  */
   __pyx_t_2 = (__pyx_slices_overlap((&__pyx_v_src), (&__pyx_v_dst), __pyx_v_ndim, __pyx_v_itemsize) != 0);
   if (__pyx_t_2) {
 
     /* "View.MemoryView":1306
  *     if slices_overlap(&src, &dst, ndim, itemsize):
- *
+ * 
  *         if not slice_is_contig(src, order, ndim):             # <<<<<<<<<<<<<<
  *             order = get_best_order(&dst, ndim)
- *
+ * 
  */
     __pyx_t_2 = ((!(__pyx_memviewslice_is_contig(__pyx_v_src, __pyx_v_order, __pyx_v_ndim) != 0)) != 0);
     if (__pyx_t_2) {
 
       /* "View.MemoryView":1307
- *
+ * 
  *         if not slice_is_contig(src, order, ndim):
  *             order = get_best_order(&dst, ndim)             # <<<<<<<<<<<<<<
- *
+ * 
  *         tmpdata = copy_data_to_temp(&src, &tmp, order, ndim)
  */
       __pyx_v_order = __pyx_get_best_slice_order((&__pyx_v_dst), __pyx_v_ndim);
 
       /* "View.MemoryView":1306
  *     if slices_overlap(&src, &dst, ndim, itemsize):
- *
+ * 
  *         if not slice_is_contig(src, order, ndim):             # <<<<<<<<<<<<<<
  *             order = get_best_order(&dst, ndim)
- *
+ * 
  */
     }
 
     /* "View.MemoryView":1309
  *             order = get_best_order(&dst, ndim)
- *
+ * 
  *         tmpdata = copy_data_to_temp(&src, &tmp, order, ndim)             # <<<<<<<<<<<<<<
  *         src = tmp
- *
+ * 
  */
     __pyx_t_7 = __pyx_memoryview_copy_data_to_temp((&__pyx_v_src), (&__pyx_v_tmp), __pyx_v_order, __pyx_v_ndim); if (unlikely(__pyx_t_7 == ((void *)NULL))) __PYX_ERR(2, 1309, __pyx_L1_error)
     __pyx_v_tmpdata = __pyx_t_7;
 
     /* "View.MemoryView":1310
- *
+ * 
  *         tmpdata = copy_data_to_temp(&src, &tmp, order, ndim)
  *         src = tmp             # <<<<<<<<<<<<<<
- *
+ * 
  *     if not broadcasting:
  */
     __pyx_v_src = __pyx_v_tmp;
 
     /* "View.MemoryView":1304
  *             _err_dim(ValueError, "Dimension %d is not direct", i)
- *
+ * 
  *     if slices_overlap(&src, &dst, ndim, itemsize):             # <<<<<<<<<<<<<<
- *
+ * 
  *         if not slice_is_contig(src, order, ndim):
  */
   }
 
   /* "View.MemoryView":1312
  *         src = tmp
- *
+ * 
  *     if not broadcasting:             # <<<<<<<<<<<<<<
- *
- *
+ * 
+ * 
  */
   __pyx_t_2 = ((!(__pyx_v_broadcasting != 0)) != 0);
   if (__pyx_t_2) {
 
     /* "View.MemoryView":1315
- *
- *
+ * 
+ * 
  *         if slice_is_contig(src, 'C', ndim):             # <<<<<<<<<<<<<<
  *             direct_copy = slice_is_contig(dst, 'C', ndim)
  *         elif slice_is_contig(src, 'F', ndim):
  */
     __pyx_t_2 = (__pyx_memviewslice_is_contig(__pyx_v_src, 'C', __pyx_v_ndim) != 0);
     if (__pyx_t_2) {
 
       /* "View.MemoryView":1316
- *
+ * 
  *         if slice_is_contig(src, 'C', ndim):
  *             direct_copy = slice_is_contig(dst, 'C', ndim)             # <<<<<<<<<<<<<<
  *         elif slice_is_contig(src, 'F', ndim):
  *             direct_copy = slice_is_contig(dst, 'F', ndim)
  */
       __pyx_v_direct_copy = __pyx_memviewslice_is_contig(__pyx_v_dst, 'C', __pyx_v_ndim);
 
       /* "View.MemoryView":1315
- *
- *
+ * 
+ * 
  *         if slice_is_contig(src, 'C', ndim):             # <<<<<<<<<<<<<<
  *             direct_copy = slice_is_contig(dst, 'C', ndim)
  *         elif slice_is_contig(src, 'F', ndim):
  */
       goto __pyx_L12;
     }
 
     /* "View.MemoryView":1317
  *         if slice_is_contig(src, 'C', ndim):
  *             direct_copy = slice_is_contig(dst, 'C', ndim)
  *         elif slice_is_contig(src, 'F', ndim):             # <<<<<<<<<<<<<<
  *             direct_copy = slice_is_contig(dst, 'F', ndim)
- *
+ * 
  */
     __pyx_t_2 = (__pyx_memviewslice_is_contig(__pyx_v_src, 'F', __pyx_v_ndim) != 0);
     if (__pyx_t_2) {
 
       /* "View.MemoryView":1318
  *             direct_copy = slice_is_contig(dst, 'C', ndim)
  *         elif slice_is_contig(src, 'F', ndim):
  *             direct_copy = slice_is_contig(dst, 'F', ndim)             # <<<<<<<<<<<<<<
- *
+ * 
  *         if direct_copy:
  */
       __pyx_v_direct_copy = __pyx_memviewslice_is_contig(__pyx_v_dst, 'F', __pyx_v_ndim);
 
       /* "View.MemoryView":1317
  *         if slice_is_contig(src, 'C', ndim):
  *             direct_copy = slice_is_contig(dst, 'C', ndim)
  *         elif slice_is_contig(src, 'F', ndim):             # <<<<<<<<<<<<<<
  *             direct_copy = slice_is_contig(dst, 'F', ndim)
- *
+ * 
  */
     }
     __pyx_L12:;
 
     /* "View.MemoryView":1320
  *             direct_copy = slice_is_contig(dst, 'F', ndim)
- *
+ * 
  *         if direct_copy:             # <<<<<<<<<<<<<<
- *
+ * 
  *             refcount_copying(&dst, dtype_is_object, ndim, False)
  */
     __pyx_t_2 = (__pyx_v_direct_copy != 0);
     if (__pyx_t_2) {
 
       /* "View.MemoryView":1322
  *         if direct_copy:
- *
+ * 
  *             refcount_copying(&dst, dtype_is_object, ndim, False)             # <<<<<<<<<<<<<<
  *             memcpy(dst.data, src.data, slice_get_size(&src, ndim))
  *             refcount_copying(&dst, dtype_is_object, ndim, True)
  */
       __pyx_memoryview_refcount_copying((&__pyx_v_dst), __pyx_v_dtype_is_object, __pyx_v_ndim, 0);
 
       /* "View.MemoryView":1323
- *
+ * 
  *             refcount_copying(&dst, dtype_is_object, ndim, False)
  *             memcpy(dst.data, src.data, slice_get_size(&src, ndim))             # <<<<<<<<<<<<<<
  *             refcount_copying(&dst, dtype_is_object, ndim, True)
  *             free(tmpdata)
  */
       (void)(memcpy(__pyx_v_dst.data, __pyx_v_src.data, __pyx_memoryview_slice_get_size((&__pyx_v_src), __pyx_v_ndim)));
 
@@ -18782,135 +19311,135 @@
       __pyx_memoryview_refcount_copying((&__pyx_v_dst), __pyx_v_dtype_is_object, __pyx_v_ndim, 1);
 
       /* "View.MemoryView":1325
  *             memcpy(dst.data, src.data, slice_get_size(&src, ndim))
  *             refcount_copying(&dst, dtype_is_object, ndim, True)
  *             free(tmpdata)             # <<<<<<<<<<<<<<
  *             return 0
- *
+ * 
  */
       free(__pyx_v_tmpdata);
 
       /* "View.MemoryView":1326
  *             refcount_copying(&dst, dtype_is_object, ndim, True)
  *             free(tmpdata)
  *             return 0             # <<<<<<<<<<<<<<
- *
+ * 
  *     if order == 'F' == get_best_order(&dst, ndim):
  */
       __pyx_r = 0;
       goto __pyx_L0;
 
       /* "View.MemoryView":1320
  *             direct_copy = slice_is_contig(dst, 'F', ndim)
- *
+ * 
  *         if direct_copy:             # <<<<<<<<<<<<<<
- *
+ * 
  *             refcount_copying(&dst, dtype_is_object, ndim, False)
  */
     }
 
     /* "View.MemoryView":1312
  *         src = tmp
- *
+ * 
  *     if not broadcasting:             # <<<<<<<<<<<<<<
- *
- *
+ * 
+ * 
  */
   }
 
   /* "View.MemoryView":1328
  *             return 0
- *
+ * 
  *     if order == 'F' == get_best_order(&dst, ndim):             # <<<<<<<<<<<<<<
- *
- *
+ * 
+ * 
  */
   __pyx_t_2 = (__pyx_v_order == 'F');
   if (__pyx_t_2) {
     __pyx_t_2 = ('F' == __pyx_get_best_slice_order((&__pyx_v_dst), __pyx_v_ndim));
   }
   __pyx_t_8 = (__pyx_t_2 != 0);
   if (__pyx_t_8) {
 
     /* "View.MemoryView":1331
- *
- *
+ * 
+ * 
  *         transpose_memslice(&src)             # <<<<<<<<<<<<<<
  *         transpose_memslice(&dst)
- *
+ * 
  */
     __pyx_t_5 = __pyx_memslice_transpose((&__pyx_v_src)); if (unlikely(__pyx_t_5 == ((int)0))) __PYX_ERR(2, 1331, __pyx_L1_error)
 
     /* "View.MemoryView":1332
- *
+ * 
  *         transpose_memslice(&src)
  *         transpose_memslice(&dst)             # <<<<<<<<<<<<<<
- *
+ * 
  *     refcount_copying(&dst, dtype_is_object, ndim, False)
  */
     __pyx_t_5 = __pyx_memslice_transpose((&__pyx_v_dst)); if (unlikely(__pyx_t_5 == ((int)0))) __PYX_ERR(2, 1332, __pyx_L1_error)
 
     /* "View.MemoryView":1328
  *             return 0
- *
+ * 
  *     if order == 'F' == get_best_order(&dst, ndim):             # <<<<<<<<<<<<<<
- *
- *
+ * 
+ * 
  */
   }
 
   /* "View.MemoryView":1334
  *         transpose_memslice(&dst)
- *
+ * 
  *     refcount_copying(&dst, dtype_is_object, ndim, False)             # <<<<<<<<<<<<<<
  *     copy_strided_to_strided(&src, &dst, ndim, itemsize)
  *     refcount_copying(&dst, dtype_is_object, ndim, True)
  */
   __pyx_memoryview_refcount_copying((&__pyx_v_dst), __pyx_v_dtype_is_object, __pyx_v_ndim, 0);
 
   /* "View.MemoryView":1335
- *
+ * 
  *     refcount_copying(&dst, dtype_is_object, ndim, False)
  *     copy_strided_to_strided(&src, &dst, ndim, itemsize)             # <<<<<<<<<<<<<<
  *     refcount_copying(&dst, dtype_is_object, ndim, True)
- *
+ * 
  */
   copy_strided_to_strided((&__pyx_v_src), (&__pyx_v_dst), __pyx_v_ndim, __pyx_v_itemsize);
 
   /* "View.MemoryView":1336
  *     refcount_copying(&dst, dtype_is_object, ndim, False)
  *     copy_strided_to_strided(&src, &dst, ndim, itemsize)
  *     refcount_copying(&dst, dtype_is_object, ndim, True)             # <<<<<<<<<<<<<<
- *
+ * 
  *     free(tmpdata)
  */
   __pyx_memoryview_refcount_copying((&__pyx_v_dst), __pyx_v_dtype_is_object, __pyx_v_ndim, 1);
 
   /* "View.MemoryView":1338
  *     refcount_copying(&dst, dtype_is_object, ndim, True)
- *
+ * 
  *     free(tmpdata)             # <<<<<<<<<<<<<<
  *     return 0
- *
+ * 
  */
   free(__pyx_v_tmpdata);
 
   /* "View.MemoryView":1339
- *
+ * 
  *     free(tmpdata)
  *     return 0             # <<<<<<<<<<<<<<
- *
+ * 
  * @cname('__pyx_memoryview_broadcast_leading')
  */
   __pyx_r = 0;
   goto __pyx_L0;
 
   /* "View.MemoryView":1270
- *
+ * 
  * @cname('__pyx_memoryview_copy_contents')
  * cdef int memoryview_copy_contents(__Pyx_memviewslice src,             # <<<<<<<<<<<<<<
  *                                   __Pyx_memviewslice dst,
  *                                   int src_ndim, int dst_ndim,
  */
 
   /* function exit code */
@@ -18926,15 +19455,15 @@
   }
   __pyx_r = -1;
   __pyx_L0:;
   return __pyx_r;
 }
 
 /* "View.MemoryView":1342
- *
+ * 
  * @cname('__pyx_memoryview_broadcast_leading')
  * cdef void broadcast_leading(__Pyx_memviewslice *mslice,             # <<<<<<<<<<<<<<
  *                             int ndim,
  *                             int ndim_other) nogil:
  */
 
 static void __pyx_memoryview_broadcast_leading(__Pyx_memviewslice *__pyx_v_mslice, int __pyx_v_ndim, int __pyx_v_ndim_other) {
@@ -18944,160 +19473,160 @@
   int __pyx_t_2;
   int __pyx_t_3;
 
   /* "View.MemoryView":1346
  *                             int ndim_other) nogil:
  *     cdef int i
  *     cdef int offset = ndim_other - ndim             # <<<<<<<<<<<<<<
- *
+ * 
  *     for i in range(ndim - 1, -1, -1):
  */
   __pyx_v_offset = (__pyx_v_ndim_other - __pyx_v_ndim);
 
   /* "View.MemoryView":1348
  *     cdef int offset = ndim_other - ndim
- *
+ * 
  *     for i in range(ndim - 1, -1, -1):             # <<<<<<<<<<<<<<
  *         mslice.shape[i + offset] = mslice.shape[i]
  *         mslice.strides[i + offset] = mslice.strides[i]
  */
   for (__pyx_t_1 = (__pyx_v_ndim - 1); __pyx_t_1 > -1; __pyx_t_1-=1) {
     __pyx_v_i = __pyx_t_1;
 
     /* "View.MemoryView":1349
- *
+ * 
  *     for i in range(ndim - 1, -1, -1):
  *         mslice.shape[i + offset] = mslice.shape[i]             # <<<<<<<<<<<<<<
  *         mslice.strides[i + offset] = mslice.strides[i]
  *         mslice.suboffsets[i + offset] = mslice.suboffsets[i]
  */
     (__pyx_v_mslice->shape[(__pyx_v_i + __pyx_v_offset)]) = (__pyx_v_mslice->shape[__pyx_v_i]);
 
     /* "View.MemoryView":1350
  *     for i in range(ndim - 1, -1, -1):
  *         mslice.shape[i + offset] = mslice.shape[i]
  *         mslice.strides[i + offset] = mslice.strides[i]             # <<<<<<<<<<<<<<
  *         mslice.suboffsets[i + offset] = mslice.suboffsets[i]
- *
+ * 
  */
     (__pyx_v_mslice->strides[(__pyx_v_i + __pyx_v_offset)]) = (__pyx_v_mslice->strides[__pyx_v_i]);
 
     /* "View.MemoryView":1351
  *         mslice.shape[i + offset] = mslice.shape[i]
  *         mslice.strides[i + offset] = mslice.strides[i]
  *         mslice.suboffsets[i + offset] = mslice.suboffsets[i]             # <<<<<<<<<<<<<<
- *
+ * 
  *     for i in range(offset):
  */
     (__pyx_v_mslice->suboffsets[(__pyx_v_i + __pyx_v_offset)]) = (__pyx_v_mslice->suboffsets[__pyx_v_i]);
   }
 
   /* "View.MemoryView":1353
  *         mslice.suboffsets[i + offset] = mslice.suboffsets[i]
- *
+ * 
  *     for i in range(offset):             # <<<<<<<<<<<<<<
  *         mslice.shape[i] = 1
  *         mslice.strides[i] = mslice.strides[0]
  */
   __pyx_t_1 = __pyx_v_offset;
   __pyx_t_2 = __pyx_t_1;
   for (__pyx_t_3 = 0; __pyx_t_3 < __pyx_t_2; __pyx_t_3+=1) {
     __pyx_v_i = __pyx_t_3;
 
     /* "View.MemoryView":1354
- *
+ * 
  *     for i in range(offset):
  *         mslice.shape[i] = 1             # <<<<<<<<<<<<<<
  *         mslice.strides[i] = mslice.strides[0]
  *         mslice.suboffsets[i] = -1
  */
     (__pyx_v_mslice->shape[__pyx_v_i]) = 1;
 
     /* "View.MemoryView":1355
  *     for i in range(offset):
  *         mslice.shape[i] = 1
  *         mslice.strides[i] = mslice.strides[0]             # <<<<<<<<<<<<<<
  *         mslice.suboffsets[i] = -1
- *
+ * 
  */
     (__pyx_v_mslice->strides[__pyx_v_i]) = (__pyx_v_mslice->strides[0]);
 
     /* "View.MemoryView":1356
  *         mslice.shape[i] = 1
  *         mslice.strides[i] = mslice.strides[0]
  *         mslice.suboffsets[i] = -1             # <<<<<<<<<<<<<<
- *
- *
+ * 
+ * 
  */
     (__pyx_v_mslice->suboffsets[__pyx_v_i]) = -1L;
   }
 
   /* "View.MemoryView":1342
- *
+ * 
  * @cname('__pyx_memoryview_broadcast_leading')
  * cdef void broadcast_leading(__Pyx_memviewslice *mslice,             # <<<<<<<<<<<<<<
  *                             int ndim,
  *                             int ndim_other) nogil:
  */
 
   /* function exit code */
 }
 
 /* "View.MemoryView":1364
- *
+ * 
  * @cname('__pyx_memoryview_refcount_copying')
  * cdef void refcount_copying(__Pyx_memviewslice *dst, bint dtype_is_object,             # <<<<<<<<<<<<<<
  *                            int ndim, bint inc) nogil:
- *
+ * 
  */
 
 static void __pyx_memoryview_refcount_copying(__Pyx_memviewslice *__pyx_v_dst, int __pyx_v_dtype_is_object, int __pyx_v_ndim, int __pyx_v_inc) {
   int __pyx_t_1;
 
   /* "View.MemoryView":1368
- *
- *
+ * 
+ * 
  *     if dtype_is_object:             # <<<<<<<<<<<<<<
  *         refcount_objects_in_slice_with_gil(dst.data, dst.shape,
  *                                            dst.strides, ndim, inc)
  */
   __pyx_t_1 = (__pyx_v_dtype_is_object != 0);
   if (__pyx_t_1) {
 
     /* "View.MemoryView":1369
- *
+ * 
  *     if dtype_is_object:
  *         refcount_objects_in_slice_with_gil(dst.data, dst.shape,             # <<<<<<<<<<<<<<
  *                                            dst.strides, ndim, inc)
- *
+ * 
  */
     __pyx_memoryview_refcount_objects_in_slice_with_gil(__pyx_v_dst->data, __pyx_v_dst->shape, __pyx_v_dst->strides, __pyx_v_ndim, __pyx_v_inc);
 
     /* "View.MemoryView":1368
- *
- *
+ * 
+ * 
  *     if dtype_is_object:             # <<<<<<<<<<<<<<
  *         refcount_objects_in_slice_with_gil(dst.data, dst.shape,
  *                                            dst.strides, ndim, inc)
  */
   }
 
   /* "View.MemoryView":1364
- *
+ * 
  * @cname('__pyx_memoryview_refcount_copying')
  * cdef void refcount_copying(__Pyx_memviewslice *dst, bint dtype_is_object,             # <<<<<<<<<<<<<<
  *                            int ndim, bint inc) nogil:
- *
+ * 
  */
 
   /* function exit code */
 }
 
 /* "View.MemoryView":1373
- *
+ * 
  * @cname('__pyx_memoryview_refcount_objects_in_slice_with_gil')
  * cdef void refcount_objects_in_slice_with_gil(char *data, Py_ssize_t *shape,             # <<<<<<<<<<<<<<
  *                                              Py_ssize_t *strides, int ndim,
  *                                              bint inc) with gil:
  */
 
 static void __pyx_memoryview_refcount_objects_in_slice_with_gil(char *__pyx_v_data, Py_ssize_t *__pyx_v_shape, Py_ssize_t *__pyx_v_strides, int __pyx_v_ndim, int __pyx_v_inc) {
@@ -19107,36 +19636,36 @@
   #endif
   __Pyx_RefNannySetupContext("refcount_objects_in_slice_with_gil", 0);
 
   /* "View.MemoryView":1376
  *                                              Py_ssize_t *strides, int ndim,
  *                                              bint inc) with gil:
  *     refcount_objects_in_slice(data, shape, strides, ndim, inc)             # <<<<<<<<<<<<<<
- *
+ * 
  * @cname('__pyx_memoryview_refcount_objects_in_slice')
  */
   __pyx_memoryview_refcount_objects_in_slice(__pyx_v_data, __pyx_v_shape, __pyx_v_strides, __pyx_v_ndim, __pyx_v_inc);
 
   /* "View.MemoryView":1373
- *
+ * 
  * @cname('__pyx_memoryview_refcount_objects_in_slice_with_gil')
  * cdef void refcount_objects_in_slice_with_gil(char *data, Py_ssize_t *shape,             # <<<<<<<<<<<<<<
  *                                              Py_ssize_t *strides, int ndim,
  *                                              bint inc) with gil:
  */
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   #ifdef WITH_THREAD
   __Pyx_PyGILState_Release(__pyx_gilstate_save);
   #endif
 }
 
 /* "View.MemoryView":1379
- *
+ * 
  * @cname('__pyx_memoryview_refcount_objects_in_slice')
  * cdef void refcount_objects_in_slice(char *data, Py_ssize_t *shape,             # <<<<<<<<<<<<<<
  *                                     Py_ssize_t *strides, int ndim, bint inc):
  *     cdef Py_ssize_t i
  */
 
 static void __pyx_memoryview_refcount_objects_in_slice(char *__pyx_v_data, Py_ssize_t *__pyx_v_shape, Py_ssize_t *__pyx_v_strides, int __pyx_v_ndim, int __pyx_v_inc) {
@@ -19146,26 +19675,26 @@
   Py_ssize_t __pyx_t_2;
   Py_ssize_t __pyx_t_3;
   int __pyx_t_4;
   __Pyx_RefNannySetupContext("refcount_objects_in_slice", 0);
 
   /* "View.MemoryView":1383
  *     cdef Py_ssize_t i
- *
+ * 
  *     for i in range(shape[0]):             # <<<<<<<<<<<<<<
  *         if ndim == 1:
  *             if inc:
  */
   __pyx_t_1 = (__pyx_v_shape[0]);
   __pyx_t_2 = __pyx_t_1;
   for (__pyx_t_3 = 0; __pyx_t_3 < __pyx_t_2; __pyx_t_3+=1) {
     __pyx_v_i = __pyx_t_3;
 
     /* "View.MemoryView":1384
- *
+ * 
  *     for i in range(shape[0]):
  *         if ndim == 1:             # <<<<<<<<<<<<<<
  *             if inc:
  *                 Py_INCREF((<PyObject **> data)[0])
  */
     __pyx_t_4 = ((__pyx_v_ndim == 1) != 0);
     if (__pyx_t_4) {
@@ -19208,67 +19737,67 @@
  */
       /*else*/ {
         Py_DECREF((((PyObject **)__pyx_v_data)[0]));
       }
       __pyx_L6:;
 
       /* "View.MemoryView":1384
- *
+ * 
  *     for i in range(shape[0]):
  *         if ndim == 1:             # <<<<<<<<<<<<<<
  *             if inc:
  *                 Py_INCREF((<PyObject **> data)[0])
  */
       goto __pyx_L5;
     }
 
     /* "View.MemoryView":1390
  *                 Py_DECREF((<PyObject **> data)[0])
  *         else:
  *             refcount_objects_in_slice(data, shape + 1, strides + 1,             # <<<<<<<<<<<<<<
  *                                       ndim - 1, inc)
- *
+ * 
  */
     /*else*/ {
 
       /* "View.MemoryView":1391
  *         else:
  *             refcount_objects_in_slice(data, shape + 1, strides + 1,
  *                                       ndim - 1, inc)             # <<<<<<<<<<<<<<
- *
+ * 
  *         data += strides[0]
  */
       __pyx_memoryview_refcount_objects_in_slice(__pyx_v_data, (__pyx_v_shape + 1), (__pyx_v_strides + 1), (__pyx_v_ndim - 1), __pyx_v_inc);
     }
     __pyx_L5:;
 
     /* "View.MemoryView":1393
  *                                       ndim - 1, inc)
- *
+ * 
  *         data += strides[0]             # <<<<<<<<<<<<<<
- *
- *
+ * 
+ * 
  */
     __pyx_v_data = (__pyx_v_data + (__pyx_v_strides[0]));
   }
 
   /* "View.MemoryView":1379
- *
+ * 
  * @cname('__pyx_memoryview_refcount_objects_in_slice')
  * cdef void refcount_objects_in_slice(char *data, Py_ssize_t *shape,             # <<<<<<<<<<<<<<
  *                                     Py_ssize_t *strides, int ndim, bint inc):
  *     cdef Py_ssize_t i
  */
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
 }
 
 /* "View.MemoryView":1399
- *
+ * 
  * @cname('__pyx_memoryview_slice_assign_scalar')
  * cdef void slice_assign_scalar(__Pyx_memviewslice *dst, int ndim,             # <<<<<<<<<<<<<<
  *                               size_t itemsize, void *item,
  *                               bint dtype_is_object) nogil:
  */
 
 static void __pyx_memoryview_slice_assign_scalar(__Pyx_memviewslice *__pyx_v_dst, int __pyx_v_ndim, size_t __pyx_v_itemsize, void *__pyx_v_item, int __pyx_v_dtype_is_object) {
@@ -19291,32 +19820,32 @@
  */
   __pyx_memoryview__slice_assign_scalar(__pyx_v_dst->data, __pyx_v_dst->shape, __pyx_v_dst->strides, __pyx_v_ndim, __pyx_v_itemsize, __pyx_v_item);
 
   /* "View.MemoryView":1405
  *     _slice_assign_scalar(dst.data, dst.shape, dst.strides, ndim,
  *                          itemsize, item)
  *     refcount_copying(dst, dtype_is_object, ndim, True)             # <<<<<<<<<<<<<<
- *
- *
+ * 
+ * 
  */
   __pyx_memoryview_refcount_copying(__pyx_v_dst, __pyx_v_dtype_is_object, __pyx_v_ndim, 1);
 
   /* "View.MemoryView":1399
- *
+ * 
  * @cname('__pyx_memoryview_slice_assign_scalar')
  * cdef void slice_assign_scalar(__Pyx_memviewslice *dst, int ndim,             # <<<<<<<<<<<<<<
  *                               size_t itemsize, void *item,
  *                               bint dtype_is_object) nogil:
  */
 
   /* function exit code */
 }
 
 /* "View.MemoryView":1409
- *
+ * 
  * @cname('__pyx_memoryview__slice_assign_scalar')
  * cdef void _slice_assign_scalar(char *data, Py_ssize_t *shape,             # <<<<<<<<<<<<<<
  *                               Py_ssize_t *strides, int ndim,
  *                               size_t itemsize, void *item) nogil:
  */
 
 static void __pyx_memoryview__slice_assign_scalar(char *__pyx_v_data, Py_ssize_t *__pyx_v_shape, Py_ssize_t *__pyx_v_strides, int __pyx_v_ndim, size_t __pyx_v_itemsize, void *__pyx_v_item) {
@@ -19329,39 +19858,39 @@
   Py_ssize_t __pyx_t_4;
 
   /* "View.MemoryView":1413
  *                               size_t itemsize, void *item) nogil:
  *     cdef Py_ssize_t i
  *     cdef Py_ssize_t stride = strides[0]             # <<<<<<<<<<<<<<
  *     cdef Py_ssize_t extent = shape[0]
- *
+ * 
  */
   __pyx_v_stride = (__pyx_v_strides[0]);
 
   /* "View.MemoryView":1414
  *     cdef Py_ssize_t i
  *     cdef Py_ssize_t stride = strides[0]
  *     cdef Py_ssize_t extent = shape[0]             # <<<<<<<<<<<<<<
- *
+ * 
  *     if ndim == 1:
  */
   __pyx_v_extent = (__pyx_v_shape[0]);
 
   /* "View.MemoryView":1416
  *     cdef Py_ssize_t extent = shape[0]
- *
+ * 
  *     if ndim == 1:             # <<<<<<<<<<<<<<
  *         for i in range(extent):
  *             memcpy(data, item, itemsize)
  */
   __pyx_t_1 = ((__pyx_v_ndim == 1) != 0);
   if (__pyx_t_1) {
 
     /* "View.MemoryView":1417
- *
+ * 
  *     if ndim == 1:
  *         for i in range(extent):             # <<<<<<<<<<<<<<
  *             memcpy(data, item, itemsize)
  *             data += stride
  */
     __pyx_t_2 = __pyx_v_extent;
     __pyx_t_3 = __pyx_t_2;
@@ -19385,15 +19914,15 @@
  *         for i in range(extent):
  */
       __pyx_v_data = (__pyx_v_data + __pyx_v_stride);
     }
 
     /* "View.MemoryView":1416
  *     cdef Py_ssize_t extent = shape[0]
- *
+ * 
  *     if ndim == 1:             # <<<<<<<<<<<<<<
  *         for i in range(extent):
  *             memcpy(data, item, itemsize)
  */
     goto __pyx_L3;
   }
 
@@ -19419,24 +19948,24 @@
  */
       __pyx_memoryview__slice_assign_scalar(__pyx_v_data, (__pyx_v_shape + 1), (__pyx_v_strides + 1), (__pyx_v_ndim - 1), __pyx_v_itemsize, __pyx_v_item);
 
       /* "View.MemoryView":1424
  *             _slice_assign_scalar(data, shape + 1, strides + 1,
  *                                 ndim - 1, itemsize, item)
  *             data += stride             # <<<<<<<<<<<<<<
- *
- *
+ * 
+ * 
  */
       __pyx_v_data = (__pyx_v_data + __pyx_v_stride);
     }
   }
   __pyx_L3:;
 
   /* "View.MemoryView":1409
- *
+ * 
  * @cname('__pyx_memoryview__slice_assign_scalar')
  * cdef void _slice_assign_scalar(char *data, Py_ssize_t *shape,             # <<<<<<<<<<<<<<
  *                               Py_ssize_t *strides, int ndim,
  *                               size_t itemsize, void *item) nogil:
  */
 
   /* function exit code */
@@ -19961,15 +20490,15 @@
   #endif
   __pyx_array_getbuffer, /*bf_getbuffer*/
   0, /*bf_releasebuffer*/
 };
 
 static PyTypeObject __pyx_type___pyx_array = {
   PyVarObject_HEAD_INIT(0, 0)
-  "smol.correlations.array", /*tp_name*/
+  "smol.utils.cluster.correlations.array", /*tp_name*/
   sizeof(struct __pyx_array_obj), /*tp_basicsize*/
   0, /*tp_itemsize*/
   __pyx_tp_dealloc_array, /*tp_dealloc*/
   #if PY_VERSION_HEX < 0x030800b4
   0, /*tp_print*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4
@@ -20026,15 +20555,15 @@
   #endif
   #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
   0, /*tp_vectorcall*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
   0, /*tp_print*/
   #endif
-  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
+  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000 && PY_VERSION_HEX < 0x030a0000
   0, /*tp_pypy_flags*/
   #endif
 };
 
 static PyObject *__pyx_tp_new_Enum(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
   struct __pyx_MemviewEnum_obj *p;
   PyObject *o;
@@ -20083,15 +20612,15 @@
   {"__reduce_cython__", (PyCFunction)__pyx_pw___pyx_MemviewEnum_1__reduce_cython__, METH_NOARGS, 0},
   {"__setstate_cython__", (PyCFunction)__pyx_pw___pyx_MemviewEnum_3__setstate_cython__, METH_O, 0},
   {0, 0, 0, 0}
 };
 
 static PyTypeObject __pyx_type___pyx_MemviewEnum = {
   PyVarObject_HEAD_INIT(0, 0)
-  "smol.correlations.Enum", /*tp_name*/
+  "smol.utils.cluster.correlations.Enum", /*tp_name*/
   sizeof(struct __pyx_MemviewEnum_obj), /*tp_basicsize*/
   0, /*tp_itemsize*/
   __pyx_tp_dealloc_Enum, /*tp_dealloc*/
   #if PY_VERSION_HEX < 0x030800b4
   0, /*tp_print*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4
@@ -20148,15 +20677,15 @@
   #endif
   #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
   0, /*tp_vectorcall*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
   0, /*tp_print*/
   #endif
-  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
+  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000 && PY_VERSION_HEX < 0x030a0000
   0, /*tp_pypy_flags*/
   #endif
 };
 static struct __pyx_vtabstruct_memoryview __pyx_vtable_memoryview;
 
 static PyObject *__pyx_tp_new_memoryview(PyTypeObject *t, PyObject *a, PyObject *k) {
   struct __pyx_memoryview_obj *p;
@@ -20347,15 +20876,15 @@
   #endif
   __pyx_memoryview_getbuffer, /*bf_getbuffer*/
   0, /*bf_releasebuffer*/
 };
 
 static PyTypeObject __pyx_type___pyx_memoryview = {
   PyVarObject_HEAD_INIT(0, 0)
-  "smol.correlations.memoryview", /*tp_name*/
+  "smol.utils.cluster.correlations.memoryview", /*tp_name*/
   sizeof(struct __pyx_memoryview_obj), /*tp_basicsize*/
   0, /*tp_itemsize*/
   __pyx_tp_dealloc_memoryview, /*tp_dealloc*/
   #if PY_VERSION_HEX < 0x030800b4
   0, /*tp_print*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4
@@ -20412,15 +20941,15 @@
   #endif
   #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
   0, /*tp_vectorcall*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
   0, /*tp_print*/
   #endif
-  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
+  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000 && PY_VERSION_HEX < 0x030a0000
   0, /*tp_pypy_flags*/
   #endif
 };
 static struct __pyx_vtabstruct__memoryviewslice __pyx_vtable__memoryviewslice;
 
 static PyObject *__pyx_tp_new__memoryviewslice(PyTypeObject *t, PyObject *a, PyObject *k) {
   struct __pyx_memoryviewslice_obj *p;
@@ -20488,15 +21017,15 @@
 static struct PyGetSetDef __pyx_getsets__memoryviewslice[] = {
   {(char *)"base", __pyx_getprop___pyx_memoryviewslice_base, 0, (char *)0, 0},
   {0, 0, 0, 0, 0}
 };
 
 static PyTypeObject __pyx_type___pyx_memoryviewslice = {
   PyVarObject_HEAD_INIT(0, 0)
-  "smol.correlations._memoryviewslice", /*tp_name*/
+  "smol.utils.cluster.correlations._memoryviewslice", /*tp_name*/
   sizeof(struct __pyx_memoryviewslice_obj), /*tp_basicsize*/
   0, /*tp_itemsize*/
   __pyx_tp_dealloc__memoryviewslice, /*tp_dealloc*/
   #if PY_VERSION_HEX < 0x030800b4
   0, /*tp_print*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4
@@ -20561,26 +21090,27 @@
   #endif
   #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
   0, /*tp_vectorcall*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
   0, /*tp_print*/
   #endif
-  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
+  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000 && PY_VERSION_HEX < 0x030a0000
   0, /*tp_pypy_flags*/
   #endif
 };
 
 static PyMethodDef __pyx_methods[] = {
-  {"corr_from_occupancy", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_4smol_12correlations_1corr_from_occupancy, METH_VARARGS|METH_KEYWORDS, __pyx_doc_4smol_12correlations_corr_from_occupancy},
-  {"delta_corr_single_flip", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_4smol_12correlations_3delta_corr_single_flip, METH_VARARGS|METH_KEYWORDS, __pyx_doc_4smol_12correlations_2delta_corr_single_flip},
-  {"indicator_delta_corr_single_flip", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_4smol_12correlations_5indicator_delta_corr_single_flip, METH_VARARGS|METH_KEYWORDS, __pyx_doc_4smol_12correlations_4indicator_delta_corr_single_flip},
-  {"delta_ewald_single_flip", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_4smol_12correlations_7delta_ewald_single_flip, METH_VARARGS|METH_KEYWORDS, __pyx_doc_4smol_12correlations_6delta_ewald_single_flip},
-  {"interactions_from_occupancy", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_4smol_12correlations_9interactions_from_occupancy, METH_VARARGS|METH_KEYWORDS, __pyx_doc_4smol_12correlations_8interactions_from_occupancy},
-  {"delta_interactions_single_flip", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_4smol_12correlations_11delta_interactions_single_flip, METH_VARARGS|METH_KEYWORDS, __pyx_doc_4smol_12correlations_10delta_interactions_single_flip},
+  {"corr_from_occupancy", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_4smol_5utils_7cluster_12correlations_1corr_from_occupancy, METH_VARARGS|METH_KEYWORDS, __pyx_doc_4smol_5utils_7cluster_12correlations_corr_from_occupancy},
+  {"delta_corr_single_flip", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_4smol_5utils_7cluster_12correlations_3delta_corr_single_flip, METH_VARARGS|METH_KEYWORDS, __pyx_doc_4smol_5utils_7cluster_12correlations_2delta_corr_single_flip},
+  {"corr_distance_single_flip", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_4smol_5utils_7cluster_12correlations_5corr_distance_single_flip, METH_VARARGS|METH_KEYWORDS, __pyx_doc_4smol_5utils_7cluster_12correlations_4corr_distance_single_flip},
+  {"interactions_from_occupancy", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_4smol_5utils_7cluster_12correlations_7interactions_from_occupancy, METH_VARARGS|METH_KEYWORDS, __pyx_doc_4smol_5utils_7cluster_12correlations_6interactions_from_occupancy},
+  {"delta_interactions_single_flip", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_4smol_5utils_7cluster_12correlations_9delta_interactions_single_flip, METH_VARARGS|METH_KEYWORDS, __pyx_doc_4smol_5utils_7cluster_12correlations_8delta_interactions_single_flip},
+  {"interaction_distance_single_flip", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_4smol_5utils_7cluster_12correlations_11interaction_distance_single_flip, METH_VARARGS|METH_KEYWORDS, __pyx_doc_4smol_5utils_7cluster_12correlations_10interaction_distance_single_flip},
+  {"delta_ewald_single_flip", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_4smol_5utils_7cluster_12correlations_13delta_ewald_single_flip, METH_VARARGS|METH_KEYWORDS, __pyx_doc_4smol_5utils_7cluster_12correlations_12delta_ewald_single_flip},
   {0, 0, 0, 0}
 };
 
 #if PY_MAJOR_VERSION >= 3
 #if CYTHON_PEP489_MULTI_PHASE_INIT
 static PyObject* __pyx_pymod_create(PyObject *spec, PyModuleDef *def); /*proto*/
 static int __pyx_pymod_exec_correlations(PyObject* module); /*proto*/
@@ -20703,14 +21233,16 @@
   {&__pyx_n_s_pyx_type, __pyx_k_pyx_type, sizeof(__pyx_k_pyx_type), 0, 0, 1, 1},
   {&__pyx_n_s_pyx_unpickle_Enum, __pyx_k_pyx_unpickle_Enum, sizeof(__pyx_k_pyx_unpickle_Enum), 0, 0, 1, 1},
   {&__pyx_n_s_pyx_vtable, __pyx_k_pyx_vtable, sizeof(__pyx_k_pyx_vtable), 0, 0, 1, 1},
   {&__pyx_n_s_range, __pyx_k_range, sizeof(__pyx_k_range), 0, 0, 1, 1},
   {&__pyx_n_s_reduce, __pyx_k_reduce, sizeof(__pyx_k_reduce), 0, 0, 1, 1},
   {&__pyx_n_s_reduce_cython, __pyx_k_reduce_cython, sizeof(__pyx_k_reduce_cython), 0, 0, 1, 1},
   {&__pyx_n_s_reduce_ex, __pyx_k_reduce_ex, sizeof(__pyx_k_reduce_ex), 0, 0, 1, 1},
+  {&__pyx_n_s_ref_corr_vector, __pyx_k_ref_corr_vector, sizeof(__pyx_k_ref_corr_vector), 0, 0, 1, 1},
+  {&__pyx_n_s_ref_interaction_vector, __pyx_k_ref_interaction_vector, sizeof(__pyx_k_ref_interaction_vector), 0, 0, 1, 1},
   {&__pyx_n_s_setstate, __pyx_k_setstate, sizeof(__pyx_k_setstate), 0, 0, 1, 1},
   {&__pyx_n_s_setstate_cython, __pyx_k_setstate_cython, sizeof(__pyx_k_setstate_cython), 0, 0, 1, 1},
   {&__pyx_n_s_shape, __pyx_k_shape, sizeof(__pyx_k_shape), 0, 0, 1, 1},
   {&__pyx_n_s_site_ind, __pyx_k_site_ind, sizeof(__pyx_k_site_ind), 0, 0, 1, 1},
   {&__pyx_n_s_site_orbit_list, __pyx_k_site_orbit_list, sizeof(__pyx_k_site_orbit_list), 0, 0, 1, 1},
   {&__pyx_n_s_size, __pyx_k_size, sizeof(__pyx_k_size), 0, 0, 1, 1},
   {&__pyx_n_s_start, __pyx_k_start, sizeof(__pyx_k_start), 0, 0, 1, 1},
@@ -20744,74 +21276,74 @@
   return -1;
 }
 
 static CYTHON_SMALL_CODE int __Pyx_InitCachedConstants(void) {
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__Pyx_InitCachedConstants", 0);
 
-  /* "../../miniconda3/envs/matx_310/lib/python3.10/site-packages/numpy/__init__.pxd":944
+  /* "../../../../../tmp/build-env-f9bdzduv/lib/python3.10/site-packages/numpy/__init__.pxd":944
  *         __pyx_import_array()
  *     except Exception:
  *         raise ImportError("numpy.core.multiarray failed to import")             # <<<<<<<<<<<<<<
- *
+ * 
  * cdef inline int import_umath() except -1:
  */
   __pyx_tuple_ = PyTuple_Pack(1, __pyx_kp_u_numpy_core_multiarray_failed_to); if (unlikely(!__pyx_tuple_)) __PYX_ERR(1, 944, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple_);
   __Pyx_GIVEREF(__pyx_tuple_);
 
-  /* "../../miniconda3/envs/matx_310/lib/python3.10/site-packages/numpy/__init__.pxd":950
+  /* "../../../../../tmp/build-env-f9bdzduv/lib/python3.10/site-packages/numpy/__init__.pxd":950
  *         _import_umath()
  *     except Exception:
  *         raise ImportError("numpy.core.umath failed to import")             # <<<<<<<<<<<<<<
- *
+ * 
  * cdef inline int import_ufunc() except -1:
  */
   __pyx_tuple__2 = PyTuple_Pack(1, __pyx_kp_u_numpy_core_umath_failed_to_impor); if (unlikely(!__pyx_tuple__2)) __PYX_ERR(1, 950, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__2);
   __Pyx_GIVEREF(__pyx_tuple__2);
 
   /* "View.MemoryView":134
- *
+ * 
  *         if not self.ndim:
  *             raise ValueError("Empty shape tuple for cython.array")             # <<<<<<<<<<<<<<
- *
+ * 
  *         if itemsize <= 0:
  */
   __pyx_tuple__3 = PyTuple_Pack(1, __pyx_kp_s_Empty_shape_tuple_for_cython_arr); if (unlikely(!__pyx_tuple__3)) __PYX_ERR(2, 134, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__3);
   __Pyx_GIVEREF(__pyx_tuple__3);
 
   /* "View.MemoryView":137
- *
+ * 
  *         if itemsize <= 0:
  *             raise ValueError("itemsize <= 0 for cython.array")             # <<<<<<<<<<<<<<
- *
+ * 
  *         if not isinstance(format, bytes):
  */
   __pyx_tuple__4 = PyTuple_Pack(1, __pyx_kp_s_itemsize_0_for_cython_array); if (unlikely(!__pyx_tuple__4)) __PYX_ERR(2, 137, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__4);
   __Pyx_GIVEREF(__pyx_tuple__4);
 
   /* "View.MemoryView":149
- *
+ * 
  *         if not self._shape:
  *             raise MemoryError("unable to allocate shape and strides.")             # <<<<<<<<<<<<<<
- *
- *
+ * 
+ * 
  */
   __pyx_tuple__5 = PyTuple_Pack(1, __pyx_kp_s_unable_to_allocate_shape_and_str); if (unlikely(!__pyx_tuple__5)) __PYX_ERR(2, 149, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__5);
   __Pyx_GIVEREF(__pyx_tuple__5);
 
   /* "View.MemoryView":177
  *             self.data = <char *>malloc(self.len)
  *             if not self.data:
  *                 raise MemoryError("unable to allocate array data.")             # <<<<<<<<<<<<<<
- *
+ * 
  *             if self.dtype_is_object:
  */
   __pyx_tuple__6 = PyTuple_Pack(1, __pyx_kp_s_unable_to_allocate_array_data); if (unlikely(!__pyx_tuple__6)) __PYX_ERR(2, 177, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__6);
   __Pyx_GIVEREF(__pyx_tuple__6);
 
   /* "View.MemoryView":193
@@ -20844,15 +21376,15 @@
   __Pyx_GOTREF(__pyx_tuple__9);
   __Pyx_GIVEREF(__pyx_tuple__9);
 
   /* "View.MemoryView":420
  *     def __setitem__(memoryview self, object index, object value):
  *         if self.view.readonly:
  *             raise TypeError("Cannot assign to read-only memoryview")             # <<<<<<<<<<<<<<
- *
+ * 
  *         have_slices, index = _unellipsify(index, self.view.ndim)
  */
   __pyx_tuple__10 = PyTuple_Pack(1, __pyx_kp_s_Cannot_assign_to_read_only_memor); if (unlikely(!__pyx_tuple__10)) __PYX_ERR(2, 420, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__10);
   __Pyx_GIVEREF(__pyx_tuple__10);
 
   /* "View.MemoryView":497
@@ -20866,37 +21398,37 @@
   __Pyx_GOTREF(__pyx_tuple__11);
   __Pyx_GIVEREF(__pyx_tuple__11);
 
   /* "View.MemoryView":522
  *     def __getbuffer__(self, Py_buffer *info, int flags):
  *         if flags & PyBUF_WRITABLE and self.view.readonly:
  *             raise ValueError("Cannot create writable memory view from read-only memoryview")             # <<<<<<<<<<<<<<
- *
+ * 
  *         if flags & PyBUF_ND:
  */
   __pyx_tuple__12 = PyTuple_Pack(1, __pyx_kp_s_Cannot_create_writable_memory_vi); if (unlikely(!__pyx_tuple__12)) __PYX_ERR(2, 522, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__12);
   __Pyx_GIVEREF(__pyx_tuple__12);
 
   /* "View.MemoryView":572
  *         if self.view.strides == NULL:
- *
+ * 
  *             raise ValueError("Buffer view does not expose strides")             # <<<<<<<<<<<<<<
- *
+ * 
  *         return tuple([stride for stride in self.view.strides[:self.view.ndim]])
  */
   __pyx_tuple__13 = PyTuple_Pack(1, __pyx_kp_s_Buffer_view_does_not_expose_stri); if (unlikely(!__pyx_tuple__13)) __PYX_ERR(2, 572, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__13);
   __Pyx_GIVEREF(__pyx_tuple__13);
 
   /* "View.MemoryView":579
  *     def suboffsets(self):
  *         if self.view.suboffsets == NULL:
  *             return (-1,) * self.view.ndim             # <<<<<<<<<<<<<<
- *
+ * 
  *         return tuple([suboffset for suboffset in self.view.suboffsets[:self.view.ndim]])
  */
   __pyx_tuple__14 = PyTuple_New(1); if (unlikely(!__pyx_tuple__14)) __PYX_ERR(2, 579, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__14);
   __Pyx_INCREF(__pyx_int_neg_1);
   __Pyx_GIVEREF(__pyx_int_neg_1);
   PyTuple_SET_ITEM(__pyx_tuple__14, 0, __pyx_int_neg_1);
@@ -20932,16 +21464,16 @@
   __Pyx_GOTREF(__pyx_slice__17);
   __Pyx_GIVEREF(__pyx_slice__17);
 
   /* "View.MemoryView":705
  *     for suboffset in suboffsets[:ndim]:
  *         if suboffset >= 0:
  *             raise ValueError("Indirect dimensions not supported")             # <<<<<<<<<<<<<<
- *
- *
+ * 
+ * 
  */
   __pyx_tuple__18 = PyTuple_Pack(1, __pyx_kp_s_Indirect_dimensions_not_supporte); if (unlikely(!__pyx_tuple__18)) __PYX_ERR(2, 705, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__18);
   __Pyx_GIVEREF(__pyx_tuple__18);
 
   /* "(tree fragment)":2
  * def __reduce_cython__(self):
@@ -20963,62 +21495,62 @@
   __Pyx_GIVEREF(__pyx_tuple__20);
   __pyx_tuple__21 = PyTuple_Pack(3, __pyx_int_184977713, __pyx_int_136983863, __pyx_int_112105877); if (unlikely(!__pyx_tuple__21)) __PYX_ERR(2, 4, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__21);
   __Pyx_GIVEREF(__pyx_tuple__21);
 
   /* "View.MemoryView":287
  *         return self.name
- *
+ * 
  * cdef generic = Enum("<strided and direct or indirect>")             # <<<<<<<<<<<<<<
  * cdef strided = Enum("<strided and direct>") # default
  * cdef indirect = Enum("<strided and indirect>")
  */
   __pyx_tuple__22 = PyTuple_Pack(1, __pyx_kp_s_strided_and_direct_or_indirect); if (unlikely(!__pyx_tuple__22)) __PYX_ERR(2, 287, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__22);
   __Pyx_GIVEREF(__pyx_tuple__22);
 
   /* "View.MemoryView":288
- *
+ * 
  * cdef generic = Enum("<strided and direct or indirect>")
  * cdef strided = Enum("<strided and direct>") # default             # <<<<<<<<<<<<<<
  * cdef indirect = Enum("<strided and indirect>")
- *
+ * 
  */
   __pyx_tuple__23 = PyTuple_Pack(1, __pyx_kp_s_strided_and_direct); if (unlikely(!__pyx_tuple__23)) __PYX_ERR(2, 288, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__23);
   __Pyx_GIVEREF(__pyx_tuple__23);
 
   /* "View.MemoryView":289
  * cdef generic = Enum("<strided and direct or indirect>")
  * cdef strided = Enum("<strided and direct>") # default
  * cdef indirect = Enum("<strided and indirect>")             # <<<<<<<<<<<<<<
- *
- *
+ * 
+ * 
  */
   __pyx_tuple__24 = PyTuple_Pack(1, __pyx_kp_s_strided_and_indirect); if (unlikely(!__pyx_tuple__24)) __PYX_ERR(2, 289, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__24);
   __Pyx_GIVEREF(__pyx_tuple__24);
 
   /* "View.MemoryView":292
- *
- *
+ * 
+ * 
  * cdef contiguous = Enum("<contiguous and direct>")             # <<<<<<<<<<<<<<
  * cdef indirect_contiguous = Enum("<contiguous and indirect>")
- *
+ * 
  */
   __pyx_tuple__25 = PyTuple_Pack(1, __pyx_kp_s_contiguous_and_direct); if (unlikely(!__pyx_tuple__25)) __PYX_ERR(2, 292, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__25);
   __Pyx_GIVEREF(__pyx_tuple__25);
 
   /* "View.MemoryView":293
- *
+ * 
  * cdef contiguous = Enum("<contiguous and direct>")
  * cdef indirect_contiguous = Enum("<contiguous and indirect>")             # <<<<<<<<<<<<<<
- *
- *
+ * 
+ * 
  */
   __pyx_tuple__26 = PyTuple_Pack(1, __pyx_kp_s_contiguous_and_indirect); if (unlikely(!__pyx_tuple__26)) __PYX_ERR(2, 293, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__26);
   __Pyx_GIVEREF(__pyx_tuple__26);
 
   /* "(tree fragment)":1
  * def __pyx_unpickle_Enum(__pyx_type, long __pyx_checksum, __pyx_state):             # <<<<<<<<<<<<<<
@@ -21036,14 +21568,15 @@
   return -1;
 }
 
 static CYTHON_SMALL_CODE int __Pyx_InitGlobals(void) {
   if (__Pyx_InitStrings(__pyx_string_tab) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
   __pyx_int_0 = PyInt_FromLong(0); if (unlikely(!__pyx_int_0)) __PYX_ERR(0, 1, __pyx_L1_error)
   __pyx_int_1 = PyInt_FromLong(1); if (unlikely(!__pyx_int_1)) __PYX_ERR(0, 1, __pyx_L1_error)
+  __pyx_int_2 = PyInt_FromLong(2); if (unlikely(!__pyx_int_2)) __PYX_ERR(0, 1, __pyx_L1_error)
   __pyx_int_112105877 = PyInt_FromLong(112105877L); if (unlikely(!__pyx_int_112105877)) __PYX_ERR(0, 1, __pyx_L1_error)
   __pyx_int_136983863 = PyInt_FromLong(136983863L); if (unlikely(!__pyx_int_136983863)) __PYX_ERR(0, 1, __pyx_L1_error)
   __pyx_int_184977713 = PyInt_FromLong(184977713L); if (unlikely(!__pyx_int_184977713)) __PYX_ERR(0, 1, __pyx_L1_error)
   __pyx_int_neg_1 = PyInt_FromLong(-1); if (unlikely(!__pyx_int_neg_1)) __PYX_ERR(0, 1, __pyx_L1_error)
   return 0;
   __pyx_L1_error:;
   return -1;
@@ -21157,55 +21690,39 @@
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__Pyx_modinit_type_import_code", 0);
   /*--- Type import code ---*/
   __pyx_t_1 = PyImport_ImportModule(__Pyx_BUILTIN_MODULE_NAME); if (unlikely(!__pyx_t_1)) __PYX_ERR(3, 9, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_ptype_7cpython_4type_type = __Pyx_ImportType(__pyx_t_1, __Pyx_BUILTIN_MODULE_NAME, "type",
+  __pyx_ptype_7cpython_4type_type = __Pyx_ImportType_0_29_35(__pyx_t_1, __Pyx_BUILTIN_MODULE_NAME, "type", 
   #if defined(PYPY_VERSION_NUM) && PYPY_VERSION_NUM < 0x050B0000
-  sizeof(PyTypeObject),
+  sizeof(PyTypeObject), __PYX_GET_STRUCT_ALIGNMENT_0_29_35(PyTypeObject),
   #else
-  sizeof(PyHeapTypeObject),
+  sizeof(PyHeapTypeObject), __PYX_GET_STRUCT_ALIGNMENT_0_29_35(PyHeapTypeObject),
   #endif
-  __Pyx_ImportType_CheckSize_Warn);
-   if (!__pyx_ptype_7cpython_4type_type) __PYX_ERR(3, 9, __pyx_L1_error)
+  __Pyx_ImportType_CheckSize_Warn_0_29_35); if (!__pyx_ptype_7cpython_4type_type) __PYX_ERR(3, 9, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __pyx_t_1 = PyImport_ImportModule("numpy"); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 199, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_ptype_5numpy_dtype = __Pyx_ImportType(__pyx_t_1, "numpy", "dtype", sizeof(PyArray_Descr), __Pyx_ImportType_CheckSize_Ignore);
-   if (!__pyx_ptype_5numpy_dtype) __PYX_ERR(1, 199, __pyx_L1_error)
-  __pyx_ptype_5numpy_flatiter = __Pyx_ImportType(__pyx_t_1, "numpy", "flatiter", sizeof(PyArrayIterObject), __Pyx_ImportType_CheckSize_Ignore);
-   if (!__pyx_ptype_5numpy_flatiter) __PYX_ERR(1, 222, __pyx_L1_error)
-  __pyx_ptype_5numpy_broadcast = __Pyx_ImportType(__pyx_t_1, "numpy", "broadcast", sizeof(PyArrayMultiIterObject), __Pyx_ImportType_CheckSize_Ignore);
-   if (!__pyx_ptype_5numpy_broadcast) __PYX_ERR(1, 226, __pyx_L1_error)
-  __pyx_ptype_5numpy_ndarray = __Pyx_ImportType(__pyx_t_1, "numpy", "ndarray", sizeof(PyArrayObject), __Pyx_ImportType_CheckSize_Ignore);
-   if (!__pyx_ptype_5numpy_ndarray) __PYX_ERR(1, 238, __pyx_L1_error)
-  __pyx_ptype_5numpy_generic = __Pyx_ImportType(__pyx_t_1, "numpy", "generic", sizeof(PyObject), __Pyx_ImportType_CheckSize_Warn);
-   if (!__pyx_ptype_5numpy_generic) __PYX_ERR(1, 770, __pyx_L1_error)
-  __pyx_ptype_5numpy_number = __Pyx_ImportType(__pyx_t_1, "numpy", "number", sizeof(PyObject), __Pyx_ImportType_CheckSize_Warn);
-   if (!__pyx_ptype_5numpy_number) __PYX_ERR(1, 772, __pyx_L1_error)
-  __pyx_ptype_5numpy_integer = __Pyx_ImportType(__pyx_t_1, "numpy", "integer", sizeof(PyObject), __Pyx_ImportType_CheckSize_Warn);
-   if (!__pyx_ptype_5numpy_integer) __PYX_ERR(1, 774, __pyx_L1_error)
-  __pyx_ptype_5numpy_signedinteger = __Pyx_ImportType(__pyx_t_1, "numpy", "signedinteger", sizeof(PyObject), __Pyx_ImportType_CheckSize_Warn);
-   if (!__pyx_ptype_5numpy_signedinteger) __PYX_ERR(1, 776, __pyx_L1_error)
-  __pyx_ptype_5numpy_unsignedinteger = __Pyx_ImportType(__pyx_t_1, "numpy", "unsignedinteger", sizeof(PyObject), __Pyx_ImportType_CheckSize_Warn);
-   if (!__pyx_ptype_5numpy_unsignedinteger) __PYX_ERR(1, 778, __pyx_L1_error)
-  __pyx_ptype_5numpy_inexact = __Pyx_ImportType(__pyx_t_1, "numpy", "inexact", sizeof(PyObject), __Pyx_ImportType_CheckSize_Warn);
-   if (!__pyx_ptype_5numpy_inexact) __PYX_ERR(1, 780, __pyx_L1_error)
-  __pyx_ptype_5numpy_floating = __Pyx_ImportType(__pyx_t_1, "numpy", "floating", sizeof(PyObject), __Pyx_ImportType_CheckSize_Warn);
-   if (!__pyx_ptype_5numpy_floating) __PYX_ERR(1, 782, __pyx_L1_error)
-  __pyx_ptype_5numpy_complexfloating = __Pyx_ImportType(__pyx_t_1, "numpy", "complexfloating", sizeof(PyObject), __Pyx_ImportType_CheckSize_Warn);
-   if (!__pyx_ptype_5numpy_complexfloating) __PYX_ERR(1, 784, __pyx_L1_error)
-  __pyx_ptype_5numpy_flexible = __Pyx_ImportType(__pyx_t_1, "numpy", "flexible", sizeof(PyObject), __Pyx_ImportType_CheckSize_Warn);
-   if (!__pyx_ptype_5numpy_flexible) __PYX_ERR(1, 786, __pyx_L1_error)
-  __pyx_ptype_5numpy_character = __Pyx_ImportType(__pyx_t_1, "numpy", "character", sizeof(PyObject), __Pyx_ImportType_CheckSize_Warn);
-   if (!__pyx_ptype_5numpy_character) __PYX_ERR(1, 788, __pyx_L1_error)
-  __pyx_ptype_5numpy_ufunc = __Pyx_ImportType(__pyx_t_1, "numpy", "ufunc", sizeof(PyUFuncObject), __Pyx_ImportType_CheckSize_Ignore);
-   if (!__pyx_ptype_5numpy_ufunc) __PYX_ERR(1, 826, __pyx_L1_error)
+  __pyx_ptype_5numpy_dtype = __Pyx_ImportType_0_29_35(__pyx_t_1, "numpy", "dtype", sizeof(PyArray_Descr), __PYX_GET_STRUCT_ALIGNMENT_0_29_35(PyArray_Descr),__Pyx_ImportType_CheckSize_Ignore_0_29_35); if (!__pyx_ptype_5numpy_dtype) __PYX_ERR(1, 199, __pyx_L1_error)
+  __pyx_ptype_5numpy_flatiter = __Pyx_ImportType_0_29_35(__pyx_t_1, "numpy", "flatiter", sizeof(PyArrayIterObject), __PYX_GET_STRUCT_ALIGNMENT_0_29_35(PyArrayIterObject),__Pyx_ImportType_CheckSize_Ignore_0_29_35); if (!__pyx_ptype_5numpy_flatiter) __PYX_ERR(1, 222, __pyx_L1_error)
+  __pyx_ptype_5numpy_broadcast = __Pyx_ImportType_0_29_35(__pyx_t_1, "numpy", "broadcast", sizeof(PyArrayMultiIterObject), __PYX_GET_STRUCT_ALIGNMENT_0_29_35(PyArrayMultiIterObject),__Pyx_ImportType_CheckSize_Ignore_0_29_35); if (!__pyx_ptype_5numpy_broadcast) __PYX_ERR(1, 226, __pyx_L1_error)
+  __pyx_ptype_5numpy_ndarray = __Pyx_ImportType_0_29_35(__pyx_t_1, "numpy", "ndarray", sizeof(PyArrayObject), __PYX_GET_STRUCT_ALIGNMENT_0_29_35(PyArrayObject),__Pyx_ImportType_CheckSize_Ignore_0_29_35); if (!__pyx_ptype_5numpy_ndarray) __PYX_ERR(1, 238, __pyx_L1_error)
+  __pyx_ptype_5numpy_generic = __Pyx_ImportType_0_29_35(__pyx_t_1, "numpy", "generic", sizeof(PyObject), __PYX_GET_STRUCT_ALIGNMENT_0_29_35(PyObject),__Pyx_ImportType_CheckSize_Warn_0_29_35); if (!__pyx_ptype_5numpy_generic) __PYX_ERR(1, 770, __pyx_L1_error)
+  __pyx_ptype_5numpy_number = __Pyx_ImportType_0_29_35(__pyx_t_1, "numpy", "number", sizeof(PyObject), __PYX_GET_STRUCT_ALIGNMENT_0_29_35(PyObject),__Pyx_ImportType_CheckSize_Warn_0_29_35); if (!__pyx_ptype_5numpy_number) __PYX_ERR(1, 772, __pyx_L1_error)
+  __pyx_ptype_5numpy_integer = __Pyx_ImportType_0_29_35(__pyx_t_1, "numpy", "integer", sizeof(PyObject), __PYX_GET_STRUCT_ALIGNMENT_0_29_35(PyObject),__Pyx_ImportType_CheckSize_Warn_0_29_35); if (!__pyx_ptype_5numpy_integer) __PYX_ERR(1, 774, __pyx_L1_error)
+  __pyx_ptype_5numpy_signedinteger = __Pyx_ImportType_0_29_35(__pyx_t_1, "numpy", "signedinteger", sizeof(PyObject), __PYX_GET_STRUCT_ALIGNMENT_0_29_35(PyObject),__Pyx_ImportType_CheckSize_Warn_0_29_35); if (!__pyx_ptype_5numpy_signedinteger) __PYX_ERR(1, 776, __pyx_L1_error)
+  __pyx_ptype_5numpy_unsignedinteger = __Pyx_ImportType_0_29_35(__pyx_t_1, "numpy", "unsignedinteger", sizeof(PyObject), __PYX_GET_STRUCT_ALIGNMENT_0_29_35(PyObject),__Pyx_ImportType_CheckSize_Warn_0_29_35); if (!__pyx_ptype_5numpy_unsignedinteger) __PYX_ERR(1, 778, __pyx_L1_error)
+  __pyx_ptype_5numpy_inexact = __Pyx_ImportType_0_29_35(__pyx_t_1, "numpy", "inexact", sizeof(PyObject), __PYX_GET_STRUCT_ALIGNMENT_0_29_35(PyObject),__Pyx_ImportType_CheckSize_Warn_0_29_35); if (!__pyx_ptype_5numpy_inexact) __PYX_ERR(1, 780, __pyx_L1_error)
+  __pyx_ptype_5numpy_floating = __Pyx_ImportType_0_29_35(__pyx_t_1, "numpy", "floating", sizeof(PyObject), __PYX_GET_STRUCT_ALIGNMENT_0_29_35(PyObject),__Pyx_ImportType_CheckSize_Warn_0_29_35); if (!__pyx_ptype_5numpy_floating) __PYX_ERR(1, 782, __pyx_L1_error)
+  __pyx_ptype_5numpy_complexfloating = __Pyx_ImportType_0_29_35(__pyx_t_1, "numpy", "complexfloating", sizeof(PyObject), __PYX_GET_STRUCT_ALIGNMENT_0_29_35(PyObject),__Pyx_ImportType_CheckSize_Warn_0_29_35); if (!__pyx_ptype_5numpy_complexfloating) __PYX_ERR(1, 784, __pyx_L1_error)
+  __pyx_ptype_5numpy_flexible = __Pyx_ImportType_0_29_35(__pyx_t_1, "numpy", "flexible", sizeof(PyObject), __PYX_GET_STRUCT_ALIGNMENT_0_29_35(PyObject),__Pyx_ImportType_CheckSize_Warn_0_29_35); if (!__pyx_ptype_5numpy_flexible) __PYX_ERR(1, 786, __pyx_L1_error)
+  __pyx_ptype_5numpy_character = __Pyx_ImportType_0_29_35(__pyx_t_1, "numpy", "character", sizeof(PyObject), __PYX_GET_STRUCT_ALIGNMENT_0_29_35(PyObject),__Pyx_ImportType_CheckSize_Warn_0_29_35); if (!__pyx_ptype_5numpy_character) __PYX_ERR(1, 788, __pyx_L1_error)
+  __pyx_ptype_5numpy_ufunc = __Pyx_ImportType_0_29_35(__pyx_t_1, "numpy", "ufunc", sizeof(PyUFuncObject), __PYX_GET_STRUCT_ALIGNMENT_0_29_35(PyUFuncObject),__Pyx_ImportType_CheckSize_Ignore_0_29_35); if (!__pyx_ptype_5numpy_ufunc) __PYX_ERR(1, 826, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __Pyx_RefNannyFinishContext();
   return 0;
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_RefNannyFinishContext();
   return -1;
@@ -21396,22 +21913,22 @@
   Py_INCREF(__pyx_cython_runtime);
   if (PyObject_SetAttrString(__pyx_m, "__builtins__", __pyx_b) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
   /*--- Initialize various global constants etc. ---*/
   if (__Pyx_InitGlobals() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
   #if PY_MAJOR_VERSION < 3 && (__PYX_DEFAULT_STRING_ENCODING_IS_ASCII || __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT)
   if (__Pyx_init_sys_getdefaultencoding_params() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
   #endif
-  if (__pyx_module_is_main_smol__correlations) {
+  if (__pyx_module_is_main_smol__utils__cluster__correlations) {
     if (PyObject_SetAttr(__pyx_m, __pyx_n_s_name_2, __pyx_n_s_main) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
   }
   #if PY_MAJOR_VERSION >= 3
   {
     PyObject *modules = PyImport_GetModuleDict(); if (unlikely(!modules)) __PYX_ERR(0, 1, __pyx_L1_error)
-    if (!PyDict_GetItemString(modules, "smol.correlations")) {
-      if (unlikely(PyDict_SetItemString(modules, "smol.correlations", __pyx_m) < 0)) __PYX_ERR(0, 1, __pyx_L1_error)
+    if (!PyDict_GetItemString(modules, "smol.utils.cluster.correlations")) {
+      if (unlikely(PyDict_SetItemString(modules, "smol.utils.cluster.correlations", __pyx_m) < 0)) __PYX_ERR(0, 1, __pyx_L1_error)
     }
   }
   #endif
   /*--- Builtin init code ---*/
   if (__Pyx_InitCachedBuiltins() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
   /*--- Constants init code ---*/
   if (__Pyx_InitCachedConstants() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
@@ -21424,130 +21941,130 @@
   (void)__Pyx_modinit_variable_import_code();
   (void)__Pyx_modinit_function_import_code();
   /*--- Execution code ---*/
   #if defined(__Pyx_Generator_USED) || defined(__Pyx_Coroutine_USED)
   if (__Pyx_patch_abc() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
   #endif
 
-  /* "smol/correlations.pyx":12
+  /* "smol/utils/cluster/correlations.pyx":12
  * """
- *
+ * 
  * __author__ = "Luis Barroso-Luque, William D. Richards"             # <<<<<<<<<<<<<<
- *
+ * 
  * import numpy as np
  */
   if (PyDict_SetItem(__pyx_d, __pyx_n_s_author, __pyx_kp_u_Luis_Barroso_Luque_William_D_Ric) < 0) __PYX_ERR(0, 12, __pyx_L1_error)
 
-  /* "smol/correlations.pyx":14
+  /* "smol/utils/cluster/correlations.pyx":14
  * __author__ = "Luis Barroso-Luque, William D. Richards"
- *
+ * 
  * import numpy as np             # <<<<<<<<<<<<<<
  * cimport numpy as np
- *
+ * 
  */
   __pyx_t_1 = __Pyx_Import(__pyx_n_s_numpy, 0, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 14, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   if (PyDict_SetItem(__pyx_d, __pyx_n_s_np, __pyx_t_1) < 0) __PYX_ERR(0, 14, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "smol/correlations.pyx":1
+  /* "smol/utils/cluster/correlations.pyx":1
  * #cython: boundscheck=False             # <<<<<<<<<<<<<<
  * #cython: nonecheck=False
  * #cython: wraparound=False
  */
   __pyx_t_1 = __Pyx_PyDict_NewPresized(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   if (PyDict_SetItem(__pyx_d, __pyx_n_s_test, __pyx_t_1) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
   /* "View.MemoryView":210
  *         info.obj = self
- *
+ * 
  *     __pyx_getbuffer = capsule(<void *> &__pyx_array_getbuffer, "getbuffer(obj, view, flags)")             # <<<<<<<<<<<<<<
- *
+ * 
  *     def __dealloc__(array self):
  */
   __pyx_t_1 = __pyx_capsule_create(((void *)(&__pyx_array_getbuffer)), ((char *)"getbuffer(obj, view, flags)")); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 210, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   if (PyDict_SetItem((PyObject *)__pyx_array_type->tp_dict, __pyx_n_s_pyx_getbuffer, __pyx_t_1) < 0) __PYX_ERR(2, 210, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   PyType_Modified(__pyx_array_type);
 
   /* "View.MemoryView":287
  *         return self.name
- *
+ * 
  * cdef generic = Enum("<strided and direct or indirect>")             # <<<<<<<<<<<<<<
  * cdef strided = Enum("<strided and direct>") # default
  * cdef indirect = Enum("<strided and indirect>")
  */
   __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)__pyx_MemviewEnum_type), __pyx_tuple__22, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 287, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_XGOTREF(generic);
   __Pyx_DECREF_SET(generic, __pyx_t_1);
   __Pyx_GIVEREF(__pyx_t_1);
   __pyx_t_1 = 0;
 
   /* "View.MemoryView":288
- *
+ * 
  * cdef generic = Enum("<strided and direct or indirect>")
  * cdef strided = Enum("<strided and direct>") # default             # <<<<<<<<<<<<<<
  * cdef indirect = Enum("<strided and indirect>")
- *
+ * 
  */
   __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)__pyx_MemviewEnum_type), __pyx_tuple__23, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 288, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_XGOTREF(strided);
   __Pyx_DECREF_SET(strided, __pyx_t_1);
   __Pyx_GIVEREF(__pyx_t_1);
   __pyx_t_1 = 0;
 
   /* "View.MemoryView":289
  * cdef generic = Enum("<strided and direct or indirect>")
  * cdef strided = Enum("<strided and direct>") # default
  * cdef indirect = Enum("<strided and indirect>")             # <<<<<<<<<<<<<<
- *
- *
+ * 
+ * 
  */
   __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)__pyx_MemviewEnum_type), __pyx_tuple__24, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 289, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_XGOTREF(indirect);
   __Pyx_DECREF_SET(indirect, __pyx_t_1);
   __Pyx_GIVEREF(__pyx_t_1);
   __pyx_t_1 = 0;
 
   /* "View.MemoryView":292
- *
- *
+ * 
+ * 
  * cdef contiguous = Enum("<contiguous and direct>")             # <<<<<<<<<<<<<<
  * cdef indirect_contiguous = Enum("<contiguous and indirect>")
- *
+ * 
  */
   __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)__pyx_MemviewEnum_type), __pyx_tuple__25, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 292, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_XGOTREF(contiguous);
   __Pyx_DECREF_SET(contiguous, __pyx_t_1);
   __Pyx_GIVEREF(__pyx_t_1);
   __pyx_t_1 = 0;
 
   /* "View.MemoryView":293
- *
+ * 
  * cdef contiguous = Enum("<contiguous and direct>")
  * cdef indirect_contiguous = Enum("<contiguous and indirect>")             # <<<<<<<<<<<<<<
- *
- *
+ * 
+ * 
  */
   __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)__pyx_MemviewEnum_type), __pyx_tuple__26, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 293, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_XGOTREF(indirect_contiguous);
   __Pyx_DECREF_SET(indirect_contiguous, __pyx_t_1);
   __Pyx_GIVEREF(__pyx_t_1);
   __pyx_t_1 = 0;
 
   /* "View.MemoryView":317
- *
+ * 
  * DEF THREAD_LOCKS_PREALLOCATED = 8
  * cdef int __pyx_memoryview_thread_locks_used = 0             # <<<<<<<<<<<<<<
  * cdef PyThread_type_lock[THREAD_LOCKS_PREALLOCATED] __pyx_memoryview_thread_locks = [
  *     PyThread_allocate_lock(),
  */
   __pyx_memoryview_thread_locks_used = 0;
 
@@ -21566,31 +22083,31 @@
   __pyx_t_2[5] = PyThread_allocate_lock();
   __pyx_t_2[6] = PyThread_allocate_lock();
   __pyx_t_2[7] = PyThread_allocate_lock();
   memcpy(&(__pyx_memoryview_thread_locks[0]), __pyx_t_2, sizeof(__pyx_memoryview_thread_locks[0]) * (8));
 
   /* "View.MemoryView":551
  *         info.obj = self
- *
+ * 
  *     __pyx_getbuffer = capsule(<void *> &__pyx_memoryview_getbuffer, "getbuffer(obj, view, flags)")             # <<<<<<<<<<<<<<
- *
- *
+ * 
+ * 
  */
   __pyx_t_1 = __pyx_capsule_create(((void *)(&__pyx_memoryview_getbuffer)), ((char *)"getbuffer(obj, view, flags)")); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 551, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   if (PyDict_SetItem((PyObject *)__pyx_memoryview_type->tp_dict, __pyx_n_s_pyx_getbuffer, __pyx_t_1) < 0) __PYX_ERR(2, 551, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   PyType_Modified(__pyx_memoryview_type);
 
   /* "View.MemoryView":997
  *         return self.from_object
- *
+ * 
  *     __pyx_getbuffer = capsule(<void *> &__pyx_memoryview_getbuffer, "getbuffer(obj, view, flags)")             # <<<<<<<<<<<<<<
- *
- *
+ * 
+ * 
  */
   __pyx_t_1 = __pyx_capsule_create(((void *)(&__pyx_memoryview_getbuffer)), ((char *)"getbuffer(obj, view, flags)")); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 997, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   if (PyDict_SetItem((PyObject *)__pyx_memoryviewslice_type->tp_dict, __pyx_n_s_pyx_getbuffer, __pyx_t_1) < 0) __PYX_ERR(2, 997, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   PyType_Modified(__pyx_memoryviewslice_type);
 
@@ -21615,19 +22132,19 @@
   /*--- Wrapped vars code ---*/
 
   goto __pyx_L0;
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   if (__pyx_m) {
     if (__pyx_d) {
-      __Pyx_AddTraceback("init smol.correlations", __pyx_clineno, __pyx_lineno, __pyx_filename);
+      __Pyx_AddTraceback("init smol.utils.cluster.correlations", __pyx_clineno, __pyx_lineno, __pyx_filename);
     }
     Py_CLEAR(__pyx_m);
   } else if (!PyErr_Occurred()) {
-    PyErr_SetString(PyExc_ImportError, "init smol.correlations");
+    PyErr_SetString(PyExc_ImportError, "init smol.utils.cluster.correlations");
   }
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   #if CYTHON_PEP489_MULTI_PHASE_INIT
   return (__pyx_m != NULL) ? 0 : -1;
   #elif PY_MAJOR_VERSION >= 3
   return __pyx_m;
@@ -22180,27 +22697,14 @@
             PyGILState_Release(_gilstate);
         }
     } else {
         memslice->memview = NULL;
     }
 }
 
-/* ExtTypeTest */
-static CYTHON_INLINE int __Pyx_TypeTest(PyObject *obj, PyTypeObject *type) {
-    if (unlikely(!type)) {
-        PyErr_SetString(PyExc_SystemError, "Missing type object");
-        return 0;
-    }
-    if (likely(__Pyx_TypeCheck(obj, type)))
-        return 1;
-    PyErr_Format(PyExc_TypeError, "Cannot convert %.200s to %.200s",
-                 Py_TYPE(obj)->tp_name, type->tp_name);
-    return 0;
-}
-
 /* RaiseArgTupleInvalid */
 static void __Pyx_RaiseArgtupleInvalid(
     const char* func_name,
     int exact,
     Py_ssize_t num_min,
     Py_ssize_t num_max,
     Py_ssize_t num_found)
@@ -22672,28 +23176,28 @@
                             "BaseException");
             goto bad;
         }
         PyException_SetCause(value, fixed_cause);
     }
     PyErr_SetObject(type, value);
     if (tb) {
-#if CYTHON_COMPILING_IN_PYPY
-        PyObject *tmp_type, *tmp_value, *tmp_tb;
-        PyErr_Fetch(&tmp_type, &tmp_value, &tmp_tb);
-        Py_INCREF(tb);
-        PyErr_Restore(tmp_type, tmp_value, tb);
-        Py_XDECREF(tmp_tb);
-#else
+#if CYTHON_FAST_THREAD_STATE
         PyThreadState *tstate = __Pyx_PyThreadState_Current;
         PyObject* tmp_tb = tstate->curexc_traceback;
         if (tb != tmp_tb) {
             Py_INCREF(tb);
             tstate->curexc_traceback = tb;
             Py_XDECREF(tmp_tb);
         }
+#else
+        PyObject *tmp_type, *tmp_value, *tmp_tb;
+        PyErr_Fetch(&tmp_type, &tmp_value, &tmp_tb);
+        Py_INCREF(tb);
+        PyErr_Restore(tmp_type, tmp_value, tb);
+        Py_XDECREF(tmp_tb);
 #endif
     }
 bad:
     Py_XDECREF(owned_instance);
     return;
 }
 #endif
@@ -23025,14 +23529,27 @@
 }
 
 /* RaiseNoneIterError */
 static CYTHON_INLINE void __Pyx_RaiseNoneNotIterableError(void) {
     PyErr_SetString(PyExc_TypeError, "'NoneType' object is not iterable");
 }
 
+/* ExtTypeTest */
+static CYTHON_INLINE int __Pyx_TypeTest(PyObject *obj, PyTypeObject *type) {
+    if (unlikely(!type)) {
+        PyErr_SetString(PyExc_SystemError, "Missing type object");
+        return 0;
+    }
+    if (likely(__Pyx_TypeCheck(obj, type)))
+        return 1;
+    PyErr_Format(PyExc_TypeError, "Cannot convert %.200s to %.200s",
+                 Py_TYPE(obj)->tp_name, type->tp_name);
+    return 0;
+}
+
 /* SwapException */
 #if CYTHON_FAST_THREAD_STATE
 static CYTHON_INLINE void __Pyx__ExceptionSwap(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb) {
     PyObject *tmp_type, *tmp_value, *tmp_tb;
     #if CYTHON_USE_EXC_INFO_STACK
     _PyErr_StackItem *exc_info = tstate->exc_info;
     tmp_type = exc_info->exc_type;
@@ -23332,16 +23849,16 @@
                 x = a + b;
             return PyLong_FromLong(x);
 #ifdef HAVE_LONG_LONG
         long_long:
                 llx = lla + llb;
             return PyLong_FromLongLong(llx);
 #endif
-
-
+        
+        
     }
     #endif
     if (PyFloat_CheckExact(op1)) {
         const long b = intval;
         double a = PyFloat_AS_DOUBLE(op1);
             double result;
             PyFPE_START_PROTECT("add", return NULL)
@@ -23581,61 +24098,79 @@
     Py_XDECREF(reduce_cython);
     Py_XDECREF(setstate);
     Py_XDECREF(setstate_cython);
     return ret;
 }
 
 /* TypeImport */
-#ifndef __PYX_HAVE_RT_ImportType
-#define __PYX_HAVE_RT_ImportType
-static PyTypeObject *__Pyx_ImportType(PyObject *module, const char *module_name, const char *class_name,
-    size_t size, enum __Pyx_ImportType_CheckSize check_size)
+#ifndef __PYX_HAVE_RT_ImportType_0_29_35
+#define __PYX_HAVE_RT_ImportType_0_29_35
+static PyTypeObject *__Pyx_ImportType_0_29_35(PyObject *module, const char *module_name, const char *class_name,
+    size_t size, size_t alignment, enum __Pyx_ImportType_CheckSize_0_29_35 check_size)
 {
     PyObject *result = 0;
     char warning[200];
     Py_ssize_t basicsize;
+    Py_ssize_t itemsize;
 #ifdef Py_LIMITED_API
     PyObject *py_basicsize;
+    PyObject *py_itemsize;
 #endif
     result = PyObject_GetAttrString(module, class_name);
     if (!result)
         goto bad;
     if (!PyType_Check(result)) {
         PyErr_Format(PyExc_TypeError,
             "%.200s.%.200s is not a type object",
             module_name, class_name);
         goto bad;
     }
 #ifndef Py_LIMITED_API
     basicsize = ((PyTypeObject *)result)->tp_basicsize;
+    itemsize = ((PyTypeObject *)result)->tp_itemsize;
 #else
     py_basicsize = PyObject_GetAttrString(result, "__basicsize__");
     if (!py_basicsize)
         goto bad;
     basicsize = PyLong_AsSsize_t(py_basicsize);
     Py_DECREF(py_basicsize);
     py_basicsize = 0;
     if (basicsize == (Py_ssize_t)-1 && PyErr_Occurred())
         goto bad;
+    py_itemsize = PyObject_GetAttrString(result, "__itemsize__");
+    if (!py_itemsize)
+        goto bad;
+    itemsize = PyLong_AsSsize_t(py_itemsize);
+    Py_DECREF(py_itemsize);
+    py_itemsize = 0;
+    if (itemsize == (Py_ssize_t)-1 && PyErr_Occurred())
+        goto bad;
 #endif
-    if ((size_t)basicsize < size) {
+    if (itemsize) {
+        if (size % alignment) {
+            alignment = size % alignment;
+        }
+        if (itemsize < (Py_ssize_t)alignment)
+            itemsize = (Py_ssize_t)alignment;
+    }
+    if ((size_t)(basicsize + itemsize) < size) {
         PyErr_Format(PyExc_ValueError,
             "%.200s.%.200s size changed, may indicate binary incompatibility. "
             "Expected %zd from C header, got %zd from PyObject",
             module_name, class_name, size, basicsize);
         goto bad;
     }
-    if (check_size == __Pyx_ImportType_CheckSize_Error && (size_t)basicsize != size) {
+    if (check_size == __Pyx_ImportType_CheckSize_Error_0_29_35 && (size_t)basicsize != size) {
         PyErr_Format(PyExc_ValueError,
             "%.200s.%.200s size changed, may indicate binary incompatibility. "
             "Expected %zd from C header, got %zd from PyObject",
             module_name, class_name, size, basicsize);
         goto bad;
     }
-    else if (check_size == __Pyx_ImportType_CheckSize_Warn && (size_t)basicsize > size) {
+    else if (check_size == __Pyx_ImportType_CheckSize_Warn_0_29_35 && (size_t)basicsize > size) {
         PyOS_snprintf(warning, sizeof(warning),
             "%s.%s size changed, may indicate binary incompatibility. "
             "Expected %zd from C header, got %zd from PyObject",
             module_name, class_name, size, basicsize);
         if (PyErr_WarnEx(NULL, warning, 0) < 0) goto bad;
     }
     return (PyTypeObject *)result;
@@ -24744,14 +25279,37 @@
                     goto raise_overflow;\
             }\
         }\
         return (target_type) value;\
     }
 
 /* ObjectToMemviewSlice */
+  static CYTHON_INLINE __Pyx_memviewslice __Pyx_PyObject_to_MemoryviewSlice_dc_double__const__(PyObject *obj, int writable_flag) {
+    __Pyx_memviewslice result = { 0, 0, { 0 }, { 0 }, { 0 } };
+    __Pyx_BufFmt_StackElem stack[1];
+    int axes_specs[] = { (__Pyx_MEMVIEW_DIRECT | __Pyx_MEMVIEW_CONTIG) };
+    int retcode;
+    if (obj == Py_None) {
+        result.memview = (struct __pyx_memoryview_obj *) Py_None;
+        return result;
+    }
+    retcode = __Pyx_ValidateAndInit_memviewslice(axes_specs, __Pyx_IS_C_CONTIG,
+                                                 (PyBUF_C_CONTIGUOUS | PyBUF_FORMAT) | writable_flag, 1,
+                                                 &__Pyx_TypeInfo_double__const__, stack,
+                                                 &result, obj);
+    if (unlikely(retcode == -1))
+        goto __pyx_fail;
+    return result;
+__pyx_fail:
+    result.memview = NULL;
+    result.data = NULL;
+    return result;
+}
+
+/* ObjectToMemviewSlice */
   static CYTHON_INLINE __Pyx_memviewslice __Pyx_PyObject_to_MemoryviewSlice_d_dc_double__const__(PyObject *obj, int writable_flag) {
     __Pyx_memviewslice result = { 0, 0, { 0 }, { 0 }, { 0 } };
     __Pyx_BufFmt_StackElem stack[1];
     int axes_specs[] = { (__Pyx_MEMVIEW_DIRECT | __Pyx_MEMVIEW_FOLLOW), (__Pyx_MEMVIEW_DIRECT | __Pyx_MEMVIEW_CONTIG) };
     int retcode;
     if (obj == Py_None) {
         result.memview = (struct __pyx_memoryview_obj *) Py_None;
@@ -24836,26 +25394,26 @@
 __pyx_fail:
     result.memview = NULL;
     result.data = NULL;
     return result;
 }
 
 /* ObjectToMemviewSlice */
-  static CYTHON_INLINE __Pyx_memviewslice __Pyx_PyObject_to_MemoryviewSlice_dc_double__const__(PyObject *obj, int writable_flag) {
+  static CYTHON_INLINE __Pyx_memviewslice __Pyx_PyObject_to_MemoryviewSlice_d_dc_double(PyObject *obj, int writable_flag) {
     __Pyx_memviewslice result = { 0, 0, { 0 }, { 0 }, { 0 } };
     __Pyx_BufFmt_StackElem stack[1];
-    int axes_specs[] = { (__Pyx_MEMVIEW_DIRECT | __Pyx_MEMVIEW_CONTIG) };
+    int axes_specs[] = { (__Pyx_MEMVIEW_DIRECT | __Pyx_MEMVIEW_FOLLOW), (__Pyx_MEMVIEW_DIRECT | __Pyx_MEMVIEW_CONTIG) };
     int retcode;
     if (obj == Py_None) {
         result.memview = (struct __pyx_memoryview_obj *) Py_None;
         return result;
     }
     retcode = __Pyx_ValidateAndInit_memviewslice(axes_specs, __Pyx_IS_C_CONTIG,
-                                                 (PyBUF_C_CONTIGUOUS | PyBUF_FORMAT) | writable_flag, 1,
-                                                 &__Pyx_TypeInfo_double__const__, stack,
+                                                 (PyBUF_C_CONTIGUOUS | PyBUF_FORMAT) | writable_flag, 2,
+                                                 &__Pyx_TypeInfo_double, stack,
                                                  &result, obj);
     if (unlikely(retcode == -1))
         goto __pyx_fail;
     return result;
 __pyx_fail:
     result.memview = NULL;
     result.data = NULL;
@@ -25293,15 +25851,15 @@
                         } else if (8 * sizeof(int) >= 4 * PyLong_SHIFT) {
                             return (int) (((((((((int)digits[3]) << PyLong_SHIFT) | (int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0]));
                         }
                     }
                     break;
             }
 #endif
-#if CYTHON_COMPILING_IN_CPYTHON
+#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX < 0x030C00A7
             if (unlikely(Py_SIZE(x) < 0)) {
                 goto raise_neg_overflow;
             }
 #else
             {
                 int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                 if (unlikely(result < 0))
@@ -25467,52 +26025,14 @@
         int one = 1; int little = (int)*(unsigned char *)&one;
         unsigned char *bytes = (unsigned char *)&value;
         return _PyLong_FromByteArray(bytes, sizeof(int),
                                      little, !is_unsigned);
     }
 }
 
-/* CIntToPy */
-  static CYTHON_INLINE PyObject* __Pyx_PyInt_From_long(long value) {
-#ifdef __Pyx_HAS_GCC_DIAGNOSTIC
-#pragma GCC diagnostic push
-#pragma GCC diagnostic ignored "-Wconversion"
-#endif
-    const long neg_one = (long) -1, const_zero = (long) 0;
-#ifdef __Pyx_HAS_GCC_DIAGNOSTIC
-#pragma GCC diagnostic pop
-#endif
-    const int is_unsigned = neg_one > const_zero;
-    if (is_unsigned) {
-        if (sizeof(long) < sizeof(long)) {
-            return PyInt_FromLong((long) value);
-        } else if (sizeof(long) <= sizeof(unsigned long)) {
-            return PyLong_FromUnsignedLong((unsigned long) value);
-#ifdef HAVE_LONG_LONG
-        } else if (sizeof(long) <= sizeof(unsigned PY_LONG_LONG)) {
-            return PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG) value);
-#endif
-        }
-    } else {
-        if (sizeof(long) <= sizeof(long)) {
-            return PyInt_FromLong((long) value);
-#ifdef HAVE_LONG_LONG
-        } else if (sizeof(long) <= sizeof(PY_LONG_LONG)) {
-            return PyLong_FromLongLong((PY_LONG_LONG) value);
-#endif
-        }
-    }
-    {
-        int one = 1; int little = (int)*(unsigned char *)&one;
-        unsigned char *bytes = (unsigned char *)&value;
-        return _PyLong_FromByteArray(bytes, sizeof(long),
-                                     little, !is_unsigned);
-    }
-}
-
 /* CIntFromPy */
   static CYTHON_INLINE long __Pyx_PyInt_As_long(PyObject *x) {
 #ifdef __Pyx_HAS_GCC_DIAGNOSTIC
 #pragma GCC diagnostic push
 #pragma GCC diagnostic ignored "-Wconversion"
 #endif
     const long neg_one = (long) -1, const_zero = (long) 0;
@@ -25565,15 +26085,15 @@
                         } else if (8 * sizeof(long) >= 4 * PyLong_SHIFT) {
                             return (long) (((((((((long)digits[3]) << PyLong_SHIFT) | (long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0]));
                         }
                     }
                     break;
             }
 #endif
-#if CYTHON_COMPILING_IN_CPYTHON
+#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX < 0x030C00A7
             if (unlikely(Py_SIZE(x) < 0)) {
                 goto raise_neg_overflow;
             }
 #else
             {
                 int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                 if (unlikely(result < 0))
@@ -25701,14 +26221,52 @@
     return (long) -1;
 raise_neg_overflow:
     PyErr_SetString(PyExc_OverflowError,
         "can't convert negative value to long");
     return (long) -1;
 }
 
+/* CIntToPy */
+  static CYTHON_INLINE PyObject* __Pyx_PyInt_From_long(long value) {
+#ifdef __Pyx_HAS_GCC_DIAGNOSTIC
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wconversion"
+#endif
+    const long neg_one = (long) -1, const_zero = (long) 0;
+#ifdef __Pyx_HAS_GCC_DIAGNOSTIC
+#pragma GCC diagnostic pop
+#endif
+    const int is_unsigned = neg_one > const_zero;
+    if (is_unsigned) {
+        if (sizeof(long) < sizeof(long)) {
+            return PyInt_FromLong((long) value);
+        } else if (sizeof(long) <= sizeof(unsigned long)) {
+            return PyLong_FromUnsignedLong((unsigned long) value);
+#ifdef HAVE_LONG_LONG
+        } else if (sizeof(long) <= sizeof(unsigned PY_LONG_LONG)) {
+            return PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG) value);
+#endif
+        }
+    } else {
+        if (sizeof(long) <= sizeof(long)) {
+            return PyInt_FromLong((long) value);
+#ifdef HAVE_LONG_LONG
+        } else if (sizeof(long) <= sizeof(PY_LONG_LONG)) {
+            return PyLong_FromLongLong((PY_LONG_LONG) value);
+#endif
+        }
+    }
+    {
+        int one = 1; int little = (int)*(unsigned char *)&one;
+        unsigned char *bytes = (unsigned char *)&value;
+        return _PyLong_FromByteArray(bytes, sizeof(long),
+                                     little, !is_unsigned);
+    }
+}
+
 /* CIntFromPy */
   static CYTHON_INLINE char __Pyx_PyInt_As_char(PyObject *x) {
 #ifdef __Pyx_HAS_GCC_DIAGNOSTIC
 #pragma GCC diagnostic push
 #pragma GCC diagnostic ignored "-Wconversion"
 #endif
     const char neg_one = (char) -1, const_zero = (char) 0;
@@ -25761,15 +26319,15 @@
                         } else if (8 * sizeof(char) >= 4 * PyLong_SHIFT) {
                             return (char) (((((((((char)digits[3]) << PyLong_SHIFT) | (char)digits[2]) << PyLong_SHIFT) | (char)digits[1]) << PyLong_SHIFT) | (char)digits[0]));
                         }
                     }
                     break;
             }
 #endif
-#if CYTHON_COMPILING_IN_CPYTHON
+#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX < 0x030C00A7
             if (unlikely(Py_SIZE(x) < 0)) {
                 goto raise_neg_overflow;
             }
 #else
             {
                 int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                 if (unlikely(result < 0))
```

### Comparing `smol-0.3.1/smol/correlations.pyx` & `smol-0.4.0/smol/utils/cluster/correlations.pyx`

 * *Files 11% similar despite different names*

```diff
@@ -18,15 +18,15 @@
 cpdef corr_from_occupancy(const long[::1] occu,
                           const int num_corr_functions,
                           list orbit_list):
     """Computes the correlation vector for a given encoded occupancy string.
 
     Args:
         occu (ndarray):
-            encoded occupancy vector
+            encoded occupancy array
         num_corr_functions (int):
             total number of bit orderings in expansion.
         orbit_list:
             Information of all orbits.
             (orbit id, flat tensor index array, flat correlation tensor,
              site indices of clusters)
 
@@ -58,30 +58,29 @@
     return out
 
 
 cpdef delta_corr_single_flip(const long[::1] occu_f,
                              const long[::1] occu_i,
                              const int num_corr_functions,
                              list site_orbit_list):
-    """Computes the correlation difference between two occupancy vectors.
+    """Computes the correlation difference between two occupancy arrays.
 
     Args:
         occu_f (ndarray):
-            encoded occupancy vector with flip
+            encoded occupancy array with flip
         occu_i (ndarray):
-            encoded occupancy vector without flip
+            encoded occupancy array without flip
         num_corr_functions (int):
             total number of bit orderings in expansion.
         site_orbit_list:
             Information of all orbits that include the flip site.
             List of tuples each with
             (orbit id, cluster ratio, flat tensor index array,
              flat correlation tensor, site indices of clusters)
 
-
     Returns:
         ndarray: correlation vector difference
     """
     cdef int i, j, n, m, I, J, M, ind_i, ind_f
     cdef double p, ratio
     cdef const long[:, ::1] indices
     cdef const long[::1] tensor_indices
@@ -102,129 +101,76 @@
                     ind_f += tensor_indices[j] * occu_f[indices[i, j]]
                 p += (corr_tensors[m, ind_f] - corr_tensors[m, ind_i])
             o_view[n] = p / ratio / I
             n += 1
     return out
 
 
-cpdef indicator_delta_corr_single_flip(const long[::1] occu_f,
-                                       const long[::1] occu_i,
-                                       const int num_corr_functions,
-                                       list site_orbit_list):
-    """Local change in indicator basis correlation vector from single flip.
+cpdef corr_distance_single_flip(const long[::1] occu_f,
+                                const long[::1] occu_i,
+                                const double[::1] ref_corr_vector,
+                                const int num_corr_functions,
+                                list orbit_list):
+    """Computes the absolute distance of two correlation vectors separated by a single
+    flip and a given correlation vector.
+
+    Unfortunately this scales just as bad as computing the full correlation vector.
 
     Args:
         occu_f (ndarray):
-            encoded occupancy vector with flip
+            encoded occupancy array with flip
         occu_i (ndarray):
-            encoded occupancy vector without flip
+            encoded occupancy array without flip
+        ref_corr_vector (ndarray):
+            reference correlation vector
         num_corr_functions (int):
             total number of bit orderings in expansion.
-        site_orbit_list:
-            Information of all orbits that include the flip site.
-            List of tuples each with
-            (orbit id, cluster ratio, bit_combos,
-             bit_combo_indices site indices, bases array)
+        orbit_list:
+            Information of all orbits.
+            (orbit id, flat tensor index array, flat correlation tensor,
+             site indices of clusters)
 
     Returns:
-        ndarray: correlation vector difference
+        ndarray: 2D with correlation vector distances from reference for each of occu_i
+        and occu_f
     """
-    cdef int i, j, k, n, m, I, K, M
-    cdef bint ok
-    cdef const long[:, ::1] bit_combos, indices
-    cdef const long[::1] bit_indices
-    out = np.zeros(num_corr_functions)
-    cdef double[::1] o_view = out
-    cdef double r, o
+    cdef int i, j, n, m, I, J, M, ind_i, ind_f
+    cdef double p_i, p_f
+    cdef const long[:, ::1] indices
+    cdef const long[::1] tensor_indices
+    cdef const double[:, ::1] corr_tensors
+    out = np.zeros((2, num_corr_functions))
+    cdef double[:, ::1] o_view = out
+    o_view[:, 0] = 0
 
-    for n, r, bit_combos, bit_indices, _, indices in site_orbit_list:
-        M = bit_indices.shape[0] # index of bit combos
+    for n, tensor_indices, corr_tensors, indices in orbit_list:
+        M = corr_tensors.shape[0]  # index of bit combos
         I = indices.shape[0] # cluster index
-        K = indices.shape[1] # index within cluster
-        for m in range(M - 1):
-            o = 0
+        J = indices.shape[1] # index within cluster
+        for m in range(M):
+            p_f, p_i = 0, 0
             for i in range(I):
-                for j in range(bit_indices[m], bit_indices[m + 1]):
-                    ok = True
-                    for k in range(K):
-                        if occu_f[indices[i, k]] != bit_combos[j, k]:
-                            ok = False
-                            break
-                    if ok:
-                        o += 1
-
-                    ok = True
-                    for k in range(K):
-                        if occu_i[indices[i, k]] != bit_combos[j, k]:
-                            ok = False
-                            break
-                    if ok:
-                        o -= 1
-
-            o_view[n] = o / r / (I * (bit_indices[m + 1] - bit_indices[m]))
+                ind_f, ind_i = 0, 0
+                for j in range(J):
+                    ind_f += tensor_indices[j] * occu_f[indices[i, j]]
+                    ind_i += tensor_indices[j] * occu_i[indices[i, j]]
+                p_f += corr_tensors[m, ind_f]
+                p_i += corr_tensors[m, ind_i]
+            o_view[1, n] = abs(p_f / I - ref_corr_vector[n])
+            o_view[0, n] = abs(p_i / I - ref_corr_vector[n])
             n += 1
     return out
 
 
-cpdef delta_ewald_single_flip(const long[::1] occu_f,
-                              const long[::1] occu_i,
-                              const double[:, ::1] ewald_matrix,
-                              const long[:, ::1] ewald_indices,
-                              const int site_ind):
-    """Compute the change in electrostatic interaction energy from a flip.
-
-    Args:
-        occu_f (ndarray):
-            encoded occupancy vector with flip
-        occu_i (ndarray):
-            encoded occupancy vector without flip
-        ewald_matrix (ndarray):
-            Ewald matrix for electrostatic interactions
-        ewald_indices (ndarray):
-            2D array of indices corresponding to a specific site occupation
-            in the ewald matrix
-        site_ind (int):
-            site index for site being flipped
-
-    Returns:
-        float: electrostatic interaction energy difference
-    """
-    cdef int i, j, k, add, sub
-    cdef bint ok
-    cdef double out = 0
-    cdef double out_k
-
-    # values of -1 are vacancies and hence don't have ewald indices
-    add = ewald_indices[site_ind, occu_f[site_ind]]
-    sub = ewald_indices[site_ind, occu_i[site_ind]]
-
-    for k in range(occu_f.shape[0]):
-        i = ewald_indices[k, occu_f[k]]
-        out_k = 0
-        if i != -1 and add != -1:
-            if i != add:
-                out_k = out_k + 2 * ewald_matrix[i, add]
-            else:
-                out_k = out_k + ewald_matrix[i, add]
-
-        j = ewald_indices[k, occu_i[k]]
-        if j != -1 and sub != -1:
-            if j != sub:
-                out_k = out_k - 2 * ewald_matrix[j, sub]
-            else:
-                out_k = out_k - ewald_matrix[j, sub]
-        out += out_k
-    return out
-
-
 cpdef interactions_from_occupancy(const long[::1] occu,
                                   const int num_interactions,
                                   const double offset,
                                   list orbit_list):
     """Computes the cluster interaction vector for a given encoded occupancy string.
+
     Args:
         occu (ndarray):
             encoded occupancy vector
         num_interactions (int):
             total number of cluster interactions (orbits in cluster subspace).
         offset (float):
             eci value for the constant term.
@@ -235,29 +181,29 @@
     Returns: array
         cluster interaction vector for given occupancy
     """
     cdef int n, i, j, I, J, index
     cdef double p
     cdef const long[:, ::1] indices
     cdef const long[::1] tensor_indices
-    cdef const double[::1] interaction_tensors
+    cdef const double[::1] interaction_tensor
     out = np.zeros(num_interactions)
     cdef double[:] o_view = out
     o_view[0] = offset  # empty cluster
 
     n = 1
-    for tensor_indices, interaction_tensors, indices in orbit_list:
+    for tensor_indices, interaction_tensor, indices in orbit_list:
         I = indices.shape[0] # cluster index
         J = indices.shape[1] # index within cluster
         p = 0
         for i in range(I):
             index = 0
             for j in range(J):
                 index += tensor_indices[j] * occu[indices[i, j]]
-            p += interaction_tensors[index]
+            p += interaction_tensor[index]
         o_view[n] = p / I
         n += 1
 
     return out
 
 
 cpdef delta_interactions_single_flip(const long[::1] occu_f,
@@ -297,7 +243,114 @@
             ind_i, ind_f = 0, 0
             for j in range(J):
                 ind_i += tensor_indices[j] * occu_i[indices[i, j]]
                 ind_f += tensor_indices[j] * occu_f[indices[i, j]]
             p += (interaction_tensor[ind_f] - interaction_tensor[ind_i])
         o_view[n] = p / ratio / I
     return out
+
+
+cpdef interaction_distance_single_flip(const long[::1] occu_f,
+                                       const long[::1] occu_i,
+                                       const double[::1] ref_interaction_vector,
+                                       const int num_interactions,
+                                       list orbit_list):
+    """Computes the absolute distance of two cluster interaction vectors separated by a
+    single flip and a given correlation vector.
+
+    Unfortunately this scales just as bad as computing the full interaction vector.
+
+    Args:
+        occu_f (ndarray):
+            encoded occupancy array with flip
+        occu_i (ndarray):
+            encoded occupancy array without flip
+        ref_interaction_vector (ndarray):
+            reference cluster interaction vector
+        num_interactions (int):
+            total number of cluster interactions (orbits in cluster subspace).
+        site_orbit_list:
+            Information of all orbits that include the flip site.
+            List of tuples each with
+            (cluster ratio, flat tensor index array, flat cluster interaction tensor,
+             site indices of clusters)
+
+    Returns:
+        ndarray: 2D with cluster interaction vector distances from reference for each of
+        occu_i and occu_f
+    """
+    cdef int n, i, j, I, J, ind_i, ind_f
+    cdef double p_i, p_f
+    cdef const long[:, ::1] indices
+    cdef const long[::1] tensor_indices
+    cdef const double[::1] interaction_tensor
+    out = np.zeros((2, num_interactions))
+    cdef double[:, ::1] o_view = out
+    o_view[:, 0] = 0
+
+    n = 1
+    for tensor_indices, interaction_tensor, indices in orbit_list:
+        I = indices.shape[0] # cluster index
+        J = indices.shape[1] # index within cluster
+        p_f, p_i = 0, 0
+        for i in range(I):
+            ind_f, ind_i = 0, 0
+            for j in range(J):
+                ind_f += tensor_indices[j] * occu_f[indices[i, j]]
+                ind_i += tensor_indices[j] * occu_i[indices[i, j]]
+            p_f += interaction_tensor[ind_f]
+            p_i += interaction_tensor[ind_i]
+        o_view[1, n] = abs(p_f / I - ref_interaction_vector[n])
+        o_view[0, n] = abs(p_i / I - ref_interaction_vector[n])
+        n += 1
+    return out
+
+
+cpdef delta_ewald_single_flip(const long[::1] occu_f,
+                              const long[::1] occu_i,
+                              const double[:, ::1] ewald_matrix,
+                              const long[:, ::1] ewald_indices,
+                              const int site_ind):
+    """Compute the change in electrostatic interaction energy from a flip.
+
+    Args:
+        occu_f (ndarray):
+            encoded occupancy array with flip
+        occu_i (ndarray):
+            encoded occupancy array without flip
+        ewald_matrix (ndarray):
+            Ewald matrix for electrostatic interactions
+        ewald_indices (ndarray):
+            2D array of indices corresponding to a specific site occupation
+            in the ewald matrix
+        site_ind (int):
+            site index for site being flipped
+
+    Returns:
+        float: electrostatic interaction energy difference
+    """
+    cdef int i, j, k, add, sub
+    cdef bint ok
+    cdef double out = 0
+    cdef double out_k
+
+    # values of -1 are vacancies and hence don't have ewald indices
+    add = ewald_indices[site_ind, occu_f[site_ind]]
+    sub = ewald_indices[site_ind, occu_i[site_ind]]
+
+    for k in range(occu_f.shape[0]):
+        i = ewald_indices[k, occu_f[k]]
+        out_k = 0
+        if i != -1 and add != -1:
+            if i != add:
+                out_k = out_k + 2 * ewald_matrix[i, add]
+            else:
+                out_k = out_k + ewald_matrix[i, add]
+
+        j = ewald_indices[k, occu_i[k]]
+        if j != -1 and sub != -1:
+            if j != sub:
+                out_k = out_k - 2 * ewald_matrix[j, sub]
+            else:
+                out_k = out_k - ewald_matrix[j, sub]
+        out += out_k
+    return out
```

### Comparing `smol-0.3.1/smol/exceptions.py` & `smol-0.4.0/smol/utils/exceptions.py`

 * *Files identical despite different names*

### Comparing `smol-0.3.1/smol/io.py` & `smol-0.4.0/smol/io.py`

 * *Files identical despite different names*

### Comparing `smol-0.3.1/smol/moca/__init__.py` & `smol-0.4.0/smol/moca/__init__.py`

 * *Files identical despite different names*

### Comparing `smol-0.3.1/smol/moca/composition.py` & `smol-0.4.0/smol/moca/composition.py`

 * *Files 1% similar despite different names*

```diff
@@ -6,26 +6,26 @@
 from itertools import chain
 
 import numpy as np
 from monty.json import MontyDecoder, MSONable
 from pymatgen.core import Composition, Element
 
 from smol.cofe.space.domain import Vacancy
-from smol.moca.utils.math import (
+from smol.moca.occu_utils import get_dim_ids_by_sublattice
+from smol.utils.math import (
     NUM_TOL,
     get_ergodic_vectors,
     get_natural_centroid,
     get_natural_solutions,
     get_nonneg_float_vertices,
     get_optimal_basis,
     integerize_multiple,
     integerize_vector,
     solve_diophantines,
 )
-from smol.moca.utils.occu import get_dim_ids_by_sublattice
 
 
 def get_oxi_state(sp):
     """Oxidation state from Specie/Element/Vacancy.
 
     Args:
        sp(Specie/Vacancy/Element):
```

### Comparing `smol-0.3.1/smol/moca/ensemble.py` & `smol-0.4.0/smol/moca/ensemble.py`

 * *Files 1% similar despite different names*

```diff
@@ -236,18 +236,17 @@
     def active_sublattices(self):
         """Get list of active sub-lattices."""
         return [s for s in self.sublattices if s.is_active]
 
     @property
     def restricted_sites(self):
         """Get indices of all restricted sites."""
-        sites = []
-        for sublattice in self.sublattices:
-            sites += sublattice.restricted_sites
-        return sites
+        return np.concatenate(
+            [sublattice.restricted_sites for sublattice in self.sublattices]
+        )
 
     @property
     def species(self):
         """Species on active sublattices.
 
         These are minimal species required in setting chemical potentials.
         """
```

### Comparing `smol-0.3.1/smol/moca/processor/__init__.py` & `smol-0.4.0/smol/moca/processor/__init__.py`

 * *Files identical despite different names*

### Comparing `smol-0.3.1/smol/moca/processor/base.py` & `smol-0.4.0/smol/moca/processor/base.py`

 * *Files 7% similar despite different names*

```diff
@@ -16,15 +16,15 @@
 
 import numpy as np
 from monty.json import MSONable
 from pymatgen.core import PeriodicSite, Structure
 
 from smol.cofe.space import Vacancy, get_allowed_species, get_site_spaces
 from smol.moca.sublattice import Sublattice
-from smol.utils import get_subclasses
+from smol.utils.class_utils import get_subclasses
 
 
 class Processor(MSONable, metaclass=ABCMeta):
     """Abstract base class for processors.
 
     A processor is used to provide a quick way to calculated energy differences
     (probability ratio's) between two configurational states for a fixed system
@@ -35,15 +35,15 @@
             Tuple of all the distinct site spaces.
         allowed_species (list):
             A list of tuples of the allowed species at each site.
         size (int):
             Number of prims in the supercell structure.
     """
 
-    def __init__(self, cluster_subspace, supercell_matrix, coefficients):
+    def __init__(self, cluster_subspace, supercell_matrix, coefficients, **kwargs):
         """Initialize a BaseProcessor.
 
         Args:
             cluster_subspace (ClusterSubspace):
                 a cluster subspace
             supercell_matrix (ndarray):
                 an array representing the supercell matrix with respect to the
@@ -58,15 +58,15 @@
 
         self.coefs = np.array(coefficients)
         # if scalar force array to have 1 dimension (1,)
         if len(self.coefs.shape) == 0:
             self.coefs = self.coefs[np.newaxis]
 
         # this can be used (maybe should) to check if a flip is valid
-        site_spaces = set(get_site_spaces(self.structure))
+        site_spaces = set(get_site_spaces(self.structure, include_measure=True))
         self.unique_site_spaces = tuple(sorted(site_spaces))
         # Sort to ensure a fixed ordering between sub-lattices.
         self.active_site_spaces = tuple(
             space for space in self.unique_site_spaces if len(space) > 1
         )
 
         self.allowed_species = get_allowed_species(self.structure)
@@ -124,14 +124,38 @@
                 for the new species to place at that site.
 
         Returns:
             array: change in correlation vector
         """
         return
 
+    def compute_feature_vector_distance_change(self, feature_vector, occupancy, flips):
+        """
+        Compute the change of feature vector differences from a fixed vector from a list of flips.
+
+        The distance used implicitly is a "Manhattan distancc", ie absolute value of differences.
+
+        Args:
+            feature_vector (ndarray):
+                fixed vector to compute absolute distance differences from.
+            occupancy (ndarray):
+                encoded occupancy array
+            flips (list of tuple):
+                list of tuples with two elements. Each tuple represents a
+                single flip where the first element is the index of the site
+                in the occupancy array and the second element is the index
+                for the new species to place at that site.
+
+        Returns:
+            array: change in correlation vector
+        """
+        raise NotImplementedError(
+            "This processor can not be currently used to compute feature vector distances."
+        )
+
     def compute_property(self, occupancy):
         """Compute the value of the property for the given occupancy array.
 
         Args:
             occupancy (ndarray):
                 encoded occupancy array
         Returns:
@@ -187,15 +211,14 @@
             if spec != Vacancy():
                 site = PeriodicSite(spec, site.frac_coords, self.structure.lattice)
                 sites.append(site)
         return Structure.from_sites(sites)
 
     def encode_occupancy(self, occupancy):
         """Encode occupancy string of Species object to ints."""
-        # TODO check if setting to intc improves speed
         return np.array(
             [
                 species.index(spec)
                 for species, spec in zip(self.allowed_species, occupancy)
             ],
             dtype=int,
         )
```

### Comparing `smol-0.3.1/smol/moca/processor/composite.py` & `smol-0.4.0/smol/moca/processor/composite.py`

 * *Files 2% similar despite different names*

```diff
@@ -122,15 +122,14 @@
 
         Returns:
             array: correlation vector
         """
         features = [
             np.array(pr.compute_feature_vector(occupancy)) for pr in self._processors
         ]
-        # TODO you may be able to cut some speed by pre-allocating this
         return np.append(features[0], features[1:])
 
     def compute_feature_vector_change(self, occupancy, flips):
         """
         Compute the change in the feature vector from a list of flips.
 
         Args:
```

### Comparing `smol-0.3.1/smol/moca/processor/ewald.py` & `smol-0.4.0/smol/moca/processor/ewald.py`

 * *Files 2% similar despite different names*

```diff
@@ -15,16 +15,16 @@
 from functools import cached_property, lru_cache
 
 import numpy as np
 from pymatgen.analysis.ewald import EwaldSummation
 
 from smol.cofe.extern.ewald import EwaldTerm
 from smol.cofe.space.clusterspace import ClusterSubspace
-from smol.correlations import delta_ewald_single_flip
 from smol.moca.processor.base import Processor
+from smol.utils.cluster.ewald import delta_ewald_single_flip
 
 
 class EwaldProcessor(Processor):
     """Processor for CE's including an EwaldTerm.
 
     A Processor class that handles changes for the electrostatic interaction
     energy using an Ewald Summation term.
```

### Comparing `smol-0.3.1/smol/moca/sampler/bias.py` & `smol-0.4.0/smol/moca/kernel/bias.py`

 * *Files 4% similar despite different names*

```diff
@@ -10,17 +10,17 @@
 from collections import Counter
 from math import log
 
 import numpy as np
 
 from smol.cofe.space.domain import get_species
 from smol.moca.composition import get_oxi_state
-from smol.moca.sampler.namespace import Metadata
-from smol.moca.utils.occu import get_dim_ids_table, occu_to_counts
-from smol.utils import class_name_from_str, derived_class_factory
+from smol.moca.metadata import Metadata
+from smol.moca.occu_utils import get_dim_ids_table, occu_to_counts
+from smol.utils.class_utils import class_name_from_str, derived_class_factory
 
 
 class MCBias(ABC):
     """Base bias term class.
 
     Note: Any MCBias should be implemented as beta * E - bias
     will be minimized in thermodynamics kernel.
@@ -67,31 +67,29 @@
             occupancy(np.ndarray):
                 encoded occupancy string.
         Returns:
             Float, bias value.
         """
         return
 
-    @abstractmethod
     def compute_bias_change(self, occupancy, step):
         """Compute bias change from step.
 
-        The returned value needs to be the difference of bias logs,
-        log(bias_f) - log(bias_i), when the bias terms would directly multiply
-        the ensemble probability (i.e. exp(-beta * E) * bias).
-
         Args:
             occupancy: (ndarray):
                 encoded occupancy array.
             step: (List[tuple(int,int)]):
                 step returned by MCUsher.
         Return:
             Float, change of bias value after step.
         """
-        return
+        occu_next = occupancy.copy()
+        for site, code in step:
+            occu_next[site] = code
+        return self.compute_bias(occu_next) - self.compute_bias(occupancy)
 
 
 class FugacityBias(MCBias):
     """Fugacity fraction bias.
 
     This bias corresponds directly to using a composition bias. Using this
     with a CanonicalEnsemble keeps fugacity fractions constant, which
@@ -180,15 +178,15 @@
         Args:
             occupancy(np.ndarray):
                 Encoded occupancy string.
         Returns:
             Float, bias value.
         """
         return sum(
-            log(self._fu_table[site][species]) for site, species in enumerate(occupancy)
+            log(self._fu_table[site, species]) for site, species in enumerate(occupancy)
         )
 
     def compute_bias_change(self, occupancy, step):
         """Compute bias change from step.
 
         The returned value needs to be the difference of bias logs,
         log(bias_f) - log(bias_i), when the bias terms would directly multiply
@@ -198,18 +196,20 @@
             occupancy: (ndarray):
                 encoded occupancy array.
             step: (List[tuple(int,int)]):
                 step returned by MCUsher.
         Return:
             float, change of bias value after step.
         """
+        # if a site is flipped twice in a step only use the last flip
+        steps = {site: code for site, code in step}
         delta_log_fu = sum(
-            log(self._fu_table[f[0]][f[1]] / self._fu_table[f[0]][occupancy[f[0]]])
-            for f in step
-        )  # Can be wrong if step has two same sites.
+            log(self._fu_table[site, code] / self._fu_table[site, occupancy[site]])
+            for site, code in steps.items()
+        )
         return delta_log_fu
 
     def _build_fu_table(self, fugacity_fractions):
         """Build an array for fugacity fractions for all sites in system.
 
         Rows represent sites and columns species. This allows quick evaluation
         of fugacity fraction changes from flips. Not that the total number
@@ -277,30 +277,14 @@
         Returns:
             Float, bias value.
         """
         c = np.sum(self._c_table[np.arange(len(occupancy), dtype=int), occupancy])
         # Returns a negative value because of the implementation in mckernels.
         return -self.penalty * c**2
 
-    def compute_bias_change(self, occupancy, step):
-        """Compute bias change from step.
-
-        Args:
-            occupancy: (ndarray):
-                Encoded occupancy array.
-            step: (List[tuple(int,int)]):
-                Step returned by MCUsher.
-        Return:
-            Float, change of bias value after step.
-        """
-        occu_next = occupancy.copy()
-        for site, code in step:
-            occu_next[site] = code
-        return self.compute_bias(occu_next) - self.compute_bias(occupancy)
-
 
 class SquareHyperplaneBias(MCBias):
     """Square hyperplane bias.
 
     This bias penalizes energy on sum square of distance from a composition n
     ("counts" format) to hyperplanes A n = b (in the unconstrained composition space,
     see CompositionSpace document). In other words, this bias penalizes the
@@ -358,30 +342,14 @@
                 Encoded occupancy string.
         Returns:
             Float, bias value.
         """
         n = occu_to_counts(occupancy, self.d, self._dim_ids_table)
         return -self.penalty * np.sum((self._A @ n - self._b) ** 2)
 
-    def compute_bias_change(self, occupancy, step):
-        """Compute bias change from step.
-
-        Args:
-            occupancy: (ndarray):
-                Encoded occupancy array.
-            step: (List[tuple(int,int)]):
-                Step returned by MCUsher.
-        Return:
-            Float, change of bias value after step.
-        """
-        occu_next = occupancy.copy()
-        for site, code in step:
-            occu_next[site] = code
-        return self.compute_bias(occu_next) - self.compute_bias(occupancy)
-
 
 def mcbias_factory(bias_type, sublattices, *args, **kwargs):
     """Get a MCMC bias from string name.
 
     Args:
         bias_type (str):
             string specifying bias name to instantiate.
```

### Comparing `smol-0.3.1/smol/moca/sampler/container.py` & `smol-0.4.0/smol/moca/sampler/container.py`

 * *Files 1% similar despite different names*

```diff
@@ -13,16 +13,17 @@
 from collections import defaultdict
 
 import numpy as np
 from monty.dev import requires
 from monty.json import MontyDecoder, MontyEncoder, MSONable, jsanitize
 
 from smol.moca import Ensemble
-from smol.moca.sampler.namespace import Metadata, Trace
+from smol.moca.metadata import Metadata
 from smol.moca.sublattice import Sublattice
+from smol.moca.trace import Trace
 
 try:
     import h5py
 except ImportError:
     h5py = None
 
 
@@ -403,14 +404,19 @@
 
     def allocate(self, nsamples):
         """Allocate more space in arrays for more samples."""
         for name, value in self._trace.items():
             arr = np.empty((nsamples, *value.shape[1:]), dtype=value.dtype)
             setattr(self._trace, name, np.append(value, arr, axis=0))
 
+    def vacuum(self):
+        """Remove any trailing allocated space that has not been used."""
+        for name, value in self._trace.items():
+            setattr(self._trace, name, value[: self._nsamples])
+
     def flush_to_backend(self, backend):
         """Flush current samples and trace to backend file.
 
         Args:
             backend (object):
                 backend file object, currently only hdf5 supported.
         """
```

### Comparing `smol-0.3.1/smol/moca/sampler/mcusher.py` & `smol-0.4.0/smol/moca/kernel/mcusher.py`

 * *Files 0% similar despite different names*

```diff
@@ -14,28 +14,24 @@
 from abc import ABC, abstractmethod
 
 import numpy as np
 from monty.json import jsanitize
 from scipy.special import gammaln
 
 from smol.moca.composition import CompositionSpace
-from smol.moca.sampler.namespace import Metadata
-from smol.moca.utils.math import (
-    NUM_TOL,
-    choose_section_from_partition,
-    flip_weights_mask,
-)
-from smol.moca.utils.occu import (
+from smol.moca.metadata import Metadata
+from smol.moca.occu_utils import (
     delta_counts_from_step,
     get_dim_ids_by_sublattice,
     get_dim_ids_table,
     occu_to_counts,
     occu_to_species_list,
 )
-from smol.utils import class_name_from_str, derived_class_factory
+from smol.utils.class_utils import class_name_from_str, derived_class_factory
+from smol.utils.math import NUM_TOL, choose_section_from_partition, flip_weights_mask
 
 
 class MCUsher(ABC):
     """Abstract base class for MC usher classes."""
 
     def __init__(self, sublattices, sublattice_probabilities=None, rng=None):
         """Initialize MCMCStep.
@@ -129,21 +125,21 @@
                 encoded occupancy string
             step (list[tuple]):
                 Metropolis step. list of tuples each with (index, code).
 
         Returns:
             float: log of a-priori adjustment weight.
         """
-        return 0
+        return 0.0
 
     def update_aux_state(self, step, *args, **kwargs):
         """Update any auxiliary state information based on an accepted step."""
         return
 
-    def set_aux_state(self, occupancies, *args, **kwargs):
+    def set_aux_state(self, occupancy, *args, **kwargs):
         """Set the auxiliary occupancies from a checkpoint values."""
         return
 
     def get_random_sublattice(self):
         """Return a random sublattice based on given probabilities."""
         return self._rng.choice(self.active_sublattices, p=self._sublatt_probs)
```

### Comparing `smol-0.3.1/smol/moca/sampler/sampler.py` & `smol-0.4.0/smol/moca/sampler/sampler.py`

 * *Files 6% similar despite different names*

```diff
@@ -8,18 +8,19 @@
 
 import os
 from datetime import datetime
 from warnings import warn
 
 import numpy as np
 
+from smol.moca.kernel import mckernel_factory
+from smol.moca.kernel.base import MulticellKernel
 from smol.moca.sampler.container import SampleContainer
-from smol.moca.sampler.kernel import mckernel_factory
-from smol.moca.sampler.namespace import Trace
-from smol.utils import progress_bar
+from smol.moca.trace import Trace
+from smol.utils.progressbar import progress_bar
 
 
 class Sampler:
     """
     A sampler is used to run MCMC sampling simulations.
 
     The specific MCMC algorithm is defined by the given MCKernel.
@@ -154,19 +155,14 @@
         """Get the efficiency of MCMC sampling (accepted/total)."""
         return self.samples.sampling_efficiency(discard=discard, flat=flat)
 
     def clear_samples(self):
         """Clear samples from sampler container."""
         self.samples.clear()
 
-    def _single_step(self, occupancies):
-        """Do a single step for all kernels."""
-        for kernel, occupancy in zip(self._kernels, occupancies):
-            yield kernel.single_step(occupancy)
-
     def sample(self, nsteps, initial_occupancies, thin_by=1, progress=False):
         """Generate MCMC samples.
 
         Yield a sampler state every `thin_by` iterations. A state is give by
         a tuple of (occupancies, features, enthalpy)
 
         Args:
@@ -178,43 +174,29 @@
                 number to thin iterations by and provide samples.
             progress (bool):
                 If true will show a progress bar.
 
         Yields:
             tuple: accepted, occupancies, features change, enthalpies change
         """
-        occupancies = initial_occupancies.copy()
-        if occupancies.shape != self.samples.shape:
-            occupancies = self._reshape_occu(occupancies)
         if nsteps % thin_by != 0:
             warn(
                 f"The number of steps {nsteps} is not a multiple of thin_by "
                 f" {thin_by}. The last {nsteps % thin_by} will be ignored.",
                 category=RuntimeWarning,
             )
-        # TODO check that initial states are independent if num_walkers > 1
-        # TODO make samplers with single chain, multiple and multiprocess
-        # TODO kernel should take only 1 occupancy
-        # set up any auxiliary states from initial occupancies
-        for kernel, occupancy in zip(self._kernels, occupancies):
-            kernel.set_aux_state(occupancy)
-
-        # get initial traces and stack them
-        trace = Trace()
-        traces = list(map(self._kernels[0].compute_initial_trace, occupancies))
-        for name in traces[0].names:
-            stack = np.stack([getattr(tr, name) for tr in traces], axis=0)
-            setattr(trace, name, stack)
 
+        occupancies, trace = self.setup_sample(initial_occupancies)
         # Initialise progress bar
         chains, nsites = self.samples.shape
-        desc = f"Sampling {chains} chain(s) from a cell with {nsites} sites..."
+        desc = f"Sampling {chains} chain(s) from a cell with {nsites} sites"
         with progress_bar(progress, total=nsteps, description=desc) as p_bar:
             for _ in range(nsteps // thin_by):
                 for _ in range(thin_by):
+                    # the occupancies are modified in place at each step
                     for i, strace in enumerate(self._single_step(occupancies)):
                         for name, value in strace.items():
                             val = getattr(trace, name)
                             val[i] = value
                             # this will mess up recording values for > 1 walkers
                             # setattr(trace, name, value)
                         if strace.accepted:
@@ -267,29 +249,26 @@
                 if true allows to read file from other processes. Single Writer
                 Multiple Readers.
         """
         if initial_occupancies is None:
             try:
                 initial_occupancies = self.samples.get_occupancies(flat=False)[-1]
                 # auxiliary states from kernels should be set here
-            except IndexError as ind_error:
+            except IndexError as index_error:
                 raise RuntimeError(
                     "There are no saved samples to obtain the initial occupancies."
                     "These must be provided."
-                ) from ind_error
+                ) from index_error
         elif self.samples.num_samples > 0:
             warn(
                 "Initial occupancies where provided with a pre-existing set of samples."
                 "\n Make real sure that is what you want. "
                 "If not, reset the samples in the sampler.",
                 RuntimeWarning,
             )
-        else:
-            if initial_occupancies.shape != self.samples.shape:
-                initial_occupancies = self._reshape_occu(initial_occupancies)
 
         if stream_chunk > 0:
             if stream_file is None:
                 now = datetime.now()
                 file_name = "moca-samples-" + now.strftime("%Y-%m-%d-%H%M%S%f")
                 stream_file = os.path.join(os.getcwd(), file_name + ".h5")
             backend = self.samples.get_backend(
@@ -363,17 +342,17 @@
             swmr_mode (bool): optional
                 if true allows to read file from other processes. Single Writer
                 Multiple Readers.
         """
         if temperatures[0] < temperatures[-1]:
             raise ValueError(
                 "End temperature is greater than start "
-                f"temperature {temperatures[-1]:.2f} > "
-                f"{temperatures[0]:.2f}."
+                f"temperature {temperatures[-1]:.2f} > {temperatures[0]:.2f}."
             )
+
         # initialize for first temperature.
         for kernel in self._kernels:
             kernel.temperature = temperatures[0]
         self.run(
             mcmc_steps,
             initial_occupancies=initial_occupancies,
             thin_by=thin_by,
@@ -396,23 +375,77 @@
                 keep_last_chunk=True,
             )
 
         # If streaming to file was done then clear samplers now.
         if stream_chunk > 0:
             self.clear_samples()
 
+    def setup_sample(self, initial_occupancies):
+        """Copy and reshape occupancies and compute initial trace for sampling.
+
+        Args:
+            initial_occupancies (ndarray):
+                initial occupancies for sampling.
+
+        Returns: (occupancies, trace)
+            occupancies (ndarray):
+                initial occupancies for sampling.
+            trace (Trace):
+                initial trace for sampling.
+        """
+        # TODO check that initial states are independent if num_walkers > 1
+        # TODO make samplers with single chain, multiple and multiprocess
+        occupancies = initial_occupancies.copy()
+        if occupancies.shape != self.samples.shape:
+            occupancies = self._reshape_occu(occupancies)
+
+        # set up any auxiliary states from initial occupancies
+        selected_occus = []
+        for kernel, occupancy in zip(self._kernels, occupancies):
+            kernel.set_aux_state(occupancy)
+            # select the current kernel occu
+            if isinstance(kernel, MulticellKernel):
+                if occupancies.ndim == 3 and occupancies.shape[1] == len(
+                    kernel.mckernels
+                ):
+                    selected_occus.append(occupancy[kernel.trace.kernel_index])
+        if len(selected_occus) > 0:
+            occupancies = np.vstack(selected_occus)
+
+        # get initial traces and stack them
+        trace = Trace()
+        traces = list(
+            map(
+                lambda kernel, occu: kernel.compute_initial_trace(occu),
+                self._kernels,
+                occupancies,
+            )
+        )
+        for name in traces[0].names:
+            stack = np.stack([getattr(tr, name) for tr in traces], axis=0)
+            setattr(trace, name, stack)
+
+        return occupancies, trace
+
+    def _single_step(self, occupancies):
+        """Do a single step for all kernels."""
+        for kernel, occupancy in zip(self._kernels, occupancies):
+            yield kernel.single_step(occupancy)
+
     def _reshape_occu(self, occupancies):
         """Reshape occupancies for the single walker case."""
         # check if this is only a single walker.
         if len(occupancies.shape) == 1 and self.samples.shape[0] == 1:
             occupancies = np.reshape(occupancies, (1, len(occupancies)))
+        elif any(isinstance(kernel, MulticellKernel) for kernel in self._kernels):
+            # reshape for multicell kernels
+            occupancies = np.reshape(occupancies, (1, *occupancies.shape))
         else:
             raise AttributeError(
-                "The given initial occcupancies have "
-                "incompompatible dimensions. Shape should"
+                "The given initial occcupancies have incompompatible dimensions. Shape should"
                 f" be {self.samples.shape}."
             )
         return occupancies
 
 
 # TODO potential define two _sample functions serial/parallel that get called
 #  in one sampler function.
```

### Comparing `smol-0.3.1/smol/moca/sublattice.py` & `smol-0.4.0/smol/moca/sublattice.py`

 * *Files 1% similar despite different names*

```diff
@@ -74,14 +74,19 @@
 
     @property
     def species(self):
         """Get allowed species for sites in sublattice."""
         return tuple(self.site_space.keys())
 
     @property
+    def composition(self):
+        """Get composition of sublattice."""
+        return self.site_space.composition
+
+    @property
     def restricted_sites(self):
         """Get restricted sites for species."""
         return np.setdiff1d(self.sites, self.active_sites)
 
     def restrict_sites(self, sites):
         """Restricts (freezes) the given sites.
```

### Comparing `smol-0.3.1/smol/moca/utils/math.py` & `smol-0.4.0/smol/utils/math.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,16 +1,16 @@
 """Mathematic utilities.
 
 Including linear algebra, combinatorics and integer enumerations.
 """
 
-__author___ = "Fengyu Xie"
+__author___ = "Fengyu Xie, Luis Barroso-Luque"
 
 from fractions import Fraction
-from itertools import combinations
+from itertools import combinations, product
 
 import numpy as np
 from monty.dev import requires
 from scipy.linalg import null_space
 from scipy.spatial import KDTree
 
 try:
@@ -24,14 +24,32 @@
     cp = None
 
 
 # Global numerical tolerance in this module.
 NUM_TOL = 1e-6
 
 
+def yield_hermite_normal_forms(determinant):
+    """Yield all hermite normal form matrices with given determinant.
+
+    Args:
+        determinant (int):
+            determinant of hermite normal forms to be yielded
+
+    Yields:
+        ndarray: hermite normal form matrix with given determinant
+    """
+    for a in filter(lambda x: determinant % x == 0, range(1, determinant + 1)):
+        quotient = determinant // a
+        for c in filter(lambda x: quotient % x == 0, range(1, determinant // a + 1)):
+            f = quotient // c
+            for b, d, e in product(range(0, c), range(0, f), range(0, f)):
+                yield np.array([[a, 0, 0], [b, c, 0], [d, e, f]], dtype=int)
+
+
 def gcdex(a, b):
     """Extend Euclidean Algorithm."""
     if a == 0:
         return 0, 1, b
 
     x1, y1, g = gcdex(b % a, a)
     x = y1 - (b // a) * x1
@@ -221,34 +239,31 @@
     t = np.array(t).astype(int)
     return s, m, t
 
 
 def solve_diophantines(A, b=None):
     """Solve diophantine equations An=b.
 
-    We use Smith normal form to solve equations.
-    If equation is not solvable, we will throw an
-    error.
-    Note: If A decomposes to snf with large matrix
-    elements, the numerical accuracy might have an
-    issue! When this is the case, even if An=b has
-    an integer solution, our function is not
-    guaranteed to find it! But for most application
-    uses, the numerical accuracy here should be enough.
+    We use Smith normal form to solve equations. If equation is not solvable, we will
+    throw an error.
+
+    Note: If A decomposes to snf with large matrix elements, the numerical accuracy
+    might have an issue! When this is the case, even if An=b has an integer solution,
+    our function is not guaranteed to find it! But for most application uses, the
+    numerical accuracy here should be enough.
 
     Args:
-        A(2D ArrayLike[int]):
+        A (2D ArrayLike[int]):
             Matrix A in An=b.
-        b(1D ArrayLike[int], default=None):
+        b (1D ArrayLike[int], default=None):
             Vector b in An=b.
             If not given, will set to zeros.
 
-    Return:
+    Return: (1D np.ndarray[int], 2D np.ndarray[int]
         A base solution and base vectors (as rows):
-        1D np.ndarray[int], 2D np.ndarray[int]
     """
     A = np.array(A, dtype=int)
     n, d = A.shape
     b = np.array(b, dtype=int) if b is not None else np.zeros(d, dtype=int)
     # If you choose b=0, the equations may not have
     # any natural number solution!
 
@@ -286,17 +301,17 @@
     This result can be used to get the minimum
     supercell size by looking for the minimum
     integer than can integerize all these vertices,
     if b is written according to number of sites in
     a primitive cell.
 
     Args:
-        A(2D np.ndarray):
+        A (2D np.ndarray):
             A in An=b.
-        b(2D np.ndarray):
+        b (2D np.ndarray):
             b in An=b.
     Returns:
         Vertices of polytope An=b, n>=0 in float:
             np.ndarray[float]
     """
     A = np.array(A)
     b = np.array(b)
@@ -331,28 +346,27 @@
     s.t. n0 + sum_s x_s * v_s >= 0
     Where centroid is the center of the polytope
     bounded by those constraints.
 
     Note: Need cvxopt and cvxpy!
 
     Args:
-        n0(1D ArrayLike[int]):
+        n0 (1D ArrayLike[int]):
             An origin point of integer lattice.
-        vs(2D ArrayLike[int]):
+        vs (2D ArrayLike[int]):
             Basis vectors of integer lattice.
-        sc_size(int):
+        sc_size (int):
             Super-cell size with n0 as a base solution.
-        a_leq(2D ArrayLike[int]), b_leq(1D ArrayLike[float]):
+        a_leq (2D ArrayLike[int]), b_leq(1D ArrayLike[float]):
             Constraint A @ n <= b. Unit is per prim.
-        a_geq(2D ArrayLike[int]), b_geq(1D ArrayLike[float]):
+        a_geq (2D ArrayLike[int]), b_geq(1D ArrayLike[float]):
             Constraint A @ n >= b. Unit is per prim.
 
-    Returns:
+    Returns: 1D np.ndarray[int]
         The natural number point on the grid closest to centroid ("x"):
-            1D np.ndarray[int]
     """
     n0 = np.array(n0, dtype=int)
     vs = np.array(vs, dtype=int)
     n, d = vs.shape
     assert len(n0) == d
     poly = pc.Polytope(-vs.transpose(), n0)
     centroid = np.average(pc.extreme(poly), axis=0)
@@ -380,25 +394,25 @@
 
 def get_one_dim_solutions(n0, v, integer_tol=NUM_TOL, step=1):
     """Solve one dimensional integer inequalities.
 
     This will solve n0 + v * x >= 0, give all
     integer solutions. x should be a single int.
     Args:
-        n0(1D np.ndarray[int]):
+        n0 (1D ArrayLinke[int]:
             1 dimensional constraining factors
-        v(1D np.ndarray[int]):
+        v (1D ArrayLinke[int]:
             1 dimensional constraining factors
-        integer_tol(float): optional
+        integer_tol (float): optional
             Tolerance of a number off integer
             value. If (number - round(number))
             <= integer_tol, it will be considered
             as an integer. Default is set by global
             NUM_TOL.
-        step(int): optional
+        step (int): optional
             Step to skip when yielding solutions. For example,
             when step=2, will yield every 2 solutions.
             Default is 1, yield every solution.
     Returns:
         All Integer solutions:
             1D np.ndarray[int]
     """
```

### Comparing `smol-0.3.1/smol/moca/utils/occu.py` & `smol-0.4.0/smol/moca/occu_utils.py`

 * *Files identical despite different names*

### Comparing `smol-0.3.1/smol/utils.py` & `smol-0.4.0/smol/utils/class_utils.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,14 +1,13 @@
 """A few general utilities functions."""
 
 __author__ = "Luis Barroso-Luque"
 
 import inspect
 import re
-import warnings
 from typing import Any, Dict
 
 
 def class_name_from_str(class_str):
     """Return a class name based on given string.
 
     Assumes all class names are properly named with Camel Caps.
@@ -65,69 +64,13 @@
     """Get all non-abstract subclasses of a class.
 
     Gets all non-abstract classes that inherit from the given base class in
     a module.
     """
     sub_classes = {}
     for sub_class in base_class.__subclasses__():
-        if inspect.isabstract(sub_class):
-            sub_classes.update(get_subclasses(sub_class))
-        else:
-            sub_classes[sub_class.__name__] = sub_class
-    return sub_classes
-
-
-def progress_bar(display, total, description):
-    """Get a tqdm progress bar interface.
-
-    If the tqdm library is not installed, this will be an empty progress bar
-    that does nothing.
-
-    Args:
-        display (bool):
-            if true, a real progress bar will be returned.
-        total (int):
-            the total size of the progress bar.
-        description (str):
-            description to print in progress bar.
-    """
-    try:
-        # pylint: disable=import-outside-toplevel
-        import tqdm
-    except ImportError:
-        tqdm = None
-
-    if display:
-        if tqdm is None:
-            warnings.warn(
-                "tqdm library needs to be installed to show a " " progress bar."
-            )
-            return _EmptyBar()
-
-        return tqdm.tqdm(total=total, desc=description)
-        # if display is True:
-        #   return tqdm.tqdm(total=total, desc=description)
-        # else:
-        #    return getattr(tqdm, "tqdm_" + display)(total=total)
-    return _EmptyBar()
+        sub_classes.update(get_subclasses(sub_class))
 
+        if not inspect.isabstract(sub_class):
+            sub_classes[sub_class.__name__] = sub_class
 
-class _EmptyBar:
-    """A dummy progress bar.
-
-    Idea take from emce:
-    https://github.com/dfm/emcee/blob/main/src/emcee/pbar.py
-    """
-
-    # pylint: disable=missing-function-docstring
-
-    def __init__(self):
-        pass
-
-    def __enter__(self, *args, **kwargs):
-        return self
-
-    def __exit__(self, *args, **kwargs):
-        pass
-
-    def update(self, *args):
-        pass
+    return sub_classes
```

### Comparing `smol-0.3.1/smol.egg-info/PKG-INFO` & `smol-0.4.0/smol.egg-info/PKG-INFO`

 * *Files 23% similar despite different names*

```diff
@@ -1,38 +1,81 @@
 Metadata-Version: 2.1
 Name: smol
-Version: 0.3.1
+Version: 0.4.0
 Summary: Lighthweight but caffeinated Python implementation of computational methods for statistical mechanical calculations of configurational states in crystalline material systems.
-Home-page: https://cedergrouphub.github.io/smol
-Author: Luis Barroso-Luque
-Author-email: lbluque@berkeley.edu
-Maintainer: Luis Barroso-Luque
-Maintainer-email: lbluque@berkeley.edu
-License: Modified BSD
-Project-URL: Documentation, https://cedergrouphub.github.io/smol
-Project-URL: Code, https://github.com/CederGroupHub/smol
-Project-URL: Issue tracker, https://github.com/CederGroupHub/smol/issues
+Author-email: Luis Barroso-Luque <lbluque@berkeley.edu>, Fengyu Xie <lbluque@berkeley.edu>
+Maintainer-email: Luis Barroso-Luque <lbluque@berkeley.edu>
+License: ::
+        
+            Statistical Mechanics on Lattices (smol) Copyright (c) 2022, The Regents
+            of the University of California, through Lawrence Berkeley National
+            Laboratory (subject to receipt of any required approvals from the U.S.
+            Dept. of Energy) and the University of California, Berkeley. All rights reserved.
+        
+            Redistribution and use in source and binary forms, with or without
+            modification, are permitted provided that the following conditions are met:
+        
+            (1) Redistributions of source code must retain the above copyright notice,
+            this list of conditions and the following disclaimer.
+        
+            (2) Redistributions in binary form must reproduce the above copyright
+            notice, this list of conditions and the following disclaimer in the
+            documentation and/or other materials provided with the distribution.
+        
+            (3) Neither the name of the University of California, Lawrence Berkeley
+            National Laboratory, U.S. Dept. of Energy, University of California,
+            Berkeley nor the names of its contributors may be used to endorse or
+            promote products derived from this software without specific prior written
+            permission.
+        
+        
+            THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+            AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+            IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+            ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+            LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+            CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+            SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+            INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+            CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+            ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+            POSSIBILITY OF SUCH DAMAGE.
+        
+            You are under no obligation whatsoever to provide any bug fixes, patches,
+            or upgrades to the features, functionality or performance of the source
+            code ("Enhancements") to anyone; however, if you choose to make your
+            Enhancements available either publicly, or directly to Lawrence Berkeley
+            National Laboratory, without imposing a separate written license agreement
+            for such Enhancements, then you hereby grant the following license: a
+            non-exclusive, royalty-free perpetual license to install, use, modify,
+            prepare derivative works, incorporate into other computer software,
+            distribute, and sublicense such enhancements or derivative works thereof,
+            in binary and source code form.
+        
+Project-URL: documentation, https://cedergrouphub.github.io/smol
+Project-URL: repository, https://github.com/CederGroupHub/smol
+Project-URL: changelog, https://cedergrouphub.github.io/smol/CHANGES.md
+Project-URL: tracker, https://github.com/CederGroupHub/smol/issues
 Classifier: Development Status :: 4 - Beta
 Classifier: Programming Language :: Python :: 3 :: Only
 Classifier: Programming Language :: Python :: 3.8
 Classifier: Programming Language :: Python :: 3.9
 Classifier: Programming Language :: Python :: 3.10
 Classifier: Intended Audience :: Science/Research
 Classifier: License :: OSI Approved :: BSD License
 Classifier: Operating System :: OS Independent
-Classifier: Topic :: Scientific/Engineering :: Information Analysis
 Classifier: Topic :: Scientific/Engineering :: Physics
 Classifier: Topic :: Scientific/Engineering :: Chemistry
 Classifier: Topic :: Software Development :: Libraries :: Python Modules
 Requires-Python: >=3.8
 Description-Content-Type: text/markdown
+Provides-Extra: optional
 Provides-Extra: docs
-Provides-Extra: tests
+Provides-Extra: test
 Provides-Extra: dev
-Provides-Extra: optional
 License-File: LICENSE
 
 <img src="docs/src/_static/logo.png" width="500px" alt=" ">
 
 Statistical Mechanics on Lattices
 =================================
 
@@ -54,41 +97,45 @@
 statistical mechanical and thermodynamic properties of crystalline
 material systems based on the *cluster expansion* method from alloy theory and
 related methods. Although **smol** is intentionally lightweight---in terms of
 dependencies and built-in functionality---it has a modular design that closely
 follows underlying mathematical formalism and provides useful abstractions to
 easily extend existing methods or implement and test new ones.
 
-
 Functionality
 -------------
 **smol** currently includes the following functionality:
 
-- Defining cluster expansion functions for a given disordered structure using a
-  variety of available site basis functions with and without explicit
-  redundancy.
-- Option to include explicit electrostatics in expansions using the Ewald
-  summation method.
-- Computing correlation vectors for a set of training structures with a variety
-  of functionality to inspect the resulting feature matrix.
-- Defining fitted cluster expansions for subsequent property prediction.
-- Fast evaluation of correlation vectors and differences in correlation vectors
-  from local updates in order to quickly compute properties and changes in
-  properties for specified supercell sizes.
-- Flexible toolset to sample cluster expansions using Monte Carlo with
-  canonical, semigrand canonical, and charge neutral semigrand canonical ensembles
-  using a Metropolis or a Wang-Landau sampler.
+-   Defining cluster expansion functions for a given disordered structure using a
+    variety of available site basis functions with and without explicit
+    redundancy.
+
+-   Option to include explicit electrostatics in expansions using the Ewald summation
+    method.
+-   Computing correlation vectors for a set of training structures with a variety
+    of functionality to inspect the resulting feature matrix.
+
+-   Defining fitted cluster expansions for subsequent property prediction.
+-   Fast evaluation of correlation vectors and differences in correlation vectors
+    from local updates in order to quickly compute properties and changes in
+    properties for specified supercell sizes.
+
+-   Flexible toolset to sample cluster expansions using Monte Carlo with
+    canonical, semigrand canonical, and charge neutral semigrand canonical ensembles
+    using a Metropolis or a Wang-Landau sampler.
+
+-   Special quasi-random structure generation based on either correlation vectors or
+    cluster interaction vectors.
 
 **smol** is built on top of [pymatgen](https://pymatgen.org) so any pre/post
 structure analysis can be done seamlessly using the various functionality
 supported there.
 
 Installation
 ------------
-
 From pypi:
 
     pip install smol
 
 From source:
 
 `Clone` the repository. The latest tag in the `main` branch is the stable version of the
@@ -106,44 +153,39 @@
     pip install smol
 
 You can also simply use the *environment.yml* file in the repository to install `smol`:
 
     conda env create -f environment.yml
     source activate smol-env
 
-
 Usage
 -----
 Refer to the [documentation](https://cedergrouphub.github.io/smol/) for details on using
 **smol**. Going through the [example notebooks](https://github.com/CederGroupHub/smol/tree/main/docs/src/notebooks)
 will also help you get started. You can run the example notebooks interactively in
 [binder](https://mybinder.org/v2/gh/CederGroupHub/smol/HEAD?labpath=docs%2Fsrc%2Fnotebooks%2Findex.ipynb).
 
-
 Citing
 ------
 If you use **smol** in your research, please give the repo a star :star: and refer to
 the [citing](https://cedergrouphub.github.io/smol/citing.html) page in the documentation
 for formal citation information.
 
-
 Contributing
 ------------
 We welcome all your contributions with open arms! Please fork and pull request any contributions.
 See the
 [developing](https://cedergrouphub.github.io/smol/developer_guide/index.html)
 page in the documentation for how to contribute.
 
-
 Changes
 -------
 The most recent changes are detailed in the
 [change log](https://github.com/CederGroupHub/smol/blob/master/CHANGES.md).
 
-
 Copyright Notice
 ----------------
     Statistical Mechanics on Lattices (smol) Copyright (c) 2022, The Regents
     of the University of California, through Lawrence Berkeley National
     Laboratory (subject to receipt of any required approvals from the U.S.
     Dept. of Energy) and the University of California, Berkeley. All rights reserved.
```

### Comparing `smol-0.3.1/smol.egg-info/SOURCES.txt` & `smol-0.4.0/smol.egg-info/SOURCES.txt`

 * *Files 13% similar despite different names*

```diff
@@ -1,17 +1,17 @@
 .coveragerc
 .gitignore
 .pre-commit-config.yaml
 CHANGES.md
 LICENSE
 README.md
 environment.yml
+pyproject.toml
 requirements-optional.txt
 requirements.txt
-setup.cfg
 setup.py
 .github/dependabot.yml
 .github/pull_request_template.md
 .github/ISSUE_TEMPLATE/bug_report.md
 .github/ISSUE_TEMPLATE/code_review.md
 .github/ISSUE_TEMPLATE/feature_request.md
 .github/workflows/build.yml
@@ -40,28 +40,29 @@
 docs/src/_static/require.js
 docs/src/_static/smol_cofe.svg
 docs/src/_static/smol_moca.svg
 docs/src/_static/smol_workflow.svg
 docs/src/_static/starting.svg
 docs/src/_static/user.svg
 docs/src/_static/css/smol.css
-docs/src/api_reference/constants.rst
-docs/src/api_reference/exceptions.rst
 docs/src/api_reference/index.rst
 docs/src/api_reference/io.rst
-docs/src/api_reference/utils.rst
 docs/src/api_reference/autogen/cofe.extern.rst
 docs/src/api_reference/autogen/cofe.rst
 docs/src/api_reference/autogen/cofe.space.rst
 docs/src/api_reference/autogen/cofe.wrangling.rst
-docs/src/api_reference/autogen/moca.ensemble.rst
 docs/src/api_reference/autogen/moca.processor.rst
 docs/src/api_reference/autogen/moca.rst
 docs/src/api_reference/autogen/moca.sampler.rst
 docs/src/api_reference/autogen/modules.rst
+docs/src/api_reference/capp/generate.enumerate.rst
+docs/src/api_reference/capp/generate.random.rst
+docs/src/api_reference/capp/generate.rst
+docs/src/api_reference/capp/generate.special.rst
+docs/src/api_reference/capp/index.rst
 docs/src/api_reference/cofe/clusterexpansion.rst
 docs/src/api_reference/cofe/clusterspace.rst
 docs/src/api_reference/cofe/extern.ewald.rst
 docs/src/api_reference/cofe/index.rst
 docs/src/api_reference/cofe/space.basis.rst
 docs/src/api_reference/cofe/space.cluster.rst
 docs/src/api_reference/cofe/space.constants.rst
@@ -70,15 +71,14 @@
 docs/src/api_reference/cofe/space.rst
 docs/src/api_reference/cofe/wrangling.rst
 docs/src/api_reference/cofe/wrangling.select.rst
 docs/src/api_reference/cofe/wrangling.sw.rst
 docs/src/api_reference/cofe/wrangling.tools.rst
 docs/src/api_reference/moca/ensemble.rst
 docs/src/api_reference/moca/index.rst
-docs/src/api_reference/moca/processors.base.rst
 docs/src/api_reference/moca/processors.composite.rst
 docs/src/api_reference/moca/processors.ewald.rst
 docs/src/api_reference/moca/processors.expansion.rst
 docs/src/api_reference/moca/processors.rst
 docs/src/api_reference/moca/sampler.bias.rst
 docs/src/api_reference/moca/sampler.container.rst
 docs/src/api_reference/moca/sampler.kernel.rst
@@ -90,23 +90,24 @@
 docs/src/developer_guide/guide.rst
 docs/src/developer_guide/index.rst
 docs/src/notebooks/adding-structures-in-parallel.ipynb
 docs/src/notebooks/ce-fit-w-centering.ipynb
 docs/src/notebooks/cluster-visualization.ipynb
 docs/src/notebooks/creating-a-ce-w-electrostatics.ipynb
 docs/src/notebooks/creating-a-ce.ipynb
+docs/src/notebooks/generating-sqs.ipynb
 docs/src/notebooks/index.ipynb
 docs/src/notebooks/lmo-drx-ce-mc.ipynb
+docs/src/notebooks/openmp-parallelism.ipynb
 docs/src/notebooks/running-canonical-mc.ipynb
 docs/src/notebooks/running-charge-balanced-gcmc.ipynb
 docs/src/notebooks/running-ewald-sim_anneal.ipynb
 docs/src/notebooks/running-semigrand-mc.ipynb
 docs/src/notebooks/training-data-preparation.ipynb
 docs/src/notebooks/wang-landau-ising.ipynb
-docs/src/notebooks/.ipynb_checkpoints/ce-fit-w-centering-checkpoint.ipynb
 docs/src/notebooks/data/LMTO.mson
 docs/src/notebooks/data/LiMn2O4_drx_tutorial.json
 docs/src/notebooks/data/MnTi_O.json
 docs/src/notebooks/data/basic_ce.mson
 docs/src/notebooks/data/basic_ce_ewald.mson
 docs/src/notebooks/data/lmo_drx_entries.json
 docs/src/notebooks/data/lmo_drx_prim.json
@@ -117,24 +118,26 @@
 docs/src/notebooks/data/lmto_prim.json
 docs/src/notebooks/data/lmto_sinusoid.mson
 docs/src/notebooks/data/lno_entries.json
 docs/src/notebooks/data/lno_prim.json
 docs/src/notebooks/wip/basis-orthogonalization.ipynb
 smol/__init__.py
 smol/constants.py
-smol/correlations.c
-smol/correlations.pyx
-smol/exceptions.py
 smol/io.py
-smol/utils.py
 smol.egg-info/PKG-INFO
 smol.egg-info/SOURCES.txt
 smol.egg-info/dependency_links.txt
 smol.egg-info/requires.txt
 smol.egg-info/top_level.txt
+smol/capp/__init__.py
+smol/capp/generate/__init__.py
+smol/capp/generate/enumerate.py
+smol/capp/generate/random.py
+smol/capp/generate/special/__init__.py
+smol/capp/generate/special/sqs.py
 smol/cofe/__init__.py
 smol/cofe/expansion.py
 smol/cofe/extern/__init__.py
 smol/cofe/extern/ewald.py
 smol/cofe/space/__init__.py
 smol/cofe/space/basis.py
 smol/cofe/space/cluster.py
@@ -145,57 +148,89 @@
 smol/cofe/wrangling/__init__.py
 smol/cofe/wrangling/select.py
 smol/cofe/wrangling/tools.py
 smol/cofe/wrangling/wrangler.py
 smol/moca/__init__.py
 smol/moca/composition.py
 smol/moca/ensemble.py
+smol/moca/metadata.py
+smol/moca/occu_utils.py
 smol/moca/sublattice.py
+smol/moca/trace.py
+smol/moca/kernel/__init__.py
+smol/moca/kernel/base.py
+smol/moca/kernel/bias.py
+smol/moca/kernel/mcusher.py
+smol/moca/kernel/metropolis.py
+smol/moca/kernel/random.py
+smol/moca/kernel/wanglandau.py
 smol/moca/processor/__init__.py
 smol/moca/processor/base.py
 smol/moca/processor/composite.py
+smol/moca/processor/distance.py
 smol/moca/processor/ewald.py
 smol/moca/processor/expansion.py
 smol/moca/sampler/__init__.py
-smol/moca/sampler/bias.py
 smol/moca/sampler/container.py
-smol/moca/sampler/kernel.py
-smol/moca/sampler/mcusher.py
-smol/moca/sampler/namespace.py
 smol/moca/sampler/sampler.py
-smol/moca/utils/__init__.py
-smol/moca/utils/math.py
-smol/moca/utils/occu.py
+smol/utils/__init__.py
+smol/utils/_openmp_helpers.c
+smol/utils/_openmp_helpers.pyx
+smol/utils/class_utils.py
+smol/utils/exceptions.py
+smol/utils/math.py
+smol/utils/progressbar.py
+smol/utils/setmany.py
+smol/utils/cluster/__init__.py
+smol/utils/cluster/container.c
+smol/utils/cluster/container.pxd
+smol/utils/cluster/container.pyx
+smol/utils/cluster/correlations.c
+smol/utils/cluster/correlations.pyx
+smol/utils/cluster/evaluator.c
+smol/utils/cluster/evaluator.pxd
+smol/utils/cluster/evaluator.pyx
+smol/utils/cluster/ewald.c
+smol/utils/cluster/ewald.pyx
+smol/utils/cluster/numthreads.py
+smol/utils/cluster/struct.pxd
 tests/__init__.py
 tests/conftest.py
 tests/pytest.ini
 tests/test_io.py
-tests/test_utils.py
 tests/utils.py
 tests/data/AuPd_prim.json
 tests/data/CrFeW_prim.json
 tests/data/LiCaBr_prim.json
 tests/data/LiMOF_prim.json
 tests/data/LiMnTiVOF_prim.json
 tests/data/LiTiMnPO_prim.json
 tests/data/__init__.py
+tests/test_capp/test_enumerate.py
+tests/test_capp/test_random.py
+tests/test_capp/test_sqs.py
 tests/test_cofe/test_basis.py
 tests/test_cofe/test_cluster.py
 tests/test_cofe/test_clusterspace.py
 tests/test_cofe/test_domain.py
 tests/test_cofe/test_ewald.py
 tests/test_cofe/test_expansion.py
 tests/test_cofe/test_orbit.py
 tests/test_cofe/test_select.py
 tests/test_cofe/test_tools.py
 tests/test_cofe/test_wrangler.py
 tests/test_moca/test_bias.py
 tests/test_moca/test_comp_space.py
+tests/test_moca/test_container.py
 tests/test_moca/test_ensemble.py
 tests/test_moca/test_kernel.py
-tests/test_moca/test_math_utils.py
 tests/test_moca/test_mcushers.py
 tests/test_moca/test_occu_utils.py
 tests/test_moca/test_processor.py
-tests/test_moca/test_samplecontainer.py
 tests/test_moca/test_sampler.py
-tests/test_moca/test_sublattice.py
+tests/test_moca/test_sublattice.py
+tests/test_utils/test_class_utils.py
+tests/test_utils/test_cluster_utils.py
+tests/test_utils/test_evaluator.py
+tests/test_utils/test_math_utils.py
+tests/test_utils/test_setmany.py
+tools/build_helpers.py
```

### Comparing `smol-0.3.1/tests/conftest.py` & `smol-0.4.0/tests/conftest.py`

 * *Files 12% similar despite different names*

```diff
@@ -11,15 +11,19 @@
 from smol.moca import Ensemble
 from smol.moca.processor import (
     ClusterDecompositionProcessor,
     ClusterExpansionProcessor,
     CompositeProcessor,
     EwaldProcessor,
 )
-from smol.utils import get_subclasses
+from smol.moca.processor.distance import (
+    ClusterInteractionDistanceProcessor,
+    CorrelationDistanceProcessor,
+)
+from smol.utils.class_utils import get_subclasses
 from tests.utils import gen_fake_training_data
 
 # uncomment below to show HDF5 C traceback
 # import h5py
 # h5py._errors.unsilence_errors()
 
 
@@ -73,20 +77,15 @@
     # this is the LiCaBr structure used for some fixed tests
     return test_structures[2]
 
 
 @pytest.fixture(params=test_structures, scope="package")
 def cluster_subspace(cluster_cutoffs, request):
     subspace = ClusterSubspace.from_cutoffs(
-        request.param,
-        cutoffs=cluster_cutoffs,
-        supercell_size="volume",
-        ltol=0.3,
-        stol=0.35,
-        angle_tol=10,
+        request.param, cutoffs=cluster_cutoffs, supercell_size="volume"
     )
     return subspace
 
 
 @pytest.fixture(params=test_structures, scope="package")
 def cluster_subspace_ewald(cluster_cutoffs, request):
     subspace = ClusterSubspace.from_cutoffs(
@@ -101,41 +100,87 @@
     # this is a subspace with the LiCaBr structure for some fixed tests
     subspace = ClusterSubspace.from_cutoffs(
         single_structure, cutoffs={2: 6, 3: 5}, supercell_size="volume"
     )
     return subspace
 
 
+# fixture for all processors
+@pytest.fixture(
+    params=[
+        "expansion",
+        "decomposition",
+        "ewald",
+        "composite",
+        "corr_distance",
+        "int_distance",
+    ],
+    scope="module",
+)
+def processor(cluster_subspace, rng, request):
+    coefs = 2 * np.random.random(cluster_subspace.num_corr_functions)
+    scmatrix = 3 * np.eye(3)
+
+    if request.param == "expansion":
+        proc = ClusterExpansionProcessor(cluster_subspace, scmatrix, coefficients=coefs)
+    elif request.param == "decomposition":
+        expansion = ClusterExpansion(cluster_subspace, coefs)
+        proc = ClusterDecompositionProcessor(
+            cluster_subspace, scmatrix, expansion.cluster_interaction_tensors
+        )
+    elif request.param == "ewald":
+        proc = EwaldProcessor(cluster_subspace, scmatrix, EwaldTerm(), coefficient=1.0)
+    elif request.param == "composite":
+        proc = CompositeProcessor(cluster_subspace, supercell_matrix=scmatrix)
+        proc.add_processor(
+            ClusterExpansionProcessor(cluster_subspace, scmatrix, coefficients=coefs)
+        )
+        proc.add_processor(
+            EwaldProcessor(cluster_subspace, scmatrix, EwaldTerm(), coefficient=1.0)
+        )
+    elif request.param == "corr_distance":
+        proc = CorrelationDistanceProcessor(cluster_subspace, scmatrix)
+    else:
+        expansion = ClusterExpansion(cluster_subspace, coefs)
+        proc = ClusterInteractionDistanceProcessor(
+            cluster_subspace, scmatrix, expansion.cluster_interaction_tensors
+        )
+
+    yield proc
+    cluster_subspace._external_terms = []  # Ewald processor will add one..
+
+
 @pytest.fixture(scope="module")
 def ce_processor(cluster_subspace, rng):
     coefs = 2 * rng.random(cluster_subspace.num_corr_functions)
     scmatrix = 3 * np.eye(3)
     return ClusterExpansionProcessor(
         cluster_subspace, supercell_matrix=scmatrix, coefficients=coefs
     )
 
 
-@pytest.fixture(params=["CE", "CD"], scope="module")
+@pytest.fixture(params=["expansion", "decomposition"], scope="module")
 def composite_processor(cluster_subspace_ewald, rng, request):
     coefs = 2 * np.random.random(cluster_subspace_ewald.num_corr_functions + 1)
     scmatrix = 3 * np.eye(3)
     proc = CompositeProcessor(cluster_subspace_ewald, supercell_matrix=scmatrix)
-    if request.param == "CE":
+    if request.param == "expansion":
         proc.add_processor(
             ClusterExpansionProcessor(
                 cluster_subspace_ewald, scmatrix, coefficients=coefs[:-1]
             )
         )
-    else:
+    else:  # elif request.param == "decomposition":
         expansion = ClusterExpansion(cluster_subspace_ewald, coefs)
         proc.add_processor(
             ClusterDecompositionProcessor(
                 cluster_subspace_ewald, scmatrix, expansion.cluster_interaction_tensors
             )
         )
+
     proc.add_processor(
         EwaldProcessor(
             cluster_subspace_ewald, scmatrix, EwaldTerm(), coefficient=coefs[-1]
         )
     )
     # bind raw coefficients since OD processors do not store them
     # and be able to test computing properties, hacky but oh well
@@ -198,9 +243,9 @@
 
 @pytest.fixture
 def structure_wrangler(single_subspace, rng):
     wrangler = StructureWrangler(single_subspace)
     for entry in gen_fake_training_data(single_subspace.structure, n=10, rng=rng):
         wrangler.add_entry(entry, weights={"random": 2.0})
     yield wrangler
-    # force remove any external terms added in tetts
+    # force remove any external terms added in tests
     wrangler.cluster_subspace._external_terms = []
```

### Comparing `smol-0.3.1/tests/data/AuPd_prim.json` & `smol-0.4.0/tests/data/AuPd_prim.json`

 * *Files identical despite different names*

### Comparing `smol-0.3.1/tests/data/CrFeW_prim.json` & `smol-0.4.0/tests/data/CrFeW_prim.json`

 * *Files identical despite different names*

### Comparing `smol-0.3.1/tests/data/LiCaBr_prim.json` & `smol-0.4.0/tests/data/LiCaBr_prim.json`

 * *Files identical despite different names*

### Comparing `smol-0.3.1/tests/data/LiMOF_prim.json` & `smol-0.4.0/tests/data/LiMOF_prim.json`

 * *Files identical despite different names*

### Comparing `smol-0.3.1/tests/data/LiMnTiVOF_prim.json` & `smol-0.4.0/tests/data/LiMnTiVOF_prim.json`

 * *Files identical despite different names*

### Comparing `smol-0.3.1/tests/data/LiTiMnPO_prim.json` & `smol-0.4.0/tests/data/LiTiMnPO_prim.json`

 * *Files identical despite different names*

### Comparing `smol-0.3.1/tests/data/__init__.py` & `smol-0.4.0/tests/data/__init__.py`

 * *Files identical despite different names*

### Comparing `smol-0.3.1/tests/test_cofe/test_basis.py` & `smol-0.4.0/tests/test_cofe/test_basis.py`

 * *Files 1% similar despite different names*

```diff
@@ -4,15 +4,15 @@
 import numpy.testing as npt
 import pytest
 from numpy.polynomial.chebyshev import chebval
 from numpy.polynomial.legendre import legval
 from pymatgen.core import Composition
 
 from smol.cofe.space import basis, domain
-from smol.utils import get_subclasses
+from smol.utils.class_utils import get_subclasses
 from tests.utils import assert_msonable
 
 pytestmark = pytest.mark.filterwarnings("ignore:The measure given does not sum to 1.")
 basis_iterators = list(get_subclasses(basis.BasisIterator).values())
 
 
 @pytest.fixture(params=[True, False], scope="module")
```

### Comparing `smol-0.3.1/tests/test_cofe/test_cluster.py` & `smol-0.4.0/tests/test_cofe/test_cluster.py`

 * *Files identical despite different names*

### Comparing `smol-0.3.1/tests/test_cofe/test_clusterspace.py` & `smol-0.4.0/tests/test_cofe/test_clusterspace.py`

 * *Files 4% similar despite different names*

```diff
@@ -10,17 +10,18 @@
 from pymatgen.core import Species, Structure
 from pymatgen.util.coord import is_coord_subset_pbc
 
 from smol.cofe import ClusterSubspace, PottsSubspace
 from smol.cofe.space.clusterspace import get_complete_mapping, invert_mapping
 from smol.cofe.space.constants import SITE_TOL
 from smol.cofe.space.domain import Vacancy, get_allowed_species
-from smol.correlations import corr_from_occupancy
-from smol.exceptions import StructureMatchError
-from tests.utils import assert_msonable, gen_random_structure
+from smol.utils.cluster import get_orbit_data
+from smol.utils.cluster.evaluator import ClusterSpaceEvaluator
+from smol.utils.exceptions import StructureMatchError
+from tests.utils import assert_msonable, gen_random_ordered_structure
 
 pytestmark = pytest.mark.filterwarnings("ignore:All bit combos have been removed")
 
 
 def test_from_cutoffs(structure):
     cutoffs = {2: 5, 3: 4, 4: 4}
     for increment in np.arange(0, 3, 1):
@@ -46,14 +47,22 @@
 
 
 def test_cutoffs(cluster_subspace, cluster_cutoffs):
     for s, c in cluster_subspace.cutoffs.items():
         assert cluster_cutoffs[s] >= c
 
 
+def test_orbits_by_diameter(cluster_subspace):
+    previous_diameter = -1
+    for diameter, orbits in cluster_subspace.orbits_by_diameter.items():
+        assert all(np.isclose(o.base_cluster.diameter, diameter) for o in orbits)
+        assert diameter > previous_diameter
+        previous_diameter = diameter
+
+
 def test_orbits_from_cutoffs(cluster_subspace, cluster_cutoffs):
     # Get all of them
     max_cutoff = max(cluster_cutoffs.values())
     assert all(
         o1 == o2
         for o1, o2 in zip(
             cluster_subspace.orbits, cluster_subspace.orbits_from_cutoffs(max_cutoff)
@@ -121,15 +130,15 @@
 def test_site_bases(cluster_subspace, basis_name, orthonormal, rng):
     subspace = cluster_subspace.copy()  # copy it to keep original state
     subspace.change_site_bases(basis_name, orthonormal=orthonormal)
     if orthonormal:
         assert subspace.basis_orthogonal
         assert subspace.basis_orthonormal
 
-    structure = gen_random_structure(subspace.structure, rng=rng)
+    structure = gen_random_ordered_structure(subspace.structure, rng=rng)
     if cluster_subspace.basis_type == subspace.basis_type and not orthonormal:
         npt.assert_array_almost_equal(
             subspace.corr_from_structure(structure),
             cluster_subspace.corr_from_structure(structure),
         )
     else:
         assert not np.allclose(
@@ -164,15 +173,17 @@
     assert np.linalg.det(sc_matrix) == pytest.approx(8)
 
 
 @pytest.mark.xfail(raises=StructureMatchError)
 def test_refine_structure(cluster_subspace, rng):
     supercell = cluster_subspace.structure.copy()
     supercell.make_supercell(3)
-    structure = gen_random_structure(cluster_subspace.structure, size=3, rng=rng)
+    structure = gen_random_ordered_structure(
+        cluster_subspace.structure, size=3, rng=rng
+    )
     structure.apply_strain(rng.uniform(-0.01, 0.01, size=3))
     refined_structure = cluster_subspace.refine_structure(structure)
 
     assert not np.allclose(  # check that distorted structure is not equivalent
         supercell.lattice.parameters, structure.lattice.parameters
     )
     npt.assert_allclose(
@@ -190,27 +201,32 @@
     ids_to_remove = rng.choice(
         range(1, subspace.num_orbits), size=remove_num, replace=False
     )
     subspace.remove_orbits(ids_to_remove)
 
     assert len(subspace.orbits) == len(cluster_subspace.orbits) - remove_num
     assert subspace.num_orbits == cluster_subspace.num_orbits - remove_num
+    # check that cached_property is reset
+    assert (
+        len([o for _, os in subspace.orbits_by_diameter.items() for o in os])
+        == len(cluster_subspace.orbits) - remove_num
+    )
 
     for i, orbit in enumerate(cluster_subspace.orbits):
         if i + 1 in ids_to_remove:
             assert orbit not in subspace.orbits
         else:
             assert orbit in subspace.orbits
 
     corr_inds = [
         i
         for i in range(len(cluster_subspace))
         if cluster_subspace.function_orbit_ids[i] not in ids_to_remove
     ]
-    structure = gen_random_structure(subspace.structure, size=2, rng=rng)
+    structure = gen_random_ordered_structure(subspace.structure, size=2, rng=rng)
     npt.assert_allclose(
         cluster_subspace.corr_from_structure(structure)[corr_inds],
         subspace.corr_from_structure(structure),
     )
 
     # remove all orbits of a certain size and make sure key is removed
     size = rng.choice(list(subspace.orbits_by_size.keys()))
@@ -234,15 +250,15 @@
 
     assert len(subspace) == len(cluster_subspace) - remove_num
     assert (
         subspace.num_corr_functions == cluster_subspace.num_corr_functions - remove_num
     )
 
     corr_inds = [i for i in range(len(cluster_subspace)) if i not in ids_to_remove]
-    structure = gen_random_structure(subspace.structure, size=2, rng=rng)
+    structure = gen_random_ordered_structure(subspace.structure, size=2, rng=rng)
     npt.assert_allclose(
         cluster_subspace.corr_from_structure(structure)[corr_inds],
         subspace.corr_from_structure(structure),
     )
     with pytest.warns(UserWarning):
         bid = subspace.orbits[-1].bit_id
         ids = list(range(bid, bid + len(subspace.orbits[-1])))
@@ -275,22 +291,33 @@
                 if is_coord_subset_pbc(equiv.frac_coords, new_fc, atol=SITE_TOL):
                     found = True
                     break
             assert found
 
     # check that the matrix was cached
     m_hash = tuple(sorted(tuple(s.tolist()) for s in supercell_matrix))
-    assert cluster_subspace._supercell_orb_inds[
-        m_hash
-    ] is cluster_subspace.supercell_orbit_mappings(supercell_matrix)
+    orbit_indices = cluster_subspace._supercell_orbit_inds[m_hash]
+    assert orbit_indices.arrays is cluster_subspace.supercell_orbit_mappings(
+        supercell_matrix
+    )
+    assert orbit_indices.container.size == len(
+        cluster_subspace.supercell_orbit_mappings(supercell_matrix)
+    )
 
+    evaluator = ClusterSpaceEvaluator(
+        get_orbit_data(cluster_subspace.orbits),
+        cluster_subspace.num_orbits,
+        cluster_subspace.num_corr_functions,
+    )
     # Test that symmetrically equivalent matrices really produce the
     # same correlation vector for the same occupancy.
     structures = [
-        gen_random_structure(cluster_subspace.structure, size=supercell_matrix, rng=rng)
+        gen_random_ordered_structure(
+            cluster_subspace.structure, size=supercell_matrix, rng=rng
+        )
         for _ in range(10)
     ]
     matrix2 = np.array([[0, 1, 0], [0, 0, 1], [1, 0, 0]]) @ np.array(
         supercell_matrix, dtype=int
     )
     matrix3 = np.array([[0, 0, 1], [-1, 0, 0], [0, 1, 0]]) @ np.array(
         supercell_matrix, dtype=int
@@ -316,54 +343,48 @@
             structure, scmatrix=matrix3, encode=True
         )
         for structure in structures
     ]
 
     corrs = np.array(
         [
-            corr_from_occupancy(
-                occu,
-                cluster_subspace.num_corr_functions,
-                cluster_subspace.gen_orbit_list(supercell_matrix),
+            evaluator.correlations_from_occupancy(
+                occu, cluster_subspace.get_orbit_indices(supercell_matrix).container
             )
             for occu in occus
         ]
     )
 
     corrs2 = np.array(
         [
-            corr_from_occupancy(
-                occu,
-                cluster_subspace.num_corr_functions,
-                cluster_subspace.gen_orbit_list(matrix2),
+            evaluator.correlations_from_occupancy(
+                occu, cluster_subspace.get_orbit_indices(matrix2).container
             )
             for occu in occus2
         ]
     )
 
     corrs3 = np.array(
         [
-            corr_from_occupancy(
-                occu,
-                cluster_subspace.num_corr_functions,
-                cluster_subspace.gen_orbit_list(matrix3),
+            evaluator.correlations_from_occupancy(
+                occu, cluster_subspace.get_orbit_indices(matrix3).container
             )
             for occu in occus3
         ]
     )
 
     # Symmetrically equivalent matrices should give the same correlation
     # function for the same structure, when the orbit indices mappings
     # are re-generated.
     npt.assert_array_almost_equal(corrs, corrs2)
     npt.assert_array_almost_equal(corrs, corrs3)
 
     # Symmetrically equivalent matrices should give the same correlation
     # vectors on the same structure, when using the default orbit mapping.
-    cluster_subspace._supercell_orb_inds = {}
+    cluster_subspace._supercell_orbit_inds = {}
     for structure, expected in zip(structures, corrs):
         predicted = cluster_subspace.corr_from_structure(
             structure, scmatrix=supercell_matrix
         )
         npt.assert_array_almost_equal(predicted, expected)
 
         predicted = cluster_subspace.corr_from_structure(structure, scmatrix=matrix2)
@@ -419,15 +440,17 @@
             aliased_orbits_std.append(orbit_i_aliased)
 
     aliased_orbits_std = sorted(list(set(aliased_orbits_std)), key=lambda x: x[0])
     assert aliased_orbits_std == aliased_orbs
 
 
 def test_periodicity_and_symmetry(cluster_subspace, supercell_matrix, rng):
-    structure = gen_random_structure(cluster_subspace.structure, size=2, rng=rng)
+    structure = gen_random_ordered_structure(
+        cluster_subspace.structure, size=2, rng=rng
+    )
     larger_structure = structure.copy()
     larger_structure.make_supercell(supercell_matrix)
 
     corr = cluster_subspace.corr_from_structure(structure)
 
     larger_scmatrix = supercell_matrix @ np.eye(3) * 2
     npt.assert_allclose(
@@ -489,24 +512,26 @@
 def test_msonable(cluster_subspace_ewald, rng):
     # force caching some orb indices for a few random structures
     _ = repr(cluster_subspace_ewald)  # can probably do better testing than this...
     _ = str(cluster_subspace_ewald)
 
     for _ in range(2):
         size = rng.integers(1, 4)
-        s = gen_random_structure(cluster_subspace_ewald.structure, size=size, rng=rng)
+        s = gen_random_ordered_structure(
+            cluster_subspace_ewald.structure, size=size, rng=rng
+        )
         _ = cluster_subspace_ewald.corr_from_structure(s)
 
     assert_msonable(cluster_subspace_ewald)
 
     subspace = ClusterSubspace.from_dict(cluster_subspace_ewald.as_dict())
-    for key in cluster_subspace_ewald._supercell_orb_inds.keys():
+    for key in cluster_subspace_ewald._supercell_orbit_inds.keys():
         for arr1, arr2 in zip(
-            subspace._supercell_orb_inds[key],
-            cluster_subspace_ewald._supercell_orb_inds[key],
+            subspace._supercell_orbit_inds[key].arrays,
+            cluster_subspace_ewald._supercell_orbit_inds[key].arrays,
         ):
             npt.assert_array_equal(arr1, arr2)
 
     assert len(cluster_subspace_ewald.external_terms) == len(subspace.external_terms)
     npt.assert_allclose(
         subspace.corr_from_structure(s), cluster_subspace_ewald.corr_from_structure(s)
     )
@@ -745,19 +770,19 @@
             cs.rotate_site_basis(1, np.pi / 4)
         cs.change_site_bases("sinusoid", orthonormal=True)
 
     with pytest.raises(ValueError):
         cs.rotate_site_basis(len(cs.orbits_by_size[1]) + 2, np.pi)
 
     cs1 = cs.copy()
-    print(cs.site_rotation_matrix)
+    # print(cs.site_rotation_matrix)
     cs1.rotate_site_basis(1, np.pi / 4)
-    print(cs1.site_rotation_matrix)
+    # print(cs1.site_rotation_matrix)
     for i in range(5):
-        structure = gen_random_structure(cs.structure, rng=rng)
+        structure = gen_random_ordered_structure(cs.structure, rng=rng)
         for j in range(5):
             coefs1 = 10 * np.random.random(len(cs))
             coefs = coefs1.copy()
             coefs = cs1.site_rotation_matrix.T @ coefs
             eci = coefs / cs.function_ordering_multiplicities
             eci1 = coefs1 / cs1.function_ordering_multiplicities
             norms = np.array(
@@ -804,127 +829,112 @@
 
 
 def test_vs_CASM_pairs(single_structure):
     species = [{"Li+": 0.1}] * 3 + ["Br-"]
     coords = ((0.25, 0.25, 0.25), (0.75, 0.75, 0.75), (0.5, 0.5, 0.5), (0, 0, 0))
     structure = Structure(single_structure.lattice, species, coords)
     cs = ClusterSubspace.from_cutoffs(structure, {2: 6}, basis="indicator")
-
+    evaluator = ClusterSpaceEvaluator(
+        get_orbit_data(cs.orbits), cs.num_orbits, cs.num_corr_functions
+    )
     spaces = get_allowed_species(structure)
     m = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]
-    orbit_list = [
-        (
-            orbit.bit_id,
-            orbit.flat_tensor_indices,
-            orbit.flat_correlation_tensors,
-            cluster_indices,
-        )
-        for orbit, cluster_indices in zip(cs.orbits, cs.supercell_orbit_mappings(m))
-    ]
+    indices = cs.get_orbit_indices(m)
 
     # last two clusters are switched from CASM output (occupancy basis)
     # all_li (ignore casm point term)
     occu = _encode_occu([Species("Li", 1), Species("Li", 1), Species("Li", 1)], spaces)
-    corr = corr_from_occupancy(occu, cs.num_corr_functions, orbit_list)
+    corr = evaluator.correlations_from_occupancy(occu, indices.container)
     npt.assert_allclose(corr, np.array([1] * 12))
 
     # all_vacancy
     occu = _encode_occu([Vacancy(), Vacancy(), Vacancy()], spaces)
-    corr = corr_from_occupancy(occu, cs.num_corr_functions, orbit_list)
+    corr = evaluator.correlations_from_occupancy(occu, indices.container)
     npt.assert_allclose(corr, np.array([1] + [0] * 11))
     # octahedral
     occu = _encode_occu([Vacancy(), Vacancy(), Species("Li", 1)], spaces)
-    corr = corr_from_occupancy(occu, cs.num_corr_functions, orbit_list)
+    corr = evaluator.correlations_from_occupancy(occu, indices.container)
     npt.assert_allclose(corr, [1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1])
     # tetrahedral
     occu = _encode_occu([Species("Li", 1), Species("Li", 1), Vacancy()], spaces)
-    corr = corr_from_occupancy(occu, cs.num_corr_functions, orbit_list)
+    corr = evaluator.correlations_from_occupancy(occu, indices.container)
     npt.assert_allclose(corr, [1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0])
     # mixed
     occu = _encode_occu([Species("Li", 1), Vacancy(), Species("Li", 1)], spaces)
-    corr = corr_from_occupancy(occu, cs.num_corr_functions, orbit_list)
+    corr = evaluator.correlations_from_occupancy(occu, indices.container)
     npt.assert_allclose(corr, [1, 0.5, 1, 0.5, 0, 0.5, 1, 0.5, 0, 0, 0.5, 1])
     # single_tet
     occu = _encode_occu([Species("Li", 1), Vacancy(), Vacancy()], spaces)
-    corr = corr_from_occupancy(occu, cs.num_corr_functions, orbit_list)
+    corr = evaluator.correlations_from_occupancy(occu, indices.container)
     npt.assert_allclose(corr, [1, 0.5, 0, 0, 0, 0.5, 0, 0, 0, 0, 0.5, 0])
 
 
 def test_vs_CASM_triplets(single_structure):
     """
     Test vs casm generated correlation with occupancy basis.
     """
     species = [{"Li+": 0.1}] * 3 + ["Br-"]
     coords = ((0.25, 0.25, 0.25), (0.75, 0.75, 0.75), (0.5, 0.5, 0.5), (0, 0, 0))
     structure = Structure(single_structure.lattice, species, coords)
     cs = ClusterSubspace.from_cutoffs(structure, {2: 6, 3: 4.5}, basis="indicator")
+    evaluator = ClusterSpaceEvaluator(
+        get_orbit_data(cs.orbits), cs.num_orbits, cs.num_corr_functions
+    )
     spaces = get_allowed_species(structure)
     m = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]
+    indices = cs.get_orbit_indices(m)
 
-    orbit_list = [
-        (
-            orbit.bit_id,
-            orbit.flat_tensor_indices,
-            orbit.flat_correlation_tensors,
-            cluster_indices,
-        )
-        for orbit, cluster_indices in zip(cs.orbits, cs.supercell_orbit_mappings(m))
-    ]
     # last two pair terms are switched from CASM output (occupancy basis)
     # all_vacancy (ignore casm point term)
     occu = _encode_occu([Vacancy(), Vacancy(), Vacancy()], spaces)
-    corr = corr_from_occupancy(occu, cs.num_corr_functions, orbit_list)
+    corr = evaluator.correlations_from_occupancy(occu, indices.container)
     npt.assert_allclose(corr, np.array([1] + [0] * 18))
     # all Li
     occu = _encode_occu([Species("Li", 1), Species("Li", 1), Species("Li", 1)], spaces)
-    corr = corr_from_occupancy(occu, cs.num_corr_functions, orbit_list)
+    corr = evaluator.correlations_from_occupancy(occu, indices.container)
     npt.assert_allclose(corr, np.array([1] * 19))
     # octahedral
     occu = _encode_occu([Vacancy(), Vacancy(), Species("Li", 1)], spaces)
-    corr = corr_from_occupancy(occu, cs.num_corr_functions, orbit_list)
+    corr = evaluator.correlations_from_occupancy(occu, indices.container)
     npt.assert_allclose(corr, [1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1])
 
     # tetrahedral
     occu = _encode_occu([Species("Li", 1), Species("Li", 1), Vacancy()], spaces)
-    corr = corr_from_occupancy(occu, cs.num_corr_functions, orbit_list)
+    corr = evaluator.correlations_from_occupancy(occu, indices.container)
     npt.assert_allclose(corr, [1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0])
     # mixed
     occu = _encode_occu([Species("Li", 1), Vacancy(), Species("Li", 1)], spaces)
-    corr = corr_from_occupancy(occu, cs.num_corr_functions, orbit_list)
+    corr = evaluator.correlations_from_occupancy(occu, indices.container)
     npt.assert_allclose(
         corr,
         [1, 0.5, 1, 0.5, 0, 0.5, 1, 0.5, 0, 0, 0.5, 1, 0, 0, 0.5, 0.5, 0.5, 0.5, 1],
     )
     # single_tet
     occu = _encode_occu([Species("Li", 1), Vacancy(), Vacancy()], spaces)
-    corr = corr_from_occupancy(occu, cs.num_corr_functions, orbit_list)
+    corr = evaluator.correlations_from_occupancy(occu, indices.container)
     npt.assert_allclose(
         corr, [1, 0.5, 0, 0, 0, 0.5, 0, 0, 0, 0, 0.5, 0, 0, 0, 0, 0, 0.5, 0.5, 0]
     )
 
 
 def test_vs_CASM_multicomp(single_structure):
     cs = ClusterSubspace.from_cutoffs(single_structure, {2: 5}, basis="indicator")
+    evaluator = ClusterSpaceEvaluator(
+        get_orbit_data(cs.orbits), cs.num_orbits, cs.num_corr_functions
+    )
     m = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]
     spaces = get_allowed_species(single_structure)
-    orbit_list = [
-        (
-            orbit.bit_id,
-            orbit.flat_tensor_indices,
-            orbit.flat_correlation_tensors,
-            cluster_indices,
-        )
-        for orbit, cluster_indices in zip(cs.orbits, cs.supercell_orbit_mappings(m))
-    ]
+    indices = cs.get_orbit_indices(m)
+
     # mixed
     occu = _encode_occu([Vacancy(), Species("Li", 1), Species("Li", 1)], spaces)
-    corr = corr_from_occupancy(occu, cs.num_corr_functions, orbit_list)
+    corr = evaluator.correlations_from_occupancy(occu, indices.container)
     npt.assert_allclose(
         corr, [1, 0.5, 0, 1, 0, 0.5, 0, 0, 0, 0, 0, 0, 0.5, 0, 0, 1, 0, 0, 0.5, 0, 0, 0]
     )
 
     # Li-tet Ca-oct
     occu = _encode_occu([Vacancy(), Species("Li", 1), Species("Ca", 1)], spaces)
-    corr = corr_from_occupancy(occu, cs.num_corr_functions, orbit_list)
+    corr = evaluator.correlations_from_occupancy(occu, indices.container)
     npt.assert_allclose(
         corr, [1, 0.5, 0, 0, 1, 0, 0.5, 0, 0, 0, 0, 0, 0.5, 0, 0, 0, 0, 1, 0, 0.5, 0, 0]
     )
```

### Comparing `smol-0.3.1/tests/test_cofe/test_domain.py` & `smol-0.4.0/tests/test_cofe/test_domain.py`

 * *Files identical despite different names*

### Comparing `smol-0.3.1/tests/test_cofe/test_ewald.py` & `smol-0.4.0/tests/test_cofe/test_ewald.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,16 +1,17 @@
 import numpy as np
 import numpy.testing as npt
 from pymatgen.analysis.ewald import EwaldSummation
 from pymatgen.analysis.structure_matcher import StructureMatcher
 from pymatgen.core import PeriodicSite, Structure
 
+from smol.capp.generate.random import _gen_neutral_occu
 from smol.cofe.extern import EwaldTerm
 from smol.cofe.space.domain import Vacancy, get_allowed_species
-from tests.utils import assert_msonable, gen_random_neutral_occupancy
+from tests.utils import assert_msonable
 
 
 def test_get_ewald_structure(ce_processor):
     supercell = ce_processor.structure
     sm = StructureMatcher()
     ew = EwaldTerm(eta=0.15)
     ew_structure, ew_inds = ew.get_ewald_structure(supercell)
@@ -43,15 +44,15 @@
     # Test 10 times at random, with charge balance.
     supercell = ce_processor.structure
     sublattices = ce_processor.get_sublattices()
     n_success = 0
     for _ in range(10):
         try:
             # We should only test neutral occupancies.
-            occu = gen_random_neutral_occupancy(sublattices, rng=rng)
+            occu = _gen_neutral_occu(sublattices, rng=rng)
             n_success += 1
         except TimeoutError:
             occu = None
 
         if occu is not None:
             s = ce_processor.structure_from_occupancy(occu)
             assert s.charge == 0
```

### Comparing `smol-0.3.1/tests/test_cofe/test_expansion.py` & `smol-0.4.0/tests/test_cofe/test_expansion.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,37 +1,45 @@
 import numpy as np
 import numpy.testing as npt
 import pytest
 from sklearn.linear_model import LinearRegression, Ridge
 
 from smol.cofe import ClusterExpansion, RegressionData
-from tests.utils import assert_msonable, gen_random_structure
+from tests.utils import assert_msonable, gen_random_ordered_structure
 
 
 @pytest.fixture(scope="module")
 def cluster_expansion(cluster_subspace, rng):
     reg = Ridge(alpha=1e-8, fit_intercept=False)
     n = rng.integers(50, 100)
     feat_matrix = np.empty((n, len(cluster_subspace)))
-    structures = []
+    structures, scmatrices = [], []
     for i in range(n):
-        structure = gen_random_structure(
-            cluster_subspace.structure, size=rng.integers(2, 5), rng=rng
+        scmatrix = np.eye(3, dtype=int) * rng.integers(2, 4)
+        scmatrix[0, 1] = 2  # Intentionally made less symmetric
+        scmatrix[1, 2] = 1
+        structure = gen_random_ordered_structure(
+            cluster_subspace.structure, size=scmatrix, rng=rng
         )
         structures.append(structure)
-        feat_matrix[i] = cluster_subspace.corr_from_structure(structure)
+        scmatrices.append(scmatrix)
+        feat_matrix[i] = cluster_subspace.corr_from_structure(
+            structure, scmatrix=scmatrix
+        )
 
     prop_vec = -5 * rng.random(n)
     reg.fit(feat_matrix, prop_vec)
     reg_data = RegressionData.from_sklearn(
         reg, feature_matrix=feat_matrix, property_vector=prop_vec
     )
     expansion = ClusterExpansion(cluster_subspace, reg.coef_, reg_data)
-    # bind the structures to the expansion willy nilly
+    # bind the structures and matrices to the expansion willy nilly
     expansion.structures = structures
+    expansion.scmatrices = scmatrices
+
     return expansion
 
 
 def test_regression_data(cluster_subspace, rng):
     reg = LinearRegression(fit_intercept=False)
     n = rng.integers(10, 100)
     feat_matrix = rng.random((n, len(cluster_subspace)))
@@ -61,15 +69,15 @@
     subspace = cluster_expansion.cluster_subspace
 
     prim = cluster_expansion.structure
     scmatrix = np.eye(3, dtype=int) * 3
     scmatrix[0, 1] = 2  # Intentionally made less symmetric
     scmatrix[1, 2] = 1
     N = np.abs(np.linalg.det(scmatrix))
-    pool = [gen_random_structure(prim, scmatrix, rng=rng) for _ in range(100)]
+    pool = [gen_random_ordered_structure(prim, scmatrix, rng=rng) for _ in range(100)]
     feature_matrix = np.array(
         [
             subspace.corr_from_structure(s, scmatrix=scmatrix, normalized=True)
             for s in pool
         ]
     )
 
@@ -85,21 +93,22 @@
     reg.fit(feature_matrix, energies)
     coefs = reg.coef_
     expansion_new = ClusterExpansion(subspace, coefs)
     # Why don't we add a "scmatrix" option into ClusterExpansion.predict?
     # This will make it safer to structure skew, because pymatgen can't seem
     # to figure out highly skewed supercell matrix correctly.
     energies_pred = np.array(
-        [expansion_new.predict(s, scmatrix=scmatrix, normalize=True) for s in pool]
+        [expansion_new.predict(s, scmatrix=scmatrix, normalized=True) for s in pool]
     )
     np.testing.assert_almost_equal(energies, energies_pred, decimal=6)
 
 
 def test_prune(cluster_expansion):
     expansion = cluster_expansion.copy()
+
     thresh = 1e-2
     expansion.prune(threshold=thresh)
     ids = [i for i, coef in enumerate(cluster_expansion.coefs) if abs(coef) >= thresh]
     new_coefs = cluster_expansion.coefs[ids]
     new_eci = cluster_expansion.eci[ids]
 
     assert len(expansion.coefs) == len(new_coefs)
@@ -117,23 +126,38 @@
     )
 
     pruned_feat_matrix = cluster_expansion._feat_matrix[:, ids]
     npt.assert_array_equal(expansion._feat_matrix, pruned_feat_matrix)
     # check that recomputing features produces what's expected
     new_feature_matrix = np.array(
         [
-            expansion.cluster_subspace.corr_from_structure(s)
-            for s in cluster_expansion.structures
+            expansion.cluster_subspace.corr_from_structure(s, scmatrix=m)
+            for s, m in zip(cluster_expansion.structures, cluster_expansion.scmatrices)
         ]
     )
     npt.assert_array_equal(new_feature_matrix, pruned_feat_matrix)
     # check new predictions
-    preds = [expansion.predict(s, normalize=True) for s in cluster_expansion.structures]
+    preds = [
+        expansion.predict(s, normalized=True, scmatrix=m)
+        for s, m in zip(cluster_expansion.structures, cluster_expansion.scmatrices)
+    ]
     npt.assert_allclose(preds, np.dot(pruned_feat_matrix, new_coefs))
 
+    # check energy computed with interactions also matches
+    ints = np.array(
+        [
+            expansion.cluster_interactions_from_structure(s, scmatrix=m)
+            for s, m in zip(cluster_expansion.structures, cluster_expansion.scmatrices)
+        ]
+    )
+    preds = np.sum(
+        cluster_expansion.cluster_subspace.orbit_multiplicities * ints, axis=1
+    )
+    npt.assert_allclose(preds, np.dot(pruned_feat_matrix, new_coefs), atol=1e-5)
+
 
 def test_msonable(cluster_expansion):
     _ = repr(cluster_expansion)
     _ = str(cluster_expansion)
     _ = str(cluster_expansion)
     d = cluster_expansion.as_dict()
     ce1 = ClusterExpansion.from_dict(d)
```

### Comparing `smol-0.3.1/tests/test_cofe/test_orbit.py` & `smol-0.4.0/tests/test_cofe/test_orbit.py`

 * *Files identical despite different names*

### Comparing `smol-0.3.1/tests/test_cofe/test_select.py` & `smol-0.4.0/tests/test_cofe/test_select.py`

 * *Files identical despite different names*

### Comparing `smol-0.3.1/tests/test_cofe/test_tools.py` & `smol-0.4.0/tests/test_cofe/test_tools.py`

 * *Files identical despite different names*

### Comparing `smol-0.3.1/tests/test_cofe/test_wrangler.py` & `smol-0.4.0/tests/test_cofe/test_wrangler.py`

 * *Files 1% similar despite different names*

```diff
@@ -3,28 +3,32 @@
 import numpy as np
 import numpy.testing as npt
 import pytest
 from pymatgen.entries.computed_entries import ComputedStructureEntry
 
 from smol.cofe import StructureWrangler
 from smol.cofe.extern import EwaldTerm
-from tests.utils import assert_msonable, gen_fake_training_data, gen_random_structure
+from tests.utils import (
+    assert_msonable,
+    gen_fake_training_data,
+    gen_random_ordered_structure,
+)
 
 pytestmark = [
     pytest.mark.filterwarnings("ignore:.*supercell_structure. Throwing out."),
     pytest.mark.filterwarnings("ignore:.*have duplicated correlation vectors"),
 ]
 
 
 def test_add_data(structure_wrangler, rng):
     for entry in gen_fake_training_data(
         structure_wrangler.cluster_subspace.structure, rng=rng
     ):
         structure_wrangler.add_entry(entry, weights={"random": 2.0})
-    struct = gen_random_structure(
+    struct = gen_random_ordered_structure(
         structure_wrangler.cluster_subspace.structure, rng=rng
     )
     energy = -len(struct) * rng.random()
     structure_wrangler.add_entry(
         ComputedStructureEntry(
             struct,
             energy,
@@ -363,15 +367,14 @@
     dup_entry2 = structure_wrangler.process_entry(
         ComputedStructureEntry(struct, structure_wrangler.entries[ind2].energy),
         properties=structure_wrangler.entries[ind2].data["properties"],
         weights=structure_wrangler.entries[ind2].data["weights"],
     )
     structure_wrangler.append_entries([dup_entry, dup_entry2])
     expected_matches = [ind, structure_wrangler.num_structures - 2]
-    print(structure_wrangler.get_matching_corr_duplicate_indices(), expected_matches)
     assert any(
         expected_matches == sorted(matches)
         for matches in structure_wrangler.get_matching_corr_duplicate_indices()
     )
 
 
 def test_get_constant_features(structure_wrangler, rng):
```

### Comparing `smol-0.3.1/tests/test_io.py` & `smol-0.4.0/tests/test_io.py`

 * *Files identical despite different names*

### Comparing `smol-0.3.1/tests/test_moca/test_bias.py` & `smol-0.4.0/tests/test_moca/test_bias.py`

 * *Files 10% similar despite different names*

```diff
@@ -2,22 +2,22 @@
 
 from copy import deepcopy
 
 import numpy as np
 import numpy.testing as npt
 import pytest
 
+from smol.capp.generate.random import _gen_unconstrained_ordered_occu
 from smol.moca.composition import get_oxi_state
-from smol.moca.sampler.bias import (
+from smol.moca.kernel.bias import (
     FugacityBias,
     SquareChargeBias,
     SquareHyperplaneBias,
     mcbias_factory,
 )
-from tests.utils import gen_random_occupancy
 
 bias_classes = [FugacityBias, SquareChargeBias, SquareHyperplaneBias]
 
 
 @pytest.fixture(scope="module")
 def all_sublattices(ce_processor):
     return ce_processor.get_sublattices()
@@ -32,27 +32,23 @@
         b = np.random.randint(low=-10, high=10, size=n_cons)
         return request.param(all_sublattices, a, b)
     return request.param(all_sublattices)
 
 
 def test_compute_bias_change(mcbias, rng):
     step = []
-    occu = gen_random_occupancy(mcbias.sublattices, rng=rng)
+    occu = _gen_unconstrained_ordered_occu(mcbias.sublattices, rng=rng)
     new_occu = occu.copy()
     rng = np.random.default_rng()
     for _ in range(50):
         s = rng.choice(list(range(len(mcbias.active_sublattices))))
         i = rng.choice(mcbias.active_sublattices[s].sites)
         sp = rng.choice(list(range(len(mcbias.active_sublattices[s].species))))
         step.append((i, sp))
-        if i == 81:
-            raise (ValueError, "81!!!!")
         new_occu[i] = sp
-    print(mcbias.sublattices)
-    print(step)
     assert mcbias.compute_bias_change(occu, step) == pytest.approx(
         mcbias.compute_bias(new_occu) - mcbias.compute_bias(occu)
     )
 
 
 def test_mcbias_factory(all_sublattices):
     for bias in bias_classes:
@@ -128,15 +124,15 @@
     for sublatt in square_charge_bias.sublattices:
         charges = np.array([get_oxi_state(sp) for sp in sublatt.species])
         npt.assert_array_equal(
             table[sublatt.sites[:, None], sublatt.encoding] - charges[None, :], 0
         )
     # Bias should be implemented as negative.
     for _ in range(100):
-        occu = gen_random_occupancy(square_charge_bias.sublattices, rng=rng)
+        occu = _gen_unconstrained_ordered_occu(square_charge_bias.sublattices, rng=rng)
         assert square_charge_bias.compute_bias(occu) <= 1e-6
 
 
 @pytest.fixture(scope="module")
 def square_comp_bias(all_sublattices):
     n_dims = sum(len(sublatt.species) for sublatt in all_sublattices)
     n_cons = max(n_dims - 1, 1)
@@ -144,9 +140,9 @@
     b = np.random.randint(low=-10, high=10, size=n_cons)
     return SquareHyperplaneBias(all_sublattices, a, b)
 
 
 def test_comp_bias(square_comp_bias, rng):
     # Bias should be implemented as negative.
     for _ in range(100):
-        occu = gen_random_occupancy(square_comp_bias.sublattices, rng=rng)
+        occu = _gen_unconstrained_ordered_occu(square_comp_bias.sublattices, rng=rng)
         assert square_comp_bias.compute_bias(occu) <= 1e-6
```

### Comparing `smol-0.3.1/tests/test_moca/test_comp_space.py` & `smol-0.4.0/tests/test_moca/test_comp_space.py`

 * *Files 0% similar despite different names*

```diff
@@ -5,16 +5,16 @@
 import numpy as np
 import numpy.testing as npt
 import pytest
 from pymatgen.core import Composition, Species
 
 from smol.cofe.space.domain import Vacancy
 from smol.moca.composition import CompositionSpace
-from smol.moca.utils.math import NUM_TOL, compute_snf, integerize_vector
-from smol.moca.utils.occu import get_dim_ids_by_sublattice
+from smol.moca.occu_utils import get_dim_ids_by_sublattice
+from smol.utils.math import NUM_TOL, compute_snf, integerize_vector
 from tests.utils import assert_msonable, assert_table_set_equal
 
 
 @pytest.fixture(scope="module")
 def comp_space(ensemble):
     bits = [s.species for s in ensemble.sublattices]
     sublattice_sizes = np.array([len(s.sites) for s in ensemble.sublattices])
@@ -491,17 +491,17 @@
         n_bad = n + dn
         if len(null_space) > 0 and not np.allclose(
             np.abs(comp_space._A @ (n / supercell_size) - comp_space._b),
             0,
             atol=NUM_TOL,
         ):
             if np.all(n_bad >= 0):
-                print("bad composition:", n_bad)
-                print("A:", comp_space._A)
-                print("b:", comp_space._b * supercell_size)
+                # print("bad composition:", n_bad)
+                # print("A:", comp_space._A)
+                # print("b:", comp_space._b * supercell_size)
                 with pytest.raises(ValueError):
                     _ = comp_space.translate_format(
                         n_bad, supercell_size, from_format="counts", to_format="counts"
                     )
         # Test rounding fails
         dx = np.random.rand(len(comp_space.basis)) + 1e-5
         x_bad = x + dx
```

### Comparing `smol-0.3.1/tests/test_moca/test_ensemble.py` & `smol-0.4.0/tests/test_moca/test_ensemble.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,23 +1,24 @@
 from copy import deepcopy
 from itertools import product
 
 import numpy as np
 import numpy.testing as npt
 import pytest
 
+from smol.capp.generate.random import _gen_unconstrained_ordered_occu
 from smol.cofe import ClusterExpansion, RegressionData
 from smol.moca import (
     ClusterDecompositionProcessor,
     ClusterExpansionProcessor,
     CompositeProcessor,
     Ensemble,
     EwaldProcessor,
 )
-from tests.utils import assert_msonable, gen_random_occupancy
+from tests.utils import assert_msonable
 
 
 @pytest.fixture
 def canonical_ensemble(composite_processor):
     return Ensemble(composite_processor)
 
 
@@ -66,14 +67,22 @@
         EwaldProcessor(
             cluster_subspace_ewald,
             scmatrix,
             cluster_subspace_ewald.external_terms[0],
             coefficient=coefs[-1],
         )
     )
+    reg_data = RegressionData(
+        module="fake.module",
+        estimator_name="Estimator",
+        feature_matrix=rng.random((5, len(coefs))),
+        property_vector=rng.random(len(coefs)),
+        parameters={"foo": "bar"},
+    )
+    expansion = ClusterExpansion(cluster_subspace_ewald, coefs, reg_data)
 
     if ensemble_type == "semigrand":
         species = {sp for space in proc.active_site_spaces for sp in space.keys()}
         chemical_potentials = {sp: 0.3 for sp in species}
         kwargs = {"chemical_potentials": chemical_potentials}
     else:
         kwargs = {}
@@ -119,15 +128,15 @@
 
 
 def test_msonable(ensemble):
     assert_msonable(ensemble)
 
 
 def test_split_ensemble(ensemble, rng):
-    occu = gen_random_occupancy(ensemble.sublattices, rng=rng)
+    occu = _gen_unconstrained_ordered_occu(ensemble.sublattices, rng=rng)
     for sublattice in ensemble.sublattices:
         npt.assert_array_equal(np.arange(len(sublattice.species)), sublattice.encoding)
         # ensemble must have been initialized from default.
     while len(ensemble.active_sublattices) > 0:
         is_active = [s.is_active for s in ensemble.sublattices]
         sl_id = np.random.choice(np.arange(len(is_active), dtype=int)[is_active])
         sublattice = ensemble.sublattices[sl_id]
@@ -204,15 +213,15 @@
                         ensemble._chemical_potentials["table"][sublattice.sites, :], 0
                     )
 
 
 # Canonical Ensemble tests
 def test_compute_feature_vector_canonical(canonical_ensemble, rng):
     processor = canonical_ensemble.processor
-    occu = gen_random_occupancy(canonical_ensemble.sublattices, rng=rng)
+    occu = _gen_unconstrained_ordered_occu(canonical_ensemble.sublattices, rng=rng)
     assert np.dot(
         canonical_ensemble.natural_parameters,
         canonical_ensemble.compute_feature_vector(occu),
     ) == pytest.approx(processor.compute_property(occu))
     npt.assert_array_equal(
         canonical_ensemble.compute_feature_vector(occu),
         canonical_ensemble.processor.compute_feature_vector(occu),
@@ -263,15 +272,15 @@
                 processor.compute_feature_vector_change(occu, flip),
             )
 
 
 # tests for a semigrand ensemble
 def test_compute_feature_vector_sgc(semigrand_ensemble, rng):
     proc = semigrand_ensemble.processor
-    occu = gen_random_occupancy(semigrand_ensemble.sublattices, rng=rng)
+    occu = _gen_unconstrained_ordered_occu(semigrand_ensemble.sublattices, rng=rng)
     chemical_work = sum(
         semigrand_ensemble._chemical_potentials["table"][site][species]
         for site, species in enumerate(occu)
     )
     assert np.dot(
         semigrand_ensemble.natural_parameters,
         semigrand_ensemble.compute_feature_vector(occu),
@@ -337,15 +346,14 @@
                 np.append(proc.compute_feature_vector_change(occu, flip), dmu),
             )
 
 
 def test_bad_chemical_potentials(semigrand_ensemble):
     proc = semigrand_ensemble.processor
     chem_pots = semigrand_ensemble.chemical_potentials
-    print(chem_pots)
     with pytest.raises(ValueError):
         items = list(chem_pots.items())
         semigrand_ensemble.chemical_potentials = {items[0][0]: items[0][1]}
     with pytest.raises(ValueError):
         semigrand_ensemble.chemical_potentials = {"A": 0.5, "D": 0.6}
     with pytest.raises(ValueError):
         chem_pots["foo"] = 0.4
```

### Comparing `smol-0.3.1/tests/test_moca/test_math_utils.py` & `smol-0.4.0/tests/test_utils/test_math_utils.py`

 * *Files 2% similar despite different names*

```diff
@@ -3,15 +3,15 @@
 from fractions import Fraction
 
 import numpy as np
 import numpy.testing as npt
 import polytope as pc
 import pytest
 
-from smol.moca.utils.math import (
+from smol.utils.math import (
     NUM_TOL,
     choose_section_from_partition,
     compute_snf,
     connectivity,
     count_row_matches,
     flip_size,
     flip_weights_mask,
@@ -21,14 +21,15 @@
     get_nonneg_float_vertices,
     get_one_dim_solutions,
     get_optimal_basis,
     integerize_multiple,
     integerize_vector,
     rationalize_number,
     solve_diophantines,
+    yield_hermite_normal_forms,
 )
 from tests.utils import assert_table_set_equal
 
 a1 = [[1, 3, 4, -3, -2], [1, 1, 1, 0, 0], [0, 0, 0, 1, 1]]
 b1 = [0, 1, 1]  # LMTPO, prim
 
 a2 = [
@@ -677,7 +678,17 @@
 
     for i in range(len(p)):
         # assert abs(counts[i] / 10000 - p[i]) <= 0.05
         # May be this is not required as long as you trust
         # np.random
         if i == 1:
             assert counts[i] <= 1
+
+
+@pytest.mark.parametrize("determinant", range(6, 13))
+def test_yield_hermite_normal_forms(determinant):
+    hnfs = [hnf for hnf in yield_hermite_normal_forms(determinant)]
+    for hnf in hnfs:
+        assert np.linalg.det(hnf) == pytest.approx(determinant)
+
+    # make sure that all the HNFs are unique
+    assert len(np.unique(hnfs, axis=0)) == len(hnfs)
```

### Comparing `smol-0.3.1/tests/test_moca/test_mcushers.py` & `smol-0.4.0/tests/test_moca/test_mcushers.py`

 * *Files 2% similar despite different names*

```diff
@@ -3,20 +3,20 @@
 from random import choice, choices
 
 import numpy as np
 import numpy.testing as npt
 import pytest
 from pymatgen.core import Composition
 
+from smol.capp.generate.random import _gen_neutral_occu, _gen_unconstrained_ordered_occu
 from smol.cofe.space.domain import SiteSpace
-from smol.moca.sampler import mcusher
-from smol.moca.sampler.bias import SquareChargeBias
-from smol.moca.sampler.kernel import ALL_MCUSHERS
+from smol.moca.kernel import mcusher
+from smol.moca.kernel.base import ALL_MCUSHERS
+from smol.moca.kernel.bias import SquareChargeBias
 from smol.moca.sublattice import Sublattice
-from tests.utils import gen_random_neutral_occupancy, gen_random_occupancy
 
 mcmcusher_classes = [getattr(mcusher, i) for i in ALL_MCUSHERS]
 num_sites = 100
 
 
 @pytest.fixture
 def all_sublattices(rng):
@@ -51,22 +51,24 @@
     inactive_sublattices = []
     return active_sublattices, inactive_sublattices
 
 
 @pytest.fixture
 def rand_occu(all_sublattices, rng):
     # generate a random occupancy according to the sublattices
-    occu = gen_random_occupancy(all_sublattices[0] + all_sublattices[1], rng=rng)
+    occu = _gen_unconstrained_ordered_occu(
+        all_sublattices[0] + all_sublattices[1], rng=rng
+    )
     return occu, all_sublattices[1][0].sites  # return indices of fixed sites
 
 
 @pytest.fixture
 def rand_occu_lmtpo(all_sublattices_lmtpo, rng):
     # generate a random occupancy according to the sublattices
-    occu = gen_random_neutral_occupancy(
+    occu = _gen_neutral_occu(
         all_sublattices_lmtpo[0] + all_sublattices_lmtpo[1], rng=rng
     )
     return occu, []  # return indices of fixed sites
 
 
 @pytest.fixture(params=mcmcusher_classes)
 def mcmcusher(request, all_sublattices):
```

### Comparing `smol-0.3.1/tests/test_moca/test_occu_utils.py` & `smol-0.4.0/tests/test_moca/test_occu_utils.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,22 +1,22 @@
 """Test smol.moca.utils.occu_utils."""
 import itertools
 
 import numpy as np
 import numpy.testing as npt
 import pytest
 
-from smol.moca.utils.occu import (
+from smol.capp.generate.random import _gen_unconstrained_ordered_occu
+from smol.moca.occu_utils import (
     delta_counts_from_step,
     get_dim_ids_by_sublattice,
     get_dim_ids_table,
     occu_to_counts,
     occu_to_species_list,
 )
-from tests.utils import gen_random_occupancy
 
 
 @pytest.fixture(scope="module")
 def sublattices(ensemble):
     sublattices = ensemble.sublattices
     all_sites = [site for sublatt in sublattices for site in sublatt.sites]
     sites_to_restrict = np.random.choice(
@@ -85,15 +85,15 @@
             )
         npt.assert_array_equal(dim_ids_table_active[sublatt.restricted_sites, :], -1)
 
 
 def test_occu_conversion(sublattices, dim_ids_table_all, dim_ids_table_active, rng):
     d = sum(len(sublatt.species) for sublatt in sublattices)
     for _ in range(10):
-        occu = gen_random_occupancy(sublattices, rng=rng)
+        occu = _gen_unconstrained_ordered_occu(sublattices, rng=rng)
         list_all = occu_to_species_list(occu, d, dim_ids_table_all)
         list_active = occu_to_species_list(occu, d, dim_ids_table_active)
         n_all = occu_to_counts(occu, d, dim_ids_table_all)
         n_active = occu_to_counts(occu, d, dim_ids_table_active)
         npt.assert_array_equal(n_all, [len(sites) for sites in list_all])
         npt.assert_array_equal(n_active, [len(sites) for sites in list_active])
         dim_id = 0
@@ -108,15 +108,15 @@
                     assert len(sites_active) == 0
                 dim_id += 1
 
 
 def test_delta_n(sublattices, dim_ids_table_active, rng):
     # Test a few good steps.
     d = sum(len(sublatt.species) for sublatt in sublattices)
-    occu = gen_random_occupancy(sublattices, rng=rng)
+    occu = _gen_unconstrained_ordered_occu(sublattices, rng=rng)
     all_sites = np.arange(len(occu), dtype=int)
     activeness = np.any(dim_ids_table_active >= 0, axis=-1)
     # An active site must have at least 2 species allowed.
     assert np.all(
         np.sum(dim_ids_table_active[all_sites[activeness], :] >= 0, axis=-1) >= 2
     )
     active_sites = all_sites[activeness]
```

### Comparing `smol-0.3.1/tests/test_moca/test_samplecontainer.py` & `smol-0.4.0/tests/test_moca/test_container.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,20 +1,19 @@
 import os
-from copy import deepcopy
 from itertools import product
 
 import numpy as np
 import numpy.testing as npt
 import pytest
 from pymatgen.core.composition import Composition
 
 from smol.cofe.space.domain import SiteSpace
-from smol.moca.sampler import SampleContainer
-from smol.moca.sampler.namespace import Trace
+from smol.moca import SampleContainer
 from smol.moca.sublattice import Sublattice
+from smol.moca.trace import Trace
 from tests.utils import assert_msonable
 
 NSAMPLES = 100
 # compositions will depend on number of sites and num species in the
 # sublattices created in the fixture, if changing make sure it works out.
 SUBLATTICE_COMPOSITIONS = [1.0 / 3.0, 1.0 / 2.0]
 
@@ -150,20 +149,15 @@
         else:
             assert c.shape == (nsamples * nw, len(sublattice.species))
         npt.assert_array_equal(c, comp * np.ones_like(c))
 
     # get non flattened values
     npt.assert_array_equal(
         container.sampling_efficiency(discard=discard, flat=False),
-        (
-            accepted[
-                discard:,
-            ].sum(axis=0)
-            / (container._total_steps - discard)
-        ),
+        (accepted[discard:,].sum(axis=0) / (container._total_steps - discard)),
     )
     assert container.get_occupancies(
         discard=discard, thin_by=thin, flat=False
     ).shape == (nsamples, nw, nsites)
     assert container.get_feature_vectors(
         discard=discard, thin_by=thin, flat=False
     ).shape == (nsamples, nw, len(nat_params))
@@ -336,23 +330,28 @@
     npt.assert_array_equal(container.get_occupancies(), cntr.get_occupancies())
     npt.assert_array_equal(container.get_energies(), cntr.get_energies())
     os.remove(file_path)
 
 
 @pytest.mark.parametrize("mode", [False, True])
 def test_flush_to_hdf5(container, fake_traces, mode, tmpdir):
-    flushed_container = deepcopy(container)
+    # deepcopy does not work with Cython extensions with nontrivial __cinit__
+    # and creating a new container from dict of an empty one loses shape information
+    # so we add samples first and then create the flushed container, and clear it
     add_samples(container, fake_traces)
+    flushed_container = SampleContainer.from_dict(container.as_dict())
+    flushed_container.clear()
+
     file_path = os.path.join(tmpdir, "test.h5")
     chunk = len(fake_traces) // 4
     flushed_container.allocate(chunk)
     backend = flushed_container.get_backend(file_path, len(fake_traces), swmr_mode=mode)
 
     start = 0
-    for j in range(4):
+    for _ in range(4):
         for i in range(start, start + chunk):
             flushed_container.save_sampled_trace(fake_traces[i], thinned_by=1)
         assert flushed_container._trace.occupancy.shape[0] == chunk
         flushed_container.flush_to_backend(backend)
         start += chunk
 
     if mode is False:
@@ -409,7 +408,20 @@
 
     # check for unflattened chains
     structures_list = container.get_sampled_structures(ids, flat=False)
     for i, structures in zip(ids, structures_list):
         occus = container.get_occupancies(flat=False)[i]
         for occu, struct in zip(occus, structures):
             assert container.ensemble.processor.structure_from_occupancy(occu) == struct
+
+
+def test_allocate_vacuum(container, fake_traces):
+    add_samples(container, fake_traces)
+    n_samples = len(container)
+
+    container.allocate(100)
+    assert len(container) == n_samples
+    assert container._trace.occupancy.shape[0] == n_samples + 100
+
+    container.vacuum()
+    assert len(container) == n_samples
+    assert container._trace.occupancy.shape[0] == n_samples
```

### Comparing `smol-0.3.1/tests/test_moca/test_sampler.py` & `smol-0.4.0/tests/test_moca/test_sampler.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,17 +1,17 @@
 import os
 
 import numpy as np
 import numpy.testing as npt
 import pytest
 
+from smol.capp.generate.random import _gen_unconstrained_ordered_occu
 from smol.moca import SampleContainer, Sampler
-from smol.moca.sampler.kernel import Metropolis
-from smol.moca.sampler.mcusher import Flip, Swap
-from tests.utils import gen_random_occupancy
+from smol.moca.kernel import Metropolis
+from smol.moca.kernel.mcusher import Flip, Swap
 
 TEMPERATURE = 5000
 # Correlations are within ATOL 1E-14, but ewald energies sometimes need more slack
 ATOL = 5e-13  # this is still enough precision anyway
 
 
 @pytest.fixture(params=[1, 5])
@@ -35,15 +35,17 @@
     assert isinstance(sampler.mckernels[0], Metropolis)
 
 
 @pytest.mark.parametrize("thin", (1, 10))
 def test_sample(sampler, thin, rng):
     occu = np.vstack(
         [
-            gen_random_occupancy(sampler.mckernels[0]._usher.sublattices, rng=rng)
+            _gen_unconstrained_ordered_occu(
+                sampler.mckernels[0]._usher.sublattices, rng=rng
+            )
             for _ in range(sampler.samples.shape[0])
         ]
     )
     steps = 1000
     samples = [state for state in sampler.sample(1000, occu, thin_by=thin)]
     assert len(samples) == steps // thin
 
@@ -52,15 +54,15 @@
         next(it)
 
 
 @pytest.mark.parametrize("thin", (1, 10))
 def test_run(sampler, thin, rng):
     occu = np.vstack(
         [
-            gen_random_occupancy(kernel._usher.sublattices, rng=rng)
+            _gen_unconstrained_ordered_occu(kernel._usher.sublattices, rng=rng)
             for kernel in sampler.mckernels
         ]
     )
     steps = 1000
     sampler.run(steps, occu, thin_by=thin)
     assert len(sampler.samples) == steps // thin
     assert 0 <= sampler.efficiency() <= 1
@@ -83,15 +85,17 @@
     sampler.clear_samples()
 
 
 def test_anneal(sampler, rng, tmpdir):
     temperatures = np.linspace(2000, 500, 5)
     occu = np.vstack(
         [
-            gen_random_occupancy(sampler.mckernels[0]._usher.sublattices, rng=rng)
+            _gen_unconstrained_ordered_occu(
+                sampler.mckernels[0]._usher.sublattices, rng=rng
+            )
             for _ in range(sampler.samples.shape[0])
         ]
     )
     steps = 100
     sampler.anneal(temperatures, steps, occu)
     expected = []
     for T in temperatures:
@@ -122,9 +126,9 @@
     # test temp error
     with pytest.raises(ValueError):
         sampler.anneal([100, 200], steps)
 
 
 def test_reshape_occu(ensemble, rng):
     sampler = Sampler.from_ensemble(ensemble, temperature=TEMPERATURE)
-    occu = gen_random_occupancy(ensemble.sublattices, rng=rng)
+    occu = _gen_unconstrained_ordered_occu(ensemble.sublattices, rng=rng)
     assert sampler._reshape_occu(occu).shape == (1, len(occu))
```

### Comparing `smol-0.3.1/tests/test_moca/test_sublattice.py` & `smol-0.4.0/tests/test_moca/test_sublattice.py`

 * *Files identical despite different names*

