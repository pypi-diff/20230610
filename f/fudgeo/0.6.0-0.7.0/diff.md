# Comparing `tmp/fudgeo-0.6.0-py3-none-any.whl.zip` & `tmp/fudgeo-0.7.0-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,23 +1,28 @@
-Zip file size: 35310 bytes, number of entries: 21
--rw-r--r--  2.0 unx      117 b- defN 23-May-22 19:54 fudgeo/__init__.py
--rw-r--r--  2.0 unx     2962 b- defN 23-May-22 19:54 fudgeo/constant.py
--rw-r--r--  2.0 unx     1157 b- defN 23-Jan-04 21:53 fudgeo/enumeration.py
--rw-r--r--  2.0 unx    24486 b- defN 23-May-22 19:54 fudgeo/geopkg.py
+Zip file size: 45555 bytes, number of entries: 26
+-rw-r--r--  2.0 unx      117 b- defN 23-Jun-10 14:29 fudgeo/__init__.py
+-rw-r--r--  2.0 unx     2867 b- defN 23-Jun-09 16:35 fudgeo/constant.py
+-rw-r--r--  2.0 unx     3251 b- defN 23-Jun-10 14:26 fudgeo/enumeration.py
+-rw-r--r--  2.0 unx    24670 b- defN 23-Jun-10 14:26 fudgeo/geopkg.py
 -rw-r--r--  2.0 unx     4118 b- defN 23-May-22 19:54 fudgeo/geopkg.sql
--rw-r--r--  2.0 unx     4772 b- defN 23-May-22 19:54 fudgeo/spatial.py
--rw-r--r--  2.0 unx    12069 b- defN 23-May-22 19:54 fudgeo/sql.py
--rw-r--r--  2.0 unx      974 b- defN 23-May-06 22:48 fudgeo/geometry/__init__.py
+-rw-r--r--  2.0 unx    16316 b- defN 23-Jun-10 14:26 fudgeo/sql.py
+-rw-r--r--  2.0 unx     2057 b- defN 23-Jun-06 00:13 fudgeo/util.py
+-rw-r--r--  2.0 unx       91 b- defN 23-Jun-06 00:13 fudgeo/extension/__init__.py
+-rw-r--r--  2.0 unx    12234 b- defN 23-Jun-10 14:26 fudgeo/extension/metadata.py
+-rw-r--r--  2.0 unx     1127 b- defN 23-Jun-09 16:35 fudgeo/extension/ogr.py
+-rw-r--r--  2.0 unx     8351 b- defN 23-Jun-09 16:35 fudgeo/extension/schema.py
+-rw-r--r--  2.0 unx     5938 b- defN 23-Jun-09 16:35 fudgeo/extension/spatial.py
+-rw-r--r--  2.0 unx      994 b- defN 23-Jun-09 16:35 fudgeo/geometry/__init__.py
 -rw-r--r--  2.0 unx     2042 b- defN 23-May-18 20:08 fudgeo/geometry/base.py
--rw-r--r--  2.0 unx     8502 b- defN 23-May-22 19:54 fudgeo/geometry/linestring.py
--rw-r--r--  2.0 unx     6742 b- defN 23-May-18 20:08 fudgeo/geometry/linestring.pyi
--rw-r--r--  2.0 unx    14814 b- defN 23-May-22 19:54 fudgeo/geometry/point.py
--rw-r--r--  2.0 unx     6409 b- defN 23-May-22 19:54 fudgeo/geometry/point.pyi
--rw-r--r--  2.0 unx    10897 b- defN 23-May-22 19:54 fudgeo/geometry/polygon.py
--rw-r--r--  2.0 unx     9350 b- defN 23-May-18 20:08 fudgeo/geometry/polygon.pyi
--rw-r--r--  2.0 unx    17251 b- defN 23-May-22 19:54 fudgeo/geometry/util.py
--rw-r--r--  2.0 unx     1088 b- defN 23-May-22 21:22 fudgeo-0.6.0.dist-info/LICENSE
--rw-r--r--  2.0 unx    15166 b- defN 23-May-22 21:22 fudgeo-0.6.0.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 23-May-22 21:22 fudgeo-0.6.0.dist-info/WHEEL
--rw-r--r--  2.0 unx        7 b- defN 23-May-22 21:22 fudgeo-0.6.0.dist-info/top_level.txt
--rw-rw-r--  2.0 unx     1650 b- defN 23-May-22 21:22 fudgeo-0.6.0.dist-info/RECORD
-21 files, 144665 bytes uncompressed, 32676 bytes compressed:  77.4%
+-rw-r--r--  2.0 unx     9597 b- defN 23-May-30 14:01 fudgeo/geometry/linestring.py
+-rw-r--r--  2.0 unx     7590 b- defN 23-May-28 12:40 fudgeo/geometry/linestring.pyi
+-rw-r--r--  2.0 unx    16868 b- defN 23-Jun-09 14:27 fudgeo/geometry/point.py
+-rw-r--r--  2.0 unx     7301 b- defN 23-May-28 12:40 fudgeo/geometry/point.pyi
+-rw-r--r--  2.0 unx    12065 b- defN 23-May-30 14:01 fudgeo/geometry/polygon.py
+-rw-r--r--  2.0 unx    10365 b- defN 23-May-28 12:40 fudgeo/geometry/polygon.pyi
+-rw-r--r--  2.0 unx    17499 b- defN 23-May-30 14:01 fudgeo/geometry/util.py
+-rw-r--r--  2.0 unx     1088 b- defN 23-Jun-10 14:35 fudgeo-0.7.0.dist-info/LICENSE
+-rw-r--r--  2.0 unx    23572 b- defN 23-Jun-10 14:35 fudgeo-0.7.0.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 23-Jun-10 14:35 fudgeo-0.7.0.dist-info/WHEEL
+-rw-r--r--  2.0 unx        7 b- defN 23-Jun-10 14:35 fudgeo-0.7.0.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     2064 b- defN 23-Jun-10 14:35 fudgeo-0.7.0.dist-info/RECORD
+26 files, 192281 bytes uncompressed, 42283 bytes compressed:  78.0%
```

## zipnote {}

```diff
@@ -9,18 +9,33 @@
 
 Filename: fudgeo/geopkg.py
 Comment: 
 
 Filename: fudgeo/geopkg.sql
 Comment: 
 
-Filename: fudgeo/spatial.py
+Filename: fudgeo/sql.py
 Comment: 
 
-Filename: fudgeo/sql.py
+Filename: fudgeo/util.py
+Comment: 
+
+Filename: fudgeo/extension/__init__.py
+Comment: 
+
+Filename: fudgeo/extension/metadata.py
+Comment: 
+
+Filename: fudgeo/extension/ogr.py
+Comment: 
+
+Filename: fudgeo/extension/schema.py
+Comment: 
+
+Filename: fudgeo/extension/spatial.py
 Comment: 
 
 Filename: fudgeo/geometry/__init__.py
 Comment: 
 
 Filename: fudgeo/geometry/base.py
 Comment: 
@@ -42,23 +57,23 @@
 
 Filename: fudgeo/geometry/polygon.pyi
 Comment: 
 
 Filename: fudgeo/geometry/util.py
 Comment: 
 
-Filename: fudgeo-0.6.0.dist-info/LICENSE
+Filename: fudgeo-0.7.0.dist-info/LICENSE
 Comment: 
 
-Filename: fudgeo-0.6.0.dist-info/METADATA
+Filename: fudgeo-0.7.0.dist-info/METADATA
 Comment: 
 
-Filename: fudgeo-0.6.0.dist-info/WHEEL
+Filename: fudgeo-0.7.0.dist-info/WHEEL
 Comment: 
 
-Filename: fudgeo-0.6.0.dist-info/top_level.txt
+Filename: fudgeo-0.7.0.dist-info/top_level.txt
 Comment: 
 
-Filename: fudgeo-0.6.0.dist-info/RECORD
+Filename: fudgeo-0.7.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## fudgeo/__init__.py

```diff
@@ -1,11 +1,11 @@
 # -*- coding: utf-8 -*-
 """
 Package Initialization
 """
 
 
-__version__ = '0.6.0'
+__version__ = '0.7.0'
 
 
 if __name__ == '__main__':
     pass
```

## fudgeo/constant.py

```diff
@@ -1,22 +1,26 @@
 # -*- coding: utf-8 -*-
 """
 Constants
 """
 
 
 from struct import pack
-from typing import ClassVar, Dict, List, Set, Tuple, Union
+from typing import Dict, List, Set, Tuple, Union
 
+from fudgeo.enumeration import EnvelopeCode
 
 DOUBLE = Tuple[float, float]
 TRIPLE = Tuple[float, float, float]
 QUADRUPLE = Tuple[float, float, float, float]
 COORDINATES = Union[List[DOUBLE], List[TRIPLE], List[QUADRUPLE]]
 
+COMMA_SPACE: str = ', '
+GPKG_EXT: str = '.gpkg'
+SHAPE: str = 'SHAPE'
 
 WGS84: int = 4326
 
 GP_MAGIC: bytes = b'GP'
 EMPTY: bytes = b''
 BYTE_CODE: str = '<BI'
 COUNT_CODE: str = '<I'
@@ -70,29 +74,17 @@
     (False, True): WKB_POINT_M_PRE,
     (True, True): WKB_POINT_ZM_PRE,
 }
 POINT_PREFIXES: Set[bytes] = {
     WKB_POINT_PRE, WKB_POINT_Z_PRE, WKB_POINT_M_PRE, WKB_POINT_ZM_PRE}
 
 
-class EnvelopeCode:
-    """
-    Envelope Code
-    """
-    empty: ClassVar[int] = 0
-    xy: ClassVar[int] = 1
-    xyz: ClassVar[int] = 2
-    xym: ClassVar[int] = 3
-    xyzm: ClassVar[int] = 4
-# End EnvelopeCode class
-
-
 HEADER_OFFSET: int = 8
 ENVELOPE_LENGTH: Dict[int, int] = {
     EnvelopeCode.empty: 0, EnvelopeCode.xy: 32, EnvelopeCode.xyz: 48,
     EnvelopeCode.xym: 48, EnvelopeCode.xyzm: 64}
 ENVELOPE_COUNT: Dict[int, int] = {k: v // 8 for k, v in ENVELOPE_LENGTH.items()}
 ENVELOPE_OFFSET = {k: v + HEADER_OFFSET for k, v in ENVELOPE_LENGTH.items()}
 
 
-if __name__ == '__main__':
+if __name__ == '__main__':  # pragma: no cover
     pass
```

## fudgeo/enumeration.py

```diff
@@ -1,61 +1,125 @@
 # -*- coding: utf-8 -*-
 """
 Enums
 """
 
 
+from typing import ClassVar
+
+
 class GPKGFlavors:
     """
     Geopackage Flavors mostly meaning which default srs definitions to use.
     Basically which 4326 definition to insert into the SRS table to start with.
     """
-    esri = 'ESRI'
-    epsg = 'EPSG'
+    esri: ClassVar[str] = 'ESRI'
+    epsg: ClassVar[str] = 'EPSG'
 # End GPKGFlavors class
 
 
 class DataType:
     """
     Allowed Data Type values
     """
-    features = 'features'
-    attributes = 'attributes'
-    tiles = 'tiles'
+    features: ClassVar[str] = 'features'
+    attributes: ClassVar[str] = 'attributes'
+    tiles: ClassVar[str] = 'tiles'
 # End DataType class
 
 
 class GeometryType:
     """
     Allowed Geometry Type values
     """
-    point = 'POINT'
-    linestring = 'LINESTRING'
-    polygon = 'POLYGON'
-    multi_point = 'MULTIPOINT'
-    multi_linestring = 'MULTILINESTRING'
-    multi_polygon = 'MULTIPOLYGON'
+    point: ClassVar[str] = 'POINT'
+    linestring: ClassVar[str] = 'LINESTRING'
+    polygon: ClassVar[str] = 'POLYGON'
+    multi_point: ClassVar[str] = 'MULTIPOINT'
+    multi_linestring: ClassVar[str] = 'MULTILINESTRING'
+    multi_polygon: ClassVar[str] = 'MULTIPOLYGON'
 # End GeometryType class
 
 
 class SQLFieldType(GeometryType):
     """
     SQL Field Types
     """
-    boolean = 'BOOLEAN'
-    tinyint = 'TINYINT'
-    smallint = 'SMALLINT'
-    mediumint = 'MEDIUMINT'
-    integer = 'INTEGER'
-    float = 'FLOAT'
-    double = 'DOUBLE'
-    real = 'REAL'
-    text = 'TEXT'
-    blob = 'BLOB'
-    date = 'DATE'
-    timestamp = 'TIMESTAMP'
-    datetime = 'DATETIME'
+    boolean: ClassVar[str] = 'BOOLEAN'
+    tinyint: ClassVar[str] = 'TINYINT'
+    smallint: ClassVar[str] = 'SMALLINT'
+    mediumint: ClassVar[str] = 'MEDIUMINT'
+    integer: ClassVar[str] = 'INTEGER'
+    float: ClassVar[str] = 'FLOAT'
+    double: ClassVar[str] = 'DOUBLE'
+    real: ClassVar[str] = 'REAL'
+    text: ClassVar[str] = 'TEXT'
+    blob: ClassVar[str] = 'BLOB'
+    date: ClassVar[str] = 'DATE'
+    timestamp: ClassVar[str] = 'TIMESTAMP'
+    datetime: ClassVar[str] = 'DATETIME'
 # End SQLFieldType class
 
 
-if __name__ == '__main__':
+class EnvelopeCode:
+    """
+    Envelope Code
+    """
+    empty: ClassVar[int] = 0
+    xy: ClassVar[int] = 1
+    xyz: ClassVar[int] = 2
+    xym: ClassVar[int] = 3
+    xyzm: ClassVar[int] = 4
+# End EnvelopeCode class
+
+
+class MetadataScope:
+    """
+    Metadata Scope
+    """
+    attribute: ClassVar[str] = 'attribute'
+    attribute_type: ClassVar[str] = 'attributeType'
+    catalog: ClassVar[str] = 'catalog'
+    collection_hardware: ClassVar[str] = 'collectionHardware'
+    collection_session: ClassVar[str] = 'collectionSession'
+    dataset: ClassVar[str] = 'dataset'
+    dimension_group: ClassVar[str] = 'dimensionGroup'
+    feature: ClassVar[str] = 'feature'
+    feature_type: ClassVar[str] = 'featureType'
+    field_session: ClassVar[str] = 'fieldSession'
+    model: ClassVar[str] = 'model'
+    non_geographic_dataset: ClassVar[str] = 'nonGeographicDataset'
+    schema: ClassVar[str] = 'schema'
+    series: ClassVar[str] = 'series'
+    service: ClassVar[str] = 'service'
+    software: ClassVar[str] = 'software'
+    style: ClassVar[str] = 'style'
+    taxonomy: ClassVar[str] = 'taxonomy'
+    tile: ClassVar[str] = 'tile'
+    undefined: ClassVar[str] = 'undefined'
+# End MetadataScope class
+
+
+class MetadataReferenceScope:
+    """
+    Metadata Reference Scope
+    """
+    geopackage: ClassVar[str] = 'geopackage'
+    table: ClassVar[str] = 'table'
+    column: ClassVar[str] = 'column'
+    row: ClassVar[str] = 'row'
+    row_col: ClassVar[str] = 'row/col'
+# End MetadataReferenceScope class
+
+
+class ConstraintType:
+    """
+    Constraint Type
+    """
+    enum: ClassVar[str] = 'enum'
+    glob: ClassVar[str] = 'glob'
+    range_: ClassVar[str] = 'range'
+# End ConstraintType class
+
+
+if __name__ == '__main__':  # pragma: no cover
     pass
```

## fudgeo/geopkg.py

```diff
@@ -1,128 +1,62 @@
 # -*- coding: utf-8 -*-
 """
 Geopackage
 """
 
 
-from datetime import datetime, timedelta, timezone
 from math import nan
 from os import PathLike
 from pathlib import Path
-from re import IGNORECASE, compile as recompile
 from sqlite3 import (
-    DatabaseError, IntegrityError, OperationalError, PARSE_COLNAMES,
-    PARSE_DECLTYPES, connect, register_adapter, register_converter)
-from typing import (
-    Callable, Dict, List, Optional, TYPE_CHECKING, Tuple, Type, Union)
-
-from fudgeo.enumeration import (
-    DataType, GPKGFlavors, GeometryType, SQLFieldType)
+    PARSE_COLNAMES, PARSE_DECLTYPES, connect, register_adapter,
+    register_converter)
+from typing import Dict, List, Optional, TYPE_CHECKING, Tuple, Type, Union
+
+from fudgeo.constant import COMMA_SPACE, GPKG_EXT, SHAPE
+from fudgeo.enumeration import DataType, GPKGFlavors, GeometryType, SQLFieldType
+from fudgeo.extension.metadata import (
+    Metadata, add_metadata_extension, has_metadata_extension)
+from fudgeo.extension.ogr import add_ogr_contents, has_ogr_contents
+from fudgeo.extension.schema import (
+    Schema, add_schema_extension, has_schema_extension)
+from fudgeo.extension.spatial import ST_FUNCS, add_spatial_index
 from fudgeo.geometry import (
-    Point, PointZ, PointM, PointZM, MultiPoint, MultiPointZ, MultiPointM,
-    MultiPointZM, LineString, LineStringZ, LineStringM, LineStringZM,
-    MultiLineString, MultiLineStringZ, MultiLineStringM, MultiLineStringZM,
-    Polygon, PolygonZ, PolygonM, PolygonZM, MultiPolygon, MultiPolygonZ,
-    MultiPolygonM, MultiPolygonZM)
-from fudgeo.spatial import ST_FUNCS
+    LineString, LineStringM, LineStringZ, LineStringZM, MultiLineString,
+    MultiLineStringM, MultiLineStringZ, MultiLineStringZM, MultiPoint,
+    MultiPointM, MultiPointZ, MultiPointZM, MultiPolygon, MultiPolygonM,
+    MultiPolygonZ, MultiPolygonZM, Point, PointM, PointZ, PointZM, Polygon,
+    PolygonM, PolygonZ, PolygonZM)
 from fudgeo.sql import (
     CHECK_SRS_EXISTS, CREATE_FEATURE_TABLE, CREATE_OGR_CONTENTS, CREATE_TABLE,
-    DEFAULT_EPSG_RECS, DEFAULT_ESRI_RECS, DELETE_OGR_CONTENTS,
-    GPKG_OGR_CONTENTS_DELETE_TRIGGER, GPKG_OGR_CONTENTS_INSERT_TRIGGER,
-    HAS_OGR_CONTENTS, INSERT_GPKG_CONTENTS_SHORT, INSERT_GPKG_GEOM_COL,
-    INSERT_GPKG_OGR_CONTENTS, INSERT_GPKG_SRS, KEYWORDS, REMOVE_FEATURE_CLASS,
-    REMOVE_TABLE, SELECT_EXTENT, SELECT_GEOMETRY_COLUMN, SELECT_GEOMETRY_TYPE,
-    SELECT_HAS_ZM, SELECT_SRS, SELECT_TABLES_BY_TYPE,
-    SPATIAL_INDEX_CREATE_TABLE, SPATIAL_INDEX_EXTENSION, SPATIAL_INDEX_INSERT,
-    SPATIAL_INDEX_RECORD, SPATIAL_INDEX_TRIGGERS, TABLE_EXISTS, UPDATE_EXTENT)
+    DEFAULT_EPSG_RECS, DEFAULT_ESRI_RECS, DELETE_DATA_COLUMNS,
+    DELETE_METADATA_REFERENCE, DELETE_OGR_CONTENTS, INSERT_GPKG_CONTENTS_SHORT,
+    INSERT_GPKG_GEOM_COL, INSERT_GPKG_SRS, REMOVE_FEATURE_CLASS, REMOVE_TABLE,
+    SELECT_COUNT, SELECT_EXTENT, SELECT_GEOMETRY_COLUMN, SELECT_GEOMETRY_TYPE,
+    SELECT_HAS_ZM, SELECT_PRIMARY_KEY, SELECT_SRS, SELECT_TABLES_BY_TYPE,
+    TABLE_EXISTS, UPDATE_EXTENT)
+from fudgeo.util import convert_datetime, escape_name, now
 
 
 if TYPE_CHECKING:
     from sqlite3 import Connection, Cursor
     from fudgeo.geometry.base import AbstractGeometry
 
 
 FIELDS = Union[Tuple['Field', ...], List['Field']]
-NAME_MATCHER: Callable = recompile(r'^[A-Z]\w*$', IGNORECASE).match
-
-
-COMMA_SPACE: str = ', '
-GPKG_EXT: str = '.gpkg'
-SHAPE: str = 'SHAPE'
-
-
-def _escape_name(name: str) -> str:
-    """
-    Escape Name
-    """
-    if name.upper() in KEYWORDS or not NAME_MATCHER(name):
-        name = f'"{name}"'
-    return name
-# End _escape_name function
-
-
-def _now() -> str:
-    """
-    Formatted Now
-    """
-    return datetime.now().strftime('%Y-%m-%dT%H:%M:%S.%fZ')
-# End _now method
 
 
 def _adapt_geometry(val: 'AbstractGeometry') -> bytes:
     """
     Adapt Geometry to Geopackage
     """
     return val.to_gpkg()
 # End _adapt_geometry function
 
 
-def _convert_datetime(val: bytes) -> datetime:
-    """
-    Heavily Influenced by convert_timestamp from ../sqlite3/dbapi2.py,
-    Added in support for timezone handling although the practice should
-    be to resolve to UTC.
-    """
-    colon = b':'
-    dash = b'-'
-    # NOTE To split timestamps like that b'2022-09-06T13:50:33'
-    for separator in (b' ', b'T'):
-        try:
-            dt, tm = val.split(separator)
-            break
-        except ValueError:
-            pass
-    else:
-        raise Exception(f"Could not split datetime: '{val}'")
-    year, month, day = map(int, dt.split(dash))
-    tm, *micro = tm.split(b'.')
-    tz = []
-    factor = 0
-    for token, scale in zip((b'+', dash), (1, -1)):
-        if token in tm:
-            tm, *tz = tm.split(token)
-            factor = scale
-            break
-    hours, minutes, seconds = map(int, tm.split(colon))
-    try:
-        micro = int('{:0<6.6}'.format(micro[0].decode())) if micro else 0
-    except (ValueError, TypeError):
-        micro = 0
-    if tz:
-        tz_hr, *tz_min = map(int, tz[0].split(colon))
-        tz_min = tz_min[0] if tz_min else 0
-        tzinfo = timezone(timedelta(
-            hours=factor * tz_hr, minutes=factor * tz_min))
-    else:
-        tzinfo = None
-    return datetime(year, month, day, hours, minutes, seconds,
-                    micro, tzinfo=tzinfo)
-# End _convert_datetime function
-
-
 def _register_geometry() -> None:
     """
     Register adapters and converters for geometry / geopackage
     """
     classes = (
         Point, PointZ, PointM, PointZM, MultiPoint, MultiPointZ, MultiPointM,
         MultiPointZM, LineString, LineStringZ, LineStringM, LineStringZM,
@@ -177,25 +111,26 @@
         """
         Connection
         """
         if self._conn is None:
             self._conn = connect(
                 str(self._path), isolation_level='EXCLUSIVE',
                 detect_types=PARSE_DECLTYPES | PARSE_COLNAMES)
+            self._conn.execute("""PRAGMA foreign_keys = true""")
             _register_geometry()
             _add_st_functions(self._conn)
-            register_converter('timestamp', _convert_datetime)
-            register_converter('datetime', _convert_datetime)
+            register_converter('timestamp', convert_datetime)
+            register_converter('datetime', convert_datetime)
         return self._conn
     # End connection property
 
     @classmethod
-    def create(cls, path: Union[PathLike, str],
-               flavor: str = GPKGFlavors.esri,
-               ogr_contents: bool = False) -> 'GeoPackage':
+    def create(cls, path: Union[PathLike, str], flavor: str = GPKGFlavors.esri,
+               ogr_contents: bool = False, enable_metadata: bool = False,
+               enable_schema: bool = False) -> 'GeoPackage':
         """
         Create a new GeoPackage
         """
         path = Path(path).with_suffix(GPKG_EXT)
         if path.is_file():
             raise ValueError(f'GeoPackage already exists: {path}')
         if not path.parent.is_dir():
@@ -206,26 +141,80 @@
             defaults = DEFAULT_EPSG_RECS
         with connect(str(path), isolation_level='EXCLUSIVE') as conn:
             with Path(__file__).parent.joinpath('geopkg.sql').open() as fin:
                 conn.executescript(fin.read())
             conn.executemany(INSERT_GPKG_SRS, defaults)
             if ogr_contents:
                 conn.execute(CREATE_OGR_CONTENTS)
+            if enable_metadata:
+                add_metadata_extension(conn)
+            if enable_schema:
+                add_schema_extension(conn)
         return cls(path)
     # End create method
 
+    def add_spatial_reference(self, srs: 'SpatialReferenceSystem') -> None:
+        """
+        Add Spatial Reference
+        """
+        if self.check_srs_exists(srs.srs_id):
+            return
+        with self.connection as conn:
+            conn.execute(INSERT_GPKG_SRS, srs.as_record())
+    # End add_spatial_reference method
+
     def check_srs_exists(self, srs_id: int) -> bool:
         """
         Check if a SpatialReferenceSystem already exists in the table.
-        This is done purely by srs id because that is all ESRI looks at.
+        Done purely by srs id here but could be done via wkt on definition.
         """
         cursor = self.connection.execute(CHECK_SRS_EXISTS, (srs_id,))
         return bool(cursor.fetchall())
     # End check_srs_exists method
 
+    def enable_metadata_extension(self) -> bool:
+        """
+        Enable Metadata Extension in the Geopackage.  Short circuit if
+        already enabled.
+        """
+        if self.is_metadata_enabled:
+            return True
+        with self.connection as conn:
+            add_metadata_extension(conn=conn)
+        return True
+    # End enable_metadata_extension method
+
+    def enable_schema_extension(self) -> bool:
+        """
+        Enable Schema Extension in the Geopackage.  Short circuit if
+        already enabled.
+        """
+        if self.is_schema_enabled:
+            return True
+        with self.connection as conn:
+            add_schema_extension(conn=conn)
+        return True
+    # End enable_schema_extension method
+
+    @property
+    def is_metadata_enabled(self) -> bool:
+        """
+        Is Metadata Extension Enabled
+        """
+        return has_metadata_extension(self.connection)
+    # End is_metadata_enabled property
+
+    @property
+    def is_schema_enabled(self) -> bool:
+        """
+        Is Schema Extension Enabled
+        """
+        return has_schema_extension(self.connection)
+    # End is_schema_enabled property
+
     def _check_table_exists(self, table_name: str) -> bool:
         """
         Check existence of table
         """
         cursor = self.connection.execute(TABLE_EXISTS, (table_name,))
         return bool(cursor.fetchall())
     # End _check_table_exists method
@@ -293,14 +282,34 @@
         """
         Get Table Objects
         """
         cursor = self.connection.execute(
             SELECT_TABLES_BY_TYPE, (data_type,))
         return {name: cls(self, name) for name, in cursor.fetchall()}
     # End _get_table_objects method
+
+    @property
+    def metadata(self) -> Optional[Metadata]:
+        """
+        Metadata for the Geopackage, None if Metadata extension not enabled.
+        """
+        if not self.is_metadata_enabled:
+            return
+        return Metadata(geopackage=self)
+    # End metadata property
+
+    @property
+    def schema(self) -> Optional[Schema]:
+        """
+        Schema for the Geopackage, None if Schema extension not enabled.
+        """
+        if not self.is_schema_enabled:
+            return
+        return Schema(geopackage=self)
+    # End schema property
 # End GeoPackage class
 
 
 class BaseTable:
     """
     Base Geopackage Table
     """
@@ -321,52 +330,54 @@
         if not fields:
             return ''
         return f'{COMMA_SPACE}{COMMA_SPACE.join(repr(f) for f in fields)}'
     # End _column_names method
 
     @staticmethod
     def _drop(conn: 'Connection', sql: str, name: str, escaped_name: str,
-              geom_name: str, has_ogr_contents: bool) -> None:
+              geom_name: str, delete_ogr_contents: bool,
+              delete_metadata: bool, delete_schema: bool) -> None:
         """
         Drop Table from Geopackage
         """
         conn.executescript(sql.format(name, escaped_name, geom_name))
-        if has_ogr_contents:
+        if delete_ogr_contents:
             conn.execute(DELETE_OGR_CONTENTS.format(name))
+        if delete_metadata:
+            conn.execute(DELETE_METADATA_REFERENCE.format(name))
+        if delete_schema:
+            conn.execute(DELETE_DATA_COLUMNS.format(name))
     # End _drop method
 
     @property
     def count(self) -> int:
         """
         Number of records
         """
         cursor = self.geopackage.connection.execute(
-            f"""SELECT COUNT(1) AS C FROM {self.escaped_name}""")
+            SELECT_COUNT.format(self.escaped_name))
         count, = cursor.fetchone()
         return count
     # End count property
 
     @property
     def escaped_name(self) -> str:
         """
         Escaped Name
         """
-        return _escape_name(self.name)
+        return escape_name(self.name)
     # End escaped_name property
 
     @property
     def primary_key_field(self) -> Optional['Field']:
         """
         Primary Key Field
         """
-        cursor = self.geopackage.connection.execute(f"""
-            SELECT name, type
-            FROM pragma_table_info('{self.name}')
-            WHERE upper(type) = '{SQLFieldType.integer}' AND 
-                  "notnull" = 1 AND pk = 1""")
+        cursor = self.geopackage.connection.execute(
+            SELECT_PRIMARY_KEY.format(self.name, SQLFieldType.integer))
         result = cursor.fetchone()
         if not result:
             return
         return Field(*result)
     # End primary_key_field property
 
     @property
@@ -405,37 +416,41 @@
     def create(cls, geopackage: GeoPackage, name: str, fields: FIELDS,
                description: str = '', overwrite: bool = False) -> 'Table':
         """
         Create a regular non-spatial table in the geopackage
         """
         cols = cls._column_names(fields)
         with geopackage.connection as conn:
-            escaped_name = _escape_name(name)
-            has_ogr_contents = _has_ogr_contents(conn)
+            escaped_name = escape_name(name)
+            has_contents = has_ogr_contents(conn)
             if overwrite:
                 cls._drop(conn=conn, sql=REMOVE_TABLE, geom_name='',
                           name=name, escaped_name=escaped_name,
-                          has_ogr_contents=has_ogr_contents)
+                          delete_ogr_contents=has_contents,
+                          delete_metadata=geopackage.is_metadata_enabled,
+                          delete_schema=geopackage.is_schema_enabled)
             conn.execute(CREATE_TABLE.format(
                 name=escaped_name, other_fields=cols))
             conn.execute(INSERT_GPKG_CONTENTS_SHORT, (
-                name, DataType.attributes, name, description, _now(), None))
-            if has_ogr_contents:
-                _add_ogr_contents(conn, name=name, escaped_name=escaped_name)
+                name, DataType.attributes, name, description, now(), None))
+            if has_contents:
+                add_ogr_contents(conn, name=name, escaped_name=escaped_name)
         return cls(geopackage=geopackage, name=name)
     # End create method
 
     def drop(self) -> None:
         """
         Drop table from Geopackage
         """
         with self.geopackage.connection as conn:
             self._drop(conn=conn, sql=REMOVE_TABLE, geom_name='',
                        name=self.name, escaped_name=self.escaped_name,
-                       has_ogr_contents=_has_ogr_contents(conn))
+                       delete_ogr_contents=has_ogr_contents(conn),
+                       delete_metadata=self.geopackage.is_metadata_enabled,
+                       delete_schema=self.geopackage.is_schema_enabled)
     # End drop method
 # End Table class
 
 
 class FeatureClass(BaseTable):
     """
     GeoPackage Feature Class
@@ -464,63 +479,66 @@
     def add_spatial_index(self) -> bool:
         """
         Add Spatial Index if does not already exist
         """
         if self.has_spatial_index:
             return False
         with self.geopackage.connection as conn:
-            _add_spatial_index(conn=conn, feature_class=self)
+            add_spatial_index(conn=conn, feature_class=self)
         return True
     # End add_spatial_index method
 
     @classmethod
     def create(cls, geopackage: GeoPackage, name: str, shape_type: str,
                srs: 'SpatialReferenceSystem', z_enabled: bool = False,
                m_enabled: bool = False, fields: FIELDS = (),
                description: str = '', overwrite: bool = False,
                spatial_index: bool = False) -> 'FeatureClass':
         """
         Create Feature Class
         """
         cols = cls._column_names(fields)
         with geopackage.connection as conn:
-            escaped_name = _escape_name(name)
-            has_ogr_contents = _has_ogr_contents(conn)
+            escaped_name = escape_name(name)
+            has_contents = has_ogr_contents(conn)
             if overwrite:
                 geom_name = cls._find_geometry_column_name(geopackage, name)
                 cls._drop(conn=conn, sql=REMOVE_FEATURE_CLASS,
                           name=name, escaped_name=escaped_name,
-                          geom_name=geom_name,
-                          has_ogr_contents=has_ogr_contents)
+                          geom_name=geom_name, delete_ogr_contents=has_contents,
+                          delete_metadata=geopackage.is_metadata_enabled,
+                          delete_schema=geopackage.is_schema_enabled)
             conn.execute(CREATE_FEATURE_TABLE.format(
                 name=escaped_name, feature_type=shape_type, other_fields=cols))
             if not geopackage.check_srs_exists(srs.srs_id):
                 conn.execute(INSERT_GPKG_SRS, srs.as_record())
+            conn.execute(INSERT_GPKG_CONTENTS_SHORT, (
+                name, DataType.features, name, description, now(), srs.srs_id))
             conn.execute(INSERT_GPKG_GEOM_COL,
                          (name, SHAPE, shape_type, srs.srs_id,
                           int(z_enabled), int(m_enabled)))
-            conn.execute(INSERT_GPKG_CONTENTS_SHORT, (
-                name, DataType.features, name, description, _now(), srs.srs_id))
-            if has_ogr_contents:
-                _add_ogr_contents(conn, name=name, escaped_name=escaped_name)
+            if has_contents:
+                add_ogr_contents(conn, name=name, escaped_name=escaped_name)
             feature_class = cls(geopackage=geopackage, name=name)
             if spatial_index:
-                _add_spatial_index(conn=conn, feature_class=feature_class)
+                add_spatial_index(conn=conn, feature_class=feature_class)
         return feature_class
     # End create method
 
     def drop(self) -> None:
         """
         Drop feature class from Geopackage
         """
         with self.geopackage.connection as conn:
             self._drop(conn=conn, sql=REMOVE_FEATURE_CLASS,
                        geom_name=self.geometry_column_name,
                        name=self.name, escaped_name=self.escaped_name,
-                       has_ogr_contents=_has_ogr_contents(conn))
+                       delete_ogr_contents=has_ogr_contents(conn),
+                       delete_metadata=self.geopackage.is_metadata_enabled,
+                       delete_schema=self.geopackage.is_schema_enabled)
     # End drop method
 
     @staticmethod
     def _check_result(cursor: 'Cursor') -> Optional[str]:
         """
         Check Result
         """
@@ -581,20 +599,38 @@
         cursor = self.geopackage.connection.execute(
             SELECT_HAS_ZM, (self.name,))
         _, m = cursor.fetchone()
         return bool(m)
     # End has_m property
 
     @property
+    def spatial_index_name(self) -> Optional[str]:
+        """
+        Spatial Index Name (escaped) if present, None otherwise
+        """
+        if not self.has_spatial_index:
+            return
+        return escape_name(self._spatial_index_name)
+    # End spatial_index_name property
+
+    @property
+    def _spatial_index_name(self) -> str:
+        """
+        Spatial Index Name
+        """
+        return f'rtree_{self.name}_{self.geometry_column_name}'
+    # End _spatial_index_name property
+
+    @property
     def has_spatial_index(self) -> bool:
         """
         Has Spatial Index
         """
-        table_name = f'rtree_{self.name}_{self.geometry_column_name}'
-        cursor = self.geopackage.connection.execute(TABLE_EXISTS, (table_name,))
+        cursor = self.geopackage.connection.execute(
+            TABLE_EXISTS, (self._spatial_index_name,))
         return bool(cursor.fetchall())
     # End has_spatial_index property
 
     @property
     def extent(self) -> Tuple[float, float, float, float]:
         """
         Extent property
@@ -677,67 +713,24 @@
     # End init built-in
 
     @property
     def escaped_name(self) -> str:
         """
         Escaped Name, only adds quotes if needed
         """
-        return _escape_name(self.name)
+        return escape_name(self.name)
     # End escaped_name property
 
     def __repr__(self) -> str:
         """
         String representation
         """
         types = SQLFieldType.blob, SQLFieldType.text
         if self.size and self.data_type in types:
             return f'{self.escaped_name} {self.data_type}{self.size}'
         return f'{self.escaped_name} {self.data_type}'
     # End repr built-in
 # End Field class
 
 
-def _has_ogr_contents(conn: 'Connection') -> bool:
-    """
-    Has gpkg_ogr_contents table
-    """
-    try:
-        cursor = conn.execute(HAS_OGR_CONTENTS)
-    except (DatabaseError, OperationalError):
-        return False
-    return bool(cursor.fetchone())
-# End _has_ogr_contents function
-
-
-def _add_ogr_contents(conn: 'Connection', name: str, escaped_name: str) -> None:
-    """
-    Add OGR Contents Table Entry and Triggers
-    """
-    conn.execute(INSERT_GPKG_OGR_CONTENTS, (name, 0))
-    conn.execute(GPKG_OGR_CONTENTS_INSERT_TRIGGER.format(name, escaped_name))
-    conn.execute(GPKG_OGR_CONTENTS_DELETE_TRIGGER.format(name, escaped_name))
-# End _add_ogr_contents function
-
-
-def _add_spatial_index(conn: 'Connection', feature_class: FeatureClass) -> None:
-    """
-    Add Spatial Index Table, Table Entry, and Triggers.  Load Spatial Index
-    Table if Feature Class has features.
-    """
-    name = feature_class.name
-    geom_name = feature_class.geometry_column_name
-    pk_name = feature_class.primary_key_field.escaped_name
-    record = name, geom_name, *SPATIAL_INDEX_RECORD
-    conn.execute(SPATIAL_INDEX_CREATE_TABLE.format(name, geom_name))
-    conn.executescript(SPATIAL_INDEX_TRIGGERS.format(name, geom_name, pk_name))
-    try:
-        conn.execute(SPATIAL_INDEX_EXTENSION, record)
-    except IntegrityError:
-        pass
-    if not feature_class.count:
-        return
-    conn.execute(SPATIAL_INDEX_INSERT.format(name, geom_name, pk_name))
-# End _add_spatial_index function
-
-
-if __name__ == '__main__':
+if __name__ == '__main__':  # pragma: no cover
     pass
```

## fudgeo/sql.py

```diff
@@ -26,14 +26,18 @@
     'REINDEX', 'RELEASE', 'RENAME', 'REPLACE', 'RESTRICT', 'RETURNING', 'RIGHT',
     'ROLLBACK', 'ROW', 'ROWS', 'SAVEPOINT', 'SELECT', 'SET', 'TABLE', 'TEMP',
     'TEMPORARY', 'THEN', 'TIES', 'TO', 'TRANSACTION', 'TRIGGER', 'UNBOUNDED',
     'UNION', 'UNIQUE', 'UPDATE', 'USING', 'VACUUM', 'VALUES', 'VIEW', 'VIRTUAL',
     'WHEN', 'WHERE', 'WINDOW', 'WITH', 'WITHOUT'
 }
 
+
+ROOT: str = 'https://www.geopackage.org/spec131/'
+
+
 INSERT_GPKG_CONTENTS_SHORT: str = """
     INSERT INTO gpkg_contents (
         table_name, data_type, identifier, description, last_change, srs_id) 
     VALUES (?, ?, ?, ?, ?, ?)
 """
 
 
@@ -53,22 +57,35 @@
 HAS_OGR_CONTENTS: str = """
     SELECT name FROM sqlite_master 
     WHERE type = 'table' AND name = 'gpkg_ogr_contents'
 """
 
 
 DELETE_OGR_CONTENTS: str = """
-    DELETE FROM gpkg_ogr_contents WHERE lower(table_name) = lower('{0}');
+    DELETE FROM gpkg_ogr_contents 
+    WHERE lower(table_name) = lower('{0}');
+"""
+
+
+DELETE_METADATA_REFERENCE: str = """
+    DELETE FROM gpkg_metadata_reference 
+    WHERE lower(table_name) = lower('{0}');
+"""
+
+
+DELETE_DATA_COLUMNS: str = """
+    DELETE FROM gpkg_data_columns 
+    WHERE lower(table_name) = lower('{0}');
 """
 
 
 # NOTE 0 - table name, 1 - escaped name, 2 - geometry column name
 REMOVE_FEATURE_CLASS: str = """
-    DELETE FROM gpkg_contents WHERE lower(table_name) = lower('{0}');
     DELETE FROM gpkg_geometry_columns WHERE lower(table_name) = lower('{0}');
+    DELETE FROM gpkg_contents WHERE lower(table_name) = lower('{0}');
     DELETE FROM gpkg_extensions 
     WHERE lower(table_name) = lower('{0}') AND 
           lower(extension_name) = 'gpkg_rtree_index';
     DROP TRIGGER IF EXISTS "trigger_insert_feature_count_{0}";
     DROP TRIGGER IF EXISTS "trigger_delete_feature_count_{0}";
     DROP TRIGGER IF EXISTS "rtree_{0}_{2}_insert";
     DROP TRIGGER IF EXISTS "rtree_{0}_{2}_update1";
@@ -112,23 +129,22 @@
         table_name, column_name, geometry_type_name, srs_id, z, m) 
     VALUES (?, ?, ?, ?, ?, ?)
 """
 
 
 CREATE_FEATURE_TABLE: str = """
     CREATE TABLE {name} (
-        fid INTEGER not null primary key autoincrement, 
+        fid INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT, 
         SHAPE {feature_type}{other_fields})
 """
 
 
 CREATE_TABLE: str = """
     CREATE TABLE {name} (
-        fid INTEGER not null 
-        primary key autoincrement  
+        fid INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT  
         {other_fields})
 """
 
 
 INSERT_GPKG_SRS: str = """
     INSERT INTO gpkg_spatial_ref_sys (
         srs_name, srs_id, organization, organization_coordsys_id, 
@@ -227,14 +243,24 @@
 SELECT_TABLES_BY_TYPE: str = """
     SELECT table_name 
     FROM gpkg_contents 
     WHERE data_type = ?
 """
 
 
+SELECT_COUNT: str = """SELECT COUNT(1) AS C FROM {}"""
+
+
+SELECT_PRIMARY_KEY: str = """
+    SELECT name, type
+    FROM pragma_table_info('{}')
+    WHERE upper(type) = '{}' AND "notnull" = 1 AND pk = 1
+"""
+
+
 DEFAULT_SRS_RECS: Tuple[Tuple[str, int, str, int, str, str], ...] = (
     ('Undefined Cartesian SRS', -1, 'NONE', -1, 'undefined',
      'undefined cartesian coordinate reference system'),
     ('Undefined Geographic SRS', 0, 'NONE', 0, 'undefined',
      'undefined geographic coordinate reference system'))
 
 
@@ -335,20 +361,145 @@
       WHEN OLD."{1}" NOT NULL
     BEGIN
       DELETE FROM "rtree_{0}_{1}" WHERE id = OLD."{2}";
     END;
 """
 
 
-SPATIAL_INDEX_EXTENSION: str = """
+INSERT_EXTENSION: str = """
     INSERT INTO gpkg_extensions (table_name, column_name, extension_name, 
                                  definition, scope) VALUES (?, ?, ?, ?, ?)
 """
 
 
 SPATIAL_INDEX_RECORD: Tuple[str, str, str] = (
-    'gpkg_rtree_index', 'https://www.geopackage.org/spec131/#extension_rtree',
-    'write-only')
+    'gpkg_rtree_index', f'{ROOT}#extension_rtree', 'write-only')
+
+
+CREATE_METADATA: str = """
+    CREATE TABLE gpkg_metadata (
+        id              INTEGER PRIMARY KEY AUTOINCREMENT,
+        md_scope        TEXT NOT NULL DEFAULT 'dataset',
+        md_standard_uri TEXT NOT NULL,
+        mime_type       TEXT NOT NULL DEFAULT 'text/xml',
+        metadata        TEXT NOT NULL DEFAULT ''
+    );
+"""
+
+
+CREATE_METADATA_REFERENCE: str = """
+    CREATE TABLE gpkg_metadata_reference (
+        reference_scope TEXT     NOT NULL,
+        table_name      TEXT,
+        column_name     TEXT,
+        row_id_value    INTEGER,
+        timestamp       DATETIME NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%S.%fZ', 'now')),
+        md_file_id      INTEGER  NOT NULL,
+        md_parent_id    INTEGER,
+        CONSTRAINT crmr_mfi_fk FOREIGN KEY (md_file_id) REFERENCES gpkg_metadata (id),
+        CONSTRAINT crmr_mpi_fk FOREIGN KEY (md_parent_id) REFERENCES gpkg_metadata (id)
+    );
+"""
+
+
+HAS_METADATA: str = """
+    SELECT name FROM sqlite_master 
+    WHERE type = 'table' AND 
+          name IN ('gpkg_metadata', 'gpkg_metadata_reference')
+"""
+
+
+INSERT_METADATA: str = """
+    INSERT INTO gpkg_metadata (md_scope, md_standard_uri, mime_type, metadata) 
+    VALUES (?, ?, ?, ?)
+"""
+
+
+SELECT_METADATA_ID: str = """
+    SELECT MAX(ID) AS MAX_ID 
+    FROM gpkg_metadata
+"""
+
+
+INSERT_METADATA_REFERENCE: str = """
+    INSERT INTO gpkg_metadata_reference (reference_scope, table_name, 
+            column_name, row_id_value, timestamp, md_file_id, md_parent_id) 
+    VALUES (?, ?, ?, ?, ?, ?, ?)
+"""
+
+
+METADATA_RECORDS: Tuple[Tuple[str, None, str, str, str], ...] = (
+    ('gpkg_metadata', None, 'gpkg_metadata',
+     f'{ROOT}#extension_metadata', 'read-write'),
+    ('gpkg_metadata_reference', None, 'gpkg_metadata',
+     f'{ROOT}#extension_metadata', 'read-write'),
+)
+
+
+CREATE_DATA_COLUMNS: str = """
+    CREATE TABLE gpkg_data_columns (
+        table_name      TEXT NOT NULL,
+        column_name     TEXT NOT NULL,
+        name            TEXT,
+        title           TEXT,
+        description     TEXT,
+        mime_type       TEXT,
+        constraint_name TEXT,
+        CONSTRAINT pk_gdc PRIMARY KEY (table_name, column_name),
+        CONSTRAINT gdc_tn UNIQUE (table_name, name)
+    );
+"""
+
+
+CREATE_DATA_COLUMN_CONSTRAINTS: str = """
+    CREATE TABLE gpkg_data_column_constraints (
+        constraint_name  TEXT NOT NULL,
+        constraint_type  TEXT NOT NULL, -- 'range' | 'enum' | 'glob'
+        value            TEXT,
+        min              NUMERIC,
+        min_is_inclusive BOOLEAN,       -- 0 = false, 1 = true
+        max              NUMERIC,
+        max_is_inclusive BOOLEAN,       -- 0 = false, 1 = true
+        description      TEXT,
+        CONSTRAINT gdcc_ntv UNIQUE (constraint_name, constraint_type, value)
+    );
+"""
+
+
+HAS_SCHEMA: str = """
+    SELECT name FROM sqlite_master 
+    WHERE type = 'table' AND 
+          name IN ('gpkg_data_columns', 'gpkg_data_column_constraints')
+"""
+
+
+INSERT_COLUMN_DEFINITION: str = """
+    INSERT INTO gpkg_data_columns (table_name, column_name, name, title, 
+            description, mime_type, constraint_name)
+    VALUES (?, ?, ?, ?, ?, ?, ?)
+"""
+
+
+INSERT_COLUMN_CONSTRAINTS: str = """
+    INSERT INTO gpkg_data_column_constraints (constraint_type, constraint_name,
+        value, min, min_is_inclusive, max, max_is_inclusive, description) 
+    VALUES (?, ?, ?, ?, ?, ?, ?, ?)
+"""
+
+
+SELECT_CONSTRAINT_NAME: str = """
+    SELECT constraint_name 
+    FROM gpkg_data_column_constraints 
+    WHERE constraint_name = ?
+"""
+
+
+SCHEMA_RECORDS: Tuple[Tuple[str, None, str, str, str], ...] = (
+    ('gpkg_data_columns', None, 'gpkg_schema',
+     f'{ROOT}#extension_schema', 'read-write'),
+    ('gpkg_data_column_constraints', None, 'gpkg_schema',
+     f'{ROOT}#extension_schema', 'read-write'),
+)
 
 
-if __name__ == '__main__':
+if __name__ == '__main__':  # pragma: no cover
     pass
```

## fudgeo/geometry/__init__.py

```diff
@@ -21,9 +21,9 @@
            'MultiLineString', 'MultiLineStringZ',
            'MultiLineStringM', 'MultiLineStringZM',
            'Polygon', 'PolygonZ', 'PolygonM', 'PolygonZM',
            'MultiPolygon', 'MultiPolygonZ',
            'MultiPolygonM', 'MultiPolygonZM']
 
 
-if __name__ == '__main__':
+if __name__ == '__main__':  # pragma: no cover
     pass
```

## fudgeo/geometry/linestring.py

```diff
@@ -1,21 +1,22 @@
 # -*- coding: utf-8 -*-
 """
 Line String
 """
 
 
 from struct import pack
-from typing import Any, ClassVar, List, TYPE_CHECKING
+from typing import Any, ClassVar, Dict, List, TYPE_CHECKING
 
 from fudgeo.constant import (
-    COUNT_CODE, EMPTY, EnvelopeCode, FOUR_D, THREE_D, TWO_D,
-    WKB_LINESTRING_M_PRE, WKB_LINESTRING_PRE, WKB_LINESTRING_ZM_PRE,
-    WKB_LINESTRING_Z_PRE, WKB_MULTI_LINESTRING_M_PRE, WKB_MULTI_LINESTRING_PRE,
+    COUNT_CODE, EMPTY, FOUR_D, THREE_D, TWO_D, WKB_LINESTRING_M_PRE,
+    WKB_LINESTRING_PRE, WKB_LINESTRING_ZM_PRE, WKB_LINESTRING_Z_PRE,
+    WKB_MULTI_LINESTRING_M_PRE, WKB_MULTI_LINESTRING_PRE,
     WKB_MULTI_LINESTRING_ZM_PRE, WKB_MULTI_LINESTRING_Z_PRE)
+from fudgeo.enumeration import EnvelopeCode
 from fudgeo.geometry.base import AbstractGeometry
 from fudgeo.geometry.point import Point, PointM, PointZ, PointZM
 from fudgeo.geometry.util import (
     EMPTY_ENVELOPE, ENV_COORD, ENV_GEOM, Envelope, as_array, lazy_unpack,
     pack_coordinates, unpack_line, unpack_lines)
 
 
@@ -52,14 +53,28 @@
             return NotImplemented
         if self.srs_id != other.srs_id:
             return False
         return self.points == other.points
     # End eq built-in
 
     @property
+    def __geo_interface__(self) -> Dict:
+        """
+        Geo Interface
+        """
+        # NOTE return 4 values when ZM present even though GeoJSON spec
+        #  suggests no more than 3
+        #  https://stevage.github.io/geojson-spec/#section-3.1.1
+        return {'type': 'LineString',
+                'bbox': self.envelope.bounding_box,
+                'coordinates': tuple(
+                    tuple(coords) for coords in self.coordinates)}
+    # End geo_interface property
+
+    @property
     def coordinates(self) -> 'ndarray':
         """
         Coordinates
         """
         if self._args:
             self._coordinates = unpack_line(*self._args)
             self._args = None
@@ -200,14 +215,29 @@
         if not isinstance(other, self.__class__):  # pragma: nocover
             return NotImplemented
         if self.srs_id != other.srs_id:
             return False
         return self.lines == other.lines
     # End eq built-in
 
+    @property
+    def __geo_interface__(self) -> Dict:
+        """
+        Geo Interface
+        """
+        # NOTE return 4 values when ZM present even though GeoJSON spec
+        #  suggests no more than 3
+        #  https://stevage.github.io/geojson-spec/#section-3.1.1
+        return {'type': 'MultiLineString',
+                'bbox': self.envelope.bounding_box,
+                'coordinates': tuple(
+                    tuple(tuple(coords) for coords in line.coordinates)
+                    for line in self.lines)}
+    # End geo_interface property
+
     def _make_lines(self, coordinates: List[List]) -> List:
         """
         Make Lines
         """
         srs_id = self.srs_id
         cls = self._class
         # noinspection PyArgumentList
```

## fudgeo/geometry/linestring.pyi

```diff
@@ -1,13 +1,13 @@
 # -*- coding: utf-8 -*-
 """
 Line String
 """
 
-from typing import Any, ClassVar, List
+from typing import Any, ClassVar, Dict, List, Tuple, Union
 
 from numpy import ndarray
 
 from fudgeo.constant import DOUBLE, QUADRUPLE, TRIPLE
 from fudgeo.geometry.base import AbstractGeometry
 from fudgeo.geometry.point import Point, PointM, PointZ, PointZM
 from fudgeo.geometry.util import Envelope
@@ -24,14 +24,16 @@
     _has_z: ClassVar[bool]
     _wkb_prefix: ClassVar[bytes]
     _coordinates: ndarray
 
     def __init__(self, coordinates: List, srs_id: int) -> None: ...
     def __eq__(self, other: Any) -> bool: ...
     @property
+    def __geo_interface__(self) -> Dict: ...
+    @property
     def coordinates(self) -> 'ndarray': ...
     @property
     def is_empty(self) -> bool: ...
     @property
     def points(self) -> List: ...
     @property
     def envelope(self) -> Envelope: ...
@@ -44,14 +46,16 @@
 class LineString(BaseLineString):
     """
     Line String
     """
     def __init__(self, coordinates: List[DOUBLE], srs_id: int) -> None: ...
     def __eq__(self, other: 'LineString') -> bool: ...
     @property
+    def __geo_interface__(self) -> Dict[str, Tuple[DOUBLE]]: ...
+    @property
     def coordinates(self) -> 'ndarray': ...
     @property
     def is_empty(self) -> bool: ...
     @property
     def points(self) -> List[Point]: ...
     @property
     def envelope(self) -> Envelope: ...
@@ -64,14 +68,16 @@
 class LineStringZ(BaseLineString):
     """
     Line String Z
     """
     def __init__(self, coordinates: List[TRIPLE], srs_id: int) -> None: ...
     def __eq__(self, other: 'LineStringZ') -> bool: ...
     @property
+    def __geo_interface__(self) -> Dict[str, Tuple[TRIPLE]]: ...
+    @property
     def coordinates(self) -> 'ndarray': ...
     @property
     def is_empty(self) -> bool: ...
     @property
     def points(self) -> List[PointZ]: ...
     @property
     def envelope(self) -> Envelope: ...
@@ -84,14 +90,16 @@
 class LineStringM(BaseLineString):
     """
     Line String M
     """
     def __init__(self, coordinates: List[TRIPLE], srs_id: int) -> None: ...
     def __eq__(self, other: 'LineStringM') -> bool: ...
     @property
+    def __geo_interface__(self) -> Dict[str, Tuple[TRIPLE]]: ...
+    @property
     def coordinates(self) -> 'ndarray': ...
     @property
     def is_empty(self) -> bool: ...
     @property
     def points(self) -> List[PointM]: ...
     @property
     def envelope(self) -> Envelope: ...
@@ -104,14 +112,16 @@
 class LineStringZM(BaseLineString):
     """
     Line String ZM
     """
     def __init__(self, coordinates: List[QUADRUPLE], srs_id: int) -> None: ...
     def __eq__(self, other: 'LineStringZM') -> bool: ...
     @property
+    def __geo_interface__(self) -> Dict[str, Tuple[QUADRUPLE]]: ...
+    @property
     def coordinates(self) -> 'ndarray': ...
     @property
     def is_empty(self) -> bool: ...
     @property
     def points(self) -> List[PointZM]: ...
     @property
     def envelope(self) -> Envelope: ...
@@ -129,14 +139,16 @@
     _dimension: ClassVar[int]
     _env_code: ClassVar[int]
     _wkb_prefix: ClassVar[bytes]
     _lines: List
 
     def __init__(self, coordinates: List[List], srs_id: int) -> None: ...
     def __eq__(self, other: Any) -> bool: ...
+    @property
+    def __geo_interface__(self) -> Dict:
     def _make_lines(self, coordinates: List[List]) -> List: ...
     @property
     def lines(self) -> List: ...
     @property
     def is_empty(self) -> bool: ...
     def _to_wkb(self, ary: bytearray) -> bytearray: ...
     @property
@@ -148,14 +160,16 @@
 
 class MultiLineString(BaseMultiLineString):
     """
     Multi Line String
     """
     def __init__(self, coordinates: List[List[DOUBLE]], srs_id: int) -> None: ...
     def __eq__(self, other: 'MultiLineString') -> bool: ...
+    @property
+    def __geo_interface__(self) -> Dict[str, Union[str, Tuple[Tuple[DOUBLE]]]]: ...
     def _make_lines(self, coordinates: List[List[DOUBLE]]) -> List[LineString]: ...
     @property
     def lines(self) -> List[LineString]: ...
     @property
     def is_empty(self) -> bool: ...
     def _to_wkb(self, ary: bytearray) -> bytearray: ...
     @property
@@ -167,14 +181,16 @@
 
 class MultiLineStringZ(BaseMultiLineString):
     """
     Multi Line String Z
     """
     def __init__(self, coordinates: List[List[TRIPLE]], srs_id: int) -> None: ...
     def __eq__(self, other: 'MultiLineStringZ') -> bool: ...
+    @property
+    def __geo_interface__(self) -> Dict[str, Union[str, Tuple[Tuple[TRIPLE]]]]: ...
     def _make_lines(self, coordinates: List[List[TRIPLE]]) -> List[LineStringZ]: ...
     @property
     def lines(self) -> List[LineStringZ]: ...
     @property
     def is_empty(self) -> bool: ...
     @property
     def envelope(self) -> Envelope: ...
@@ -186,14 +202,16 @@
 
 class MultiLineStringM(BaseMultiLineString):
     """
     Multi Line String M
     """
     def __init__(self, coordinates: List[List[TRIPLE]], srs_id: int) -> None: ...
     def __eq__(self, other: 'MultiLineStringM') -> bool: ...
+    @property
+    def __geo_interface__(self) -> Dict[str, Union[str, Tuple[Tuple[TRIPLE]]]]: ...
     def _make_lines(self, coordinates: List[List[TRIPLE]]) -> List[LineStringM]: ...
     @property
     def lines(self) -> List[LineStringM]: ...
     @property
     def is_empty(self) -> bool: ...
     @property
     def envelope(self) -> Envelope: ...
@@ -205,14 +223,16 @@
 
 class MultiLineStringZM(BaseMultiLineString):
     """
     Multi Line String ZM
     """
     def __init__(self, coordinates: List[List[QUADRUPLE]], srs_id: int) -> None: ...
     def __eq__(self, other: 'MultiLineStringZM') -> bool: ...
+    @property
+    def __geo_interface__(self) -> Dict[str, Union[str, Tuple[Tuple[QUADRUPLE]]]]: ...
     def _make_lines(self, coordinates: List[List[QUADRUPLE]]) -> List[LineStringZM]: ...
     @property
     def lines(self) -> List[LineStringZM]: ...
     @property
     def is_empty(self) -> bool: ...
     @property
     def envelope(self) -> Envelope: ...
```

## fudgeo/geometry/point.py

```diff
@@ -2,22 +2,23 @@
 """
 Points
 """
 
 
 from math import isnan, nan
 from struct import pack, unpack
-from typing import Any, ClassVar, List, Optional, TYPE_CHECKING
+from typing import Any, ClassVar, Dict, List, Optional, TYPE_CHECKING, Union
 
 from fudgeo.constant import (
-    DOUBLE, EMPTY, EnvelopeCode, FOUR_D, FOUR_D_PACK_CODE, FOUR_D_UNPACK_CODE,
-    HEADER_OFFSET, QUADRUPLE, THREE_D, THREE_D_PACK_CODE, THREE_D_UNPACK_CODE,
-    TRIPLE, TWO_D, TWO_D_PACK_CODE, TWO_D_UNPACK_CODE, WKB_MULTI_POINT_M_PRE,
+    DOUBLE, EMPTY, FOUR_D, FOUR_D_PACK_CODE, FOUR_D_UNPACK_CODE, HEADER_OFFSET,
+    QUADRUPLE, THREE_D, THREE_D_PACK_CODE, THREE_D_UNPACK_CODE, TRIPLE, TWO_D,
+    TWO_D_PACK_CODE, TWO_D_UNPACK_CODE, WKB_MULTI_POINT_M_PRE,
     WKB_MULTI_POINT_PRE, WKB_MULTI_POINT_ZM_PRE, WKB_MULTI_POINT_Z_PRE,
     WKB_POINT_M_PRE, WKB_POINT_PRE, WKB_POINT_ZM_PRE, WKB_POINT_Z_PRE)
+from fudgeo.enumeration import EnvelopeCode
 from fudgeo.geometry.base import AbstractGeometry
 from fudgeo.geometry.util import (
     EMPTY_ENVELOPE, ENV_COORD, Envelope, as_array, lazy_unpack, make_header,
     pack_coordinates, unpack_header, unpack_points)
 
 if TYPE_CHECKING:
     from numpy import ndarray
@@ -42,18 +43,33 @@
         """
         Equals
         """
         if not isinstance(other, Point):  # pragma: nocover
             return NotImplemented
         if self.srs_id != other.srs_id:
             return False
-        return (self.x, self.y) == (other.x, other.y)
+        return self.as_tuple() == other.as_tuple()
     # End eq built-in
 
     @property
+    def __geo_interface__(self) -> Dict[str, Union[str, DOUBLE]]:
+        """
+        Geo Interface
+        """
+        return {'type': 'Point', 'coordinates': self.as_tuple()}
+    # End geo_interface property
+
+    def as_tuple(self) -> DOUBLE:
+        """
+        As Tuple
+        """
+        return self.x, self.y
+    # End as_tuple method
+
+    @property
     def is_empty(self) -> bool:
         """
         Is Empty
         """
         return isnan(self.x) and isnan(self.y)
     # End is_empty property
 
@@ -66,15 +82,15 @@
         return x, y
     # End _unpack method
 
     def _to_wkb(self, ary: Optional[bytearray] = None) -> bytes:
         """
         To WKB
         """
-        return WKB_POINT_PRE + pack(TWO_D_PACK_CODE, self.x, self.y)
+        return WKB_POINT_PRE + pack(TWO_D_PACK_CODE, *self.as_tuple())
     # End _to_wkb method
 
     @property
     def envelope(self) -> Envelope:
         """
         Envelope
         """
@@ -140,18 +156,34 @@
         """
         Equals
         """
         if not isinstance(other, PointZ):  # pragma: nocover
             return NotImplemented
         if self.srs_id != other.srs_id:
             return False
-        return (self.x, self.y, self.z) == (other.x, other.y, other.z)
+        return self.as_tuple() == other.as_tuple()
     # End eq built-in
 
     @property
+    def __geo_interface__(self) -> Dict[str, Union[str, TRIPLE]]:
+        """
+        Geo Interface
+        """
+        return {'type': 'Point', 'coordinates': self.as_tuple()}
+
+    # End geo_interface property
+
+    def as_tuple(self) -> TRIPLE:
+        """
+        As Tuple
+        """
+        return self.x, self.y, self.z
+    # End as_tuple method
+
+    @property
     def is_empty(self) -> bool:
         """
         Is Empty
         """
         return isnan(self.x) and isnan(self.y) and isnan(self.z)
     # End is_empty property
 
@@ -164,15 +196,15 @@
         return x, y, z
     # End _unpack method
 
     def _to_wkb(self, ary: Optional[bytearray] = None) -> bytes:
         """
         To WKB
         """
-        return WKB_POINT_Z_PRE + pack(THREE_D_PACK_CODE, self.x, self.y, self.z)
+        return WKB_POINT_Z_PRE + pack(THREE_D_PACK_CODE, *self.as_tuple())
     # End _to_wkb method
 
     @property
     def envelope(self) -> Envelope:
         """
         Envelope
         """
@@ -238,18 +270,33 @@
         """
         Equals
         """
         if not isinstance(other, PointM):  # pragma: nocover
             return NotImplemented
         if self.srs_id != other.srs_id:
             return False
-        return (self.x, self.y, self.m) == (other.x, other.y, other.m)
+        return self.as_tuple() == other.as_tuple()
     # End eq built-in
 
     @property
+    def __geo_interface__(self) -> Dict[str, Union[str, TRIPLE]]:
+        """
+        Geo Interface
+        """
+        return {'type': 'Point', 'coordinates': self.as_tuple()}
+    # End geo_interface property
+
+    def as_tuple(self) -> TRIPLE:
+        """
+        As Tuple
+        """
+        return self.x, self.y, self.m
+    # End as_tuple method
+
+    @property
     def is_empty(self) -> bool:
         """
         Is Empty
         """
         return isnan(self.x) and isnan(self.y) and isnan(self.m)
     # End is_empty property
 
@@ -262,15 +309,15 @@
         return x, y, m
     # End _unpack method
 
     def _to_wkb(self, ary: Optional[bytearray] = None) -> bytes:
         """
         To WKB
         """
-        return WKB_POINT_M_PRE + pack(THREE_D_PACK_CODE, self.x, self.y, self.m)
+        return WKB_POINT_M_PRE + pack(THREE_D_PACK_CODE, *self.as_tuple())
     # End _to_wkb method
 
     @property
     def envelope(self) -> Envelope:
         """
         Envelope
         """
@@ -338,19 +385,36 @@
         """
         Equals
         """
         if not isinstance(other, PointZM):  # pragma: nocover
             return NotImplemented
         if self.srs_id != other.srs_id:
             return False
-        return (self.x, self.y, self.z, self.m) == (
-            other.x, other.y, other.z, other.m)
+        return self.as_tuple() == other.as_tuple()
     # End eq built-in
 
     @property
+    def __geo_interface__(self) -> Dict[str, Union[str, QUADRUPLE]]:
+        """
+        Geo Interface
+        """
+        # NOTE return 4 values when ZM present even though GeoJSON spec
+        #  suggests no more than 3
+        #  https://stevage.github.io/geojson-spec/#section-3.1.1
+        return {'type': 'Point', 'coordinates': self.as_tuple()}
+    # End geo_interface property
+
+    def as_tuple(self) -> QUADRUPLE:
+        """
+        As Tuple
+        """
+        return self.x, self.y, self.z, self.m
+    # End as_tuple method
+
+    @property
     def is_empty(self) -> bool:
         """
         Is Empty
         """
         return (isnan(self.x) and isnan(self.y) and
                 isnan(self.z) and isnan(self.m))
     # End is_empty property
@@ -364,16 +428,15 @@
         return x, y, z, m
     # End _unpack method
 
     def _to_wkb(self, ary: Optional[bytearray] = None) -> bytes:
         """
         To WKB
         """
-        return WKB_POINT_ZM_PRE + pack(
-            FOUR_D_PACK_CODE, self.x, self.y, self.z, self.m)
+        return WKB_POINT_ZM_PRE + pack(FOUR_D_PACK_CODE, *self.as_tuple())
     # End _to_wkb method
 
     @property
     def envelope(self) -> Envelope:
         """
         Envelope
         """
@@ -448,14 +511,28 @@
             return NotImplemented
         if self.srs_id != other.srs_id:
             return False
         return self.points == other.points
     # End eq built-in
 
     @property
+    def __geo_interface__(self) -> Dict:
+        """
+        Geo Interface
+        """
+        # NOTE return 4 values when ZM present even though GeoJSON spec
+        #  suggests no more than 3
+        #  https://stevage.github.io/geojson-spec/#section-3.1.1
+        return {'type': 'MultiPoint',
+                'bbox': self.envelope.bounding_box,
+                'coordinates': tuple(
+                    tuple(coords) for coords in self.coordinates)}
+    # End geo_interface property
+
+    @property
     def coordinates(self) -> 'ndarray':
         """
         Coordinates
         """
         if self._args:
             self._coordinates = unpack_points(*self._args)
             self._args = None
```

## fudgeo/geometry/point.pyi

```diff
@@ -1,13 +1,13 @@
 # -*- coding: utf-8 -*-
 """
 Points
 """
 
-from typing import Any, ClassVar, List, Optional
+from typing import Any, ClassVar, Dict, List, Optional, Tuple, Union
 
 from numpy import ndarray
 
 from fudgeo.constant import DOUBLE, QUADRUPLE, TRIPLE
 from fudgeo.geometry.base import AbstractGeometry
 from fudgeo.geometry.util import Envelope
 
@@ -19,14 +19,17 @@
     """
     x: float
     y: float
 
     def __init__(self, *, x: float, y: float, srs_id: int) -> None: ...
     def __eq__(self, other: 'Point') -> bool: ...
     @property
+    def __geo_interface__(self) -> Dict[str, Union[str, DOUBLE]]: ...
+    def as_tuple(self) -> DOUBLE: ...
+    @property
     def is_empty(self) -> bool: ...
     @staticmethod
     def _unpack(value: bytes) -> DOUBLE: ...
     def _to_wkb(self, ary: Optional[bytearray] = None) -> bytes: ...
     @property
     def envelope(self) -> Envelope: ...
     def to_gpkg(self) -> bytes: ...
@@ -46,14 +49,17 @@
     x: float
     y: float
     z: float
 
     def __init__(self, *, x: float, y: float, z: float, srs_id: int) -> None: ...
     def __eq__(self, other: 'PointZ') -> bool: ...
     @property
+    def __geo_interface__(self) -> Dict[str, Union[str, TRIPLE]]: ...
+    def as_tuple(self) -> TRIPLE: ...
+    @property
     def is_empty(self) -> bool: ...
     @staticmethod
     def _unpack(value: bytes) -> TRIPLE: ...
     def _to_wkb(self, ary: Optional[bytearray] = None) -> bytes: ...
     @property
     def envelope(self) -> Envelope: ...
     def to_gpkg(self) -> bytes: ...
@@ -73,14 +79,17 @@
     x: float
     y: float
     m: float
 
     def __init__(self, *, x: float, y: float, m: float, srs_id: int) -> None: ...
     def __eq__(self, other: 'PointM') -> bool: ...
     @property
+    def __geo_interface__(self) -> Dict[str, Union[str, TRIPLE]]: ...
+    def as_tuple(self) -> TRIPLE: ...
+    @property
     def is_empty(self) -> bool: ...
     @staticmethod
     def _unpack(value: bytes) -> TRIPLE: ...
     def _to_wkb(self, ary: Optional[bytearray] = None) -> bytes: ...
     @property
     def envelope(self) -> Envelope: ...
     def to_gpkg(self) -> bytes: ...
@@ -101,14 +110,17 @@
     y: float
     z: float
     m: float
 
     def __init__(self, *, x: float, y: float, z: float, m: float, srs_id: int) -> None: ...
     def __eq__(self, other: 'PointZM') -> bool: ...
     @property
+    def __geo_interface__(self) -> Dict[str, Union[str, QUADRUPLE]]: ...
+    def as_tuple(self) -> QUADRUPLE: ...
+    @property
     def is_empty(self) -> bool: ...
     @staticmethod
     def _unpack(value: bytes) -> QUADRUPLE: ...
     def _to_wkb(self, ary: Optional[bytearray] = None) -> bytes: ...
     @property
     def envelope(self) -> Envelope: ...
     def to_gpkg(self) -> bytes: ...
@@ -134,14 +146,16 @@
     _has_z: ClassVar[bool]
     _wkb_prefix: ClassVar[bytes]
     _coordinates: ndarray
 
     def __init__(self, coordinates: List, srs_id: int) -> None: ...
     def __eq__(self, other: Any) -> bool: ...
     @property
+    def __geo_interface__(self) -> Dict: ...
+    @property
     def coordinates(self) -> 'ndarray': ...
     @property
     def is_empty(self) -> bool: ...
     @property
     def points(self) -> List: ...
     @property
     def envelope(self) -> Envelope: ...
@@ -154,14 +168,16 @@
 class MultiPoint(BaseMultiPoint):
     """
     Multi Point
     """
     def __init__(self, coordinates: List[DOUBLE], srs_id: int) -> None: ...
     def __eq__(self, other: 'MultiPoint') -> bool: ...
     @property
+    def __geo_interface__(self) -> Dict[str, Tuple[DOUBLE]]: ...
+    @property
     def coordinates(self) -> 'ndarray': ...
     @property
     def is_empty(self) -> bool: ...
     @property
     def points(self) -> List[Point]: ...
     @property
     def envelope(self) -> Envelope: ...
@@ -174,14 +190,16 @@
 class MultiPointZ(BaseMultiPoint):
     """
     Multi Point Z
     """
     def __init__(self, coordinates: List[TRIPLE], srs_id: int) -> None: ...
     def __eq__(self, other: 'MultiPointZ') -> bool: ...
     @property
+    def __geo_interface__(self) -> Dict[str, Tuple[TRIPLE]]: ...
+    @property
     def coordinates(self) -> 'ndarray': ...
     @property
     def is_empty(self) -> bool: ...
     @property
     def points(self) -> List[PointZ]: ...
     @property
     def envelope(self) -> Envelope: ...
@@ -194,14 +212,16 @@
 class MultiPointM(BaseMultiPoint):
     """
     Multi Point M
     """
     def __init__(self, coordinates: List[TRIPLE], srs_id: int) -> None: ...
     def __eq__(self, other: 'MultiPointM') -> bool: ...
     @property
+    def __geo_interface__(self) -> Dict[str, Tuple[TRIPLE]]: ...
+    @property
     def coordinates(self) -> 'ndarray': ...
     @property
     def is_empty(self) -> bool: ...
     @property
     def points(self) -> List[PointM]: ...
     @property
     def envelope(self) -> Envelope: ...
@@ -214,14 +234,16 @@
 class MultiPointZM(BaseMultiPoint):
     """
     Multi Point ZM
     """
     def __init__(self, coordinates: List[QUADRUPLE], srs_id: int) -> None: ...
     def __eq__(self, other: 'MultiPointZM') -> bool: ...
     @property
+    def __geo_interface__(self) -> Dict[str, Tuple[QUADRUPLE]]: ...
+    @property
     def coordinates(self) -> 'ndarray': ...
     @property
     def is_empty(self) -> bool: ...
     @property
     def points(self) -> List[PointZM]: ...
     @property
     def envelope(self) -> Envelope: ...
```

## fudgeo/geometry/polygon.py

```diff
@@ -1,21 +1,21 @@
 # -*- coding: utf-8 -*-
 """
 Polygons
 """
 
 
 from struct import pack
-from typing import Any, ClassVar, List, TYPE_CHECKING
+from typing import Any, ClassVar, Dict, List, TYPE_CHECKING
 
 from fudgeo.constant import (
-    COUNT_CODE, EMPTY, EnvelopeCode, FOUR_D, THREE_D, TWO_D,
-    WKB_MULTI_POLYGON_M_PRE, WKB_MULTI_POLYGON_PRE, WKB_MULTI_POLYGON_ZM_PRE,
-    WKB_MULTI_POLYGON_Z_PRE, WKB_POLYGON_M_PRE, WKB_POLYGON_PRE,
-    WKB_POLYGON_ZM_PRE, WKB_POLYGON_Z_PRE)
+    COUNT_CODE, EMPTY, FOUR_D, THREE_D, TWO_D, WKB_MULTI_POLYGON_M_PRE,
+    WKB_MULTI_POLYGON_PRE, WKB_MULTI_POLYGON_ZM_PRE, WKB_MULTI_POLYGON_Z_PRE,
+    WKB_POLYGON_M_PRE, WKB_POLYGON_PRE, WKB_POLYGON_ZM_PRE, WKB_POLYGON_Z_PRE)
+from fudgeo.enumeration import EnvelopeCode
 from fudgeo.geometry.base import AbstractGeometry
 from fudgeo.geometry.point import Point, PointM, PointZ, PointZM
 from fudgeo.geometry.util import (
     EMPTY_ENVELOPE, ENV_COORD, ENV_GEOM, Envelope, as_array, lazy_unpack,
     pack_coordinates, unpack_lines, unpack_polygons)
 
 
@@ -169,14 +169,29 @@
         if not isinstance(other, self.__class__):  # pragma: nocover
             return NotImplemented
         if self.srs_id != other.srs_id:
             return False
         return self.rings == other.rings
     # End eq built-in
 
+    @property
+    def __geo_interface__(self) -> Dict:
+        """
+        Geo Interface
+        """
+        # NOTE return 4 values when ZM present even though GeoJSON spec
+        #  suggests no more than 3
+        #  https://stevage.github.io/geojson-spec/#section-3.1.1
+        return {'type': 'Polygon',
+                'bbox': self.envelope.bounding_box,
+                'coordinates': tuple(
+                    tuple(tuple(coords) for coords in ring.coordinates)
+                    for ring in self.rings)}
+    # End geo_interface property
+
     def _make_rings(self, coordinates: List[List]) -> List:
         """
         Make Rings
         """
         srs_id = self.srs_id
         cls = self._class
         return [cls(coords, srs_id=srs_id) for coords in coordinates]
@@ -315,14 +330,29 @@
         if not isinstance(other, self.__class__):  # pragma: nocover
             return NotImplemented
         if self.srs_id != other.srs_id:
             return False
         return self.polygons == other.polygons
     # End eq built-in
 
+    @property
+    def __geo_interface__(self) -> Dict:
+        """
+        Geo Interface
+        """
+        # NOTE return 4 values when ZM present even though GeoJSON spec
+        #  suggests no more than 3
+        #  https://stevage.github.io/geojson-spec/#section-3.1.1
+        return {'type': 'MultiPolygon',
+                'bbox': self.envelope.bounding_box,
+                'coordinates': tuple(tuple(tuple(
+                    tuple(coords) for coords in ring.coordinates)
+                    for ring in poly.rings) for poly in self.polygons)}
+    # End geo_interface property
+
     def _make_polygons(self, coordinates: List[List[List]]) -> List:
         """
         Make Polygons
         """
         srs_id = self.srs_id
         cls = self._class
         return [cls(coords, srs_id=srs_id) for coords in coordinates]
```

## fudgeo/geometry/polygon.pyi

```diff
@@ -1,14 +1,14 @@
 # -*- coding: utf-8 -*-
 """
 Polygons
 """
 
 
-from typing import Any, ClassVar, List
+from typing import Any, ClassVar, Dict, List, Tuple, Union
 
 from numpy import ndarray
 
 from fudgeo.constant import (
     DOUBLE, QUADRUPLE, TRIPLE)
 from fudgeo.geometry.base import AbstractGeometry
 from fudgeo.geometry.point import Point, PointM, PointZ, PointZM
@@ -22,14 +22,16 @@
     _class: ClassVar[Any]
     _env_code: ClassVar[int]
     coordinates: ndarray
 
     def __init__(self, coordinates: List, srs_id: int) -> None: ...
     def __eq__(self, other: Any) -> bool: ...
     @property
+    def __geo_interface__(self) -> Dict: ...
+    @property
     def is_empty(self) -> bool: ...
     @property
     def points(self) -> List: ...
     @property
     def envelope(self) -> Envelope: ...
     def _to_wkb(self, ary: bytearray) -> bytearray: ...
     @classmethod
@@ -117,14 +119,16 @@
     _dimension: ClassVar[int]
     _env_code: ClassVar[int]
     _wkb_prefix: ClassVar[bytes]
     _rings: List
 
     def __init__(self, coordinates: List[List], srs_id: int) -> None: ...
     def __eq__(self, other: Any) -> bool: ...
+    @property
+    def __geo_interface__(self) -> Dict: ...
     def _make_rings(self, coordinates: List[List]) -> List: ...
     @property
     def rings(self) -> List: ...
     @property
     def is_empty(self) -> bool: ...
     @property
     def envelope(self) -> Envelope: ...
@@ -136,14 +140,16 @@
 
 class Polygon(BasePolygon):
     """
     Polygon
     """
     def __init__(self, coordinates: List[List[DOUBLE]], srs_id: int) -> None: ...
     def __eq__(self, other: 'Polygon') -> bool: ...
+    @property
+    def __geo_interface__(self) -> Dict[str, Union[str, Tuple[Tuple[DOUBLE]]]]: ...
     def _make_rings(self, coordinates: List[List[DOUBLE]]) -> List[LinearRing]: ...
     @property
     def rings(self) -> List[LinearRing]: ...
     @property
     def is_empty(self) -> bool: ...
     @property
     def envelope(self) -> Envelope: ...
@@ -155,14 +161,16 @@
 
 class PolygonZ(BasePolygon):
     """
     Polygon Z
     """
     def __init__(self, coordinates: List[List[TRIPLE]], srs_id: int) -> None: ...
     def __eq__(self, other: 'PolygonZ') -> bool: ...
+    @property
+    def __geo_interface__(self) -> Dict[str, Union[str, Tuple[Tuple[TRIPLE]]]]: ...
     def _make_rings(self, coordinates: List[List[TRIPLE]]) -> List[LinearRingZ]: ...
     @property
     def rings(self) -> List[LinearRingZ]: ...
     @property
     def is_empty(self) -> bool: ...
     @property
     def envelope(self) -> Envelope: ...
@@ -174,14 +182,16 @@
 
 class PolygonM(BasePolygon):
     """
     Polygon M
     """
     def __init__(self, coordinates: List[List[TRIPLE]], srs_id: int) -> None: ...
     def __eq__(self, other: 'PolygonM') -> bool: ...
+    @property
+    def __geo_interface__(self) -> Dict[str, Union[str, Tuple[Tuple[TRIPLE]]]]: ...
     def _make_rings(self, coordinates: List[List[TRIPLE]]) -> List[LinearRingM]: ...
     @property
     def rings(self) -> List[LinearRingM]: ...
     @property
     def is_empty(self) -> bool: ...
     @property
     def envelope(self) -> Envelope: ...
@@ -193,14 +203,16 @@
 
 class PolygonZM(BasePolygon):
     """
     Polygon ZM
     """
     def __init__(self, coordinates: List[List[QUADRUPLE]], srs_id: int) -> None: ...
     def __eq__(self, other: 'PolygonZM') -> bool: ...
+    @property
+    def __geo_interface__(self) -> Dict[str, Union[str, Tuple[Tuple[QUADRUPLE]]]]: ...
     def _make_rings(self, coordinates: List[List[QUADRUPLE]]) -> List[LinearRingZM]: ...
     @property
     def rings(self) -> List[LinearRingZM]: ...
     @property
     def is_empty(self) -> bool: ...
     @property
     def envelope(self) -> Envelope: ...
@@ -218,14 +230,16 @@
     _dimension: ClassVar[int]
     _env_code: ClassVar[int]
     _wkb_prefix: ClassVar[bytes]
     _polygons: List
 
     def __init__(self, coordinates: List[List[List]], srs_id: int) -> None: ...
     def __eq__(self, other: Any) -> bool: ...
+    @property
+    def __geo_interface__(self) -> Dict: ...
     def _make_polygons(self, coordinates: List[List[List]]) -> List: ...
     @property
     def polygons(self) -> List: ...
     @property
     def is_empty(self) -> bool: ...
     @property
     def envelope(self) -> Envelope: ...
@@ -237,14 +251,16 @@
 
 class MultiPolygon(BaseMultiPolygon):
     """
     Multi Polygon
     """
     def __init__(self, coordinates: List[List[List[DOUBLE]]], srs_id: int) -> None: ...
     def __eq__(self, other: 'MultiPolygon') -> bool: ...
+    @property
+    def __geo_interface__(self) -> Dict[str, Union[str, Tuple[Tuple[Tuple[DOUBLE]]]]]: ...
     def _make_polygons(self, coordinates: List[List[List[DOUBLE]]]) -> List[Polygon]: ...
     @property
     def polygons(self) -> List[Polygon]: ...
     @property
     def is_empty(self) -> bool: ...
     @property
     def envelope(self) -> Envelope: ...
@@ -253,14 +269,16 @@
     def from_gpkg(cls, value: bytes) -> 'MultiPolygon': ...
 # End MultiPolygon class
 
 
 class MultiPolygonZ(BaseMultiPolygon):
     def __init__(self, coordinates: List[List[List[TRIPLE]]], srs_id: int) -> None: ...
     def __eq__(self, other: 'MultiPolygonZ') -> bool: ...
+    @property
+    def __geo_interface__(self) -> Dict[str, Union[str, Tuple[Tuple[Tuple[TRIPLE]]]]]: ...
     def _make_polygons(self, coordinates: List[List[List[TRIPLE]]]) -> List[PolygonZ]: ...
     @property
     def polygons(self) -> List[PolygonZ]: ...
     @property
     def is_empty(self) -> bool: ...
     @property
     def envelope(self) -> Envelope: ...
@@ -272,14 +290,16 @@
 
 class MultiPolygonM(BaseMultiPolygon):
     """
     Multi Polygon M
     """
     def __init__(self, coordinates: List[List[List[TRIPLE]]], srs_id: int) -> None: ...
     def __eq__(self, other: 'MultiPolygonM') -> bool: ...
+    @property
+    def __geo_interface__(self) -> Dict[str, Union[str, Tuple[Tuple[Tuple[TRIPLE]]]]]: ...
     def _make_polygons(self, coordinates: List[List[List[TRIPLE]]]) -> List[PolygonM]: ...
     @property
     def polygons(self) -> List[PolygonM]: ...
     @property
     def is_empty(self) -> bool: ...
     @property
     def envelope(self) -> Envelope: ...
@@ -291,14 +311,16 @@
 
 class MultiPolygonZM(BaseMultiPolygon):
     """
     Multi Polygon ZM
     """
     def __init__(self, coordinates: List[List[List[QUADRUPLE]]], srs_id: int) -> None: ...
     def __eq__(self, other: 'MultiPolygonZM') -> bool: ...
+    @property
+    def __geo_interface__(self) -> Dict[str, Union[str, Tuple[Tuple[Tuple[QUADRUPLE]]]]]: ...
     def _make_polygons(self, coordinates: List[List[List[QUADRUPLE]]]) -> List[PolygonZM]: ...
     @property
     def polygons(self) -> List[PolygonZM]: ...
     @property
     def is_empty(self) -> bool: ...
     @property
     def envelope(self) -> Envelope: ...
```

## fudgeo/geometry/util.py

```diff
@@ -10,17 +10,17 @@
 from struct import error as StructError, pack, unpack
 from typing import Any, Callable, Dict, List, TYPE_CHECKING, Tuple, Union
 
 from numpy import array, frombuffer, ndarray
 from bottleneck import nanmax, nanmin
 
 from fudgeo.constant import (
-    COUNT_CODE, EMPTY, ENVELOPE_COUNT, ENVELOPE_OFFSET, EnvelopeCode, GP_MAGIC,
-    HEADER_CODE, HEADER_OFFSET, POINT_PREFIX_ZM)
-
+    COUNT_CODE, EMPTY, ENVELOPE_COUNT, ENVELOPE_OFFSET, GP_MAGIC, HEADER_CODE,
+    HEADER_OFFSET, POINT_PREFIX_ZM)
+from fudgeo.enumeration import EnvelopeCode
 
 if TYPE_CHECKING:  # pragma: no cover
     # noinspection PyUnresolvedReferences
     from fudgeo.geometry.linestring import (
         LineString, LineStringZ, LineStringM, LineStringZM)
     # noinspection PyUnresolvedReferences
     from fudgeo.geometry.polygon import (
@@ -102,14 +102,22 @@
             return same_z
         same_m = self.min_m == other.min_m and self.max_m == other.max_m
         if code == EnvelopeCode.xym:
             return same_m
         return same_m and same_z
     # End eq built-in
 
+    @property
+    def bounding_box(self) -> Tuple[float, float, float, float]:
+        """
+        Bounding Box
+        """
+        return self.min_x, self.min_y, self.max_x, self.max_y
+    # End bounding_box property
+
     def to_wkb(self) -> Tuple[int, bytes]:
         """
         To WKB
         """
         code = self.code
         if code not in {EnvelopeCode.xy, EnvelopeCode.xyz,
                         EnvelopeCode.xym, EnvelopeCode.xyzm}:
```

## Comparing `fudgeo-0.6.0.dist-info/LICENSE` & `fudgeo-0.7.0.dist-info/LICENSE`

 * *Files identical despite different names*

